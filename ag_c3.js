"use strict";
(function(e, t) {
    typeof exports == "object" && typeof module != "undefined" ? t(exports) : typeof define == "function" && define.amd ? define(["exports"], t) : (e = e || self, t(e.glMatrix = {}))
})(this, function(e) {
    var o, i, a, r, c, l, m, g, j, _, O, A, S, M, T, D, N, L, R, P, B, V, $, W, K, q, Y, X, Z, t = 1e-6,
        bt, $e, ie, ae, re, Pe, He, Ie, St, Ft, Mt, gt, pt, ut, lt, ct, at, it, ot, Fe, Me, Se, Ae, Ee, Ce, xe, Oe, ue, de, oe, se, ne, le, me, pe, we, Le, Ve, rt, vt, Et, n = typeof Float32Array != "undefined" ? Float32Array : Array,
        s = Math.random;

    function Pi(e) {
        n = e
    }
    bt = Math.PI / 180;

    function Ri(e) {
        return e * bt
    }

    function Li(e, n) {
        return Math.abs(e - n) <= t * Math.max(1, Math.abs(e), Math.abs(n))
    }
    Math.hypot || (Math.hypot = function() {
        for (var t = 0, e = arguments.length; e--;) t += arguments[e] * arguments[e];
        return Math.sqrt(t)
    }), $e = Object.freeze({
        __proto__: null,
        EPSILON: t,
        get ARRAY_TYPE() {
            return n
        },
        RANDOM: s,
        setMatrixArrayType: Pi,
        toRadian: Ri,
        equals: Li
    });

    function Ni() {
        var e = new n(4);
        return n != Float32Array && (e[1] = 0, e[2] = 0), e[0] = 1, e[3] = 1, e
    }

    function Di(e) {
        var t = new n(4);
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t
    }

    function zi(e, t) {
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e
    }

    function Ti(e) {
        return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e
    }

    function Fi(e, t, s, o) {
        var i = new n(4);
        return i[0] = e, i[1] = t, i[2] = s, i[3] = o, i
    }

    function Mi(e, t, n, s, o) {
        return e[0] = t, e[1] = n, e[2] = s, e[3] = o, e
    }

    function hi(e, t) {
        if (e === t) {
            var n = t[1];
            e[1] = t[2], e[2] = n
        } else e[0] = t[0], e[1] = t[2], e[2] = t[1], e[3] = t[3];
        return e
    }

    function ui(e, t) {
        var s = t[0],
            o = t[1],
            i = t[2],
            a = t[3],
            n = s * a - i * o;
        return n ? (n = 1 / n, e[0] = a * n, e[1] = -o * n, e[2] = -i * n, e[3] = s * n, e) : null
    }

    function di(e, t) {
        var n = t[0];
        return e[0] = t[3], e[1] = -t[1], e[2] = -t[2], e[3] = n, e
    }

    function li(e) {
        return e[0] * e[3] - e[2] * e[1]
    }

    function ke(e, t, n) {
        var s = t[0],
            o = t[1],
            i = t[2],
            a = t[3],
            r = n[0],
            c = n[1],
            l = n[2],
            d = n[3];
        return e[0] = s * r + i * c, e[1] = o * r + a * c, e[2] = s * l + i * d, e[3] = o * l + a * d, e
    }

    function ti(e, t, n) {
        var i = t[0],
            a = t[1],
            r = t[2],
            c = t[3],
            s = Math.sin(n),
            o = Math.cos(n);
        return e[0] = i * o + r * s, e[1] = a * o + c * s, e[2] = i * -s + r * o, e[3] = a * -s + c * o, e
    }

    function ei(e, t, n) {
        var i = t[0],
            a = t[1],
            r = t[2],
            c = t[3],
            s = n[0],
            o = n[1];
        return e[0] = i * s, e[1] = a * s, e[2] = r * o, e[3] = c * o, e
    }

    function Jo(e, t) {
        var n = Math.sin(t),
            s = Math.cos(t);
        return e[0] = s, e[1] = n, e[2] = -n, e[3] = s, e
    }

    function qo(e, t) {
        return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = t[1], e
    }

    function Ko(e) {
        return "mat2(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ")"
    }

    function Bo(e) {
        return Math.hypot(e[0], e[1], e[2], e[3])
    }

    function Io(e, t, n, s) {
        return e[2] = s[2] / s[0], n[0] = s[0], n[1] = s[1], n[3] = s[3] - e[2] * n[1], [e, t, n]
    }

    function Ho(e, t, n) {
        return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e[3] = t[3] + n[3], e
    }

    function F(e, t, n) {
        return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e[2] = t[2] - n[2], e[3] = t[3] - n[3], e
    }

    function Po(e, t) {
        return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3]
    }

    function Do(e, n) {
        var s = e[0],
            o = e[1],
            i = e[2],
            a = e[3],
            r = n[0],
            c = n[1],
            l = n[2],
            d = n[3];
        return Math.abs(s - r) <= t * Math.max(1, Math.abs(s), Math.abs(r)) && Math.abs(o - c) <= t * Math.max(1, Math.abs(o), Math.abs(c)) && Math.abs(i - l) <= t * Math.max(1, Math.abs(i), Math.abs(l)) && Math.abs(a - d) <= t * Math.max(1, Math.abs(a), Math.abs(d))
    }

    function To(e, t, n) {
        return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e
    }

    function Fo(e, t, n, s) {
        return e[0] = t[0] + n[0] * s, e[1] = t[1] + n[1] * s, e[2] = t[2] + n[2] * s, e[3] = t[3] + n[3] * s, e
    }
    D = ke, N = F, L = Object.freeze({
        __proto__: null,
        create: Ni,
        clone: Di,
        copy: zi,
        identity: Ti,
        fromValues: Fi,
        set: Mi,
        transpose: hi,
        invert: ui,
        adjoint: di,
        determinant: li,
        multiply: ke,
        rotate: ti,
        scale: ei,
        fromRotation: Jo,
        fromScaling: qo,
        str: Ko,
        frob: Bo,
        LDU: Io,
        add: Ho,
        subtract: F,
        exactEquals: Po,
        equals: Do,
        multiplyScalar: To,
        multiplyScalarAndAdd: Fo,
        mul: D,
        sub: N
    });

    function yo() {
        var e = new n(6);
        return n != Float32Array && (e[1] = 0, e[2] = 0, e[4] = 0, e[5] = 0), e[0] = 1, e[3] = 1, e
    }

    function bo(e) {
        var t = new n(6);
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t
    }

    function po(e, t) {
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e
    }

    function uo(e) {
        return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, e
    }

    function io(e, t, s, o, i, a) {
        var r = new n(6);
        return r[0] = e, r[1] = t, r[2] = s, r[3] = o, r[4] = i, r[5] = a, r
    }

    function oo(e, t, n, s, o, i, a) {
        return e[0] = t, e[1] = n, e[2] = s, e[3] = o, e[4] = i, e[5] = a, e
    }

    function so(e, t) {
        var s = t[0],
            o = t[1],
            i = t[2],
            a = t[3],
            r = t[4],
            c = t[5],
            n = s * a - o * i;
        return n ? (n = 1 / n, e[0] = a * n, e[1] = -o * n, e[2] = -i * n, e[3] = s * n, e[4] = (i * c - a * r) * n, e[5] = (o * r - s * c) * n, e) : null
    }

    function no(e) {
        return e[0] * e[3] - e[1] * e[2]
    }

    function U(e, t, n) {
        var s = t[0],
            o = t[1],
            i = t[2],
            a = t[3],
            m = t[4],
            f = t[5],
            r = n[0],
            c = n[1],
            l = n[2],
            d = n[3],
            u = n[4],
            h = n[5];
        return e[0] = s * r + i * c, e[1] = o * r + a * c, e[2] = s * l + i * d, e[3] = o * l + a * d, e[4] = s * u + i * h + m, e[5] = o * u + a * h + f, e
    }

    function to(e, t, n) {
        var i = t[0],
            a = t[1],
            r = t[2],
            c = t[3],
            l = t[4],
            d = t[5],
            s = Math.sin(n),
            o = Math.cos(n);
        return e[0] = i * o + r * s, e[1] = a * o + c * s, e[2] = i * -s + r * o, e[3] = a * -s + c * o, e[4] = l, e[5] = d, e
    }

    function eo(e, t, n) {
        var i = t[0],
            a = t[1],
            r = t[2],
            c = t[3],
            l = t[4],
            d = t[5],
            s = n[0],
            o = n[1];
        return e[0] = i * s, e[1] = a * s, e[2] = r * o, e[3] = c * o, e[4] = l, e[5] = d, e
    }

    function Js(e, t, n) {
        var s = t[0],
            o = t[1],
            i = t[2],
            a = t[3],
            l = t[4],
            d = t[5],
            r = n[0],
            c = n[1];
        return e[0] = s, e[1] = o, e[2] = i, e[3] = a, e[4] = s * r + i * c + l, e[5] = o * r + a * c + d, e
    }

    function Zs(e, t) {
        var n = Math.sin(t),
            s = Math.cos(t);
        return e[0] = s, e[1] = n, e[2] = -n, e[3] = s, e[4] = 0, e[5] = 0, e
    }

    function Qs(e, t) {
        return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = t[1], e[4] = 0, e[5] = 0, e
    }

    function Xs(e, t) {
        return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = t[0], e[5] = t[1], e
    }

    function Gs(e) {
        return "mat2d(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ")"
    }

    function Ys(e) {
        return Math.hypot(e[0], e[1], e[2], e[3], e[4], e[5], 1)
    }

    function qs(e, t, n) {
        return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e[3] = t[3] + n[3], e[4] = t[4] + n[4], e[5] = t[5] + n[5], e
    }

    function ee(e, t, n) {
        return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e[2] = t[2] - n[2], e[3] = t[3] - n[3], e[4] = t[4] - n[4], e[5] = t[5] - n[5], e
    }

    function Ks(e, t, n) {
        return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e[4] = t[4] * n, e[5] = t[5] * n, e
    }

    function Us(e, t, n, s) {
        return e[0] = t[0] + n[0] * s, e[1] = t[1] + n[1] * s, e[2] = t[2] + n[2] * s, e[3] = t[3] + n[3] * s, e[4] = t[4] + n[4] * s, e[5] = t[5] + n[5] * s, e
    }

    function Ws(e, t) {
        return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5]
    }

    function $s(e, n) {
        var s = e[0],
            o = e[1],
            i = e[2],
            a = e[3],
            r = e[4],
            c = e[5],
            l = n[0],
            d = n[1],
            u = n[2],
            h = n[3],
            m = n[4],
            f = n[5];
        return Math.abs(s - l) <= t * Math.max(1, Math.abs(s), Math.abs(l)) && Math.abs(o - d) <= t * Math.max(1, Math.abs(o), Math.abs(d)) && Math.abs(i - u) <= t * Math.max(1, Math.abs(i), Math.abs(u)) && Math.abs(a - h) <= t * Math.max(1, Math.abs(a), Math.abs(h)) && Math.abs(r - m) <= t * Math.max(1, Math.abs(r), Math.abs(m)) && Math.abs(c - f) <= t * Math.max(1, Math.abs(c), Math.abs(f))
    }
    ie = U, ae = ee, re = Object.freeze({
        __proto__: null,
        create: yo,
        clone: bo,
        copy: po,
        identity: uo,
        fromValues: io,
        set: oo,
        invert: so,
        determinant: no,
        multiply: U,
        rotate: to,
        scale: eo,
        translate: Js,
        fromRotation: Zs,
        fromScaling: Qs,
        fromTranslation: Xs,
        str: Gs,
        frob: Ys,
        add: qs,
        subtract: ee,
        multiplyScalar: Ks,
        multiplyScalarAndAdd: Us,
        exactEquals: Ws,
        equals: $s,
        mul: ie,
        sub: ae
    });

    function ce() {
        var e = new n(9);
        return n != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[5] = 0, e[6] = 0, e[7] = 0), e[0] = 1, e[4] = 1, e[8] = 1, e
    }

    function Vs(e, t) {
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[4], e[4] = t[5], e[5] = t[6], e[6] = t[8], e[7] = t[9], e[8] = t[10], e
    }

    function Bs(e) {
        var t = new n(9);
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t
    }

    function Is(e, t) {
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e
    }

    function Rs(e, t, s, o, i, a, r, c, l) {
        var d = new n(9);
        return d[0] = e, d[1] = t, d[2] = s, d[3] = o, d[4] = i, d[5] = a, d[6] = r, d[7] = c, d[8] = l, d
    }

    function zs(e, t, n, s, o, i, a, r, c, l) {
        return e[0] = t, e[1] = n, e[2] = s, e[3] = o, e[4] = i, e[5] = a, e[6] = r, e[7] = c, e[8] = l, e
    }

    function Fs(e) {
        return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e
    }

    function Ms(e, t) {
        if (e === t) {
            var n = t[1],
                s = t[2],
                o = t[5];
            e[1] = t[3], e[2] = t[6], e[3] = n, e[5] = t[7], e[6] = s, e[7] = o
        } else e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8];
        return e
    }

    function As(e, t) {
        var s = t[0],
            o = t[1],
            i = t[2],
            u = t[3],
            c = t[4],
            r = t[5],
            a = t[6],
            l = t[7],
            d = t[8],
            h = d * c - r * l,
            m = -d * u + r * a,
            f = l * u - c * a,
            n = s * h + o * m + i * f;
        return n ? (n = 1 / n, e[0] = h * n, e[1] = (-d * o + i * l) * n, e[2] = (r * o - i * c) * n, e[3] = m * n, e[4] = (d * s - i * a) * n, e[5] = (-r * s + i * u) * n, e[6] = f * n, e[7] = (-l * s + o * a) * n, e[8] = (c * s - o * u) * n, e) : null
    }

    function ks(e, t) {
        var n = t[0],
            s = t[1],
            o = t[2],
            i = t[3],
            a = t[4],
            r = t[5],
            c = t[6],
            l = t[7],
            d = t[8];
        return e[0] = a * d - r * l, e[1] = o * l - s * d, e[2] = s * r - o * a, e[3] = r * c - i * d, e[4] = n * d - o * c, e[5] = o * i - n * r, e[6] = i * l - a * c, e[7] = s * c - n * l, e[8] = n * a - s * i, e
    }

    function Es(e) {
        var r = e[0],
            c = e[1],
            l = e[2],
            t = e[3],
            n = e[4],
            s = e[5],
            o = e[6],
            i = e[7],
            a = e[8];
        return r * (a * n - s * i) + c * (-a * t + s * o) + l * (i * t - n * o)
    }

    function je(e, t, n) {
        var s = t[0],
            o = t[1],
            i = t[2],
            a = t[3],
            r = t[4],
            c = t[5],
            l = t[6],
            d = t[7],
            u = t[8],
            h = n[0],
            m = n[1],
            f = n[2],
            p = n[3],
            g = n[4],
            v = n[5],
            b = n[6],
            j = n[7],
            y = n[8];
        return e[0] = h * s + m * a + f * l, e[1] = h * o + m * r + f * d, e[2] = h * i + m * c + f * u, e[3] = p * s + g * a + v * l, e[4] = p * o + g * r + v * d, e[5] = p * i + g * c + v * u, e[6] = b * s + j * a + y * l, e[7] = b * o + j * r + y * d, e[8] = b * i + j * c + y * u, e
    }

    function Cs(e, t, n) {
        var i = t[0],
            a = t[1],
            r = t[2],
            c = t[3],
            l = t[4],
            d = t[5],
            u = t[6],
            h = t[7],
            m = t[8],
            s = n[0],
            o = n[1];
        return e[0] = i, e[1] = a, e[2] = r, e[3] = c, e[4] = l, e[5] = d, e[6] = s * i + o * c + u, e[7] = s * a + o * l + h, e[8] = s * r + o * d + m, e
    }

    function ws(e, t, n) {
        var i = t[0],
            a = t[1],
            r = t[2],
            c = t[3],
            l = t[4],
            d = t[5],
            u = t[6],
            h = t[7],
            m = t[8],
            s = Math.sin(n),
            o = Math.cos(n);
        return e[0] = o * i + s * c, e[1] = o * a + s * l, e[2] = o * r + s * d, e[3] = o * c - s * i, e[4] = o * l - s * a, e[5] = o * d - s * r, e[6] = u, e[7] = h, e[8] = m, e
    }

    function ys(e, t, n) {
        var s = n[0],
            o = n[1];
        return e[0] = s * t[0], e[1] = s * t[1], e[2] = s * t[2], e[3] = o * t[3], e[4] = o * t[4], e[5] = o * t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e
    }

    function js(e, t) {
        return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = t[0], e[7] = t[1], e[8] = 1, e
    }

    function bs(e, t) {
        var n = Math.sin(t),
            s = Math.cos(t);
        return e[0] = s, e[1] = n, e[2] = 0, e[3] = -n, e[4] = s, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e
    }

    function vs(e, t) {
        return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = t[1], e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e
    }

    function gs(e, t) {
        return e[0] = t[0], e[1] = t[1], e[2] = 0, e[3] = t[2], e[4] = t[3], e[5] = 0, e[6] = t[4], e[7] = t[5], e[8] = 1, e
    }

    function ps(e, t) {
        var i = t[0],
            s = t[1],
            n = t[2],
            a = t[3],
            o = i + i,
            r = s + s,
            d = n + n,
            l = i * o,
            c = s * o,
            u = s * r,
            h = n * o,
            m = n * r,
            f = n * d,
            p = a * o,
            g = a * r,
            v = a * d;
        return e[0] = 1 - u - f, e[3] = c - v, e[6] = h + g, e[1] = c + v, e[4] = 1 - l - f, e[7] = m - p, e[2] = h - g, e[5] = m + p, e[8] = 1 - l - u, e
    }

    function fs(e, t) {
        var g = t[0],
            d = t[1],
            v = t[2],
            i = t[3],
            l = t[4],
            r = t[5],
            c = t[6],
            s = t[7],
            k = t[8],
            E = t[9],
            C = t[10],
            O = t[11],
            f = t[12],
            p = t[13],
            a = t[14],
            o = t[15],
            M = g * r - d * l,
            A = g * c - v * l,
            j = g * s - i * l,
            S = d * c - v * r,
            y = d * s - i * r,
            _ = v * s - i * c,
            w = k * p - E * f,
            b = k * a - C * f,
            m = k * o - O * f,
            x = E * a - C * p,
            h = E * o - O * p,
            u = C * o - O * a,
            n = M * u - A * h + j * x + S * m - y * b + _ * w;
        return n ? (n = 1 / n, e[0] = (r * u - c * h + s * x) * n, e[1] = (c * m - l * u - s * b) * n, e[2] = (l * h - r * m + s * w) * n, e[3] = (v * h - d * u - i * x) * n, e[4] = (g * u - v * m + i * b) * n, e[5] = (d * m - g * h - i * w) * n, e[6] = (p * _ - a * y + o * S) * n, e[7] = (a * j - f * _ - o * A) * n, e[8] = (f * y - p * j + o * M) * n, e) : null
    }

    function ms(e, t, n) {
        return e[0] = 2 / t, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = -2 / n, e[5] = 0, e[6] = -1, e[7] = 1, e[8] = 1, e
    }

    function hs(e) {
        return "mat3(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ", " + e[6] + ", " + e[7] + ", " + e[8] + ")"
    }

    function us(e) {
        return Math.hypot(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8])
    }

    function ds(e, t, n) {
        return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e[3] = t[3] + n[3], e[4] = t[4] + n[4], e[5] = t[5] + n[5], e[6] = t[6] + n[6], e[7] = t[7] + n[7], e[8] = t[8] + n[8], e
    }

    function ze(e, t, n) {
        return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e[2] = t[2] - n[2], e[3] = t[3] - n[3], e[4] = t[4] - n[4], e[5] = t[5] - n[5], e[6] = t[6] - n[6], e[7] = t[7] - n[7], e[8] = t[8] - n[8], e
    }

    function ls(e, t, n) {
        return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e[4] = t[4] * n, e[5] = t[5] * n, e[6] = t[6] * n, e[7] = t[7] * n, e[8] = t[8] * n, e
    }

    function ns(e, t, n, s) {
        return e[0] = t[0] + n[0] * s, e[1] = t[1] + n[1] * s, e[2] = t[2] + n[2] * s, e[3] = t[3] + n[3] * s, e[4] = t[4] + n[4] * s, e[5] = t[5] + n[5] * s, e[6] = t[6] + n[6] * s, e[7] = t[7] + n[7] * s, e[8] = t[8] + n[8] * s, e
    }

    function Tt(e, t) {
        return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8]
    }

    function es(e, n) {
        var s = e[0],
            o = e[1],
            i = e[2],
            a = e[3],
            r = e[4],
            c = e[5],
            l = e[6],
            d = e[7],
            u = e[8],
            h = n[0],
            m = n[1],
            f = n[2],
            p = n[3],
            g = n[4],
            v = n[5],
            b = n[6],
            j = n[7],
            y = n[8];
        return Math.abs(s - h) <= t * Math.max(1, Math.abs(s), Math.abs(h)) && Math.abs(o - m) <= t * Math.max(1, Math.abs(o), Math.abs(m)) && Math.abs(i - f) <= t * Math.max(1, Math.abs(i), Math.abs(f)) && Math.abs(a - p) <= t * Math.max(1, Math.abs(a), Math.abs(p)) && Math.abs(r - g) <= t * Math.max(1, Math.abs(r), Math.abs(g)) && Math.abs(c - v) <= t * Math.max(1, Math.abs(c), Math.abs(v)) && Math.abs(l - b) <= t * Math.max(1, Math.abs(l), Math.abs(b)) && Math.abs(d - j) <= t * Math.max(1, Math.abs(d), Math.abs(j)) && Math.abs(u - y) <= t * Math.max(1, Math.abs(u), Math.abs(y))
    }
    Pe = je, He = ze, Ie = Object.freeze({
        __proto__: null,
        create: ce,
        fromMat4: Vs,
        clone: Bs,
        copy: Is,
        fromValues: Rs,
        set: zs,
        identity: Fs,
        transpose: Ms,
        invert: As,
        adjoint: ks,
        determinant: Es,
        multiply: je,
        translate: Cs,
        rotate: ws,
        scale: ys,
        fromTranslation: js,
        fromRotation: bs,
        fromScaling: vs,
        fromMat2d: gs,
        fromQuat: ps,
        normalFromMat4: fs,
        projection: ms,
        str: hs,
        frob: us,
        add: ds,
        subtract: ze,
        multiplyScalar: ls,
        multiplyScalarAndAdd: ns,
        exactEquals: Tt,
        equals: es,
        mul: Pe,
        sub: He
    });

    function Jn() {
        var e = new n(16);
        return n != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0), e[0] = 1, e[5] = 1, e[10] = 1, e[15] = 1, e
    }

    function Xn(e) {
        var t = new n(16);
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t
    }

    function Gn(e, t) {
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e
    }

    function Yn(e, t, s, o, i, a, r, c, l, d, u, h, m, f, p, g) {
        var v = new n(16);
        return v[0] = e, v[1] = t, v[2] = s, v[3] = o, v[4] = i, v[5] = a, v[6] = r, v[7] = c, v[8] = l, v[9] = d, v[10] = u, v[11] = h, v[12] = m, v[13] = f, v[14] = p, v[15] = g, v
    }

    function qn(e, t, n, s, o, i, a, r, c, l, d, u, h, m, f, p, g) {
        return e[0] = t, e[1] = n, e[2] = s, e[3] = o, e[4] = i, e[5] = a, e[6] = r, e[7] = c, e[8] = l, e[9] = d, e[10] = u, e[11] = h, e[12] = m, e[13] = f, e[14] = p, e[15] = g, e
    }

    function Ke(e) {
        return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
    }

    function Un(e, t) {
        if (e === t) {
            var n = t[1],
                s = t[2],
                o = t[3],
                i = t[6],
                a = t[7],
                r = t[11];
            e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = n, e[6] = t[9], e[7] = t[13], e[8] = s, e[9] = i, e[11] = t[14], e[12] = o, e[13] = a, e[14] = r
        } else e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15];
        return e
    }

    function Hn(e, t) {
        var b = t[0],
            p = t[1],
            g = t[2],
            i = t[3],
            a = t[4],
            r = t[5],
            c = t[6],
            l = t[7],
            o = t[8],
            u = t[9],
            h = t[10],
            m = t[11],
            f = t[12],
            v = t[13],
            s = t[14],
            d = t[15],
            A = b * r - p * a,
            _ = b * c - g * a,
            y = b * l - i * a,
            M = p * c - g * r,
            w = p * l - i * r,
            O = g * l - i * c,
            x = o * v - u * f,
            C = o * s - h * f,
            E = o * d - m * f,
            k = u * s - h * v,
            j = u * d - m * v,
            S = h * d - m * s,
            n = A * S - _ * j + y * k + M * E - w * C + O * x;
        return n ? (n = 1 / n, e[0] = (r * S - c * j + l * k) * n, e[1] = (g * j - p * S - i * k) * n, e[2] = (v * O - s * w + d * M) * n, e[3] = (h * w - u * O - m * M) * n, e[4] = (c * E - a * S - l * C) * n, e[5] = (b * S - g * E + i * C) * n, e[6] = (s * y - f * O - d * _) * n, e[7] = (o * O - h * y + m * _) * n, e[8] = (a * j - r * E + l * x) * n, e[9] = (p * E - b * j - i * x) * n, e[10] = (f * w - v * y + d * A) * n, e[11] = (u * y - o * w - m * A) * n, e[12] = (r * C - a * k - c * x) * n, e[13] = (b * k - p * C + g * x) * n, e[14] = (v * _ - f * M - s * A) * n, e[15] = (o * M - u * _ + h * A) * n, e) : null
    }

    function Pn(e, t) {
        var g = t[0],
            u = t[1],
            n = t[2],
            s = t[3],
            v = t[4],
            h = t[5],
            i = t[6],
            a = t[7],
            f = t[8],
            m = t[9],
            c = t[10],
            l = t[11],
            p = t[12],
            d = t[13],
            r = t[14],
            o = t[15];
        return e[0] = h * (c * o - l * r) - m * (i * o - a * r) + d * (i * l - a * c), e[1] = -(u * (c * o - l * r) - m * (n * o - s * r) + d * (n * l - s * c)), e[2] = u * (i * o - a * r) - h * (n * o - s * r) + d * (n * a - s * i), e[3] = -(u * (i * l - a * c) - h * (n * l - s * c) + m * (n * a - s * i)), e[4] = -(v * (c * o - l * r) - f * (i * o - a * r) + p * (i * l - a * c)), e[5] = g * (c * o - l * r) - f * (n * o - s * r) + p * (n * l - s * c), e[6] = -(g * (i * o - a * r) - v * (n * o - s * r) + p * (n * a - s * i)), e[7] = g * (i * l - a * c) - v * (n * l - s * c) + f * (n * a - s * i), e[8] = v * (m * o - l * d) - f * (h * o - a * d) + p * (h * l - a * m), e[9] = -(g * (m * o - l * d) - f * (u * o - s * d) + p * (u * l - s * m)), e[10] = g * (h * o - a * d) - v * (u * o - s * d) + p * (u * a - s * h), e[11] = -(g * (h * l - a * m) - v * (u * l - s * m) + f * (u * a - s * h)), e[12] = -(v * (m * r - c * d) - f * (h * r - i * d) + p * (h * c - i * m)), e[13] = g * (m * r - c * d) - f * (u * r - n * d) + p * (u * c - n * m), e[14] = -(g * (h * r - i * d) - v * (u * r - n * d) + p * (u * i - n * h)), e[15] = g * (h * c - i * m) - v * (u * c - n * m) + f * (u * i - n * h), e
    }

    function Rn(e) {
        var t = e[0],
            n = e[1],
            s = e[2],
            o = e[3],
            i = e[4],
            a = e[5],
            r = e[6],
            c = e[7],
            l = e[8],
            d = e[9],
            u = e[10],
            h = e[11],
            m = e[12],
            f = e[13],
            p = e[14],
            g = e[15],
            v = t * a - n * i,
            b = t * r - s * i,
            j = t * c - o * i,
            y = n * r - s * a,
            _ = n * c - o * a,
            w = s * c - o * r,
            O = l * f - d * m,
            x = l * p - u * m,
            C = l * g - h * m,
            E = d * p - u * f,
            k = d * g - h * f,
            A = u * g - h * p;
        return v * A - b * k + j * E + y * C - _ * x + w * O
    }

    function Qe(e, t, n) {
        var m = t[0],
            w = t[1],
            _ = t[2],
            y = t[3],
            j = t[4],
            f = t[5],
            l = t[6],
            d = t[7],
            u = t[8],
            h = t[9],
            r = t[10],
            c = t[11],
            p = t[12],
            g = t[13],
            v = t[14],
            b = t[15],
            s = n[0],
            a = n[1],
            i = n[2],
            o = n[3];
        return e[0] = s * m + a * j + i * u + o * p, e[1] = s * w + a * f + i * h + o * g, e[2] = s * _ + a * l + i * r + o * v, e[3] = s * y + a * d + i * c + o * b, s = n[4], a = n[5], i = n[6], o = n[7], e[4] = s * m + a * j + i * u + o * p, e[5] = s * w + a * f + i * h + o * g, e[6] = s * _ + a * l + i * r + o * v, e[7] = s * y + a * d + i * c + o * b, s = n[8], a = n[9], i = n[10], o = n[11], e[8] = s * m + a * j + i * u + o * p, e[9] = s * w + a * f + i * h + o * g, e[10] = s * _ + a * l + i * r + o * v, e[11] = s * y + a * d + i * c + o * b, s = n[12], a = n[13], i = n[14], o = n[15], e[12] = s * m + a * j + i * u + o * p, e[13] = s * w + a * f + i * h + o * g, e[14] = s * _ + a * l + i * r + o * v, e[15] = s * y + a * d + i * c + o * b, e
    }

    function Ln(e, t, n) {
        var a, r, c, l, d, u, h, m, f, p, g, v, s = n[0],
            o = n[1],
            i = n[2];
        return t === e ? (e[12] = t[0] * s + t[4] * o + t[8] * i + t[12], e[13] = t[1] * s + t[5] * o + t[9] * i + t[13], e[14] = t[2] * s + t[6] * o + t[10] * i + t[14], e[15] = t[3] * s + t[7] * o + t[11] * i + t[15]) : (a = t[0], r = t[1], c = t[2], l = t[3], d = t[4], u = t[5], h = t[6], m = t[7], f = t[8], p = t[9], g = t[10], v = t[11], e[0] = a, e[1] = r, e[2] = c, e[3] = l, e[4] = d, e[5] = u, e[6] = h, e[7] = m, e[8] = f, e[9] = p, e[10] = g, e[11] = v, e[12] = a * s + d * o + f * i + t[12], e[13] = r * s + u * o + p * i + t[13], e[14] = c * s + h * o + g * i + t[14], e[15] = l * s + m * o + v * i + t[15]), e
    }

    function Nn(e, t, n) {
        var s = n[0],
            o = n[1],
            i = n[2];
        return e[0] = t[0] * s, e[1] = t[1] * s, e[2] = t[2] * s, e[3] = t[3] * s, e[4] = t[4] * o, e[5] = t[5] * o, e[6] = t[6] * o, e[7] = t[7] * o, e[8] = t[8] * i, e[9] = t[9] * i, e[10] = t[10] * i, e[11] = t[11] * i, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e
    }

    function Dn(e, n, s, o) {
        var i, l, u, h, m, f, p, g, v, b, j, y, _, w, O, x, C, E, k, A, S, M, F, T, c = o[0],
            a = o[1],
            r = o[2],
            d = Math.hypot(c, a, r);
        return d < t ? null : (d = 1 / d, c *= d, a *= d, r *= d, l = Math.sin(s), h = Math.cos(s), i = 1 - h, _ = n[0], T = n[1], F = n[2], M = n[3], S = n[4], A = n[5], k = n[6], E = n[7], C = n[8], x = n[9], w = n[10], O = n[11], m = c * c * i + h, y = a * c * i + r * l, j = r * c * i - a * l, b = c * a * i - r * l, v = a * a * i + h, g = r * a * i + c * l, p = c * r * i + a * l, f = a * r * i - c * l, u = r * r * i + h, e[0] = _ * m + S * y + C * j, e[1] = T * m + A * y + x * j, e[2] = F * m + k * y + w * j, e[3] = M * m + E * y + O * j, e[4] = _ * b + S * v + C * g, e[5] = T * b + A * v + x * g, e[6] = F * b + k * v + w * g, e[7] = M * b + E * v + O * g, e[8] = _ * p + S * f + C * u, e[9] = T * p + A * f + x * u, e[10] = F * p + k * f + w * u, e[11] = M * p + E * f + O * u, n !== e && (e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15]), e)
    }

    function zn(e, t, n) {
        var s = Math.sin(n),
            o = Math.cos(n),
            i = t[4],
            a = t[5],
            r = t[6],
            c = t[7],
            l = t[8],
            d = t[9],
            u = t[10],
            h = t[11];
        return t !== e && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[4] = i * o + l * s, e[5] = a * o + d * s, e[6] = r * o + u * s, e[7] = c * o + h * s, e[8] = l * o - i * s, e[9] = d * o - a * s, e[10] = u * o - r * s, e[11] = h * o - c * s, e
    }

    function Tn(e, t, n) {
        var s = Math.sin(n),
            o = Math.cos(n),
            i = t[0],
            a = t[1],
            r = t[2],
            c = t[3],
            l = t[8],
            d = t[9],
            u = t[10],
            h = t[11];
        return t !== e && (e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = i * o - l * s, e[1] = a * o - d * s, e[2] = r * o - u * s, e[3] = c * o - h * s, e[8] = i * s + l * o, e[9] = a * s + d * o, e[10] = r * s + u * o, e[11] = c * s + h * o, e
    }

    function Fn(e, t, n) {
        var s = Math.sin(n),
            o = Math.cos(n),
            i = t[0],
            a = t[1],
            r = t[2],
            c = t[3],
            l = t[4],
            d = t[5],
            u = t[6],
            h = t[7];
        return t !== e && (e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = i * o + l * s, e[1] = a * o + d * s, e[2] = r * o + u * s, e[3] = c * o + h * s, e[4] = l * o - i * s, e[5] = d * o - a * s, e[6] = u * o - r * s, e[7] = h * o - c * s, e
    }

    function Mn(e, t) {
        return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = t[0], e[13] = t[1], e[14] = t[2], e[15] = 1, e
    }

    function Sn(e, t) {
        return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = t[1], e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = t[2], e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
    }

    function An(e, n, s) {
        var r, c, d, o = s[0],
            i = s[1],
            a = s[2],
            l = Math.hypot(o, i, a);
        return l < t ? null : (l = 1 / l, o *= l, i *= l, a *= l, c = Math.sin(n), d = Math.cos(n), r = 1 - d, e[0] = o * o * r + d, e[1] = i * o * r + a * c, e[2] = a * o * r - i * c, e[3] = 0, e[4] = o * i * r - a * c, e[5] = i * i * r + d, e[6] = a * i * r + o * c, e[7] = 0, e[8] = o * a * r + i * c, e[9] = i * a * r - o * c, e[10] = a * a * r + d, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e)
    }

    function kn(e, t) {
        var n = Math.sin(t),
            s = Math.cos(t);
        return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = s, e[6] = n, e[7] = 0, e[8] = 0, e[9] = -n, e[10] = s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
    }

    function En(e, t) {
        var n = Math.sin(t),
            s = Math.cos(t);
        return e[0] = s, e[1] = 0, e[2] = -n, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = n, e[9] = 0, e[10] = s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
    }

    function Cn(e, t) {
        var n = Math.sin(t),
            s = Math.cos(t);
        return e[0] = s, e[1] = n, e[2] = 0, e[3] = 0, e[4] = -n, e[5] = s, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
    }

    function dt(e, t, n) {
        var s = t[0],
            i = t[1],
            a = t[2],
            r = t[3],
            u = s + s,
            c = i + i,
            o = a + a,
            d = s * u,
            l = s * c,
            h = s * o,
            m = i * c,
            f = i * o,
            p = a * o,
            g = r * u,
            v = r * c,
            b = r * o;
        return e[0] = 1 - (m + p), e[1] = l + b, e[2] = h - v, e[3] = 0, e[4] = l - b, e[5] = 1 - (d + p), e[6] = f + g, e[7] = 0, e[8] = h + v, e[9] = f - g, e[10] = 1 - (d + m), e[11] = 0, e[12] = n[0], e[13] = n[1], e[14] = n[2], e[15] = 1, e
    }

    function xn(e, t) {
        var r = new n(3),
            s = -t[0],
            o = -t[1],
            i = -t[2],
            a = t[3],
            c = t[4],
            l = t[5],
            d = t[6],
            u = t[7],
            h = s * s + o * o + i * i + a * a;
        return h > 0 ? (r[0] = (c * a + u * s + l * i - d * o) * 2 / h, r[1] = (l * a + u * o + d * s - c * i) * 2 / h, r[2] = (d * a + u * i + c * o - l * s) * 2 / h) : (r[0] = (c * a + u * s + l * i - d * o) * 2, r[1] = (l * a + u * o + d * s - c * i) * 2, r[2] = (d * a + u * i + c * o - l * s) * 2), dt(e, t, r), e
    }

    function ht(e, t) {
        return e[0] = t[12], e[1] = t[13], e[2] = t[14], e
    }

    function mt(e, t) {
        var n = t[0],
            s = t[1],
            o = t[2],
            i = t[4],
            a = t[5],
            r = t[6],
            c = t[8],
            l = t[9],
            d = t[10];
        return e[0] = Math.hypot(n, s, o), e[1] = Math.hypot(i, a, r), e[2] = Math.hypot(c, l, d), e
    }

    function ft(e, t) {
        var s, o, i, a, r, c, l, d, u, h, m, p, g, v, f = new n(3);
        return mt(f, t), g = 1 / f[0], p = 1 / f[1], m = 1 / f[2], o = t[0] * g, c = t[1] * p, l = t[2] * m, d = t[4] * g, a = t[5] * p, r = t[6] * m, u = t[8] * g, h = t[9] * p, i = t[10] * m, v = o + a + i, s = 0, v > 0 ? (s = Math.sqrt(v + 1) * 2, e[3] = .25 * s, e[0] = (r - h) / s, e[1] = (u - l) / s, e[2] = (c - d) / s) : o > a && o > i ? (s = Math.sqrt(1 + o - a - i) * 2, e[3] = (r - h) / s, e[0] = .25 * s, e[1] = (c + d) / s, e[2] = (u + l) / s) : a > i ? (s = Math.sqrt(1 + a - o - i) * 2, e[3] = (u - l) / s, e[0] = (c + d) / s, e[1] = .25 * s, e[2] = (r + h) / s) : (s = Math.sqrt(1 + i - o - a) * 2, e[3] = (c - d) / s, e[0] = (u + l) / s, e[1] = (r + h) / s, e[2] = .25 * s), e
    }

    function On(e, t, n, s) {
        var o = t[0],
            i = t[1],
            c = t[2],
            l = t[3],
            w = o + o,
            u = i + i,
            a = c + c,
            _ = o * w,
            m = o * u,
            y = o * a,
            f = i * u,
            p = i * a,
            g = c * a,
            v = l * w,
            b = l * u,
            j = l * a,
            r = s[0],
            h = s[1],
            d = s[2];
        return e[0] = (1 - (f + g)) * r, e[1] = (m + j) * r, e[2] = (y - b) * r, e[3] = 0, e[4] = (m - j) * h, e[5] = (1 - (_ + g)) * h, e[6] = (p + v) * h, e[7] = 0, e[8] = (y + b) * d, e[9] = (p - v) * d, e[10] = (1 - (_ + f)) * d, e[11] = 0, e[12] = n[0], e[13] = n[1], e[14] = n[2], e[15] = 1, e
    }

    function wn(e, t, n, s, o) {
        var i = t[0],
            a = t[1],
            h = t[2],
            m = t[3],
            b = i + i,
            f = a + a,
            c = h + h,
            v = i * b,
            C = i * f,
            x = i * c,
            O = a * f,
            w = a * c,
            _ = h * c,
            E = m * b,
            j = m * f,
            y = m * c,
            u = s[0],
            g = s[1],
            p = s[2],
            d = o[0],
            l = o[1],
            r = o[2],
            k = (1 - (O + _)) * u,
            A = (C + y) * u,
            S = (x - j) * u,
            M = (C - y) * g,
            F = (1 - (v + _)) * g,
            T = (w + E) * g,
            z = (x + j) * p,
            D = (w - E) * p,
            N = (1 - (v + O)) * p;
        return e[0] = k, e[1] = A, e[2] = S, e[3] = 0, e[4] = M, e[5] = F, e[6] = T, e[7] = 0, e[8] = z, e[9] = D, e[10] = N, e[11] = 0, e[12] = n[0] + d - (k * d + M * l + z * r), e[13] = n[1] + l - (A * d + F * l + D * r), e[14] = n[2] + r - (S * d + T * l + N * r), e[15] = 1, e
    }

    function an(e, t) {
        var i = t[0],
            s = t[1],
            n = t[2],
            a = t[3],
            o = i + i,
            r = s + s,
            d = n + n,
            l = i * o,
            c = s * o,
            u = s * r,
            h = n * o,
            m = n * r,
            f = n * d,
            p = a * o,
            g = a * r,
            v = a * d;
        return e[0] = 1 - u - f, e[1] = c + v, e[2] = h - g, e[3] = 0, e[4] = c - v, e[5] = 1 - l - f, e[6] = m + p, e[7] = 0, e[8] = h + g, e[9] = m - p, e[10] = 1 - l - u, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
    }

    function on(e, t, n, s, o, i, a) {
        var r = 1 / (n - t),
            c = 1 / (o - s),
            l = 1 / (i - a);
        return e[0] = i * 2 * r, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = i * 2 * c, e[6] = 0, e[7] = 0, e[8] = (n + t) * r, e[9] = (o + s) * c, e[10] = (a + i) * l, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = a * i * 2 * l, e[15] = 0, e
    }

    function sn(e, t, n, s, o) {
        var i, a = 1 / Math.tan(t / 2);
        return e[0] = a / n, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = a, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, o != null && o !== 1 / 0 ? (i = 1 / (s - o), e[10] = (o + s) * i, e[14] = 2 * o * s * i) : (e[10] = -1, e[14] = -2 * s), e
    }

    function en(e, t, n, s) {
        var o = Math.tan(t.upDegrees * Math.PI / 180),
            i = Math.tan(t.downDegrees * Math.PI / 180),
            a = Math.tan(t.leftDegrees * Math.PI / 180),
            r = Math.tan(t.rightDegrees * Math.PI / 180),
            c = 2 / (a + r),
            l = 2 / (o + i);
        return e[0] = c, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = l, e[6] = 0, e[7] = 0, e[8] = -((a - r) * c * .5), e[9] = (o - i) * l * .5, e[10] = s / (n - s), e[11] = -1, e[12] = 0, e[13] = 0, e[14] = s * n / (n - s), e[15] = 0, e
    }

    function Jt(e, t, n, s, o, i, a) {
        var r = 1 / (t - n),
            c = 1 / (s - o),
            l = 1 / (i - a);
        return e[0] = -2 * r, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * l, e[11] = 0, e[12] = (t + n) * r, e[13] = (o + s) * c, e[14] = (a + i) * l, e[15] = 1, e
    }

    function Zt(e, n, s, o) {
        var i, a, r, c, l, d, u, h, m, f, p = n[0],
            g = n[1],
            v = n[2],
            b = o[0],
            j = o[1],
            y = o[2],
            _ = s[0],
            w = s[1],
            O = s[2];
        return Math.abs(p - _) < t && Math.abs(g - w) < t && Math.abs(v - O) < t ? Ke(e) : (c = p - _, a = g - w, r = v - O, i = 1 / Math.hypot(c, a, r), c *= i, a *= i, r *= i, u = j * r - y * a, l = y * c - b * r, d = b * a - j * c, i = Math.hypot(u, l, d), i ? (i = 1 / i, u *= i, l *= i, d *= i) : (u = 0, l = 0, d = 0), f = a * d - r * l, h = r * u - c * d, m = c * l - a * u, i = Math.hypot(f, h, m), i ? (i = 1 / i, f *= i, h *= i, m *= i) : (f = 0, h = 0, m = 0), e[0] = u, e[1] = f, e[2] = c, e[3] = 0, e[4] = l, e[5] = h, e[6] = a, e[7] = 0, e[8] = d, e[9] = m, e[10] = r, e[11] = 0, e[12] = -(u * p + l * g + d * v), e[13] = -(f * p + h * g + m * v), e[14] = -(c * p + a * g + r * v), e[15] = 1, e)
    }

    function Wt(e, t, n, s) {
        var p = t[0],
            g = t[1],
            u = t[2],
            h = s[0],
            m = s[1],
            f = s[2],
            i = p - n[0],
            a = g - n[1],
            r = u - n[2],
            o = i * i + a * a + r * r;
        o > 0 && (o = 1 / Math.sqrt(o), i *= o, a *= o, r *= o);
        var c = m * r - f * a,
            l = f * i - h * r,
            d = h * a - m * i,
            o = c * c + l * l + d * d;
        return o > 0 && (o = 1 / Math.sqrt(o), c *= o, l *= o, d *= o), e[0] = c, e[1] = l, e[2] = d, e[3] = 0, e[4] = a * d - r * l, e[5] = r * c - i * d, e[6] = i * l - a * c, e[7] = 0, e[8] = i, e[9] = a, e[10] = r, e[11] = 0, e[12] = p, e[13] = g, e[14] = u, e[15] = 1, e
    }

    function $t(e) {
        return "mat4(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ", " + e[6] + ", " + e[7] + ", " + e[8] + ", " + e[9] + ", " + e[10] + ", " + e[11] + ", " + e[12] + ", " + e[13] + ", " + e[14] + ", " + e[15] + ")"
    }

    function Vt(e) {
        return Math.hypot(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15])
    }

    function Pt(e, t, n) {
        return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e[3] = t[3] + n[3], e[4] = t[4] + n[4], e[5] = t[5] + n[5], e[6] = t[6] + n[6], e[7] = t[7] + n[7], e[8] = t[8] + n[8], e[9] = t[9] + n[9], e[10] = t[10] + n[10], e[11] = t[11] + n[11], e[12] = t[12] + n[12], e[13] = t[13] + n[13], e[14] = t[14] + n[14], e[15] = t[15] + n[15], e
    }

    function kt(e, t, n) {
        return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e[2] = t[2] - n[2], e[3] = t[3] - n[3], e[4] = t[4] - n[4], e[5] = t[5] - n[5], e[6] = t[6] - n[6], e[7] = t[7] - n[7], e[8] = t[8] - n[8], e[9] = t[9] - n[9], e[10] = t[10] - n[10], e[11] = t[11] - n[11], e[12] = t[12] - n[12], e[13] = t[13] - n[13], e[14] = t[14] - n[14], e[15] = t[15] - n[15], e
    }

    function Rt(e, t, n) {
        return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e[4] = t[4] * n, e[5] = t[5] * n, e[6] = t[6] * n, e[7] = t[7] * n, e[8] = t[8] * n, e[9] = t[9] * n, e[10] = t[10] * n, e[11] = t[11] * n, e[12] = t[12] * n, e[13] = t[13] * n, e[14] = t[14] * n, e[15] = t[15] * n, e
    }

    function Nt(e, t, n, s) {
        return e[0] = t[0] + n[0] * s, e[1] = t[1] + n[1] * s, e[2] = t[2] + n[2] * s, e[3] = t[3] + n[3] * s, e[4] = t[4] + n[4] * s, e[5] = t[5] + n[5] * s, e[6] = t[6] + n[6] * s, e[7] = t[7] + n[7] * s, e[8] = t[8] + n[8] * s, e[9] = t[9] + n[9] * s, e[10] = t[10] + n[10] * s, e[11] = t[11] + n[11] * s, e[12] = t[12] + n[12] * s, e[13] = t[13] + n[13] * s, e[14] = t[14] + n[14] * s, e[15] = t[15] + n[15] * s, e
    }

    function Dt(e, t) {
        return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[11] === t[11] && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[15] === t[15]
    }

    function Ns(e, n) {
        var s = e[0],
            o = e[1],
            i = e[2],
            a = e[3],
            r = e[4],
            c = e[5],
            l = e[6],
            d = e[7],
            u = e[8],
            h = e[9],
            m = e[10],
            f = e[11],
            p = e[12],
            g = e[13],
            v = e[14],
            b = e[15],
            j = n[0],
            y = n[1],
            _ = n[2],
            w = n[3],
            O = n[4],
            x = n[5],
            C = n[6],
            E = n[7],
            k = n[8],
            A = n[9],
            S = n[10],
            M = n[11],
            F = n[12],
            T = n[13],
            z = n[14],
            D = n[15];
        return Math.abs(s - j) <= t * Math.max(1, Math.abs(s), Math.abs(j)) && Math.abs(o - y) <= t * Math.max(1, Math.abs(o), Math.abs(y)) && Math.abs(i - _) <= t * Math.max(1, Math.abs(i), Math.abs(_)) && Math.abs(a - w) <= t * Math.max(1, Math.abs(a), Math.abs(w)) && Math.abs(r - O) <= t * Math.max(1, Math.abs(r), Math.abs(O)) && Math.abs(c - x) <= t * Math.max(1, Math.abs(c), Math.abs(x)) && Math.abs(l - C) <= t * Math.max(1, Math.abs(l), Math.abs(C)) && Math.abs(d - E) <= t * Math.max(1, Math.abs(d), Math.abs(E)) && Math.abs(u - k) <= t * Math.max(1, Math.abs(u), Math.abs(k)) && Math.abs(h - A) <= t * Math.max(1, Math.abs(h), Math.abs(A)) && Math.abs(m - S) <= t * Math.max(1, Math.abs(m), Math.abs(S)) && Math.abs(f - M) <= t * Math.max(1, Math.abs(f), Math.abs(M)) && Math.abs(p - F) <= t * Math.max(1, Math.abs(p), Math.abs(F)) && Math.abs(g - T) <= t * Math.max(1, Math.abs(g), Math.abs(T)) && Math.abs(v - z) <= t * Math.max(1, Math.abs(v), Math.abs(z)) && Math.abs(b - D) <= t * Math.max(1, Math.abs(b), Math.abs(D))
    }
    St = Qe, Ft = kt, Mt = Object.freeze({
        __proto__: null,
        create: Jn,
        clone: Xn,
        copy: Gn,
        fromValues: Yn,
        set: qn,
        identity: Ke,
        transpose: Un,
        invert: Hn,
        adjoint: Pn,
        determinant: Rn,
        multiply: Qe,
        translate: Ln,
        scale: Nn,
        rotate: Dn,
        rotateX: zn,
        rotateY: Tn,
        rotateZ: Fn,
        fromTranslation: Mn,
        fromScaling: Sn,
        fromRotation: An,
        fromXRotation: kn,
        fromYRotation: En,
        fromZRotation: Cn,
        fromRotationTranslation: dt,
        fromQuat2: xn,
        getTranslation: ht,
        getScaling: mt,
        getRotation: ft,
        fromRotationTranslationScale: On,
        fromRotationTranslationScaleOrigin: wn,
        fromQuat: an,
        frustum: on,
        perspective: sn,
        perspectiveFromFieldOfView: en,
        ortho: Jt,
        lookAt: Zt,
        targetTo: Wt,
        str: $t,
        frob: Vt,
        add: Pt,
        subtract: kt,
        multiplyScalar: Rt,
        multiplyScalarAndAdd: Nt,
        exactEquals: Dt,
        equals: Ns,
        mul: St,
        sub: Ft
    });

    function y() {
        var e = new n(3);
        return n != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e
    }

    function Lt(e) {
        var t = new n(3);
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t
    }

    function At(e) {
        var t = e[0],
            n = e[1],
            s = e[2];
        return Math.hypot(t, n, s)
    }

    function b(e, t, s) {
        var o = new n(3);
        return o[0] = e, o[1] = t, o[2] = s, o
    }

    function Ht(e, t) {
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e
    }

    function It(e, t, n, s) {
        return e[0] = t, e[1] = n, e[2] = s, e
    }

    function Bt(e, t, n) {
        return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e
    }

    function Ct(e, t, n) {
        return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e[2] = t[2] - n[2], e
    }

    function xt(e, t, n) {
        return e[0] = t[0] * n[0], e[1] = t[1] * n[1], e[2] = t[2] * n[2], e
    }

    function Ot(e, t, n) {
        return e[0] = t[0] / n[0], e[1] = t[1] / n[1], e[2] = t[2] / n[2], e
    }

    function Ut(e, t) {
        return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e
    }

    function Kt(e, t) {
        return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e
    }

    function qt(e, t, n) {
        return e[0] = Math.min(t[0], n[0]), e[1] = Math.min(t[1], n[1]), e[2] = Math.min(t[2], n[2]), e
    }

    function Yt(e, t, n) {
        return e[0] = Math.max(t[0], n[0]), e[1] = Math.max(t[1], n[1]), e[2] = Math.max(t[2], n[2]), e
    }

    function Gt(e, t) {
        return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e[2] = Math.round(t[2]), e
    }

    function Xt(e, t, n) {
        return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e
    }

    function Qt(e, t, n, s) {
        return e[0] = t[0] + n[0] * s, e[1] = t[1] + n[1] * s, e[2] = t[2] + n[2] * s, e
    }

    function wt(e, t) {
        var n = t[0] - e[0],
            s = t[1] - e[1],
            o = t[2] - e[2];
        return Math.hypot(n, s, o)
    }

    function _t(e, t) {
        var n = t[0] - e[0],
            s = t[1] - e[1],
            o = t[2] - e[2];
        return n * n + s * s + o * o
    }

    function yt(e) {
        var t = e[0],
            n = e[1],
            s = e[2];
        return t * t + n * n + s * s
    }

    function tn(e, t) {
        return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e
    }

    function nn(e, t) {
        return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e
    }

    function jt(e, t) {
        var s = t[0],
            o = t[1],
            i = t[2],
            n = s * s + o * o + i * i;
        return n > 0 && (n = 1 / Math.sqrt(n)), e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e
    }

    function v(e, t) {
        return e[0] * t[0] + e[1] * t[1] + e[2] * t[2]
    }

    function u(e, t, n) {
        var s = t[0],
            o = t[1],
            i = t[2],
            a = n[0],
            r = n[1],
            c = n[2];
        return e[0] = o * c - i * r, e[1] = i * a - s * c, e[2] = s * r - o * a, e
    }

    function rn(e, t, n, s) {
        var o = t[0],
            i = t[1],
            a = t[2];
        return e[0] = o + s * (n[0] - o), e[1] = i + s * (n[1] - i), e[2] = a + s * (n[2] - a), e
    }

    function cn(e, t, n, s, o, i) {
        var a = i * i,
            r = a * (2 * i - 3) + 1,
            c = a * (i - 2) + i,
            l = a * (i - 1),
            d = a * (3 - 2 * i);
        return e[0] = t[0] * r + n[0] * c + s[0] * l + o[0] * d, e[1] = t[1] * r + n[1] * c + s[1] * l + o[1] * d, e[2] = t[2] * r + n[2] * c + s[2] * l + o[2] * d, e
    }

    function ln(e, t, n, s, o, i) {
        var a = 1 - i,
            u = a * a,
            h = i * i,
            r = u * a,
            c = 3 * i * u,
            l = 3 * h * a,
            d = h * i;
        return e[0] = t[0] * r + n[0] * c + s[0] * l + o[0] * d, e[1] = t[1] * r + n[1] * c + s[1] * l + o[1] * d, e[2] = t[2] * r + n[2] * c + s[2] * l + o[2] * d, e
    }

    function dn(e, t) {
        t = t || 1;
        var o = s() * 2 * Math.PI,
            n = s() * 2 - 1,
            i = Math.sqrt(1 - n * n) * t;
        return e[0] = Math.cos(o) * i, e[1] = Math.sin(o) * i, e[2] = n * t, e
    }

    function un(e, t, n) {
        var o = t[0],
            i = t[1],
            a = t[2],
            s = n[3] * o + n[7] * i + n[11] * a + n[15],
            s = s || 1;
        return e[0] = (n[0] * o + n[4] * i + n[8] * a + n[12]) / s, e[1] = (n[1] * o + n[5] * i + n[9] * a + n[13]) / s, e[2] = (n[2] * o + n[6] * i + n[10] * a + n[14]) / s, e
    }

    function hn(e, t, n) {
        var s = t[0],
            o = t[1],
            i = t[2];
        return e[0] = s * n[0] + o * n[3] + i * n[6], e[1] = s * n[1] + o * n[4] + i * n[7], e[2] = s * n[2] + o * n[5] + i * n[8], e
    }

    function mn(e, t, n) {
        var s = n[0],
            o = n[1],
            i = n[2],
            g = n[3],
            u = t[0],
            d = t[1],
            l = t[2],
            c = o * l - i * d,
            r = i * u - s * l,
            a = s * d - o * u,
            m = o * a - i * r,
            f = i * c - s * a,
            p = s * r - o * c,
            h = g * 2;
        return c *= h, r *= h, a *= h, m *= 2, f *= 2, p *= 2, e[0] = u + c + m, e[1] = d + r + f, e[2] = l + a + p, e
    }

    function fn(e, t, n, s) {
        var o = [],
            i = [];
        return o[0] = t[0] - n[0], o[1] = t[1] - n[1], o[2] = t[2] - n[2], i[0] = o[0], i[1] = o[1] * Math.cos(s) - o[2] * Math.sin(s), i[2] = o[1] * Math.sin(s) + o[2] * Math.cos(s), e[0] = i[0] + n[0], e[1] = i[1] + n[1], e[2] = i[2] + n[2], e
    }

    function pn(e, t, n, s) {
        var o = [],
            i = [];
        return o[0] = t[0] - n[0], o[1] = t[1] - n[1], o[2] = t[2] - n[2], i[0] = o[2] * Math.sin(s) + o[0] * Math.cos(s), i[1] = o[1], i[2] = o[2] * Math.cos(s) - o[0] * Math.sin(s), e[0] = i[0] + n[0], e[1] = i[1] + n[1], e[2] = i[2] + n[2], e
    }

    function gn(e, t, n, s) {
        var o = [],
            i = [];
        return o[0] = t[0] - n[0], o[1] = t[1] - n[1], o[2] = t[2] - n[2], i[0] = o[0] * Math.cos(s) - o[1] * Math.sin(s), i[1] = o[0] * Math.sin(s) + o[1] * Math.cos(s), i[2] = o[2], e[0] = i[0] + n[0], e[1] = i[1] + n[1], e[2] = i[2] + n[2], e
    }

    function vn(e, t) {
        var n = e[0],
            s = e[1],
            o = e[2],
            i = t[0],
            a = t[1],
            r = t[2],
            l = Math.sqrt(n * n + s * s + o * o),
            d = Math.sqrt(i * i + a * a + r * r),
            c = l * d,
            u = c && v(e, t) / c;
        return Math.acos(Math.min(Math.max(u, -1), 1))
    }

    function bn(e) {
        return e[0] = 0, e[1] = 0, e[2] = 0, e
    }

    function jn(e) {
        return "vec3(" + e[0] + ", " + e[1] + ", " + e[2] + ")"
    }

    function yn(e, t) {
        return e[0] === t[0] && e[1] === t[1] && e[2] === t[2]
    }

    function _n(e, n) {
        var s = e[0],
            o = e[1],
            i = e[2],
            a = n[0],
            r = n[1],
            c = n[2];
        return Math.abs(s - a) <= t * Math.max(1, Math.abs(s), Math.abs(a)) && Math.abs(o - r) <= t * Math.max(1, Math.abs(o), Math.abs(r)) && Math.abs(i - c) <= t * Math.max(1, Math.abs(i), Math.abs(c))
    }
    gt = Ct, pt = xt, ut = Ot, lt = wt, ct = _t, g = At, at = yt, it = function() {
        var e = y();
        return function(t, n, s, o, i, a) {
            var r, c;
            n || (n = 3), s || (s = 0), o ? c = Math.min(o * n + s, t.length) : c = t.length;
            for (r = s; r < c; r += n) e[0] = t[r], e[1] = t[r + 1], e[2] = t[r + 2], i(e, e, a), t[r] = e[0], t[r + 1] = e[1], t[r + 2] = e[2];
            return t
        }
    }(), ot = Object.freeze({
        __proto__: null,
        create: y,
        clone: Lt,
        length: At,
        fromValues: b,
        copy: Ht,
        set: It,
        add: Bt,
        subtract: Ct,
        multiply: xt,
        divide: Ot,
        ceil: Ut,
        floor: Kt,
        min: qt,
        max: Yt,
        round: Gt,
        scale: Xt,
        scaleAndAdd: Qt,
        distance: wt,
        squaredDistance: _t,
        squaredLength: yt,
        negate: tn,
        inverse: nn,
        normalize: jt,
        dot: v,
        cross: u,
        lerp: rn,
        hermite: cn,
        bezier: ln,
        random: dn,
        transformMat4: un,
        transformMat3: hn,
        transformQuat: mn,
        rotateX: fn,
        rotateY: pn,
        rotateZ: gn,
        angle: vn,
        zero: bn,
        str: jn,
        exactEquals: yn,
        equals: _n,
        sub: gt,
        mul: pt,
        div: ut,
        dist: lt,
        sqrDist: ct,
        len: g,
        sqrLen: at,
        forEach: it
    });

    function st() {
        var e = new n(4);
        return n != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0), e
    }

    function nt(e) {
        var t = new n(4);
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t
    }

    function tt(e, t, s, o) {
        var i = new n(4);
        return i[0] = e, i[1] = t, i[2] = s, i[3] = o, i
    }

    function et(e, t) {
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e
    }

    function Je(e, t, n, s, o) {
        return e[0] = t, e[1] = n, e[2] = s, e[3] = o, e
    }

    function Ze(e, t, n) {
        return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e[3] = t[3] + n[3], e
    }

    function Xe(e, t, n) {
        return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e[2] = t[2] - n[2], e[3] = t[3] - n[3], e
    }

    function Ge(e, t, n) {
        return e[0] = t[0] * n[0], e[1] = t[1] * n[1], e[2] = t[2] * n[2], e[3] = t[3] * n[3], e
    }

    function Ye(e, t, n) {
        return e[0] = t[0] / n[0], e[1] = t[1] / n[1], e[2] = t[2] / n[2], e[3] = t[3] / n[3], e
    }

    function In(e, t) {
        return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e[3] = Math.ceil(t[3]), e
    }

    function Bn(e, t) {
        return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e[3] = Math.floor(t[3]), e
    }

    function Vn(e, t, n) {
        return e[0] = Math.min(t[0], n[0]), e[1] = Math.min(t[1], n[1]), e[2] = Math.min(t[2], n[2]), e[3] = Math.min(t[3], n[3]), e
    }

    function $n(e, t, n) {
        return e[0] = Math.max(t[0], n[0]), e[1] = Math.max(t[1], n[1]), e[2] = Math.max(t[2], n[2]), e[3] = Math.max(t[3], n[3]), e
    }

    function Wn(e, t) {
        return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e[2] = Math.round(t[2]), e[3] = Math.round(t[3]), e
    }

    function qe(e, t, n) {
        return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e
    }

    function Kn(e, t, n, s) {
        return e[0] = t[0] + n[0] * s, e[1] = t[1] + n[1] * s, e[2] = t[2] + n[2] * s, e[3] = t[3] + n[3] * s, e
    }

    function Ue(e, t) {
        var n = t[0] - e[0],
            s = t[1] - e[1],
            o = t[2] - e[2],
            i = t[3] - e[3];
        return Math.hypot(n, s, o, i)
    }

    function We(e, t) {
        var n = t[0] - e[0],
            s = t[1] - e[1],
            o = t[2] - e[2],
            i = t[3] - e[3];
        return n * n + s * s + o * o + i * i
    }

    function p(e) {
        var t = e[0],
            n = e[1],
            s = e[2],
            o = e[3];
        return Math.hypot(t, n, s, o)
    }

    function f(e) {
        var t = e[0],
            n = e[1],
            s = e[2],
            o = e[3];
        return t * t + n * n + s * s + o * o
    }

    function Qn(e, t) {
        return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = -t[3], e
    }

    function Zn(e, t) {
        return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e[3] = 1 / t[3], e
    }

    function Be(e, t) {
        var s = t[0],
            o = t[1],
            i = t[2],
            a = t[3],
            n = s * s + o * o + i * i + a * a;
        return n > 0 && (n = 1 / Math.sqrt(n)), e[0] = s * n, e[1] = o * n, e[2] = i * n, e[3] = a * n, e
    }

    function Re(e, t) {
        return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3]
    }

    function ts(e, t, n, s) {
        var c = n[0] * s[1] - n[1] * s[0],
            l = n[0] * s[2] - n[2] * s[0],
            d = n[0] * s[3] - n[3] * s[0],
            u = n[1] * s[2] - n[2] * s[1],
            h = n[1] * s[3] - n[3] * s[1],
            m = n[2] * s[3] - n[3] * s[2],
            o = t[0],
            i = t[1],
            a = t[2],
            r = t[3];
        return e[0] = i * m - a * h + r * u, e[1] = -(o * m) + a * d - r * l, e[2] = o * h - i * d + r * c, e[3] = -(o * u) + i * l - a * c, e
    }

    function Ne(e, t, n, s) {
        var o = t[0],
            i = t[1],
            a = t[2],
            r = t[3];
        return e[0] = o + s * (n[0] - o), e[1] = i + s * (n[1] - i), e[2] = a + s * (n[2] - a), e[3] = r + s * (n[3] - r), e
    }

    function ss(e, t) {
        t = t || 1;
        do n = s() * 2 - 1, o = s() * 2 - 1, r = n * n + o * o; while (r >= 1) do i = s() * 2 - 1, a = s() * 2 - 1, c = i * i + a * a; while (c >= 1) var n, o, i, a, r, c, l = Math.sqrt((1 - r) / c);
        return e[0] = t * n, e[1] = t * o, e[2] = t * i * l, e[3] = t * a * l, e
    }

    function os(e, t, n) {
        var s = t[0],
            o = t[1],
            i = t[2],
            a = t[3];
        return e[0] = n[0] * s + n[4] * o + n[8] * i + n[12] * a, e[1] = n[1] * s + n[5] * o + n[9] * i + n[13] * a, e[2] = n[2] * s + n[6] * o + n[10] * i + n[14] * a, e[3] = n[3] * s + n[7] * o + n[11] * i + n[15] * a, e
    }

    function is(e, t, n) {
        var r = t[0],
            c = t[1],
            l = t[2],
            s = n[0],
            o = n[1],
            i = n[2],
            a = n[3],
            d = a * r + o * l - i * c,
            u = a * c + i * r - s * l,
            h = a * l + s * c - o * r,
            m = -s * r - o * c - i * l;
        return e[0] = d * a + m * -s + u * -i - h * -o, e[1] = u * a + m * -o + h * -s - d * -i, e[2] = h * a + m * -i + d * -o - u * -s, e[3] = t[3], e
    }

    function rs(e) {
        return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e
    }

    function cs(e) {
        return "vec4(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ")"
    }

    function De(e, t) {
        return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3]
    }

    function Te(e, n) {
        var s = e[0],
            o = e[1],
            i = e[2],
            a = e[3],
            r = n[0],
            c = n[1],
            l = n[2],
            d = n[3];
        return Math.abs(s - r) <= t * Math.max(1, Math.abs(s), Math.abs(r)) && Math.abs(o - c) <= t * Math.max(1, Math.abs(o), Math.abs(c)) && Math.abs(i - l) <= t * Math.max(1, Math.abs(i), Math.abs(l)) && Math.abs(a - d) <= t * Math.max(1, Math.abs(a), Math.abs(d))
    }
    Fe = Xe, Me = Ge, Se = Ye, Ae = Ue, O = We, Ee = p, Ce = f, xe = function() {
        var e = st();
        return function(t, n, s, o, i, a) {
            var r, c;
            n || (n = 4), s || (s = 0), o ? c = Math.min(o * n + s, t.length) : c = t.length;
            for (r = s; r < c; r += n) e[0] = t[r], e[1] = t[r + 1], e[2] = t[r + 2], e[3] = t[r + 3], i(e, e, a), t[r] = e[0], t[r + 1] = e[1], t[r + 2] = e[2], t[r + 3] = e[3];
            return t
        }
    }(), Oe = Object.freeze({
        __proto__: null,
        create: st,
        clone: nt,
        fromValues: tt,
        copy: et,
        set: Je,
        add: Ze,
        subtract: Xe,
        multiply: Ge,
        divide: Ye,
        ceil: In,
        floor: Bn,
        min: Vn,
        max: $n,
        round: Wn,
        scale: qe,
        scaleAndAdd: Kn,
        distance: Ue,
        squaredDistance: We,
        length: p,
        squaredLength: f,
        negate: Qn,
        inverse: Zn,
        normalize: Be,
        dot: Re,
        cross: ts,
        lerp: Ne,
        random: ss,
        transformMat4: os,
        transformQuat: is,
        zero: rs,
        str: cs,
        exactEquals: De,
        equals: Te,
        sub: Fe,
        mul: Me,
        div: Se,
        dist: Ae,
        sqrDist: O,
        len: Ee,
        sqrLen: Ce,
        forEach: xe
    });

    function h() {
        var e = new n(4);
        return n != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e[3] = 1, e
    }

    function _s(e) {
        return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e
    }

    function _e(e, t, n) {
        n = n * .5;
        var s = Math.sin(n);
        return e[0] = s * t[0], e[1] = s * t[1], e[2] = s * t[2], e[3] = Math.cos(n), e
    }

    function Os(e, n) {
        var o = Math.acos(n[3]) * 2,
            s = Math.sin(o / 2);
        return s > t ? (e[0] = n[0] / s, e[1] = n[1] / s, e[2] = n[2] / s) : (e[0] = 1, e[1] = 0, e[2] = 0), o
    }

    function xs(e, t) {
        var n = c(e, t);
        return Math.acos(2 * n * n - 1)
    }

    function ye(e, t, n) {
        var s = t[0],
            o = t[1],
            i = t[2],
            a = t[3],
            r = n[0],
            c = n[1],
            l = n[2],
            d = n[3];
        return e[0] = s * d + a * r + o * l - i * c, e[1] = o * d + a * c + i * r - s * l, e[2] = i * d + a * l + s * c - o * r, e[3] = a * d - s * r - o * c - i * l, e
    }

    function be(e, t, n) {
        n *= .5;
        var i = t[0],
            a = t[1],
            r = t[2],
            c = t[3],
            s = Math.sin(n),
            o = Math.cos(n);
        return e[0] = i * o + c * s, e[1] = a * o + r * s, e[2] = r * o - a * s, e[3] = c * o - i * s, e
    }

    function ve(e, t, n) {
        n *= .5;
        var i = t[0],
            a = t[1],
            r = t[2],
            c = t[3],
            s = Math.sin(n),
            o = Math.cos(n);
        return e[0] = i * o - r * s, e[1] = a * o + c * s, e[2] = r * o + i * s, e[3] = c * o - a * s, e
    }

    function ge(e, t, n) {
        n *= .5;
        var i = t[0],
            a = t[1],
            r = t[2],
            c = t[3],
            s = Math.sin(n),
            o = Math.cos(n);
        return e[0] = i * o + a * s, e[1] = a * o - i * s, e[2] = r * o + c * s, e[3] = c * o - r * s, e
    }

    function Ss(e, t) {
        var n = t[0],
            s = t[1],
            o = t[2];
        return e[0] = n, e[1] = s, e[2] = o, e[3] = Math.sqrt(Math.abs(1 - n * n - s * s - o * o)), e
    }

    function w(e, t) {
        var s = t[0],
            o = t[1],
            i = t[2],
            c = t[3],
            n = Math.sqrt(s * s + o * o + i * i),
            r = Math.exp(c),
            a = n > 0 ? r * Math.sin(n) / n : 0;
        return e[0] = s * a, e[1] = o * a, e[2] = i * a, e[3] = r * Math.cos(n), e
    }

    function fe(e, t) {
        var n = t[0],
            s = t[1],
            o = t[2],
            i = t[3],
            a = Math.sqrt(n * n + s * s + o * o),
            r = a > 0 ? Math.atan2(a, i) / a : 0;
        return e[0] = n * r, e[1] = s * r, e[2] = o * r, e[3] = .5 * Math.log(n * n + s * s + o * o + i * i), e
    }

    function Ts(e, t, n) {
        return fe(e, t), j(e, e, n), w(e, e), e
    }

    function d(e, n, s, o) {
        var i, a, h, m, f = n[0],
            v = n[1],
            g = n[2],
            p = n[3],
            l = s[0],
            d = s[1],
            c = s[2],
            u = s[3],
            r = f * l + v * d + g * c + p * u;
        return r < 0 && (r = -r, l = -l, d = -d, c = -c, u = -u), 1 - r > t ? (h = Math.acos(r), m = Math.sin(h), a = Math.sin((1 - o) * h) / m, i = Math.sin(o * h) / m) : (a = 1 - o, i = o), e[0] = a * f + i * l, e[1] = a * v + i * d, e[2] = a * g + i * c, e[3] = a * p + i * u, e
    }

    function Ds(e) {
        var t = s(),
            n = s(),
            o = s(),
            i = Math.sqrt(1 - t),
            a = Math.sqrt(t);
        return e[0] = i * Math.sin(2 * Math.PI * n), e[1] = i * Math.cos(2 * Math.PI * n), e[2] = a * Math.sin(2 * Math.PI * o), e[3] = a * Math.cos(2 * Math.PI * o), e
    }

    function zt(e, t) {
        var s = t[0],
            o = t[1],
            i = t[2],
            a = t[3],
            r = s * s + o * o + i * i + a * a,
            n = r ? 1 / r : 0;
        return e[0] = -s * n, e[1] = -o * n, e[2] = -i * n, e[3] = a * n, e
    }

    function Ls(e, t) {
        return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = t[3], e
    }

    function he(e, t) {
        var n, s, o, i, a = t[0] + t[4] + t[8];
        return a > 0 ? (n = Math.sqrt(a + 1), e[3] = .5 * n, n = .5 / n, e[0] = (t[5] - t[7]) * n, e[1] = (t[6] - t[2]) * n, e[2] = (t[1] - t[3]) * n) : (s = 0, t[4] > t[0] && (s = 1), t[8] > t[s * 3 + s] && (s = 2), o = (s + 1) % 3, i = (s + 2) % 3, n = Math.sqrt(t[s * 3 + s] - t[o * 3 + o] - t[i * 3 + i] + 1), e[s] = .5 * n, n = .5 / n, e[3] = (t[o * 3 + i] - t[i * 3 + o]) * n, e[o] = (t[o * 3 + s] + t[s * 3 + o]) * n, e[i] = (t[i * 3 + s] + t[s * 3 + i]) * n), e
    }

    function Ps(e, t, n, s) {
        var o, i, a, r, c, l, d = .5 * Math.PI / 180;
        return t *= d, n *= d, s *= d, o = Math.sin(t), i = Math.cos(t), a = Math.sin(n), r = Math.cos(n), c = Math.sin(s), l = Math.cos(s), e[0] = o * r * l - i * a * c, e[1] = i * a * l + o * r * c, e[2] = i * r * c - o * a * l, e[3] = i * r * l + o * a * c, e
    }

    function Hs(e) {
        return "quat(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ")"
    }
    ue = nt, de = tt, l = et, oe = Je, se = Ze, ne = ye, j = qe, c = Re, Z = Ne, a = p, X = a, r = f, Y = r, i = Be, q = De, K = Te, W = function() {
        var e = y(),
            t = b(1, 0, 0),
            n = b(0, 1, 0);
        return function(s, o, a) {
            var r = v(o, a);
            return r < -.999999 ? (u(e, t, o), g(e) < 1e-6 && u(e, n, o), jt(e, e), _e(s, e, Math.PI), s) : r > .999999 ? (s[0] = 0, s[1] = 0, s[2] = 0, s[3] = 1, s) : (u(e, o, a), s[0] = e[0], s[1] = e[1], s[2] = e[2], s[3] = 1 + r, i(s, s))
        }
    }(), $ = function() {
        var e = h(),
            t = h();
        return function(n, s, o, i, a, r) {
            return d(e, s, a, r), d(t, o, i, r), d(n, e, t, 2 * r * (1 - r)), n
        }
    }(), V = function() {
        var e = ce();
        return function(t, n, s, o) {
            return e[0] = s[0], e[3] = s[1], e[6] = s[2], e[1] = o[0], e[4] = o[1], e[7] = o[2], e[2] = -n[0], e[5] = -n[1], e[8] = -n[2], i(t, he(t, e))
        }
    }(), B = Object.freeze({
        __proto__: null,
        create: h,
        identity: _s,
        setAxisAngle: _e,
        getAxisAngle: Os,
        getAngle: xs,
        multiply: ye,
        rotateX: be,
        rotateY: ve,
        rotateZ: ge,
        calculateW: Ss,
        exp: w,
        ln: fe,
        pow: Ts,
        slerp: d,
        random: Ds,
        invert: zt,
        conjugate: Ls,
        fromMat3: he,
        fromEuler: Ps,
        str: Hs,
        clone: ue,
        fromValues: de,
        copy: l,
        set: oe,
        add: se,
        mul: ne,
        scale: j,
        dot: c,
        lerp: Z,
        length: a,
        len: X,
        squaredLength: r,
        sqrLen: Y,
        normalize: i,
        exactEquals: q,
        equals: K,
        rotationTo: W,
        sqlerp: $,
        setAxes: V
    });

    function ao() {
        var e = new n(8);
        return n != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0, e[4] = 0, e[5] = 0, e[6] = 0, e[7] = 0), e[3] = 1, e
    }

    function ro(e) {
        var t = new n(8);
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t
    }

    function co(e, t, s, o, i, a, r, c) {
        var l = new n(8);
        return l[0] = e, l[1] = t, l[2] = s, l[3] = o, l[4] = i, l[5] = a, l[6] = r, l[7] = c, l
    }

    function lo(e, t, s, o, i, a, r) {
        c = new n(8), c[0] = e, c[1] = t, c[2] = s, c[3] = o;
        var c, l = i * .5,
            d = a * .5,
            u = r * .5;
        return c[4] = l * o + d * s - u * t, c[5] = d * o + u * e - l * s, c[6] = u * o + l * t - d * e, c[7] = -l * e - d * t - u * s, c
    }

    function I(e, t, n) {
        var s = n[0] * .5,
            o = n[1] * .5,
            i = n[2] * .5,
            a = t[0],
            r = t[1],
            c = t[2],
            l = t[3];
        return e[0] = a, e[1] = r, e[2] = c, e[3] = l, e[4] = s * l + o * c - i * r, e[5] = o * l + i * a - s * c, e[6] = i * l + s * r - o * a, e[7] = -s * a - o * r - i * c, e
    }

    function ho(e, t) {
        return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = t[0] * .5, e[5] = t[1] * .5, e[6] = t[2] * .5, e[7] = 0, e
    }

    function mo(e, t) {
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = 0, e[5] = 0, e[6] = 0, e[7] = 0, e
    }

    function fo(e, t) {
        var s, o = h();
        return ft(o, t), s = new n(3), ht(s, t), I(e, o, s), e
    }

    function H(e, t) {
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e
    }

    function go(e) {
        return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, e[6] = 0, e[7] = 0, e
    }

    function vo(e, t, n, s, o, i, a, r, c) {
        return e[0] = t, e[1] = n, e[2] = s, e[3] = o, e[4] = i, e[5] = a, e[6] = r, e[7] = c, e
    }
    P = l;

    function jo(e, t) {
        return e[0] = t[4], e[1] = t[5], e[2] = t[6], e[3] = t[7], e
    }
    R = l;

    function _o(e, t) {
        return e[4] = t[0], e[5] = t[1], e[6] = t[2], e[7] = t[3], e
    }

    function wo(e, t) {
        var n = t[4],
            s = t[5],
            o = t[6],
            i = t[7],
            a = -t[0],
            r = -t[1],
            c = -t[2],
            l = t[3];
        return e[0] = (n * l + i * a + s * c - o * r) * 2, e[1] = (s * l + i * r + o * a - n * c) * 2, e[2] = (o * l + i * c + n * r - s * a) * 2, e
    }

    function Oo(e, t, n) {
        var s = t[0],
            o = t[1],
            i = t[2],
            a = t[3],
            r = n[0] * .5,
            c = n[1] * .5,
            l = n[2] * .5,
            d = t[4],
            u = t[5],
            h = t[6],
            m = t[7];
        return e[0] = s, e[1] = o, e[2] = i, e[3] = a, e[4] = a * r + o * l - i * c + d, e[5] = a * c + i * r - s * l + u, e[6] = a * l + s * c - o * r + h, e[7] = -s * r - o * c - i * l + m, e
    }

    function xo(e, t, n) {
        var s = -t[0],
            o = -t[1],
            i = -t[2],
            a = t[3],
            r = t[4],
            c = t[5],
            l = t[6],
            d = t[7],
            u = r * a + d * s + c * i - l * o,
            h = c * a + d * o + l * s - r * i,
            m = l * a + d * i + r * o - c * s,
            f = d * a - r * s - c * o - l * i;
        return be(e, t, n), s = e[0], o = e[1], i = e[2], a = e[3], e[4] = u * a + f * s + h * i - m * o, e[5] = h * a + f * o + m * s - u * i, e[6] = m * a + f * i + u * o - h * s, e[7] = f * a - u * s - h * o - m * i, e
    }

    function Co(e, t, n) {
        var s = -t[0],
            o = -t[1],
            i = -t[2],
            a = t[3],
            r = t[4],
            c = t[5],
            l = t[6],
            d = t[7],
            u = r * a + d * s + c * i - l * o,
            h = c * a + d * o + l * s - r * i,
            m = l * a + d * i + r * o - c * s,
            f = d * a - r * s - c * o - l * i;
        return ve(e, t, n), s = e[0], o = e[1], i = e[2], a = e[3], e[4] = u * a + f * s + h * i - m * o, e[5] = h * a + f * o + m * s - u * i, e[6] = m * a + f * i + u * o - h * s, e[7] = f * a - u * s - h * o - m * i, e
    }

    function Eo(e, t, n) {
        var s = -t[0],
            o = -t[1],
            i = -t[2],
            a = t[3],
            r = t[4],
            c = t[5],
            l = t[6],
            d = t[7],
            u = r * a + d * s + c * i - l * o,
            h = c * a + d * o + l * s - r * i,
            m = l * a + d * i + r * o - c * s,
            f = d * a - r * s - c * o - l * i;
        return ge(e, t, n), s = e[0], o = e[1], i = e[2], a = e[3], e[4] = u * a + f * s + h * i - m * o, e[5] = h * a + f * o + m * s - u * i, e[6] = m * a + f * i + u * o - h * s, e[7] = f * a - u * s - h * o - m * i, e
    }

    function ko(e, t, n) {
        var r = n[0],
            c = n[1],
            l = n[2],
            d = n[3],
            s = t[0],
            o = t[1],
            i = t[2],
            a = t[3];
        return e[0] = s * d + a * r + o * l - i * c, e[1] = o * d + a * c + i * r - s * l, e[2] = i * d + a * l + s * c - o * r, e[3] = a * d - s * r - o * c - i * l, s = t[4], o = t[5], i = t[6], a = t[7], e[4] = s * d + a * r + o * l - i * c, e[5] = o * d + a * c + i * r - s * l, e[6] = i * d + a * l + s * c - o * r, e[7] = a * d - s * r - o * c - i * l, e
    }

    function Ao(e, t, n) {
        var r = t[0],
            c = t[1],
            l = t[2],
            d = t[3],
            s = n[0],
            o = n[1],
            i = n[2],
            a = n[3];
        return e[0] = r * a + d * s + c * i - l * o, e[1] = c * a + d * o + l * s - r * i, e[2] = l * a + d * i + r * o - c * s, e[3] = d * a - r * s - c * o - l * i, s = n[4], o = n[5], i = n[6], a = n[7], e[4] = r * a + d * s + c * i - l * o, e[5] = c * a + d * o + l * s - r * i, e[6] = l * a + d * i + r * o - c * s, e[7] = d * a - r * s - c * o - l * i, e
    }

    function So(e, n, s, o) {
        if (Math.abs(o) < t) return H(e, n);
        d = Math.hypot(s[0], s[1], s[2]), o = o * .5;
        var d, b = Math.sin(o),
            r = b * s[0] / d,
            c = b * s[1] / d,
            i = b * s[2] / d,
            a = Math.cos(o),
            l = n[0],
            u = n[1],
            h = n[2],
            m = n[3];
        e[0] = l * a + m * r + u * i - h * c, e[1] = u * a + m * c + h * r - l * i, e[2] = h * a + m * i + l * c - u * r, e[3] = m * a - l * r - u * c - h * i;
        var f = n[4],
            p = n[5],
            g = n[6],
            v = n[7];
        return e[4] = f * a + v * r + p * i - g * c, e[5] = p * a + v * c + g * r - f * i, e[6] = g * a + v * i + f * c - p * r, e[7] = v * a - f * r - p * c - g * i, e
    }

    function Mo(e, t, n) {
        return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e[3] = t[3] + n[3], e[4] = t[4] + n[4], e[5] = t[5] + n[5], e[6] = t[6] + n[6], e[7] = t[7] + n[7], e
    }

    function z(e, t, n) {
        var r = t[0],
            o = t[1],
            i = t[2],
            a = t[3],
            u = n[4],
            b = n[5],
            v = n[6],
            g = n[7],
            p = t[4],
            h = t[5],
            m = t[6],
            f = t[7],
            s = n[0],
            d = n[1],
            l = n[2],
            c = n[3];
        return e[0] = r * c + a * s + o * l - i * d, e[1] = o * c + a * d + i * s - r * l, e[2] = i * c + a * l + r * d - o * s, e[3] = a * c - r * s - o * d - i * l, e[4] = r * g + a * u + o * v - i * b + p * c + f * s + h * l - m * d, e[5] = o * g + a * b + i * u - r * v + h * c + f * d + m * s - p * l, e[6] = i * g + a * v + r * b - o * u + m * c + f * l + p * d - h * s, e[7] = a * g - r * u - o * b - i * v + f * c - p * s - h * d - m * l, e
    }
    T = z;

    function zo(e, t, n) {
        return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e[4] = t[4] * n, e[5] = t[5] * n, e[6] = t[6] * n, e[7] = t[7] * n, e
    }
    m = c;

    function No(e, t, n, s) {
        var o = 1 - s;
        return m(t, n) < 0 && (s = -s), e[0] = t[0] * o + n[0] * s, e[1] = t[1] * o + n[1] * s, e[2] = t[2] * o + n[2] * s, e[3] = t[3] * o + n[3] * s, e[4] = t[4] * o + n[4] * s, e[5] = t[5] * o + n[5] * s, e[6] = t[6] * o + n[6] * s, e[7] = t[7] * o + n[7] * s, e
    }

    function Lo(e, t) {
        var n = o(t);
        return e[0] = -t[0] / n, e[1] = -t[1] / n, e[2] = -t[2] / n, e[3] = t[3] / n, e[4] = -t[4] / n, e[5] = -t[5] / n, e[6] = -t[6] / n, e[7] = t[7] / n, e
    }

    function Ro(e, t) {
        return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = t[3], e[4] = -t[4], e[5] = -t[5], e[6] = -t[6], e[7] = t[7], e
    }
    _ = a, M = _, o = r, S = o;

    function Vo(e, t) {
        var s, i, a, r, c, l, d, u, h, n = o(t);
        return n > 0 && (n = Math.sqrt(n), i = t[0] / n, a = t[1] / n, r = t[2] / n, c = t[3] / n, l = t[4], d = t[5], u = t[6], h = t[7], s = i * l + a * d + r * u + c * h, e[0] = i, e[1] = a, e[2] = r, e[3] = c, e[4] = (l - i * s) / n, e[5] = (d - a * s) / n, e[6] = (u - r * s) / n, e[7] = (h - c * s) / n), e
    }

    function $o(e) {
        return "quat2(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ", " + e[6] + ", " + e[7] + ")"
    }

    function Wo(e, t) {
        return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7]
    }

    function Uo(e, n) {
        var s = e[0],
            o = e[1],
            i = e[2],
            a = e[3],
            r = e[4],
            c = e[5],
            l = e[6],
            d = e[7],
            u = n[0],
            h = n[1],
            m = n[2],
            f = n[3],
            p = n[4],
            g = n[5],
            v = n[6],
            b = n[7];
        return Math.abs(s - u) <= t * Math.max(1, Math.abs(s), Math.abs(u)) && Math.abs(o - h) <= t * Math.max(1, Math.abs(o), Math.abs(h)) && Math.abs(i - m) <= t * Math.max(1, Math.abs(i), Math.abs(m)) && Math.abs(a - f) <= t * Math.max(1, Math.abs(a), Math.abs(f)) && Math.abs(r - p) <= t * Math.max(1, Math.abs(r), Math.abs(p)) && Math.abs(c - g) <= t * Math.max(1, Math.abs(c), Math.abs(g)) && Math.abs(l - v) <= t * Math.max(1, Math.abs(l), Math.abs(v)) && Math.abs(d - b) <= t * Math.max(1, Math.abs(d), Math.abs(b))
    }
    A = Object.freeze({
        __proto__: null,
        create: ao,
        clone: ro,
        fromValues: co,
        fromRotationTranslationValues: lo,
        fromRotationTranslation: I,
        fromTranslation: ho,
        fromRotation: mo,
        fromMat4: fo,
        copy: H,
        identity: go,
        set: vo,
        getReal: P,
        getDual: jo,
        setReal: R,
        setDual: _o,
        getTranslation: wo,
        translate: Oo,
        rotateX: xo,
        rotateY: Co,
        rotateZ: Eo,
        rotateByQuatAppend: ko,
        rotateByQuatPrepend: Ao,
        rotateAroundAxis: So,
        add: Mo,
        multiply: z,
        mul: T,
        scale: zo,
        dot: m,
        lerp: No,
        invert: Lo,
        conjugate: Ro,
        length: _,
        len: M,
        squaredLength: o,
        sqrLen: S,
        normalize: Vo,
        str: $o,
        exactEquals: Wo,
        equals: Uo
    });

    function k() {
        var e = new n(2);
        return n != Float32Array && (e[0] = 0, e[1] = 0), e
    }

    function Yo(e) {
        var t = new n(2);
        return t[0] = e[0], t[1] = e[1], t
    }

    function Go(e, t) {
        var s = new n(2);
        return s[0] = e, s[1] = t, s
    }

    function Xo(e, t) {
        return e[0] = t[0], e[1] = t[1], e
    }

    function Qo(e, t, n) {
        return e[0] = t, e[1] = n, e
    }

    function Zo(e, t, n) {
        return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e
    }

    function E(e, t, n) {
        return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e
    }

    function C(e, t, n) {
        return e[0] = t[0] * n[0], e[1] = t[1] * n[1], e
    }

    function x(e, t, n) {
        return e[0] = t[0] / n[0], e[1] = t[1] / n[1], e
    }

    function ni(e, t) {
        return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e
    }

    function si(e, t) {
        return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e
    }

    function oi(e, t, n) {
        return e[0] = Math.min(t[0], n[0]), e[1] = Math.min(t[1], n[1]), e
    }

    function ii(e, t, n) {
        return e[0] = Math.max(t[0], n[0]), e[1] = Math.max(t[1], n[1]), e
    }

    function ai(e, t) {
        return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e
    }

    function ri(e, t, n) {
        return e[0] = t[0] * n, e[1] = t[1] * n, e
    }

    function ci(e, t, n, s) {
        return e[0] = t[0] + n[0] * s, e[1] = t[1] + n[1] * s, e
    }

    function G(e, t) {
        var n = t[0] - e[0],
            s = t[1] - e[1];
        return Math.hypot(n, s)
    }

    function Q(e, t) {
        var n = t[0] - e[0],
            s = t[1] - e[1];
        return n * n + s * s
    }

    function J(e) {
        var t = e[0],
            n = e[1];
        return Math.hypot(t, n)
    }

    function te(e) {
        var t = e[0],
            n = e[1];
        return t * t + n * n
    }

    function mi(e, t) {
        return e[0] = -t[0], e[1] = -t[1], e
    }

    function fi(e, t) {
        return e[0] = 1 / t[0], e[1] = 1 / t[1], e
    }

    function pi(e, t) {
        var s = t[0],
            o = t[1],
            n = s * s + o * o;
        return n > 0 && (n = 1 / Math.sqrt(n)), e[0] = t[0] * n, e[1] = t[1] * n, e
    }

    function gi(e, t) {
        return e[0] * t[0] + e[1] * t[1]
    }

    function vi(e, t, n) {
        var s = t[0] * n[1] - t[1] * n[0];
        return e[0] = e[1] = 0, e[2] = s, e
    }

    function bi(e, t, n, s) {
        var o = t[0],
            i = t[1];
        return e[0] = o + s * (n[0] - o), e[1] = i + s * (n[1] - i), e
    }

    function ji(e, t) {
        t = t || 1;
        var n = s() * 2 * Math.PI;
        return e[0] = Math.cos(n) * t, e[1] = Math.sin(n) * t, e
    }

    function yi(e, t, n) {
        var s = t[0],
            o = t[1];
        return e[0] = n[0] * s + n[2] * o, e[1] = n[1] * s + n[3] * o, e
    }

    function _i(e, t, n) {
        var s = t[0],
            o = t[1];
        return e[0] = n[0] * s + n[2] * o + n[4], e[1] = n[1] * s + n[3] * o + n[5], e
    }

    function wi(e, t, n) {
        var s = t[0],
            o = t[1];
        return e[0] = n[0] * s + n[3] * o + n[6], e[1] = n[1] * s + n[4] * o + n[7], e
    }

    function Oi(e, t, n) {
        var s = t[0],
            o = t[1];
        return e[0] = n[0] * s + n[4] * o + n[12], e[1] = n[1] * s + n[5] * o + n[13], e
    }

    function xi(e, t, n, s) {
        var o = t[0] - n[0],
            i = t[1] - n[1],
            a = Math.sin(s),
            r = Math.cos(s);
        return e[0] = o * r - i * a + n[0], e[1] = o * a + i * r + n[1], e
    }

    function Ci(e, t) {
        var n = e[0],
            s = e[1],
            o = t[0],
            i = t[1],
            a = Math.sqrt(n * n + s * s) * Math.sqrt(o * o + i * i),
            r = a && (n * o + s * i) / a;
        return Math.acos(Math.min(Math.max(r, -1), 1))
    }

    function Ei(e) {
        return e[0] = 0, e[1] = 0, e
    }

    function ki(e) {
        return "vec2(" + e[0] + ", " + e[1] + ")"
    }

    function Ai(e, t) {
        return e[0] === t[0] && e[1] === t[1]
    }

    function Si(e, n) {
        var s = e[0],
            o = e[1],
            i = n[0],
            a = n[1];
        return Math.abs(s - i) <= t * Math.max(1, Math.abs(s), Math.abs(i)) && Math.abs(o - a) <= t * Math.max(1, Math.abs(o), Math.abs(a))
    }
    le = J, me = E, pe = C, we = x, Le = G, Ve = Q, rt = te, vt = function() {
        var e = k();
        return function(t, n, s, o, i, a) {
            var r, c;
            n || (n = 2), s || (s = 0), o ? c = Math.min(o * n + s, t.length) : c = t.length;
            for (r = s; r < c; r += n) e[0] = t[r], e[1] = t[r + 1], i(e, e, a), t[r] = e[0], t[r + 1] = e[1];
            return t
        }
    }(), Et = Object.freeze({
        __proto__: null,
        create: k,
        clone: Yo,
        fromValues: Go,
        copy: Xo,
        set: Qo,
        add: Zo,
        subtract: E,
        multiply: C,
        divide: x,
        ceil: ni,
        floor: si,
        min: oi,
        max: ii,
        round: ai,
        scale: ri,
        scaleAndAdd: ci,
        distance: G,
        squaredDistance: Q,
        length: J,
        squaredLength: te,
        negate: mi,
        inverse: fi,
        normalize: pi,
        dot: gi,
        cross: vi,
        lerp: bi,
        random: ji,
        transformMat2: yi,
        transformMat2d: _i,
        transformMat3: wi,
        transformMat4: Oi,
        rotate: xi,
        angle: Ci,
        zero: Ei,
        str: ki,
        exactEquals: Ai,
        equals: Si,
        len: le,
        sub: me,
        mul: pe,
        div: we,
        dist: Le,
        sqrDist: Ve,
        sqrLen: rt,
        forEach: vt
    }), e.glMatrix = $e, e.mat2 = L, e.mat2d = re, e.mat3 = Ie, e.mat4 = Mt, e.quat = B, e.quat2 = A, e.vec2 = Et, e.vec3 = ot, e.vec4 = Oe, Object.defineProperty(e, "__esModule", {
        value: !0
    })
}), "use strict";
{
    function lineInt(e, t, n) {
        n = n || 0;
        var s = [0, 0],
            o = e[1][1] - e[0][1],
            i = e[0][0] - e[1][0],
            l = o * e[0][0] + i * e[0][1],
            a = t[1][1] - t[0][1],
            r = t[0][0] - t[1][0],
            d = a * t[0][0] + r * t[0][1],
            c = o * r - a * i;
        return scalar_eq(c, 0, n) || (s[0] = (r * l - i * d) / c, s[1] = (o * d - a * l) / c), s
    }

    function lineSegmentsIntersect(e, t, n, s) {
        var c, l, o = t[0] - e[0],
            i = t[1] - e[1],
            a = s[0] - n[0],
            r = s[1] - n[1];
        return a * i - r * o !== 0 && (c = (o * (n[1] - e[1]) + i * (e[0] - n[0])) / (a * i - r * o), l = (a * (e[1] - n[1]) + r * (n[0] - e[0])) / (r * o - a * i), c >= 0 && c <= 1 && l >= 0 && l <= 1)
    }

    function triangleArea(e, t, n) {
        return (t[0] - e[0]) * (n[1] - e[1]) - (n[0] - e[0]) * (t[1] - e[1])
    }

    function isLeft(e, t, n) {
        return triangleArea(e, t, n) > 0
    }

    function isLeftOn(e, t, n) {
        return triangleArea(e, t, n) >= 0
    }

    function isRight(e, t, n) {
        return triangleArea(e, t, n) < 0
    }

    function isRightOn(e, t, n) {
        return triangleArea(e, t, n) <= 0
    }
    var tmpPoint1 = [],
        tmpPoint2 = [],
        tmpLine1, tmpLine2;

    function collinear(e, t, n, s) {
        if (s) {
            o = tmpPoint1, i = tmpPoint2, o[0] = t[0] - e[0], o[1] = t[1] - e[1], i[0] = n[0] - t[0], i[1] = n[1] - t[1];
            var o, i, a = o[0] * i[0] + o[1] * i[1],
                r = Math.sqrt(o[0] * o[0] + o[1] * o[1]),
                c = Math.sqrt(i[0] * i[0] + i[1] * i[1]),
                l = Math.acos(a / (r * c));
            return l < s
        }
        return triangleArea(e, t, n) === 0
    }

    function sqdist(e, t) {
        var n = t[0] - e[0],
            s = t[1] - e[1];
        return n * n + s * s
    }

    function polygonAt(e, t) {
        var n = e.length;
        return e[t < 0 ? t % n + n : t % n]
    }

    function polygonClear(e) {
        e.length = 0
    }

    function polygonAppend(e, t, n, s) {
        for (var o = n; o < s; o++) e.push(t[o])
    }

    function polygonMakeCCW(e) {
        for (var t = 0, n = e, s = 1; s < e.length; ++s)(n[s][1] < n[t][1] || n[s][1] === n[t][1] && n[s][0] > n[t][0]) && (t = s);
        return !isLeft(polygonAt(e, t - 1), polygonAt(e, t), polygonAt(e, t + 1)) && (polygonReverse(e), !0)
    }

    function polygonReverse(e) {
        for (var n = [], s = e.length, t = 0; t !== s; t++) n.push(e.pop());
        for (t = 0; t !== s; t++) e[t] = n[t]
    }

    function polygonIsReflex(e, t) {
        return isRight(polygonAt(e, t - 1), polygonAt(e, t), polygonAt(e, t + 1))
    }
    tmpLine1 = [], tmpLine2 = [];

    function polygonCanSee(e, t, n) {
        var s, a, r, o = tmpLine1,
            i = tmpLine2;
        if (isLeftOn(polygonAt(e, t + 1), polygonAt(e, t), polygonAt(e, n)) && isRightOn(polygonAt(e, t - 1), polygonAt(e, t), polygonAt(e, n))) return !1;
        r = sqdist(polygonAt(e, t), polygonAt(e, n));
        for (s = 0; s !== e.length; ++s) {
            if ((s + 1) % e.length === t || s === t) continue;
            if (isLeftOn(polygonAt(e, t), polygonAt(e, n), polygonAt(e, s + 1)) && isRightOn(polygonAt(e, t), polygonAt(e, n), polygonAt(e, s)) && (o[0] = polygonAt(e, t), o[1] = polygonAt(e, n), i[0] = polygonAt(e, s), i[1] = polygonAt(e, s + 1), a = lineInt(o, i), sqdist(polygonAt(e, t), a) < r)) return !1
        }
        return !0
    }

    function polygonCanSee2(e, t, n) {
        for (var s = 0; s !== e.length; ++s) {
            if (s === t || s === n || (s + 1) % e.length === t || (s + 1) % e.length === n) continue;
            if (lineSegmentsIntersect(polygonAt(e, t), polygonAt(e, n), polygonAt(e, s), polygonAt(e, s + 1))) return !1
        }
        return !0
    }

    function polygonCopy(e, t, n, s) {
        var o, i = s || [];
        if (polygonClear(i), t < n)
            for (o = t; o <= n; o++) i.push(e[o]);
        else {
            for (o = 0; o <= n; o++) i.push(e[o]);
            for (o = t; o < e.length; o++) i.push(e[o])
        }
        return i
    }

    function polygonGetCutEdges(e) {
        for (var n, o, i = [], s = [], a = [], r = [], c = Number.MAX_VALUE, t = 0; t < e.length; ++t)
            if (polygonIsReflex(e, t))
                for (n = 0; n < e.length; ++n)
                    if (polygonCanSee(e, t, n)) {
                        s = polygonGetCutEdges(polygonCopy(e, t, n, r)), a = polygonGetCutEdges(polygonCopy(e, n, t, r));
                        for (o = 0; o < a.length; o++) s.push(a[o]);
                        s.length < c && (i = s, c = s.length, i.push([polygonAt(e, t), polygonAt(e, n)]))
                    } return i
    }

    function polygonDecomp(e) {
        var t = polygonGetCutEdges(e);
        return t.length > 0 ? polygonSlice(e, t) : [e]
    }

    function polygonSlice(e, t) {
        if (t.length === 0) return [e];
        if (t instanceof Array && t.length && t[0] instanceof Array && t[0].length === 2 && t[0][0] instanceof Array) {
            for (var n, i, a, r, o = [e], s = 0; s < t.length; s++) {
                i = t[s];
                for (n = 0; n < o.length; n++)
                    if (r = o[n], a = polygonSlice(r, i), a) {
                        o.splice(n, 1), o.push(a[0], a[1]);
                        break
                    }
            }
            return o
        }
        return i = t, s = e.indexOf(i[0]), n = e.indexOf(i[1]), s !== -1 && n !== -1 && [polygonCopy(e, s, n), polygonCopy(e, n, s)]
    }

    function polygonIsSimple(e) {
        var n, s, t = e;
        for (n = 0; n < t.length - 1; n++)
            for (s = 0; s < n - 1; s++)
                if (lineSegmentsIntersect(t[n], t[n + 1], t[s], t[s + 1])) return !1;
        for (n = 1; n < t.length - 2; n++)
            if (lineSegmentsIntersect(t[0], t[t.length - 1], t[n], t[n + 1])) return !1;
        return !0
    }

    function getIntersectionPoint(e, t, n, s, o) {
        o = o || 0;
        var i = t[1] - e[1],
            a = e[0] - t[0],
            d = i * e[0] + a * e[1],
            r = s[1] - n[1],
            c = n[0] - s[0],
            u = r * n[0] + c * n[1],
            l = i * c - r * a;
        return scalar_eq(l, 0, o) ? [0, 0] : [(c * d - a * u) / l, (i * u - r * d) / l]
    }

    function polygonQuickDecomp(e, t, n, s, o, i, a) {
        i = i || 100, a = a || 0, o = o || 25, t = typeof t != "undefined" ? t : [], n = n || [], s = s || [];
        var c, l, v = [0, 0],
            w = [0, 0],
            d = [0, 0],
            _ = 0,
            j = 0,
            m = 0,
            b = 0,
            f = 0,
            p = 0,
            g = 0,
            u = [],
            h = [],
            r = e,
            y = e;
        if (y.length < 3) return t;
        if (a++, a > i) return console.warn("quickDecomp: max level (" + i + ") reached."), t;
        for (c = 0; c < e.length; ++c)
            if (polygonIsReflex(r, c)) {
                n.push(r[c]), _ = j = Number.MAX_VALUE;
                for (l = 0; l < e.length; ++l) isLeft(polygonAt(r, c - 1), polygonAt(r, c), polygonAt(r, l)) && isRightOn(polygonAt(r, c - 1), polygonAt(r, c), polygonAt(r, l - 1)) && (d = getIntersectionPoint(polygonAt(r, c - 1), polygonAt(r, c), polygonAt(r, l), polygonAt(r, l - 1)), isRight(polygonAt(r, c + 1), polygonAt(r, c), d) && (m = sqdist(r[c], d), m < j && (j = m, w = d, p = l))), isLeft(polygonAt(r, c + 1), polygonAt(r, c), polygonAt(r, l + 1)) && isRightOn(polygonAt(r, c + 1), polygonAt(r, c), polygonAt(r, l)) && (d = getIntersectionPoint(polygonAt(r, c + 1), polygonAt(r, c), polygonAt(r, l), polygonAt(r, l + 1)), isLeft(polygonAt(r, c - 1), polygonAt(r, c), d) && (m = sqdist(r[c], d), m < _ && (_ = m, v = d, f = l)));
                if (p === (f + 1) % e.length) d[0] = (w[0] + v[0]) / 2, d[1] = (w[1] + v[1]) / 2, s.push(d), c < f ? (polygonAppend(u, r, c, f + 1), u.push(d), h.push(d), p !== 0 && polygonAppend(h, r, p, r.length), polygonAppend(h, r, 0, c + 1)) : (c !== 0 && polygonAppend(u, r, c, r.length), polygonAppend(u, r, 0, f + 1), u.push(d), h.push(d), polygonAppend(h, r, p, c + 1));
                else {
                    if (p > f && (f += e.length), b = Number.MAX_VALUE, f < p) return t;
                    for (l = p; l <= f; ++l) isLeftOn(polygonAt(r, c - 1), polygonAt(r, c), polygonAt(r, l)) && isRightOn(polygonAt(r, c + 1), polygonAt(r, c), polygonAt(r, l)) && (m = sqdist(polygonAt(r, c), polygonAt(r, l)), m < b && polygonCanSee2(r, c, l) && (b = m, g = l % e.length));
                    c < g ? (polygonAppend(u, r, c, g + 1), g !== 0 && polygonAppend(h, r, g, y.length), polygonAppend(h, r, 0, c + 1)) : (c !== 0 && polygonAppend(u, r, c, y.length), polygonAppend(u, r, 0, g + 1), polygonAppend(h, r, g, c + 1))
                }
                return u.length < h.length ? (polygonQuickDecomp(u, t, n, s, o, i, a), polygonQuickDecomp(h, t, n, s, o, i, a)) : (polygonQuickDecomp(h, t, n, s, o, i, a), polygonQuickDecomp(u, t, n, s, o, i, a)), t
            } return t.push(e), t
    }

    function polygonRemoveCollinearPoints(e, t) {
        for (var s = 0, n = e.length - 1; e.length > 3 && n >= 0; --n) collinear(polygonAt(e, n - 1), polygonAt(e, n), polygonAt(e, n + 1), t) && (e.splice(n % e.length, 1), s++);
        return s
    }

    function polygonRemoveDuplicatePoints(e, t) {
        for (var s, o, n = e.length - 1; n >= 1; --n) {
            o = e[n];
            for (s = n - 1; s >= 0; --s)
                if (points_eq(o, e[s], t)) {
                    e.splice(n, 1);
                    continue
                }
        }
    }

    function scalar_eq(e, t, n) {
        return n = n || 0, Math.abs(e - t) <= n
    }

    function points_eq(e, t, n) {
        return scalar_eq(e[0], t[0], n) && scalar_eq(e[1], t[1], n)
    }
    self.polyDecomp = {
        decomp: polygonDecomp,
        quickDecomp: polygonQuickDecomp,
        isSimple: polygonIsSimple,
        removeCollinearPoints: polygonRemoveCollinearPoints,
        removeDuplicatePoints: polygonRemoveDuplicatePoints,
        makeCCW: polygonMakeCCW
    }
}
"use strict";
{
    let n = !1,
        s = !1,
        e = "dev";
    const t = self.C3 = class C3 {
        constructor() {
            throw TypeError("static class can't be instantiated")
        }
        static SetReady() {
            n = !0
        }
        static IsReady() {
            return n
        }
        static SetAppStarted() {
            s = !0
        }
        static HasAppStarted() {
            return s
        }
        static SetBuildMode(t) {
            e = t
        }
        static GetBuildMode() {
            return e
        }
        static IsReleaseBuild() {
            return e === "final"
        }
    };
    t.isDebug = !1, t.isDebugDefend = !1, t.hardwareConcurrency = navigator.hardwareConcurrency || 2
}
"use strict";
{
    const e = self.C3;
    e.QueryParser = class QueryParser {
        constructor(e) {
            this._queryString = e, this._parameters = new Map, this._Parse()
        }
        _Parse() {
            let e = this._queryString;
            (e.startsWith("?") || e.startsWith("#")) && (e = e.substr(1));
            const t = e.split("&");
            for (const e of t) this._ParseParameter(e)
        }
        _ParseParameter(e) {
            if (!e) return;
            if (!e.includes("=")) {
                this._parameters.set(e, null);
                return
            }
            const t = e.indexOf("="),
                n = decodeURIComponent(e.substring(0, t)),
                s = decodeURIComponent(e.substring(t + 1));
            this._parameters.set(n, s)
        }
        LogAll() {
            for (const e of this._parameters) console.log("[QueryParser] Parameter '" + e[0] + "' = " + (e[1] === null ? "null" : "'" + e[1] + "'"))
        }
        Has(e) {
            return this._parameters.has(e)
        }
        Get(e) {
            const t = this._parameters.get(e);
            return typeof t == "undefined" ? null : t
        }
        ClearHash() {
            history.replaceState("", document.title, location.pathname + location.search)
        }
        Reparse(e) {
            this._queryString = e, this._parameters.clear(), this._Parse()
        }
    }, e.QueryString = new e.QueryParser(location.search), e.LocationHashString = new e.QueryParser(location.hash), e.QueryString.Get("mode") !== "dev" && e.SetBuildMode("final")
}
"use strict";
{
    const g = self.C3,
        c = "(unknown)",
        e = navigator.userAgent;
    let n = {
            linux: /linux|openbsd|freebsd|netbsd/i.test(e),
            chromeOS: /CrOS/.test(e),
            windowsTizen: /trident|iemobile|msie|tizen/i.test(e),
            genericMS: /trident|iemobile|msie|edge\//i.test(e),
            opera: /OPR\//.test(e),
            blackberry: /bb10/i.test(e),
            edge: /edge\//i.test(e),
            trident: /trident/i.test(e),
            webkit: /webkit/i.test(e),
            safari: /safari\//i.test(e),
            chrome: /chrome\//i.test(e),
            chromium: /chromium\//i.test(e),
            crosswalk: /crosswalk|xwalk/i.test(e),
            nwjs: /nwjs/i.test(e),
            amazonwebapp: /amazonwebappplatform/i.test(e),
            webview: /wv\)/.test(e),
            android: /android/i.test(e),
            nokia: /nokiabrowser\/[0-9.]+/i.test(e)
        },
        i = {
            windows: /windows\s+nt\s+\d+\.\d+/i.exec(e),
            OSX: /mac\s+os\s+x\s+[0-9_]+/i.exec(e),
            android: /android\s+[0-9.]+/i.exec(e),
            opera: /OPR\/[0-9.]+/.exec(e),
            tizen: /tizen\s+[0-9.]+/i.exec(e),
            iphone: /iphone\s+os\s+[0-9_]+/i.exec(e),
            ipad: /ipad[^)]*os\s+[0-9_]+/i.exec(e),
            winPhone: /windows\s+phone\s+[0-9.]+/i.exec(e),
            winPhoneOS: /windows\s+phone\s+os\s+[0-9.]+/i.exec(e),
            chrome: /chrome\/[0-9.]+/i.exec(e),
            chromium: /chromium\/[0-9.]+/i.exec(e),
            nwjs: /nwjs\/[0-9.]+/i.exec(e),
            firefox: /firefox\/[0-9.]+/i.exec(e),
            ie: /msie\s+[0-9.]+/i.exec(e),
            edge: /edge\/[0-9.]+/i.exec(e),
            edgeChromium: /edg\/[0-9.]+/i.exec(e),
            silk: /silk\/[0-9.]+/i.exec(e)
        },
        t = c,
        o = c,
        d = c,
        s = c,
        a = c,
        h = c,
        r = c,
        l = "browser",
        u = !1,
        m = !1,
        f = new Map;

    function runTest(e, t, n) {
        if (t === !0) {
            const t = n();
            f.set(e, !0)
        } else if (t && t.length) {
            const s = n(t[0]);
            f.set(e, !0)
        }
    }
    runTest("isWindows", i.windows, e => {
        t = "Windows";
        const n = e.split(" ")[2];
        if (n) switch (n) {
            case "5.0":
                o = "2000";
                break;
            case "5.1":
                o = "XP";
                break;
            case "5.2":
                o = "XP";
                break;
            case "6.0":
                o = "Vista";
                break;
            case "6.1":
                o = "7";
                break;
            case "6.2":
                o = "8";
                break;
            case "6.3":
                o = "8.1";
                break;
            case "10.0":
                o = "10";
                break
        }
    }), runTest("isOSX", i.OSX, e => {
        t = "Mac OS X";
        const n = e.split(" ")[3];
        n && (o = n.replace("_", "."))
    }), runTest("isLinux", n.linux, () => {
        t = "Linux"
    }), runTest("isChromeOS", n.chromeOS, () => {
        t = "Chrome OS"
    }), runTest("isAndroid", !n.windowsTizen && i.android, e => {
        t = "Android";
        const n = e.split(" ")[1];
        n && (o = n)
    }), runTest("isTizen", i.tizen, e => {
        t = "Tizen";
        const n = e.split(" ")[1];
        n && (o = n)
    }), runTest("isIPhone", !n.windowsTizen && i.iphone, e => {
        t = "iOS";
        const n = e.split(" ")[2];
        n && (o = n.replace("_", "."))
    }), runTest("isIPad", !n.windowsTizen && i.ipad, e => {
        t = "iOS";
        const n = e.split(" ")[3];
        n && (o = n.replace("_", "."))
    }), runTest("isWindowsPhone", i.winPhone, e => {
        t = "Windows Phone";
        const n = e.split(" ")[2];
        n && (o = n)
    }), runTest("isWindowsPhoneOS", i.winPhoneOS, e => {
        t = "Windows Phone";
        const n = e.split(" ")[3];
        n && (o = n)
    }), runTest("isBlackberry", n.blackberry, () => {
        t = "Blackberry", o = "10", s = "stock", r = "webkit"
    }), runTest("isChrome", !n.edge && !n.opera && i.chrome, e => {
        s = "Chrome", r = "Chromium";
        const t = e.split("/")[1];
        t && (a = t)
    }), runTest("isOpera", i.opera, e => {
        s = "Opera", r = "Chromium";
        const t = e.split("/")[1];
        t && (a = t)
    }), runTest("isChromium", i.chromium, e => {
        s = "Chromium", r = "Chromium";
        const t = e.split("/")[1];
        t && (a = t)
    }), runTest("isFirefox", i.firefox, e => {
        s = "Firefox", r = "Gecko";
        const t = e.split("/")[1];
        t && (a = t)
    }), runTest("isInternetExplorer", i.ie, e => {
        s = "Internet Explorer", r = "Trident";
        const t = e.split(" ")[1];
        t && (a = t)
    }), runTest("isTrident", s !== "Internet Explorer" && n.trident, () => {
        r = "Trident";
        const t = /rv:[0-9.]+/i.exec(e);
        if (t && t.length) {
            s = "Internet Explorer";
            const e = t[0].split(":")[1];
            e && (a = e)
        }
    }), runTest("isEdge", i.edge, e => {
        s = "Edge", r = "Edge";
        const t = e.split("/")[1];
        t && (a = t)
    }), runTest("isEdgeChromium", i.edgeChromium, e => {
        s = "Edge", r = "Chromium";
        const t = e.split("/")[1];
        t && (a = t)
    }), runTest("isSafari", n.safari && !n.nokia && !n.chrome && !n.chromium && !n.genericIE && !n.blackberry, () => {
        s = "Safari", r = "WebKit";
        const t = /version\/[0-9.]+/i.exec(e),
            n = /crios\/[0-9.]+/i.exec(e),
            o = /fxios\/[0-9.]+/i.exec(e);
        if (t && t.length) {
            const e = t[0].split("/")[1];
            e && (a = e)
        }
        if (n && n.length) {
            s = "Chrome for iOS";
            const e = n[0].split("/")[1];
            e && (a = e)
        }
        if (o && o.length) {
            s = "Firefox for iOS";
            const e = o[0].split("/")[1];
            e && (a = e)
        }
    }), runTest("isSilk", i.silk, e => {
        s = "Silk";
        const t = e.split("/")[1];
        t && (a = t)
    }), runTest("isCrosswalk", n.crosswalk, () => l = "crosswalk"), runTest("isCordova", self.device && (self.device.cordova || self.device.phonegap), () => l = "cordova"), runTest("isNWJS", i.nwjs, e => {
        l = "nwjs", s = "NW.js", r = "Chromium";
        const t = e.split("/")[1];
        t && (a = t)
    }), runTest("isAmazonWebApp", n.amazonwebapp, () => l = "webapp"), runTest("isHomeScreenWebApp", l !== "nwjs" && typeof window != "undefined" && (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches || navigator.standalone), () => l = "webapp"), runTest("isFalseSafari", s === "Safari" && (t === "Android" || t === "Tizen" || t === "Blackberry"), () => s = "stock"), runTest("isAndroidWebview", s === "Chrome" && l === "browser" && n.webview, () => l = "webview"), runTest("isFirefoxOS", s === "Firefox" && t === c, () => t = "Firefox OS"), runTest("isAndroidFallback", t === c && !n.windowsTizen && n.android, () => t = "Android"), runTest("isTridentFallback", t === c && n.trident, () => r = "Trident"), runTest("isWebkitFallback", t === c && n.webkit, () => r = "WebKit"), runTest("is64Bit", (t => t.test(e) || t.test(navigator.platform) || navigator.cpuClass === "x64")(/x86_64|x86-64|win64|x64;|x64\)|x64_|amd64|wow64|ia64|arm64|arch64|sparc64|ppc64|irix64/i), () => d = "64-bit"), runTest("is32Bit", (t => t.test(e) || t.test(navigator.platform) || navigator.cpuClass === "x86")(/x86;|x86\)|i86|i386|i486|i586|i686|armv1|armv2|armv3|armv4|armv5|armv6|armv7/i), () => d = "32-bit"), runTest("is64BitFallback", d === c && t === "Mac OS X" && parseFloat(o) >= 10.7, () => d = "64-bit"), runTest("is32BitFallback", d === c && t === "Windows" || t === "Android" && parseFloat(o) < 5, () => d = "32-bit"), runTest("is32BitBrowser", d === "32-bit" || /wow64/i.test(e), () => h = "32-bit"), runTest("is64BitBrowser", /win64/i.test(e), () => h = "64-bit"), runTest("isDesktop", (() => t === "Windows" || t === "Mac OS X" || t === "Linux" || t === "Chrome OS" || l === "nwjs")(), () => u = !0), r === "Edge" && typeof Windows != "undefined" && typeof Windows.System != "undefined" && (l = "windows-store"), m = l === "nwjs";
    const p = t === "Mac OS X" && navigator.maxTouchPoints && navigator.maxTouchPoints > 2;
    p && (t = "iOS", o = a, u = !1, m = !1), g.Platform = {
        OS: t,
        OSVersion: o,
        OSArchitecture: d,
        Browser: s,
        BrowserVersion: a,
        BrowserVersionNumber: parseFloat(a),
        BrowserArchitecture: h,
        BrowserEngine: r,
        Context: l,
        IsDesktop: u,
        IsMobile: !u,
        IsDesktopApp: m,
        IsChromeWebStore: !!(self.chrome && self.chrome.runtime && self.chrome.runtime.id),
        IsAppleOS: t === "Mac OS X" || t === "iOS",
        IsIpadOS: p,
        IsLinux: t === "Linux"
    }
}
"use strict";
{
    const n = 2,
        e = "keyvaluepairs",
        t = new Map,
        s = typeof IDBObjectStore != "undefined" && typeof IDBObjectStore.prototype.getAll == "function",
        o = typeof IDBObjectStore != "undefined" && typeof IDBObjectStore.prototype.getAllKeys == "function";

    function asyncifyRequest(e) {
        return new Promise((t, n) => {
            e.onsuccess = () => t(e.result), e.onerror = () => n(e.error)
        })
    }

    function asyncifyTransaction(e) {
        return new Promise((t, n) => {
            e.oncomplete = () => t(), e.onerror = () => n(e.error), e.onabort = () => n(e.error)
        })
    }

    function openReadOnlyTransaction(e, t) {
        return openTransaction(e, t)
    }

    function openWriteTransaction(e, t) {
        return openTransaction(e, t, !0)
    }
    async function openTransaction(n, s, o = !1, i = !0) {
        const a = await lazyOpenDatabase(n);
        try {
            const t = a.transaction([e], o ? "readwrite" : "readonly");
            return s(t)
        } catch (e) {
            if (i && e.name === "InvalidStateError") return t.delete(n), openTransaction(n, s, o, !1);
            throw e
        }
    }

    function lazyOpenDatabase(e) {
        RequireString(e);
        let n = t.get(e);
        return n instanceof Promise || (n = openDatabase(e), t.set(e, n), n.catch(n => t.delete(e))), n
    }
    async function openDatabase(t) {
        RequireString(t);
        const s = indexedDB.open(t, n);
        return s.addEventListener("upgradeneeded", n => {
            try {
                const t = n.target.result;
                t.createObjectStore(e)
            } catch (e) {
                console.error(`Failed to create objectstore for database ${t}`, e)
            }
        }), asyncifyRequest(s)
    }

    function RequireString(e) {
        if (typeof e != "string") throw new TypeError("expected string")
    }

    function getEntriesFromCursor(t, n) {
        const s = t.objectStore(e).openCursor();
        return new Promise(e => {
            const t = [];
            s.onsuccess = s => {
                const o = s.target.result;
                if (o) {
                    switch (n) {
                        case "entries":
                            t.push([o.key, o.value]);
                            break;
                        case "keys":
                            t.push(o.key);
                            break;
                        case "values":
                            t.push(o.value);
                            break
                    }
                    o.continue()
                } else e(t)
            }
        })
    }
    class i {
        constructor(e) {
            RequireString(e), this.name = e
        }
        async ready() {
            await lazyOpenDatabase(this.name)
        }
        set(t, n) {
            return RequireString(t), openWriteTransaction(this.name, async s => {
                const o = s.objectStore(e).put(n, t),
                    i = asyncifyRequest(o),
                    a = asyncifyTransaction(s);
                await Promise.all([a, i])
            })
        }
        get(t) {
            return RequireString(t), openReadOnlyTransaction(this.name, async n => {
                const s = n.objectStore(e).get(t),
                    o = asyncifyRequest(s),
                    i = asyncifyTransaction(n),
                    [r, a] = await Promise.all([i, o]);
                return a
            })
        }
        delete(t) {
            return RequireString(t), openWriteTransaction(this.name, async n => {
                const s = n.objectStore(e).delete(t),
                    o = asyncifyRequest(s),
                    i = asyncifyTransaction(n);
                await Promise.all([i, o])
            })
        }
        clear() {
            return openWriteTransaction(this.name, async t => {
                const n = t.objectStore(e).clear(),
                    s = asyncifyRequest(n),
                    o = asyncifyTransaction(t);
                await Promise.all([o, s])
            })
        }
        keys() {
            return openReadOnlyTransaction(this.name, async t => {
                let n;
                if (o) {
                    const s = t.objectStore(e).getAllKeys();
                    n = asyncifyRequest(s)
                } else n = getEntriesFromCursor(t, "keys");
                const s = asyncifyTransaction(t),
                    [a, i] = await Promise.all([s, n]);
                return i
            })
        }
        values() {
            return openReadOnlyTransaction(this.name, async t => {
                let n;
                if (s) {
                    const s = t.objectStore(e).getAll();
                    n = asyncifyRequest(s)
                } else n = getEntriesFromCursor(t, "values");
                const o = asyncifyTransaction(t),
                    [a, i] = await Promise.all([o, n]);
                return i
            })
        }
        entries() {
            return openReadOnlyTransaction(this.name, async e => {
                const t = getEntriesFromCursor(e, "entries"),
                    n = asyncifyTransaction(e),
                    [o, s] = await Promise.all([n, t]);
                return s
            })
        }
    }
    self.KVStorageContainer = i
}
"use strict";
{
    const n = self.KVStorageContainer,
        o = [/no available storage method found/i, /an attempt was made to break through the security policy of the user agent/i, /the user denied permission to access the database/i, /a mutation operation was attempted on a database that did not allow mutations/i, /idbfactory\.open\(\) called in an invalid security context/i],
        t = new WeakMap;
    let e = !1;
    typeof indexedDB == "undefined" && (e = !0, console.warn("Unable to use local storage because indexedDB is not defined"));

    function NOT_IMPLEMENTED(e) {
        throw new Error(`"${e}" is not implemented`)
    }

    function DISALLOW_CALLBACK(e) {
        if (typeof e == "function") throw new Error(`localforage callback API is not implemented; please use the promise API instead`)
    }

    function StructuredClone(e) {
        return typeof e == "object" ? new Promise(t => {
            const {
                port1: n,
                port2: s
            } = new MessageChannel;
            s.onmessage = e => t(e.data), n.postMessage(e)
        }) : Promise.resolve(e)
    }
    class s {
        constructor(e) {
            this._inst = e, t.set(this, new Map)
        }
        _MaybeSwitchToMemoryFallback(t) {
            if (e) return;
            for (const n of o)
                if (t && n.test(t.message)) {
                    console.error("Unable to use local storage, reverting to in-memory store: ", t, t.message), e = !0;
                    break
                }
        }
        async _getItemFallback(e) {
            const s = t.get(this).get(e),
                n = await StructuredClone(s);
            return typeof n == "undefined" ? null : n
        }
        async _setItemFallback(e, n) {
            n = await StructuredClone(n), t.get(this).set(e, n)
        }
        _removeItemFallback(e) {
            t.get(this).delete(e)
        }
        _clearFallback() {
            t.get(this).clear()
        }
        _keysFallback() {
            return Array.from(t.get(this).keys())
        }
        IsUsingFallback() {
            return e
        }
        async getItem(t, n) {
            if (DISALLOW_CALLBACK(n), e) return await this._getItemFallback(t);
            let s;
            try {
                s = await this._inst.get(t)
            } catch (n) {
                return this._MaybeSwitchToMemoryFallback(n), e ? await this._getItemFallback(t) : (console.error(`Error reading '${t}' from storage, returning null: `, n), null)
            }
            return typeof s == "undefined" ? null : s
        }
        async setItem(t, n, s) {
            if (DISALLOW_CALLBACK(s), typeof n == "undefined" && (n = null), e) {
                await this._setItemFallback(t, n);
                return
            }
            try {
                await this._inst.set(t, n)
            } catch (s) {
                if (this._MaybeSwitchToMemoryFallback(s), e) await this._setItemFallback(t, n);
                else throw s
            }
        }
        async removeItem(t, n) {
            if (DISALLOW_CALLBACK(n), e) {
                this._removeItemFallback(t);
                return
            }
            try {
                await this._inst.delete(t)
            } catch (n) {
                this._MaybeSwitchToMemoryFallback(n), e ? this._removeItemFallback(t) : console.error(`Error removing '${t}' from storage: `, n)
            }
        }
        async clear(t) {
            if (DISALLOW_CALLBACK(t), e) {
                this._clearFallback();
                return
            }
            try {
                await this._inst.clear()
            } catch (t) {
                this._MaybeSwitchToMemoryFallback(t), e ? this._clearFallback() : console.error(`Error clearing storage: `, t)
            }
        }
        async keys(t) {
            if (DISALLOW_CALLBACK(t), e) return this._keysFallback();
            let n = [];
            try {
                n = await this._inst.keys()
            } catch (t) {
                if (this._MaybeSwitchToMemoryFallback(t), e) return this._keysFallback();
                console.error(`Error getting storage keys: `, t)
            }
            return n
        }
        ready(t) {
            return DISALLOW_CALLBACK(t), e ? Promise.resolve(!0) : this._inst.ready()
        }
        createInstance(e) {
            if (typeof e != "object") throw new TypeError("invalid options object");
            const t = e.name;
            if (typeof t != "string") throw new TypeError("invalid store name");
            const o = new n(t);
            return new s(o)
        }
        length() {
            NOT_IMPLEMENTED("localforage.length()")
        }
        key() {
            NOT_IMPLEMENTED("localforage.key()")
        }
        iterate() {
            NOT_IMPLEMENTED("localforage.iterate()")
        }
        setDriver() {
            NOT_IMPLEMENTED("localforage.setDriver()")
        }
        config() {
            NOT_IMPLEMENTED("localforage.config()")
        }
        defineDriver() {
            NOT_IMPLEMENTED("localforage.defineDriver()")
        }
        driver() {
            NOT_IMPLEMENTED("localforage.driver()")
        }
        supports() {
            NOT_IMPLEMENTED("localforage.supports()")
        }
        dropInstance() {
            NOT_IMPLEMENTED("localforage.dropInstance()")
        }
        disableMemoryMode() {
            e = !1
        }
    }
    self.localforage = new s(new n("localforage"))
}
"use strict";
{
    const e = self.C3;
    if (e.Supports = {}, e.Supports.WebAnimations = (() => {
            try {
                if (e.Platform.Browser === "Safari") return !1;
                if (typeof document == "undefined") return !1;
                const t = document.createElement("div");
                if (typeof t.animate == "undefined") return !1;
                const n = t.animate([{
                    opacity: "0"
                }, {
                    opacity: "1"
                }], 1e3);
                return typeof n.reverse != "undefined"
            } catch {
                return !1
            }
        })(), e.Supports.DialogElement = typeof HTMLDialogElement != "undefined", e.Supports.RequestIdleCallback = !!self.requestIdleCallback, e.Supports.ImageBitmap = !!self.createImageBitmap, e.Supports.ImageBitmapOptions = !1, e.Supports.ImageBitmap) try {
        self.createImageBitmap(new ImageData(32, 32), {
            premultiplyAlpha: "none"
        }).then(t => {
            e.Supports.ImageBitmapOptions = !0
        }).catch(t => {
            e.Supports.ImageBitmapOptions = !1
        })
    } catch {
        e.Supports.ImageBitmapOptions = !1
    }
    e.Supports.ClipboardReadText = !!(navigator.clipboard && navigator.clipboard.readText && e.Platform.Browser !== "Firefox"), e.Supports.PermissionsQuery = !!(navigator.permissions && navigator.permissions.query), e.Supports.Proxies = typeof Proxy != "undefined", e.Supports.DownloadAttribute = (() => {
        if (typeof document == "undefined") return !1;
        const e = document.createElement("a");
        return typeof e.download != "undefined"
    })(), e.Supports.CanvasToBlob = (() => typeof HTMLCanvasElement != "undefined" && HTMLCanvasElement.prototype.toBlob)(), e.Supports.Fetch = typeof fetch == "function", e.Supports.PersistentStorage = !!(self.isSecureContext && e.Platform.Browser !== "Opera" && navigator.storage && navigator.storage.persist), e.Supports.StorageQuotaEstimate = !!(self.isSecureContext && navigator.storage && navigator.storage.estimate), e.Supports.Fullscreen = (() => {
        if (typeof document == "undefined") return !1;
        if (e.Platform.OS === "iOS") return !1;
        const t = document.documentElement;
        return !!(t.requestFullscreen || t.msRequestFullscreen || t.mozRequestFullScreen || t.webkitRequestFullscreen)
    })(), e.Supports.ImageDecoder = typeof self.ImageDecoder != "undefined", e.Supports.NativeFileSystemAPI = !!self.showOpenFilePicker, e.Supports.NavigatorFontsQuery = !!(navigator.fonts && navigator.fonts.query)
}
"use strict";
{
    const e = self.C3;
    if (!String.prototype.trimStart) {
        const e = /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*/;
        String.prototype.trimStart = function() {
            return this.replace(e, "")
        }
    }
    if (!String.prototype.trimEnd) {
        const e = /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*$/;
        String.prototype.trimEnd = function() {
            return this.replace(e, "")
        }
    }
    if (String.prototype.replaceAll || (String.prototype.replaceAll = function(n, s) {
            return this.replace(new RegExp(e.EscapeRegex(n), "g"), s)
        }), Array.prototype.values || (Array.prototype.values = function*() {
            for (const e of this) yield e
        }), !Array.prototype.flat) {
        function arrayFlat(e, t) {
            return e.reduce((e, n) => t > 0 && Array.isArray(n) ? (Array.prototype.push.apply(e, arrayFlat(n, t - 1)), e) : (e.push(n), e), [])
        }
        Array.prototype.flat = function(e = 1) {
            return arrayFlat(this, e)
        }
    }
    if (RegExp.escape || (RegExp.escape = function(e) {
            return String(e).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&")
        }), navigator.storage && !navigator.storage.estimate && navigator.webkitTemporaryStorage && navigator.webkitTemporaryStorage.queryUsageAndQuota && (navigator.storage.estimate = function() {
            return new Promise((e, t) => navigator.webkitTemporaryStorage.queryUsageAndQuota((t, n) => e({
                usage: t,
                quota: n
            }), t))
        }), typeof HTMLCollection != "undefined" && !HTMLCollection.prototype[Symbol.iterator] && (HTMLCollection.prototype[Symbol.iterator] = function() {
            let e = 0;
            return {
                next: () => e >= this.length ? {
                    done: !0
                } : {
                    value: this.item(e++),
                    done: !1
                }
            }
        }), typeof NodeList != "undefined" && !NodeList.prototype[Symbol.iterator] && (NodeList.prototype[Symbol.iterator] = function() {
            let e = 0;
            return {
                next: () => e >= this.length ? {
                    done: !0
                } : {
                    value: this.item(e++),
                    done: !1
                }
            }
        }), typeof DOMTokenList != "undefined" && !DOMTokenList.prototype[Symbol.iterator] && (DOMTokenList.prototype[Symbol.iterator] = function() {
            let e = 0;
            return {
                next: () => e >= this.length ? {
                    done: !0
                } : {
                    value: this.item(e++),
                    done: !1
                }
            }
        }), typeof FileList != "undefined" && !FileList.prototype[Symbol.iterator] && (FileList.prototype[Symbol.iterator] = function() {
            let e = 0;
            return {
                next: () => e >= this.length ? {
                    done: !0
                } : {
                    value: this.item(e++),
                    done: !1
                }
            }
        }), typeof TextEncoder == "undefined" && (self.TextEncoder = class TextEncoder {
            constructor() {
                Object.defineProperty(this, "encoding", {
                    value: "utf-8",
                    writable: !1
                })
            }
            encode(e) {
                i = e.length, t = -1, n = new Uint8Array(i * 3);
                for (var t, n, i, s = 0, a = 0, o = 0; o !== i;) {
                    if (s = e.charCodeAt(o), o += 1, s >= 55296 && s <= 56319) {
                        if (o === i) {
                            n[t += 1] = 239, n[t += 1] = 191, n[t += 1] = 189;
                            break
                        }
                        if (a = e.charCodeAt(o), a >= 56320 && a <= 57343) {
                            if (s = (s - 55296) * 1024 + a - 56320 + 65536, o += 1, s > 65535) {
                                n[t += 1] = 30 << 3 | s >>> 18, n[t += 1] = 2 << 6 | s >>> 12 & 63, n[t += 1] = 2 << 6 | s >>> 6 & 63, n[t += 1] = 2 << 6 | s & 63;
                                continue
                            }
                        } else {
                            n[t += 1] = 239, n[t += 1] = 191, n[t += 1] = 189;
                            continue
                        }
                    }
                    s <= 127 ? n[t += 1] = 0 << 7 | s : s <= 2047 ? (n[t += 1] = 6 << 5 | s >>> 6, n[t += 1] = 2 << 6 | s & 63) : (n[t += 1] = 14 << 4 | s >>> 12, n[t += 1] = 2 << 6 | s >>> 6 & 63, n[t += 1] = 2 << 6 | s & 63)
                }
                return new Uint8Array(n.buffer.slice(0, t + 1))
            }
            toString() {
                return "[object TextEncoder]"
            }
        }, TextEncoder[Symbol.toStringTag] = "TextEncoder"), typeof TextDecoder == "undefined") {
        function persist(e) {
            const t = e[Symbol.iterator]();
            return {
                next: e => t.next(),
                [Symbol.iterator]() {
                    return this
                }
            }
        }

        function readNext(e) {
            const t = e.next();
            if (t.done) throw new Error("unexpected end of input");
            if ((t.value & 192 ^ 128) != 0) throw new Error("invalid byte");
            return t.value & 63
        }
        const e = new Map;
        e.set("utf-8", (e, t) => {
            let s;
            if (e.buffer) s = new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
            else if (s instanceof ArrayBuffer) s = new Uint8Array(e);
            else throw new Error("Invalid parameter");
            const n = persist(s),
                o = [];
            try {
                for (const e of n) {
                    let t;
                    if (e < 127) t = e & 127;
                    else if (e < 223) t = (e & 31) << 6 | readNext(n);
                    else if (e < 239) t = (e & 15) << 12 | readNext(n) << 6 | readNext(n);
                    else if (e < 247) t = (e & 7) << 18 | readNext(n) << 12 | readNext(n) << 6 | readNext(n);
                    else throw new Error("Invalid character");
                    o.push(String.fromCodePoint(t))
                }
            } catch (e) {
                if (t) throw e;
                o.push("")
            }
            return o.join("")
        }), e.set("utf8", e.get("utf-8")), e.set("utf-16le", () => {
            throw new Error("utf-16le decoder not implemented")
        }), self.TextDecoder = class TextDecoder {
            constructor(t = "utf-8", n = {}) {
                const s = e.get(t);
                if (!s) throw new Error(`TextDecoder polyfill does not support "${t}"`);
                Object.defineProperty(this, "fatal", {
                    value: n.fatal === !0,
                    writable: !1
                }), Object.defineProperty(this, "_decoder", {
                    value: s,
                    writable: !1
                }), Object.defineProperty(this, "encoding", {
                    value: t,
                    writable: !1
                })
            }
            decode(e) {
                return this._decoder(e, this.fatal)
            }
            toString() {
                return "[object TextDecoder]"
            }
        }, TextDecoder[Symbol.toStringTag] = "TextDecoder"
    }
    typeof self.isSecureContext == "undefined" && (self.isSecureContext = location.protocol === "https:"), typeof self.globalThis == "undefined" && (self.globalThis = self)
}
"use strict";
{
    const e = self.C3;

    function assertFail(t) {
        let n = e.GetCallStack(),
            s = "Assertion failure: " + t + `

Stack trace:
` + n;
        console.error(s)
    }
    self.assert = function(t, n) {
        t || assertFail(n)
    }
}
"use strict";
{
    const e = self.C3;
    e.IsNumber = function(t) {
        return typeof t == "number"
    }, e.IsFiniteNumber = function(n) {
        return e.IsNumber(n) && isFinite(n)
    }, e.RequireNumber = function(n) {
        if (!e.IsNumber(n)) throw new TypeError("expected number")
    }, e.RequireOptionalNumber = function(n) {
        if (e.IsNullOrUndefined(n)) return
    }, e.RequireNumberInRange = function(n, s, o) {
        if (!e.IsNumber(n) || isNaN(n) || s > n || o < n) throw new RangeError("number outside of range")
    }, e.RequireAllNumber = function(...e) {
        for (let t of e);
    }, e.RequireFiniteNumber = function(n) {
        if (!e.IsFiniteNumber(n)) throw new TypeError("expected finite number")
    }, e.RequireOptionalFiniteNumber = function(n) {
        if (e.IsNullOrUndefined(n)) return
    }, e.RequireAllFiniteNumber = function(...e) {
        for (let t of e);
    }, e.IsString = function(t) {
        return typeof t == "string"
    }, e.RequireString = function(n) {
        if (!e.IsString(n)) throw new TypeError("expected string")
    }, e.RequireOptionalString = function(n) {
        if (e.IsNullOrUndefined(n)) return
    }, e.RequireAllString = function(...e) {
        for (let t of e);
    }, e.IsSimpleObject = function(t) {
        if (typeof t != "object" || t === null) return !1;
        let n = Object.getPrototypeOf(t);
        return n ? n.constructor === Object : n === null
    }, e.RequireSimpleObject = function(n) {
        if (!e.IsSimpleObject(n)) throw new TypeError("expected simple object")
    }, e.RequireOptionalSimpleObject = function(n) {
        if (e.IsNullOrUndefined(n)) return;
        if (!e.IsSimpleObject(n)) throw new TypeError("expected simple object")
    }, e.IsObject = function(t) {
        return typeof t == "object" && t !== null && !Array.isArray(t)
    }, e.RequireObject = function(n) {
        if (!e.IsObject(n)) throw new TypeError("expected object")
    }, e.RequireOptionalObject = function(n) {
        if (e.IsNullOrUndefined(n)) return
    }, e.RequireAllObject = function(...e) {
        for (let t of e);
    }, e.IsFileLike = function(n) {
        return e.IsInstanceOf(n, Blob) && typeof n.name == "string"
    }, e.RequireFileLike = function(n) {
        if (!e.IsFileLike(n)) throw new TypeError("expected file")
    }, e.RequireOptionalFileLike = function(n) {
        if (e.IsNullOrUndefined(n)) return
    }, e.IsArray = function(t) {
        return Array.isArray(t)
    }, e.RequireArray = function(n) {
        if (!e.IsArray(n)) throw new TypeError("expected array")
    }, e.RequireOptionalArray = function(n) {
        if (e.IsNullOrUndefined(n)) return
    }, e.RequireAllArray = function(...e) {
        for (let t of e);
    }, e.Is2DArray = function(t) {
        return !!e.IsArray(t) && (!t.length || !!e.IsArray(t[0]))
    }, e.Require2DArray = function(n) {
        if (!e.Is2DArray(n)) throw new TypeError("expected 2d array");
        for (let t of n)
            if (!e.IsArray(t)) throw new TypeError("expected 2d array")
    }, e.RequireOptional2DArray = function(n) {
        if (e.IsNullOrUndefined(n)) return
    }, e.IsFunction = function(t) {
        return typeof t == "function"
    }, e.RequireFunction = function(n, s) {
        if (!e.IsFunction(n)) throw new TypeError("expected function");
        if (!e.IsNullOrUndefined(s) && n !== s) throw new TypeError("expected same function reference")
    }, e.RequireOptionalFunction = function(n) {
        if (e.IsNullOrUndefined(n)) return
    }, e.RequireAllFunction = function(...e) {
        for (let t of e);
    }, e.RequireAnyFunction = function(t, ...n) {
        if (!e.IsFunction(t)) throw new TypeError("expected function");
        if (!n.length) throw new Error("missing comparison functions");
        for (let s of n)
            if (!e.IsNullOrUndefined(s) && t === s) return;
        throw new TypeError("expected same function reference")
    }, e.RequireOptionalAllFunction = function(...t) {
        if (e.IsNullOrUndefined(t)) return;
        for (let e of t);
    }, e.IsInstanceOf = function(t, n) {
        return t instanceof n
    }, e.IsInstanceOfAny = function(t, ...n) {
        for (let s of n)
            if (e.IsInstanceOf(t, s)) return !0;
        return !1
    }, e.RequireInstanceOf = function(n, s) {
        if (!e.IsInstanceOf(n, s)) throw new TypeError("unexpected type")
    }, e.RequireOptionalInstanceOf = function(n) {
        if (e.IsNullOrUndefined(n)) return
    }, e.RequireAllInstanceOf = function(n, ...e) {
        for (let t of e);
    }, e.RequireAnyInstanceOf = function(t, ...n) {
        if (!e.IsInstanceOfAny(t, ...n)) throw new TypeError("unexpected type")
    }, e.RequireAnyOptionalInstanceOf = function(t, ...n) {
        if (e.IsNullOrUndefined(t)) return;
        if (!e.IsInstanceOfAny(t, ...n)) throw new TypeError("unexpected type")
    }, e.IsArrayOf = function(n, s) {
        for (let t of n)
            if (!e.IsInstanceOf(t, s)) return !1;
        return !0
    }, e.IsArrayOfFiniteNumbers = function(n) {
        for (let t of n)
            if (!e.IsFiniteNumber(t)) return !1;
        return !0
    }, e.RequireArrayOf = function(t) {
        for (let e of t);
    }, e.RequireOptionalArrayOf = function(n) {
        if (e.IsNullOrUndefined(n)) return;
        for (let e of n);
    }, e.RequireArrayOfAny = function(e, ...n) {
        for (let t of e);
    }, e.RequireOptionalArrayOfAny = function(t, ...s) {
        if (e.IsNullOrUndefined(t)) return;
        for (let e of t);
    }, e.IsDOMNode = function(n, s) {
        return !e.IsNullOrUndefined(n) && !!e.IsString(n.nodeName) && (!s || e.equalsNoCase(n.nodeName, s))
    }, e.RequireDOMNode = function(n, s) {
        if (e.IsNullOrUndefined(n) || !e.IsString(n.nodeName)) throw new TypeError("expected DOM node");
        if (s && !e.equalsNoCase(n.nodeName, s)) throw new TypeError(`expected DOM '${s}' node`)
    }, e.RequireOptionalDOMNode = function(n) {
        if (e.IsNullOrUndefined(n)) return
    }, e.IsHTMLElement = function(n, s) {
        return !e.IsNullOrUndefined(n) && !!e.IsString(n.tagName) && (!s || e.equalsNoCase(n.tagName, s))
    }, e.RequireHTMLElement = function(n, s) {
        if (e.IsNullOrUndefined(n) || !e.IsString(n.tagName)) throw new TypeError("expected HTML element");
        if (s && !e.equalsNoCase(n.tagName, s)) throw new TypeError(`expected HTML '${s}' element`)
    }, e.RequireOptionalHTMLElement = function(n) {
        if (e.IsNullOrUndefined(n)) return
    }, e.IsDrawable = function(n) {
        return e.IsHTMLElement(n, "img") || e.IsHTMLElement(n, "canvas") || e.IsHTMLElement(n, "video") || typeof OffscreenCanvas != "undefined" && n instanceof OffscreenCanvas || typeof ImageBitmap != "undefined" && n instanceof ImageBitmap
    }, e.RequireDrawable = function(n) {
        if (!e.IsDrawable(n)) throw new TypeError("expected drawable")
    }, e.RequireOptionalDrawable = function(n) {
        if (e.IsNullOrUndefined(n)) return
    }, e.IsDrawableOrImageData = function(n) {
        return n instanceof ImageData || e.IsDrawable(n)
    }, e.RequireDrawableOrImageData = function(n) {
        if (!e.IsDrawableOrImageData(n)) throw new TypeError("expected drawable or image data")
    }, e.RequireOptionalDrawableOrImageData = function(n) {
        if (e.IsNullOrUndefined(n)) return;
        if (!e.IsDrawableOrImageData(n)) throw new TypeError("expected drawable or image data")
    }, e.IsStringLike = function(n) {
        return typeof n == "string" || n instanceof e.HtmlString || n instanceof e.BBString
    }, e.RequireStringLike = function(n) {
        if (!e.IsStringLike(n)) throw new TypeError("expected string-like")
    }, e.RequireOptionalStringLike = function(n) {
        if (e.IsNullOrUndefined(n)) return
    }, e.RequireAllStringLike = function(...e) {
        for (let t of e);
    }, e.RequireOverride = function() {
        throw new Error("must be overridden")
    }, e.NotYetImplemented = function() {
        throw new Error("not yet implemented")
    }, e.IsDefined = function(t, ...n) {
        let e = t;
        if (typeof e == "undefined") return !1;
        for (let t of n) {
            if (typeof e[t] == "undefined") return !1;
            e = e[t]
        }
        return !0
    }, e.IsNullOrUndefined = function(e) {
        return typeof e == "undefined" || e === null
    }, e.AreArrayElementsOfSameType = function(e) {
        let t = e[0].constructor;
        for (let n of e)
            if (n.constructor !== t) return !1;
        return t
    }, e.AreArrayElementsOfType = function(e, t) {
        for (let n of e)
            if (!(n instanceof t)) return !1;
        return !0
    };
    const t = Object.getPrototypeOf(Uint8Array);
    e.IsTypedArray = function(n) {
        return e.IsInstanceOf(n, t)
    }, e.RequireTypedArray = function() {}, e.WeakRequireTypedArray = function(s) {
        e.WeakRequireInstanceOf(s, t)
    }, e.WeakRequireAnyInstanceOf = function(t, ...n) {
        if (!e.WeakIsAnyInstanceOf(t, ...n)) throw new TypeError("unexpected type")
    }, e.WeakIsAnyInstanceOf = function(t, ...n) {
        for (const s of n)
            if (e.WeakIsInstanceOf(t, s)) return !0;
        return !1
    }, e.WeakRequireInstanceOf = function(n, s) {
        if (!e.WeakIsInstanceOf(n, s)) throw new TypeError("unexpected type")
    }, e.WeakIsInstanceOf = function(t, n) {
        for (; t = Object.getPrototypeOf(t);)
            if (t.constructor.name === n.name) return !0;
        return !1
    }
}
"use strict";
{
    const e = self.C3;
    e.GetCallStack = function() {
        return (new Error).stack
    }, e.Debugger = function() {
        debugger
    }, e.cast = function(t, n) {
        return t && t instanceof n ? t : null
    }, e.getName = function(n) {
        return typeof n == "undefined" ? "undefined" : n === null ? "null" : typeof n == "boolean" ? "<boolean>" : e.IsNumber(n) ? "<number>" : e.IsString(n) ? "<string>" : e.IsArray(n) ? "<array>" : typeof n == "symbol" ? "<" + n.toString() + ">" : e.IsFunction(n) ? n.name && n.name !== "Function" ? n.name : "<anonymous function>" : typeof n == "object" ? n.constructor && n.constructor.name && n.constructor.name !== "Object" ? n.constructor.name : "<anonymous object>" : "<unknown>"
    }, e.getType = function(t) {
        return t === null ? "null" : Array.isArray(t) ? "array" : typeof t
    }, e.range = function*(t, n) {
        if (!isFinite(Math.abs(t - n))) throw new Error("Invalid parameters");
        if (t > n)
            for (let e = t - 1; e >= n; e--) yield e;
        else
            for (let e = t; e < n; e++) yield e
    };

    function isValidTypeChange(t, n) {
        let s = e.getType(t),
            o = e.getType(n);
        return s === "null" || o === "null" || s !== "undefined" && o !== "undefined" && s === o
    }
    let t = new Map,
        n = new Map,
        o = new WeakMap,
        s = new WeakMap;
    e.DefendHandler = {};
    const a = new Set(["then", "splice"]);

    function logDefendedObjectWarning(t) {
        console.warn("[Defence] " + t + " @", e.GetCallStack())
    }
    e.DefendHandler.get = function(n, o) {
        return !(o in n) && typeof o != "symbol" && !a.has(o) && logDefendedObjectWarning(`Accessed missing property '${o}' from defended object '${e.getName(n)}', returning undefined`), s.has(n) && typeof o != "symbol" && !a.has(o) && logDefendedObjectWarning(`Accessed property '${o}' on a released object '${e.getName(n)}'
Object was originally released at: ${s.get(n)})
Call stack at access: `), n[o]
    }, e.DefendHandler.set = function(o, i, a) {
        return !(i in o) && !t.has(o) && logDefendedObjectWarning(`Set non-existent property '${i}' to '${a}' on defended object '${e.getName(o)}'`), !isValidTypeChange(o[i], a) && !t.has(o) && logDefendedObjectWarning(`Set '${e.getType(o[i])}' property '${i}' to type '${e.getType(a)}' on defended object '${e.getName(o)}'`), s.has(o) && logDefendedObjectWarning(`Set property '${i}' on a released object '${e.getName(o)}'
Object was originally released at: ${s.get(o)})
Call stack at access: `), o[i] = a, !0
    }, e.DefendHandler.deleteProperty = function(n, s) {
        throw new ReferenceError(`Cannot delete property '${s}' from defended object '${e.getName(n)}'`)
    }, e.DefendHandler.defineProperty = function(n, s) {
        throw new ReferenceError(`Cannot define property '${s}' on defended object '${e.getName(n)}'`)
    }, e.DefendHandler.enumerate = function(n) {
        throw new ReferenceError(`Cannot enumerate defended object '${e.getName(n)}'`)
    };
    let i = -1;

    function CheckDefendedObjectsUsedCorrectly() {
        if (i = -1, t.size > 0 || n.size > 0) {
            let s = new Set([...t.keys()].map(t => e.getName(t))),
                o = [...s].join(",");
            console.warn(`An object derived from DefendedBase was not protected with debugDefend(). This will disable some checks. See the coding guidelines! Possible affected class names: ${o}`), t.clear(), n.clear()
        }
    }
    e.DefendedBase = class DefendedBase {
        constructor() {
            if (!e.isDebugDefend || !e.Supports.Proxies) return;
            let r = new.target,
                s = Object.create(r.prototype),
                a = new Proxy(s, e.DefendHandler);
            return t.set(s, a), n.set(a, s), o.set(a, s), i === -1 && (i = requestAnimationFrame(CheckDefendedObjectsUsedCorrectly)), a
        }
    }, e.debugDefend = function(o) {
        if (e.isDebugDefend && e.Supports.Proxies && o instanceof e.DefendedBase) {
            if (!n.has(o)) return o;
            let e = n.get(o);
            return n.delete(o), t.delete(e), o
        }
        return e.isDebug ? Object.seal(o) : o
    }, e.New = function(o, ...i) {
        let s;
        try {
            s = new o(...i)
        } catch (e) {
            throw n.clear(), t.clear(), e
        }
        return e.isDebugDefend && VerifyObjectPropertiesConsistent(o, s), e.debugDefend(s)
    }, e.Release = function(n) {
        let i = o.get(n);
        i && s.set(i, e.GetCallStack())
    }, e.WasReleased = function(e) {
        let t = o.get(e);
        return !!t && !!s.get(t)
    };
    let r = new Map;

    function getObjectPropertySet(e) {
        let t = new Set;
        for (let n in e) t.add(n);
        return t
    }

    function VerifyObjectPropertiesConsistent(t, n) {
        let s = getObjectPropertySet(n),
            o = r.get(t);
        if (o) {
            let n = [];
            for (let e of o.values()) s.has(e) ? s.delete(e) : n.push(e);
            e.appendArray(n, [...s]), n.length && console.warn(`[Defence] '${e.getName(t)}' constructor creates inconsistent properties: ${n.join(", ")}`)
        } else r.set(t, s)
    }
    e.PerfMark = class PerfMark {
        constructor(e) {
            this._name = "", e && this.start(e)
        }
        start(e) {
            this._name = e, performance.mark(this._name + "-Start")
        }
        end() {
            performance.mark(this._name + "-End"), performance.measure(this._name, this._name + "-Start", this._name + "-End")
        }
        next(e) {
            this.end(), this._name = e, performance.mark(this._name + "-Start")
        }
    }
}
"use strict";
{
    const e = self.C3,
        s = Math.PI * 2,
        c = Math.PI / 180,
        l = 180 / Math.PI;
    e.wrap = function(t, n, s) {
        if (t = Math.floor(t), n = Math.floor(n), s = Math.floor(s), t < n) {
            let e = s - (n - t) % (s - n);
            return e === s ? 0 : e
        }
        return n + (t - n) % (s - n)
    }, e.mapToRange = function(t, n, s, o, i) {
        return (t - n) * (i - o) / (s - n) + o
    }, e.normalize = function(t, n, s) {
        return (t - n) / (s - n)
    }, e.clamp = function(t, n, s) {
        return t < n ? n : t > s ? s : t
    }, e.clampAngle = function(t) {
        return t %= s, t < 0 && (t += s), t
    }, e.toRadians = function(t) {
        return t * c
    }, e.toDegrees = function(t) {
        return t * l
    }, e.distanceTo = function(t, n, s, o) {
        return Math.hypot(s - t, o - n)
    }, e.distanceSquared = function(t, n, s, o) {
        const i = s - t,
            a = o - n;
        return i * i + a * a
    }, e.angleTo = function(t, n, s, o) {
        return Math.atan2(o - n, s - t)
    }, e.angleDiff = function(t, n) {
        if (t === n) return 0;
        let o = Math.sin(t),
            i = Math.cos(t),
            a = Math.sin(n),
            r = Math.cos(n),
            s = o * a + i * r;
        return s >= 1 ? 0 : s <= -1 ? Math.PI : Math.acos(s)
    }, e.angleRotate = function(n, s, o) {
        let i = Math.sin(n),
            a = Math.cos(n),
            r = Math.sin(s),
            c = Math.cos(s);
        return Math.acos(i * r + a * c) > o ? a * r - i * c > 0 ? e.clampAngle(n + o) : e.clampAngle(n - o) : e.clampAngle(s)
    }, e.angleClockwise = function(t, n) {
        let s = Math.sin(t),
            o = Math.cos(t),
            i = Math.sin(n),
            a = Math.cos(n);
        return o * i - s * a <= 0
    }, e.angleLerp = function(n, o, i, a = 0) {
        let r = e.angleDiff(n, o);
        const c = s * a;
        return e.angleClockwise(o, n) ? e.clampAngle(n + (r + c) * i) : e.clampAngle(n - (r + c) * i)
    }, e.angleLerpClockwise = function(n, o, i, a = 0) {
        const r = e.angleDiff(n, o),
            c = s * a;
        return e.angleClockwise(o, n) ? e.clampAngle(n + (r + c) * i) : e.clampAngle((s - r + c) * i)
    }, e.angleLerpAntiClockwise = function(n, o, i, a = 0) {
        const r = e.angleDiff(n, o),
            c = s * a;
        return e.angleClockwise(o, n) ? e.clampAngle((-s + r - c) * i) : e.clampAngle(n - (r + c) * i)
    }, e.lerp = function(t, n, s) {
        return t + s * (n - t)
    }, e.unlerp = function(t, n, s) {
        return t === n ? 0 : (s - t) / (n - t)
    }, e.relerp = function(n, s, o, i, a) {
        return e.lerp(i, a, e.unlerp(n, s, o))
    }, e.qarp = function(n, s, o, i) {
        return e.lerp(e.lerp(n, s, i), e.lerp(s, o, i), i)
    }, e.cubic = function(n, s, o, i, a) {
        return e.lerp(e.qarp(n, s, o, a), e.qarp(s, o, i, a), a)
    }, e.cosp = function(t, n, s) {
        return (t + n + (t - n) * Math.cos(s * Math.PI)) / 2
    }, e.isPOT = function(t) {
        return t > 0 && (t - 1 & t) === 0
    }, e.nextHighestPowerOfTwo = function(t) {
        --t;
        for (let e = 1; e < 32; e <<= 1) t = t | t >> e;
        return t + 1
    }, e.roundToNearestFraction = function(t, n) {
        return Math.round(t * n) / n
    }, e.floorToNearestFraction = function(t, n) {
        return Math.floor(t * n) / n
    }, e.round6dp = function(t) {
        return Math.round(t * 1e6) / 1e6
    }, e.toFixed = function(t, n) {
        let o = t.toFixed(n),
            s = o.length - 1;
        for (; s >= 0 && o.charAt(s) === "0"; --s);
        return s >= 0 && o.charAt(s) === "." && --s, s < 0 ? o : o.substr(0, s + 1)
    }, e.PackRGB = function(n, s, o) {
        return e.clamp(n, 0, 255) | e.clamp(s, 0, 255) << 8 | e.clamp(o, 0, 255) << 16
    };
    const n = 1024,
        i = 1023,
        t = 16384,
        o = 8191,
        a = -8192;
    e.PackRGBAEx = function(r, c, l, d) {
        return r = e.clamp(Math.floor(r * 1024), a, o), c = e.clamp(Math.floor(c * 1024), a, o), l = e.clamp(Math.floor(l * 1024), a, o), d = e.clamp(Math.floor(d * i), 0, i), r < 0 && (r += t), c < 0 && (c += t), l < 0 && (l += t), -(r * t * t * n + c * t * n + l * n + d)
    }, e.PackRGBEx = function(n, s, o) {
        return e.PackRGBAEx(n, s, o, 1)
    };

    function isNegativeZero(e) {
        return e === 0 && 1 / e < 0
    }
    e.GetRValue = function(s) {
        if (s >= 0) return (s & 255) / 255;
        let i = Math.floor(-s / (t * t * n));
        return i > o && (i -= t), i / 1024
    }, e.GetGValue = function(s) {
        if (s >= 0) return ((s & 65280) >> 8) / 255;
        let i = Math.floor(-s % (t * t * n) / (t * n));
        return i > o && (i -= t), i / 1024
    }, e.GetBValue = function(s) {
        if (s >= 0) return ((s & 16711680) >> 16) / 255;
        let i = Math.floor(-s % (t * n) / n);
        return i > o && (i -= t), i / 1024
    }, e.GetAValue = function(t) {
        if (isNegativeZero(t)) return 0;
        if (t >= 0) return 1;
        const s = Math.floor(-t % n);
        return s / i
    }, e.greatestCommonDivisor = function(t, n) {
        for (t = Math.floor(t), n = Math.floor(n); n !== 0;) {
            let e = n;
            n = t % n, t = e
        }
        return t
    };
    const d = [
        [3, 2],
        [4, 3],
        [5, 4],
        [5, 3],
        [6, 5],
        [14, 9],
        [16, 9],
        [16, 10],
        [21, 9]
    ];
    e.getAspectRatio = function(n, s) {
        if (n = Math.floor(n), s = Math.floor(s), n === s) return [1, 1];
        for (let e of d) {
            let t = n / e[0] * e[1];
            if (Math.abs(s - t) < 1) return e.slice(0);
            if (t = n / e[1] * e[0], Math.abs(s - t) < 1) return [e[1], e[0]]
        }
        let o = e.greatestCommonDivisor(n, s);
        return [n / o, s / o]
    }, e.segmentsIntersect = function(t, n, s, o, i, a, r, c) {
        const _ = Math.min(t, s),
            w = Math.max(t, s),
            v = Math.min(i, r),
            O = Math.max(i, r);
        if (w < v || _ > O) return !1;
        const b = Math.min(n, o),
            g = Math.max(n, o),
            y = Math.min(a, c),
            j = Math.max(a, c);
        if (g < y || b > j) return !1;
        const u = i - t + r - s,
            m = a - n + c - o,
            d = s - t,
            p = o - n,
            l = r - i,
            f = c - a,
            h = Math.abs(p * l - f * d),
            x = l * m - f * u;
        if (Math.abs(x) > h) return !1;
        const C = d * m - p * u;
        return Math.abs(C) <= h
    }, e.segmentsIntersectPreCalc = function(t, n, s, o, i, a, r, c, l, d, u, h) {
        const O = Math.min(l, u),
            y = Math.max(l, u);
        if (a < O || i > y) return !1;
        const _ = Math.min(d, h),
            w = Math.max(d, h);
        if (c < _ || r > w) return !1;
        const f = l - t + u - s,
            p = d - n + h - o,
            g = s - t,
            v = o - n,
            b = u - l,
            m = h - d,
            j = Math.abs(v * b - m * g),
            x = b * p - m * f;
        if (Math.abs(x) > j) return !1;
        const C = g * p - v * f;
        return Math.abs(C) <= j
    }, e.segmentIntersectsQuad = function(n, s, o, i, a) {
        const r = Math.min(n, o),
            c = Math.max(n, o),
            l = Math.min(s, i),
            d = Math.max(s, i),
            u = a.getTlx(),
            h = a.getTly(),
            m = a.getTrx(),
            f = a.getTry(),
            p = a.getBrx(),
            g = a.getBry(),
            v = a.getBlx(),
            b = a.getBly();
        return e.segmentsIntersectPreCalc(n, s, o, i, r, c, l, d, u, h, m, f) || e.segmentsIntersectPreCalc(n, s, o, i, r, c, l, d, m, f, p, g) || e.segmentsIntersectPreCalc(n, s, o, i, r, c, l, d, p, g, v, b) || e.segmentsIntersectPreCalc(n, s, o, i, r, c, l, d, v, b, u, h)
    }, e.segmentIntersectsAnyN = function(n, s, o, i, a) {
        const c = Math.min(n, o),
            l = Math.max(n, o),
            d = Math.min(s, i),
            u = Math.max(s, i);
        let r = 0;
        for (let t = a.length - 4; r <= t; r += 2)
            if (e.segmentsIntersectPreCalc(n, s, o, i, c, l, d, u, a[r], a[r + 1], a[r + 2], a[r + 3])) return !0;
        return e.segmentsIntersectPreCalc(n, s, o, i, c, l, d, u, a[r], a[r + 1], a[0], a[1])
    };
    const r = 2,
        u = 1e-6;
    e.rayIntersect = function(t, n, s, o, i, a, c, l) {
        const h = s - t,
            p = o - n,
            g = c - i,
            m = l - a,
            d = h * m - p * g;
        if (d === 0) return r;
        const f = ((n - o) * (c - t) + h * (l - n)) / d;
        return 0 < f && f < 1 + u ? (m * (c - t) + (i - c) * (l - n)) / d : r
    }, e.rayIntersectExtended = function(n, s, o, i, a, r, c, l, d) {
        const u = (c - a) * d,
            h = (l - r) * d;
        return e.rayIntersect(n, s, o, i, a - u, r - h, c + u, l + h)
    }, e.isPointInTriangleInclusive = function(t, n, s, o, i, a, r, c) {
        const l = i - s,
            d = a - o,
            u = r - s,
            h = c - o,
            g = t - s,
            p = n - o,
            f = l * l + d * d,
            m = l * u + d * h,
            v = l * g + d * p,
            b = u * u + h * h,
            j = u * g + h * p,
            y = 1 / (f * b - m * m),
            _ = (b * v - m * j) * y,
            w = (f * j - m * v) * y;
        return _ >= 0 && w >= 0 && _ + w <= 1
    }, e.triangleCartesianToBarycentric = function(t, n, s, o, i, a, r, c) {
        const l = i - s,
            d = a - o,
            u = r - s,
            h = c - o,
            g = t - s,
            p = n - o,
            f = l * l + d * d,
            m = l * u + d * h,
            v = u * u + h * h,
            b = g * l + p * d,
            j = g * u + p * h,
            y = f * v - m * m,
            _ = (v * b - m * j) / y,
            w = (f * j - m * b) / y,
            O = 1 - _ - w;
        return [O, _, w]
    }, e.triangleBarycentricToCartesian = function(t, n, s, o, i, a, r, c, l) {
        return [t * o + n * a + s * c, t * i + n * r + s * l]
    }
}
"use strict";
{
    const e = self.C3;
    let o = null,
        t = "";
    if (typeof document != "undefined") {
        o = document;
        const e = document.querySelector("base");
        t = e && e.hasAttribute("href") ? e.getAttribute("href") : "", t && (t.startsWith("/") && (t = t.substr(1)), t.endsWith("/") || (t += "/"))
    }
    e.GetBaseHref = function() {
        return t
    }, e.GetBaseURL = function() {
        if (!o) return "";
        const s = o.location;
        return e.GetPathFromURL(s.origin + s.pathname) + t
    }, e.GetPathFromURL = function(t) {
        if (!t.length) return t;
        if (t.endsWith("/") || t.endsWith("\\")) return t;
        const n = Math.max(t.lastIndexOf("/"), t.lastIndexOf("\\"));
        return n === -1 ? "" : t.substr(0, n + 1)
    }, e.GetFilenameFromURL = function(t) {
        if (!t.length) return t;
        if (t.endsWith("/") || t.endsWith("\\")) return "";
        const n = Math.max(t.lastIndexOf("/"), t.lastIndexOf("\\"));
        return n === -1 ? t : t.substr(n + 1)
    }, e.DataTransferHasFiles = function(t) {
        if (t.types)
            for (let e = 0; e < t.types.length; e++)
                if (t.types[e] === "Files" || t.types[e] === "application/x-c3-file") return !0;
        return !1
    }, e.DataTransferFilterFiles = async function(n, s) {
        const o = Array.from(n.files).filter(e => e.size !== 0).filter(e => s(e)).map(async t => {
                try {
                    return await e.CloneFile(t)
                } catch {
                    return null
                }
            }),
            i = await Promise.all(o);
        return i.filter(e => e)
    }, e.IsFileAnImage = function(n) {
        if (n.type) return n.type.search(/image\/.*/) !== -1;
        const s = e.MimeType.GetForFileExtension(e.GetFileExtension(n.name)).GetString();
        return s.search(/image\/.*/) !== -1
    }, e.IsFileAnSVG = function(t) {
        return t.type === "image/svg+xml"
    }, e.IsFileAMultiImageContainer = function(n) {
        return n.type ? e.MimeType.Get(n.type).IsAnimatedImage() : e.MimeType.GetForFileExtension(e.GetFileExtension(n.name)).IsAnimatedImage()
    }, e.GetFileExtension = function(t) {
        let n = t.lastIndexOf(".");
        return n < 1 ? "" : t.substr(n)
    }, e.GetFileNamePart = function(t) {
        let n = t.lastIndexOf(".");
        return n < 1 ? t : t.substr(0, n)
    }, e.NormalizeFileSeparator = function(t) {
        return t.replace(/\\/g, "/")
    }, e.ParseFilePath = function(n) {
        n = e.NormalizeFileSeparator(n);
        let o = /^\w:\//.exec(n);
        o ? (o = o[0], n = n.slice(3), n[0] !== "/" && (n = "/" + n)) : o = "", n = n.replace(/\/{2,}/g, "/"), n.length > 1 && n.slice(-1) === "/" && (n = n.slice(0, -1));
        const i = n.lastIndexOf("/") + 1;
        let a = "",
            s = n,
            r, c = "";
        i > 0 && (a = n.slice(0, i), s = n.slice(i)), r = s;
        const l = s.lastIndexOf(".");
        l > 0 && (c = s.slice(l), r = s.slice(0, -c.length));
        const d = o + a + s;
        return {
            dir: a,
            base: s,
            name: r,
            root: o,
            ext: c,
            full: d
        }
    }, e.Wait = function(t, n) {
        return new Promise((e) => {
            self.setTimeout(e, t, n)
        })
    }, e.swallowException = function(n) {
        try {
            n()
        } catch (t) {
            e.isDebug && console.warn("Swallowed exception: ", t)
        }
    }, e.noop = function() {}, e.equalsNoCase = function(t, n) {
        return typeof t == "string" && typeof n == "string" && (t === n || (t = t.normalize(), n = n.normalize(), t.length === n.length && t.toLowerCase() === n.toLowerCase()))
    }, e.equalsCase = function(t, n) {
        return typeof t == "string" && typeof n == "string" && (t === n || t.normalize() === n.normalize())
    }, e.typedArraySet16 = function(t, n, s) {
        t[s++] = n[0], t[s++] = n[1], t[s++] = n[2], t[s++] = n[3], t[s++] = n[4], t[s++] = n[5], t[s++] = n[6], t[s++] = n[7], t[s++] = n[8], t[s++] = n[9], t[s++] = n[10], t[s++] = n[11], t[s++] = n[12], t[s++] = n[13], t[s++] = n[14], t[s] = n[15]
    }, e.truncateArray = function(t, n) {
        t.length = n
    }, e.clearArray = function(n) {
        if (!n) return;
        if (n.length === 0) return;
        e.truncateArray(n, 0)
    }, e.clear2DArray = function(n) {
        if (!n) return;
        for (let t = 0; t < n.length; t++) {
            let s = n[t];
            e.truncateArray(s, 0)
        }
        e.truncateArray(n, 0)
    }, e.extendArray = function(t, n, s) {
        n = n | 0;
        const o = t.length;
        if (n <= o) return;
        for (let e = o; e < n; ++e) t.push(s)
    }, e.resizeArray = function(n, s, o) {
        s = s | 0;
        const i = n.length;
        s < i ? e.truncateArray(n, s) : s > i && e.extendArray(n, s, o)
    }, e.shallowAssignArray = function(n, s) {
        e.clearArray(n), e.appendArray(n, s)
    }, e.appendArray = function(t, n) {
        if (n.length < 1e4) t.push(...n);
        else
            for (let e = 0, s = n.length; e < s; ++e) t.push(n[e])
    }, e.arrayRemove = function(t, n) {
        if (n = Math.floor(n), n < 0 || n >= t.length) return;
        let s = t.length - 1;
        for (let e = n; e < s; ++e) t[e] = t[e + 1];
        e.truncateArray(t, s)
    }, e.arrayFindRemove = function(t, n) {
        let s = t.indexOf(n);
        s >= 0 && t.splice(s, 1)
    }, e.arraysEqual = function(t, n) {
        let s = t.length;
        if (n.length !== s) return !1;
        for (let e = 0; e < s; ++e)
            if (t[e] !== n[e]) return !1;
        return !0
    }, e.arrayFilterOut = function(n, s) {
        let i = [],
            o = 0;
        for (let e = 0, a = n.length; e < a; ++e) {
            let t = n[e];
            s(t) ? i.push(t) : (n[o] = t, ++o)
        }
        return e.truncateArray(n, o), i
    }, e.arrayRemoveAllInSet = function(n, s) {
        const i = n.length;
        let o = 0;
        for (let e = 0, i = n.length; e < i; ++e) {
            let t = n[e];
            s.has(t) || (n[o++] = t)
        }
        return e.truncateArray(n, o), i - o
    }, e.isArrayIndexInBounds = function(t, n) {
        return t === Math.floor(t) && t >= 0 && t < n.length
    }, e.validateArrayIndex = function(n, s) {
        if (!e.isArrayIndexInBounds(n, s)) throw new RangeError("array index out of bounds")
    }, e.cloneArray = function(t) {
        return t.slice()
    }, e.deepCloneArray = function(n, s) {
        let o = [];
        for (let t of n)
            if (e.IsObject(t)) {
                let e = s(t);
                if (!e) throw new Error("missing clone");
                if (e.constructor !== t.constructor) throw new Error("object is not a clone");
                o.push(e)
            } else e.IsArray(t) ? o.push(e.deepCloneArray(t, s)) : o.push(t);
        return o
    }, e.clone2DArray = function(t) {
        let n = [];
        for (let e of t) n.push(e.slice());
        return n
    }, e.mergeSets = function(t, n) {
        return new Set([...t, ...n])
    }, e.mergeSetsInPlace = function(t, n) {
        for (const e of n) t.add(e);
        return t
    }, e.first = function(t) {
        for (let e of t) return e;
        return null
    }, e.xor = function(e, t) {
        return !e !== !t
    }, e.compare = function(t, n, s) {
        switch (n) {
            case 0:
                return t === s;
            case 1:
                return t !== s;
            case 2:
                return t < s;
            case 3:
                return t <= s;
            case 4:
                return t > s;
            case 5:
                return t >= s;
            default:
                return !1
        }
    }, e.hasAnyOwnProperty = function(t) {
        for (let e in t)
            if (t.hasOwnProperty(e)) return !0;
        return !1
    }, e.PromiseAllWithProgress = function(t, n) {
        return t.length ? new Promise((e, s) => {
            const o = [];
            let i = 0,
                a = !1;
            for (let r = 0, c = t.length; r < c; ++r) o.push(void 0), t[r].then(s => {
                if (a) return;
                o[r] = s, ++i, i === t.length ? e(o) : n(i, t.length)
            }).catch(e => {
                a = !0, s(e)
            })
        }) : Promise.resolve([])
    };
    let i = [];
    e.AddLibraryMemoryCallback = function(t) {
        i.push(t)
    }, e.GetEstimatedLibraryMemoryUsage = function() {
        let t = 0;
        for (let e of i) {
            let n = e();
            t += n
        }
        return Math.floor(t)
    };
    let r = 1;
    const s = new Map,
        a = new MessageChannel;
    a.port2.onmessage = function(t) {
        const n = t.data,
            o = s.get(n);
        s.delete(n), o && o(t.timeStamp)
    }, e.RequestUnlimitedAnimationFrame = function(t) {
        const n = r++;
        return s.set(n, t), a.port1.postMessage(n), n
    }, e.CancelUnlimitedAnimationFrame = function(t) {
        s.delete(t)
    }, e.PostTask = e.RequestUnlimitedAnimationFrame, e.WaitForNextTask = function() {
        return new Promise(t => e.PostTask(t))
    };
    const n = new Set;
    e.RequestPostAnimationFrame = function(s) {
        const o = self.requestAnimationFrame(async t => {
            if (await e.WaitForNextTask(), !n.has(o)) return;
            n.delete(o), s(t)
        });
        return n.add(o), o
    }, e.CancelPostAnimationFrame = function(t) {
        if (!n.has(t)) return;
        self.cancelAnimationFrame(t), n.delete(t)
    }
}
"use strict";
{
    const e = self.C3;
    e.IsAbsoluteURL = function(t) {
        return /^(?:[a-z]+:)?\/\//.test(t) || t.substr(0, 5) === "data:" || t.substr(0, 5) === "blob:"
    }, e.IsRelativeURL = function(n) {
        return !e.IsAbsoluteURL(n)
    }, e.ThrowIfNotOk = function(t) {
        if (!t.ok) throw new Error(`fetch '${t.url}' response returned ${t.status} ${t.statusText}`)
    }, e.FetchOk = function(n, s) {
        return fetch(n, s).then(t => (e.ThrowIfNotOk(t), t))
    }, e.FetchText = function(n) {
        return e.FetchOk(n).then(e => e.text())
    }, e.FetchJson = function(n) {
        return e.FetchOk(n).then(e => e.json())
    }, e.FetchBlob = function(n) {
        return e.FetchOk(n).then(e => e.blob())
    }, e.FetchArrayBuffer = function(n) {
        return e.FetchOk(n).then(e => e.arrayBuffer())
    }, e.FetchImage = function(t) {
        return new Promise((e, n) => {
            const s = new Image;
            s.onload = () => e(s), s.onerror = e => n(e), s.src = t
        })
    }, e.BlobToArrayBuffer = function(t) {
        return typeof t.arrayBuffer == "function" ? t.arrayBuffer() : new Promise((e, n) => {
            const s = new FileReader;
            s.onload = () => e(s.result), s.onerror = () => n(s.error), s.readAsArrayBuffer(t)
        })
    }, e.BlobToString = function(t) {
        return typeof t.text == "function" ? t.text() : new Promise((e, n) => {
            const s = new FileReader;
            s.onload = () => e(s.result), s.onerror = () => n(s.error), s.readAsText(t)
        })
    }, e.BlobToJson = function(n) {
        return e.BlobToString(n).then(e => JSON.parse(e))
    }, e.BlobToImage = async function(n, s) {
        let o = URL.createObjectURL(n);
        try {
            const t = await e.FetchImage(o);
            return URL.revokeObjectURL(o), o = "", s && typeof t.decode == "function" && await t.decode(), t
        } finally {
            o && URL.revokeObjectURL(o)
        }
    }, e.CreateCanvas = function(t, n) {
        if (typeof document != "undefined" && typeof document.createElement == "function") {
            const e = document.createElement("canvas");
            return e.width = t, e.height = n, e
        }
        return new OffscreenCanvas(t, n)
    }, e.CanvasToBlob = function(n, s, o) {
        return typeof o != "number" && (o = 1), s = s || "image/png", o = e.clamp(o, 0, 1), n.toBlob ? new Promise(e => n.toBlob(e, s, o)) : n.convertToBlob ? n.convertToBlob({
            type: s,
            quality: o
        }) : e.Asyncify(() => e.CanvasToBlobSync(n, s, o))
    }, e.CanvasToBlobSync = function(n, s, o) {
        return typeof o != "number" && (o = 1), s = s || "image/png", o = e.clamp(o, 0, 1), e.DataURIToBinaryBlobSync(n.toDataURL(s, o))
    }, e.DataURIToBinaryBlobSync = function(n) {
        const s = e.ParseDataURI(n);
        return e.BinaryStringToBlob(s.data, s.mime_type)
    }, e.ParseDataURI = function(t) {
        if (t.substr(0, 5) !== "data:") throw new URIError("expected data: uri");
        let n = t.indexOf(",");
        if (n < 0) throw new URIError("expected comma in data: uri");
        let a = t.substring(5, n),
            i = t.substring(n + 1),
            s = a.split(";"),
            r = s[0] || "",
            c = s[1],
            l = s[2],
            o;
        return c === "base64" || l === "base64" ? o = atob(i) : o = decodeURIComponent(i), {
            mime_type: r,
            data: o
        }
    }, e.BinaryStringToBlob = function(t, n) {
        let a = t.length,
            r = a >> 2,
            o = new Uint8Array(a),
            c = new Uint32Array(o.buffer, 0, r),
            i, s;
        for (i = 0, s = 0; i < r; ++i) c[i] = t.charCodeAt(s++) | t.charCodeAt(s++) << 8 | t.charCodeAt(s++) << 16 | t.charCodeAt(s++) << 24;
        let l = a & 3;
        for (; l--;) o[s] = t.charCodeAt(s), ++s;
        return n ? new Blob([o], {
            type: n
        }) : new Blob([o])
    }, e.DrawableToBlob = function(n, s, o) {
        const i = e.CreateCanvas(n.width, n.height),
            a = i.getContext("2d");
        return a.drawImage(n, 0, 0), e.CanvasToBlob(i, s, o)
    }, e.ImageDataToBlobSync = function(n, s, o) {
        const i = e.CreateCanvas(n.width, n.height),
            a = i.getContext("2d");
        return a.putImageData(n, 0, 0), e.CanvasToBlobSync(i, s, o)
    }, e.ImageDataToBlob = function(n, s, o) {
        if (e.Supports.ImageBitmapOptions) return createImageBitmap(n, {
            premultiplyAlpha: "none"
        }).then(t => e.DrawableToBlob(t, s, o));
        if (e.Supports.ImageBitmap) return createImageBitmap(n).then(t => e.DrawableToBlob(t, s, o));
        const i = e.CreateCanvas(n.width, n.height),
            a = i.getContext("2d");
        return a.putImageData(n, 0, 0), e.CanvasToBlob(i, s, o)
    }, e.CopySet = function(t, n) {
        t.clear();
        for (const e of n) t.add(e)
    }, e.MapToObject = function(t) {
        const n = Object.create(null);
        for (const [e, s] of t.entries()) n[e] = s;
        return n
    }, e.ObjectToMap = function(t, n) {
        n.clear();
        for (const [e, s] of Object.entries(t)) n.set(e, s)
    }, e.ToSuperJSON = function e(t) {
        if (typeof t == "object" && t !== null)
            if (t instanceof Set) return {
                _c3type_: "set",
                data: [...t].map(t => e(t))
            };
            else if (t instanceof Map) return {
            _c3type_: "map",
            data: [...t].map(t => [t[0], e(t[1])])
        };
        else {
            const n = Object.create(null);
            for (const [s, o] of Object.entries(t)) n[s] = e(o);
            return n
        }
        return t
    }, e.FromSuperJSON = function e(t) {
        if (typeof t == "object" & t !== null)
            if (t._c3type_ === "set") return new Set(t.data.map(t => e(t)));
            else if (t._c3type_ === "map") return new Map(t.data.map(t => [t[0], e(t[1])]));
        else {
            const n = Object.create(null);
            for (const [s, o] of Object.entries(t)) n[s] = e(o);
            return n
        }
        return t
    }, e.CSSToCamelCase = function(e) {
        let t = "",
            n = !1;
        for (const s of e) s === "-" ? n = !0 : n ? (t += s.toUpperCase(), n = !1) : t += s;
        return t
    }, e.IsIterator = function(e) {
        return typeof e == "object" && typeof e.next == "function"
    }, e.MakeFilledArray = function(t, n) {
        const s = [];
        if (typeof n == "function")
            for (let e = 0; e < t; ++e) s.push(n());
        else
            for (let e = 0; e < t; ++e) s.push(n);
        return s
    }
}
"use strict";
{
    const e = self.C3,
        t = /([0-9.]+),([0-9.]+)%?,([0-9.]+)%?/i,
        n = /([0-9.]+),([0-9.]+)%?,([0-9.]+)%?,([0-9.])/i;

    function padTwoDigits(e) {
        return e.length === 0 ? "00" : e.length === 1 ? "0" + e : e
    }

    function hueToRGB(e, t, n) {
        return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
    }
    e.Color = class Color {
        constructor(t, n, s, o) {
            this._r = NaN, this._g = NaN, this._b = NaN, this._a = NaN, this._r = 0, this._g = 0, this._b = 0, this._a = 0, t instanceof e.Color ? this.set(t) : this.setRgba(t || 0, n || 0, s || 0, o || 0)
        }
        setRgb(e, t, n) {
            return this._r = +e, this._g = +t, this._b = +n, this.clamp(), this
        }
        setRgba(e, t, n, s) {
            return this._r = +e, this._g = +t, this._b = +n, this._a = +s, this.clamp(), this
        }
        set(e) {
            return this._r = e._r, this._g = e._g, this._b = e._b, this._a = e._a, this
        }
        copy(e) {
            return this.set(e)
        }
        add(e) {
            this._r += e._r, this._g += e._g, this._b += e._b, this._a += e._a, this.clamp()
        }
        addRgb(e, t, n, s = 0) {
            this._r += +e, this._g += +t, this._b += +n, this._a += +s, this.clamp()
        }
        diff(e) {
            this.setR(Math.max(this._r, e._r) - Math.min(this._r, e._r)), this.setG(Math.max(this._g, e._g) - Math.min(this._g, e._g)), this.setB(Math.max(this._b, e._b) - Math.min(this._b, e._b)), this.setA(Math.max(this._a, e._a) - Math.min(this._a, e._a)), this.clamp()
        }
        copyRgb(e) {
            this._r = e._r, this._g = e._g, this._b = e._b
        }
        setR(t) {
            this._r = e.clamp(+t, 0, 1)
        }
        getR() {
            return this._r
        }
        setG(t) {
            this._g = e.clamp(+t, 0, 1)
        }
        getG() {
            return this._g
        }
        setB(t) {
            this._b = e.clamp(+t, 0, 1)
        }
        getB() {
            return this._b
        }
        setA(t) {
            this._a = e.clamp(+t, 0, 1)
        }
        getA() {
            return this._a
        }
        clone() {
            return e.New(e.Color, this._r, this._g, this._b, this._a)
        }
        toArray() {
            return [this._r, this._g, this._b, this._a]
        }
        toTypedArray() {
            return new Float64Array(this.toArray())
        }
        writeToTypedArray(e, t) {
            e[t++] = this._r, e[t++] = this._g, e[t++] = this._b, e[t] = this._a
        }
        equals(e) {
            return this._r === e._r && this._g === e._g && this._b === e._b && this._a === e._a
        }
        equalsIgnoringAlpha(e) {
            return this._r === e._r && this._g === e._g && this._b === e._b
        }
        equalsRgb(e, t, n) {
            return this._r === e && this._g === t && this._b === n
        }
        equalsRgba(e, t, n, s) {
            return this._r === e && this._g === t && this._b === n && this._a === s
        }
        multiply(e) {
            this._r *= e._r, this._g *= e._g, this._b *= e._b, this._a *= e._a
        }
        multiplyAlpha(e) {
            this._r *= e, this._g *= e, this._b *= e, this._a *= e
        }
        premultiply() {
            return this._r *= this._a, this._g *= this._a, this._b *= this._a, this
        }
        unpremultiply() {
            return this._r /= this._a, this._g /= this._a, this._b /= this._a, this
        }
        clamp() {
            return this._r = e.clamp(this._r, 0, 1), this._g = e.clamp(this._g, 0, 1), this._b = e.clamp(this._b, 0, 1), this._a = e.clamp(this._a, 0, 1), this
        }
        setFromRgbValue(t) {
            this._r = e.GetRValue(t), this._g = e.GetGValue(t), this._b = e.GetBValue(t), this._a = e.GetAValue(t)
        }
        getCssRgb(t, n, s) {
            const o = e.IsFiniteNumber(t) ? t : this.getR(),
                i = e.IsFiniteNumber(n) ? n : this.getG(),
                a = e.IsFiniteNumber(s) ? s : this.getB();
            return `rgb(${o*100}%, ${i*100}%, ${a*100}%)`
        }
        getCssRgba(t, n, s, o) {
            const i = e.IsFiniteNumber(t) ? t : this.getR(),
                a = e.IsFiniteNumber(n) ? n : this.getG(),
                r = e.IsFiniteNumber(s) ? s : this.getB(),
                c = e.IsFiniteNumber(o) ? o : this.getA();
            return `rgba(${i*100}%, ${a*100}%, ${r*100}%, ${c})`
        }
        toHexString() {
            const e = Math.round(this.getR() * 255),
                t = Math.round(this.getG() * 255),
                n = Math.round(this.getB() * 255);
            return "#" + padTwoDigits(e.toString(16)) + padTwoDigits(t.toString(16)) + padTwoDigits(n.toString(16))
        }
        parseHexString(e) {
            if (typeof e != "string") return !1;
            e = e.trim(), e.charAt(0) === "#" && (e = e.substr(1));
            let t, n, s;
            if (e.length === 3) t = parseInt(e[0], 16) / 15, n = parseInt(e[1], 16) / 15, s = parseInt(e[2], 16) / 15;
            else if (e.length === 6) t = parseInt(e.substr(0, 2), 16) / 255, n = parseInt(e.substr(2, 2), 16) / 255, s = parseInt(e.substr(4, 2), 16) / 255;
            else return !1;
            return isFinite(t) && this.setR(t), isFinite(n) && this.setG(n), isFinite(s) && this.setB(s), this.setA(1), !0
        }
        toCommaSeparatedRgb() {
            const e = Math.round(this.getR() * 255),
                t = Math.round(this.getG() * 255),
                n = Math.round(this.getB() * 255);
            return `${e}, ${t}, ${n}`
        }
        toRgbArray() {
            const e = Math.round(this.getR() * 255),
                t = Math.round(this.getG() * 255),
                n = Math.round(this.getB() * 255);
            return [e, t, n]
        }
        parseCommaSeparatedRgb(e) {
            if (typeof e != "string") return !1;
            e = e.replace(/^rgb\(|\)|%/, "");
            const t = e.split(",");
            if (t.length < 3) return !1;
            const n = parseInt(t[0].trim(), 10) / 255,
                s = parseInt(t[1].trim(), 10) / 255,
                o = parseInt(t[2].trim(), 10) / 255;
            return isFinite(n) && this.setR(n), isFinite(s) && this.setG(s), isFinite(o) && this.setB(o), this.setA(1), !0
        }
        parseCommaSeparatedPercentageRgb(e) {
            if (typeof e != "string") return !1;
            e = e.replace(/^rgb\(|\)|%/, "");
            const t = e.split(",");
            if (t.length < 3) return !1;
            const n = parseInt(t[0].trim(), 10) / 100,
                s = parseInt(t[1].trim(), 10) / 100,
                o = parseInt(t[2].trim(), 10) / 100;
            return isFinite(n) && this.setR(n), isFinite(s) && this.setG(s), isFinite(o) && this.setB(o), this.setA(1), !0
        }
        parseCommaSeparatedRgba(e) {
            if (typeof e != "string") return !1;
            e = e.replace(/^rgba\(|\)|%/, "");
            const t = e.split(",");
            if (t.length < 4) return !1;
            const n = parseInt(t[0].trim(), 10) / 255,
                s = parseInt(t[1].trim(), 10) / 255,
                o = parseInt(t[2].trim(), 10) / 255,
                i = parseFloat(t[3].trim());
            return isFinite(n) && this.setR(n), isFinite(s) && this.setG(s), isFinite(o) && this.setB(o), isFinite(i) && this.setA(i), !0
        }
        parseCommaSeparatedPercentageRgba(e) {
            if (typeof e != "string") return !1;
            e = e.replace(/^rgba\(|\)|%/, "");
            const t = e.split(",");
            if (t.length < 4) return !1;
            const n = parseInt(t[0].trim(), 10) / 100,
                s = parseInt(t[1].trim(), 10) / 100,
                o = parseInt(t[2].trim(), 10) / 100,
                i = parseFloat(t[3].trim());
            return isFinite(n) && this.setR(n), isFinite(s) && this.setG(s), isFinite(o) && this.setB(o), isFinite(i) && this.setA(i), !0
        }
        parseString(e) {
            if (typeof e != "string") return !1;
            if (e = e.replace(/\s+/, ""), e.includes(","))
                if (e.startsWith("rgb(")) return e.includes("%") ? this.parseCommaSeparatedPercentageRgb(e) : this.parseCommaSeparatedRgb(e);
                else if (e.startsWith("rgba(")) return e.includes("%") ? this.parseCommaSeparatedPercentageRgba(e) : this.parseCommaSeparatedRgba(e);
            else if (e.startsWith("hsl(") || e.startsWith("hsla(")) return this.parseHSLString(e);
            else {
                const t = e.split(",");
                return e.includes("%") ? t.length === 3 ? this.parseCommaSeparatedPercentageRgb(e) : t.length === 4 && this.parseCommaSeparatedPercentageRgba(e) : t.length === 3 ? this.parseCommaSeparatedRgb(e) : t.length === 4 && this.parseCommaSeparatedRgba(e)
            } else return this.parseHexString(e)
        }
        toJSON() {
            return [this._r, this._g, this._b, this._a]
        }
        setFromHSLA(t, n, s, o) {
            let i, a, r;
            if (t %= 360, n = e.clamp(n, 0, 100), s = e.clamp(s, 0, 100), o = e.clamp(o, 0, 1), t /= 360, n /= 100, s /= 100, n === 0) i = a = r = s;
            else {
                const e = s < .5 ? s * (1 + n) : s + n - s * n,
                    o = 2 * s - e;
                i = hueToRGB(o, e, t + 1 / 3), a = hueToRGB(o, e, t), r = hueToRGB(o, e, t - 1 / 3)
            }
            return this.setR(i), this.setG(a), this.setB(r), this.setA(o), this
        }
        parseHSLString(e) {
            const o = e.replace(/ |hsl|hsla|\(|\)|;/gi, ""),
                s = t.exec(o),
                i = n.exec(o);
            return s && s.length === 4 ? (this.setFromHSLA(+s[1], +s[2], +s[3], 1), !0) : !!(i && i.length === 5) && (this.setFromHSLA(+s[1], +s[2], +s[3], +s[4]), !0)
        }
        toHSLAString() {
            const t = this._r,
                n = this._g,
                s = this._b,
                o = this._a,
                i = e.Color.GetHue(t, n, s),
                a = e.Color.GetSaturation(t, n, s),
                r = e.Color.GetLuminosity(t, n, s);
            return `hsla(${i}, ${a}%, ${r}%, ${o})`
        }
        toHSLAArray() {
            const t = this._r,
                n = this._g,
                s = this._b;
            return [e.Color.GetHue(t, n, s), e.Color.GetSaturation(t, n, s), e.Color.GetLuminosity(t, n, s), this._a]
        }
        setFromJSON(e) {
            if (!Array.isArray(e)) return;
            if (e.length < 3) return;
            this._r = e[0], this._g = e[1], this._b = e[2], e.length >= 4 ? this._a = e[3] : this._a = 1
        }
        set r(e) {
            this.setR(e)
        }
        get r() {
            return this.getR()
        }
        set g(e) {
            this.setG(e)
        }
        get g() {
            return this.getG()
        }
        set b(e) {
            this.setB(e)
        }
        get b() {
            return this.getB()
        }
        set a(e) {
            this.setA(e)
        }
        get a() {
            return this.getA()
        }
        setAtIndex(e, t) {
            switch (e) {
                case 0:
                    this.setR(t);
                    break;
                case 1:
                    this.setG(t);
                    break;
                case 2:
                    this.setB(t);
                    break;
                case 3:
                    this.setA(t);
                    break;
                default:
                    throw new RangeError("invalid color index")
            }
        }
        getAtIndex(e) {
            switch (e) {
                case 0:
                    return this.getR();
                case 1:
                    return this.getG();
                case 2:
                    return this.getB();
                case 3:
                    return this.getA();
                default:
                    throw new RangeError("invalid color index")
            }
        }
        static DiffChannel(t, n) {
            return e.clamp(Math.max(t, n) - Math.min(t, n), 0, 1)
        }
        static Diff(t, n) {
            const s = new e.Color;
            return s.setR(Math.max(t._r, n._r) - Math.min(t._r, n._r)), s.setG(Math.max(t._g, n._g) - Math.min(t._g, n._g)), s.setB(Math.max(t._b, n._b) - Math.min(t._b, n._b)), s.setA(Math.max(t._a, n._a) - Math.min(t._a, n._a)), s
        }
        static DiffNoAlpha(t, n) {
            const s = new e.Color(0, 0, 0, 1);
            return s.setR(Math.max(t._r, n._r) - Math.min(t._r, n._r)), s.setG(Math.max(t._g, n._g) - Math.min(t._g, n._g)), s.setB(Math.max(t._b, n._b) - Math.min(t._b, n._b)), s
        }
        static GetHue(e, t, n) {
            const s = Math.max(e, t, n),
                o = Math.min(e, t, n);
            if (s === o) return 0;
            let i = 0;
            switch (s) {
                case e:
                    i = (t - n) / (s - o) + (t < n ? 6 : 0);
                    break;
                case t:
                    i = (n - e) / (s - o) + 2;
                    break;
                case n:
                    i = (e - t) / (s - o) + 4;
                    break
            }
            return Math.round(i / 6 * 360)
        }
        static GetSaturation(e, t, n) {
            const s = Math.max(e, t, n),
                o = Math.min(e, t, n);
            if (s === o) return 0;
            const a = (s + o) / 2,
                i = s - o,
                r = a > .5 ? i / (2 - s - o) : i / (s + o);
            return Math.round(r * 100)
        }
        static GetLuminosity(e, t, n) {
            const s = Math.max(e, t, n),
                o = Math.min(e, t, n),
                i = (s + o) / 2;
            return s ? Math.round(i * 100) : 0
        }
    }, e.Color.White = Object.freeze(e.New(e.Color, 1, 1, 1, 1)), e.Color.Black = Object.freeze(e.New(e.Color, 0, 0, 0, 1)), e.Color.TransparentBlack = Object.freeze(e.New(e.Color, 0, 0, 0, 0))
}
"use strict";
{
    const e = self.C3;
    e.Vector2 = class Vector2 {
        constructor(t, n) {
            this._x = 0, this._y = 0, t instanceof e.Vector2 ? this.copy(t) : this.set(t || 0, n || 0)
        }
        set(e, t) {
            this._x = +e, this._y = +t
        }
        copy(e) {
            this._x = e._x, this._y = e._y
        }
        equals(e) {
            return this._x === e._x && this._y === e._y
        }
        setX(e) {
            this._x = +e
        }
        getX() {
            return this._x
        }
        setY(e) {
            this._y = +e
        }
        getY() {
            return this._y
        }
        toArray() {
            return [this._x, this._y]
        }
        toTypedArray() {
            return new Float64Array(this.toArray())
        }
        writeToTypedArray(e, t) {
            e[t++] = this._x, e[t] = this._y
        }
        offset(e, t) {
            this._x += +e, this._y += +t
        }
        scale(e, t) {
            this._x *= e, this._y *= t
        }
        divide(e, t) {
            this._x /= e, this._y /= t
        }
        round() {
            this._x = Math.round(this._x), this._y = Math.round(this._y)
        }
        floor() {
            this._x = Math.floor(this._x), this._y = Math.floor(this._y)
        }
        ceil() {
            this._x = Math.ceil(this._x), this._y = Math.ceil(this._y)
        }
        angle() {
            return e.angleTo(0, 0, this._x, this._y)
        }
        lengthSquared() {
            return this._x * this._x + this._y * this._y
        }
        length() {
            return Math.sqrt(this.lengthSquared())
        }
        rotatePrecalc(e, t) {
            const n = this._x * t - this._y * e;
            this._y = this._y * t + this._x * e, this._x = n
        }
        rotate(e) {
            if (e === 0) return;
            this.rotatePrecalc(Math.sin(e), Math.cos(e))
        }
        rotateAbout(e, t, n) {
            if (e === 0 || t === this._x && n === this._y) return;
            this._x -= t, this._y -= n, this.rotatePrecalc(Math.sin(e), Math.cos(e)), this._x += +t, this._y += +n
        }
        move(e, t) {
            if (t === 0) return;
            this._x += Math.cos(e) * t, this._y += Math.sin(e) * t
        }
        normalize() {
            const e = this.length();
            e !== 0 && e !== 1 && (this._x /= e, this._y /= e)
        }
        clamp(t, n) {
            this._x = e.clamp(this._x, t, n), this._y = e.clamp(this._y, t, n)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Rect = class Rect {
        constructor(t, n, s, o) {
            this._left = NaN, this._top = NaN, this._right = NaN, this._bottom = NaN, this._left = 0, this._top = 0, this._right = 0, this._bottom = 0, t instanceof e.Rect ? this.copy(t) : this.set(t || 0, n || 0, s || 0, o || 0)
        }
        set(e, t, n, s) {
            this._left = +e, this._top = +t, this._right = +n, this._bottom = +s
        }
        setWH(e, t, n, s) {
            e = +e, t = +t, this._left = e, this._top = t, this._right = e + +n, this._bottom = t + +s
        }
        copy(e) {
            this._left = +e._left, this._top = +e._top, this._right = +e._right, this._bottom = +e._bottom
        }
        clone() {
            return new e.Rect(this._left, this._top, this._right, this._bottom)
        }
        static Merge(t, n) {
            const s = new e.Rect;
            return s.setLeft(Math.min(t._left, n._left)), s.setTop(Math.min(t._top, n._top)), s.setRight(Math.max(t._right, n._right)), s.setBottom(Math.max(t._bottom, n._bottom)), s
        }
        static FromObject(t) {
            return new e.Rect(t.left, t.top, t.right, t.bottom)
        }
        equals(e) {
            return this._left === e._left && this._top === e._top && this._right === e._right && this._bottom === e._bottom
        }
        setLeft(e) {
            this._left = +e
        }
        getLeft() {
            return this._left
        }
        setTop(e) {
            this._top = +e
        }
        getTop() {
            return this._top
        }
        setRight(e) {
            this._right = +e
        }
        getRight() {
            return this._right
        }
        setBottom(e) {
            this._bottom = +e
        }
        getBottom() {
            return this._bottom
        }
        toArray() {
            return [this._left, this._top, this._right, this._bottom]
        }
        toTypedArray() {
            return new Float64Array(this.toArray())
        }
        toDOMRect() {
            return new DOMRect(this._left, this._top, this.width(), this.height())
        }
        writeToTypedArray(e, t) {
            e[t++] = this._left, e[t++] = this._top, e[t++] = this._right, e[t] = this._bottom
        }
        writeAsQuadToTypedArray(e, t) {
            e[t++] = this._left, e[t++] = this._top, e[t++] = this._right, e[t++] = this._top, e[t++] = this._right, e[t++] = this._bottom, e[t++] = this._left, e[t] = this._bottom
        }
        width() {
            return this._right - this._left
        }
        height() {
            return this._bottom - this._top
        }
        midX() {
            return (this._left + this._right) / 2
        }
        midY() {
            return (this._top + this._bottom) / 2
        }
        offset(e, t) {
            e = +e, t = +t, this._left += e, this._top += t, this._right += e, this._bottom += t
        }
        offsetLeft(e) {
            this._left += +e
        }
        offsetTop(e) {
            this._top += +e
        }
        offsetRight(e) {
            this._right += +e
        }
        offsetBottom(e) {
            this._bottom += +e
        }
        toSquare(e) {
            if (e !== "x") throw new Error("invalid axis, only 'x' supported");
            this._top < this._bottom ? this._left < this._right ? this._bottom = this._top + this.width() : this._bottom = this._top - this.width() : this._left < this._right ? this._bottom = this._top - this.width() : this._bottom = this._top + this.width()
        }
        inflate(e, t) {
            e = +e, t = +t, this._left -= e, this._top -= t, this._right += e, this._bottom += t
        }
        deflate(e, t) {
            e = +e, t = +t, this._left += e, this._top += t, this._right -= e, this._bottom -= t
        }
        multiply(e, t) {
            this._left *= e, this._top *= t, this._right *= e, this._bottom *= t
        }
        divide(e, t) {
            this._left /= e, this._top /= t, this._right /= e, this._bottom /= t
        }
        mirrorAround(e) {
            this._left = +e - this._left, this._right = +e - this._right
        }
        flipAround(e) {
            this._top = +e - this._top, this._bottom = +e - this._bottom
        }
        swapLeftRight() {
            const e = this._left;
            this._left = this._right, this._right = e
        }
        swapTopBottom() {
            const e = this._top;
            this._top = this._bottom, this._bottom = e
        }
        shuntY(e) {
            const t = this._top;
            this._top = +e - this._bottom, this._bottom = +e - t
        }
        round() {
            this._left = Math.round(this._left), this._top = Math.round(this._top), this._right = Math.round(this._right), this._bottom = Math.round(this._bottom)
        }
        roundInner() {
            this._left = Math.ceil(this._left), this._top = Math.ceil(this._top), this._right = Math.floor(this._right), this._bottom = Math.floor(this._bottom)
        }
        roundOuter() {
            this._left = Math.floor(this._left), this._top = Math.floor(this._top), this._right = Math.ceil(this._right), this._bottom = Math.ceil(this._bottom)
        }
        floor() {
            this._left = Math.floor(this._left), this._top = Math.floor(this._top), this._right = Math.floor(this._right), this._bottom = Math.floor(this._bottom)
        }
        ceil() {
            this._left = Math.ceil(this._left), this._top = Math.ceil(this._top), this._right = Math.ceil(this._right), this._bottom = Math.ceil(this._bottom)
        }
        clamp(e, t, n, s) {
            this._left < e && (this._left = +e), this._top < t && (this._top = +t), this._right > n && (this._right = +n), this._bottom > s && (this._bottom = +s)
        }
        clampFlipped(e, t, n, s) {
            this._left < e && (this._left = +e), this._top > t && (this._top = +t), this._right > n && (this._right = +n), this._bottom < s && (this._bottom = +s)
        }
        normalize() {
            this._left > this._right && this.swapLeftRight(), this._top > this._bottom && this.swapTopBottom()
        }
        intersectsRect(e) {
            return !(e._right < this._left || e._bottom < this._top || e._left > this._right || e._top > this._bottom)
        }
        intersectsRectOffset(e, t, n) {
            return !(e._right + t < this._left || e._bottom + n < this._top || e._left + t > this._right || e._top + n > this._bottom)
        }
        containsPoint(e, t) {
            return e >= this._left && e <= this._right && t >= this._top && t <= this._bottom
        }
        containsRect(e) {
            return e._left >= this._left && e._top >= this._top && e._right <= this._right && e._bottom <= this._bottom
        }
        expandToContain(e) {
            e._left < this._left && (this._left = +e._left), e._top < this._top && (this._top = +e._top), e._right > this._right && (this._right = +e._right), e._bottom > this._bottom && (this._bottom = +e._bottom)
        }
        lerpInto(t) {
            this._left = e.lerp(t._left, t._right, this._left), this._top = e.lerp(t._top, t._bottom, this._top), this._right = e.lerp(t._left, t._right, this._right), this._bottom = e.lerp(t._top, t._bottom, this._bottom)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Quad = class Quad {
        constructor(t, n, s, o, i, a, r, c) {
            this._tlx = NaN, this._tly = NaN, this._trx = NaN, this._try = NaN, this._brx = NaN, this._bry = NaN, this._blx = NaN, this._bly = NaN, this._tlx = 0, this._tly = 0, this._trx = 0, this._try = 0, this._brx = 0, this._bry = 0, this._blx = 0, this._bly = 0, t instanceof e.Quad ? this.copy(t) : this.set(t || 0, n || 0, s || 0, o || 0, i || 0, a || 0, r || 0, c || 0)
        }
        set(e, t, n, s, o, i, a, r) {
            this._tlx = +e, this._tly = +t, this._trx = +n, this._try = +s, this._brx = +o, this._bry = +i, this._blx = +a, this._bly = +r
        }
        setRect(e, t, n, s) {
            this.set(e, t, n, t, n, s, e, s)
        }
        copy(e) {
            this._tlx = e._tlx, this._tly = e._tly, this._trx = e._trx, this._try = e._try, this._brx = e._brx, this._bry = e._bry, this._blx = e._blx, this._bly = e._bly
        }
        equals(e) {
            return this._tlx === e._tlx && this._tly === e._tly && this._trx === e._trx && this._try === e._try && this._brx === e._brx && this._bry === e._bry && this._blx === e._blx && this._bly === e._bly
        }
        setTlx(e) {
            this._tlx = +e
        }
        getTlx() {
            return this._tlx
        }
        setTly(e) {
            this._tly = +e
        }
        getTly() {
            return this._tly
        }
        setTrx(e) {
            this._trx = +e
        }
        getTrx() {
            return this._trx
        }
        setTry(e) {
            this._try = +e
        }
        getTry() {
            return this._try
        }
        setBrx(e) {
            this._brx = +e
        }
        getBrx() {
            return this._brx
        }
        setBry(e) {
            this._bry = +e
        }
        getBry() {
            return this._bry
        }
        setBlx(e) {
            this._blx = +e
        }
        getBlx() {
            return this._blx
        }
        setBly(e) {
            this._bly = +e
        }
        getBly() {
            return this._bly
        }
        toDOMQuad() {
            return new DOMQuad(new DOMPoint(this._tlx, this._tly), new DOMPoint(this._trx, this._try), new DOMPoint(this._brx, this._bry), new DOMPoint(this._blx, this._bly))
        }
        toArray() {
            return [this._tlx, this._tly, this._trx, this._try, this._brx, this._bry, this._blx, this._bly]
        }
        toTypedArray() {
            return new Float64Array(this.toArray())
        }
        writeToTypedArray(e, t) {
            e[t++] = this._tlx, e[t++] = this._tly, e[t++] = this._trx, e[t++] = this._try, e[t++] = this._brx, e[t++] = this._bry, e[t++] = this._blx, e[t] = this._bly
        }
        writeToTypedArray3D(e, t, n) {
            e[t++] = this._tlx, e[t++] = this._tly, e[t++] = n, e[t++] = this._trx, e[t++] = this._try, e[t++] = n, e[t++] = this._brx, e[t++] = this._bry, e[t++] = n, e[t++] = this._blx, e[t++] = this._bly, e[t] = n
        }
        offset(e, t) {
            e = +e, t = +t, this._tlx += e, this._tly += t, this._trx += e, this._try += t, this._brx += e, this._bry += t, this._blx += e, this._bly += t
        }
        round() {
            this._tlx = Math.round(this._tlx), this._tly = Math.round(this._tly), this._trx = Math.round(this._trx), this._try = Math.round(this._try), this._brx = Math.round(this._brx), this._bry = Math.round(this._bry), this._blx = Math.round(this._blx), this._bly = Math.round(this._bly)
        }
        floor() {
            this._tlx = Math.floor(this._tlx), this._tly = Math.floor(this._tly), this._trx = Math.floor(this._trx), this._try = Math.floor(this._try), this._brx = Math.floor(this._brx), this._bry = Math.floor(this._bry), this._blx = Math.floor(this._blx), this._bly = Math.floor(this._bly)
        }
        ceil() {
            this._tlx = Math.ceil(this._tlx), this._tly = Math.ceil(this._tly), this._trx = Math.ceil(this._trx), this._try = Math.ceil(this._try), this._brx = Math.ceil(this._brx), this._bry = Math.ceil(this._bry), this._blx = Math.ceil(this._blx), this._bly = Math.ceil(this._bly)
        }
        setFromRect(e) {
            this._tlx = e._left, this._tly = e._top, this._trx = e._right, this._try = e._top, this._brx = e._right, this._bry = e._bottom, this._blx = e._left, this._bly = e._bottom
        }
        setFromRotatedRect(e, t) {
            t === 0 ? this.setFromRect(e) : this.setFromRotatedRectPrecalc(e, Math.sin(t), Math.cos(t))
        }
        setFromRotatedRectPrecalc(e, t, n) {
            const s = e._left * t,
                o = e._top * t,
                i = e._right * t,
                a = e._bottom * t,
                r = e._left * n,
                c = e._top * n,
                l = e._right * n,
                d = e._bottom * n;
            this._tlx = r - o, this._tly = c + s, this._trx = l - o, this._try = c + i, this._brx = l - a, this._bry = d + i, this._blx = r - a, this._bly = d + s
        }
        getBoundingBox(e) {
            e.set(Math.min(this._tlx, this._trx, this._brx, this._blx), Math.min(this._tly, this._try, this._bry, this._bly), Math.max(this._tlx, this._trx, this._brx, this._blx), Math.max(this._tly, this._try, this._bry, this._bly))
        }
        containsPoint(e, t) {
            let n = this._trx - this._tlx,
                s = this._try - this._tly;
            const r = this._brx - this._tlx,
                a = this._bry - this._tly,
                f = e - this._tlx,
                p = t - this._tly;
            let i = n * n + s * s,
                o = n * r + s * a,
                c = n * f + s * p;
            const h = r * r + a * a,
                m = r * f + a * p;
            let l = 1 / (i * h - o * o),
                d = (h * c - o * m) * l,
                u = (i * m - o * c) * l;
            return d >= 0 && u > 0 && d + u < 1 || (n = this._blx - this._tlx, s = this._bly - this._tly, i = n * n + s * s, o = n * r + s * a, c = n * f + s * p, l = 1 / (i * h - o * o), d = (h * c - o * m) * l, u = (i * m - o * c) * l, d >= 0 && u > 0 && d + u < 1)
        }
        midX() {
            return (this._tlx + this._trx + this._brx + this._blx) / 4
        }
        midY() {
            return (this._tly + this._try + this._bry + this._bly) / 4
        }
        intersectsSegment(t, n, s, o) {
            return !!(this.containsPoint(t, n) || this.containsPoint(s, o)) || e.segmentIntersectsQuad(t, n, s, o, this)
        }
        intersectsQuad(t) {
            let n = t.midX(),
                s = t.midY();
            if (this.containsPoint(n, s)) return !0;
            if (n = this.midX(), s = this.midY(), t.containsPoint(n, s)) return !0;
            const o = this._tlx,
                i = this._tly,
                a = this._trx,
                r = this._try,
                c = this._brx,
                l = this._bry,
                d = this._blx,
                u = this._bly;
            return e.segmentIntersectsQuad(o, i, a, r, t) || e.segmentIntersectsQuad(a, r, c, l, t) || e.segmentIntersectsQuad(c, l, d, u, t) || e.segmentIntersectsQuad(d, u, o, i, t)
        }
        mirror() {
            this._swap(0, 2), this._swap(1, 3), this._swap(6, 4), this._swap(7, 5)
        }
        flip() {
            this._swap(0, 6), this._swap(1, 7), this._swap(2, 4), this._swap(3, 5)
        }
        diag() {
            this._swap(2, 6), this._swap(3, 7)
        }
        _swap(e, t) {
            const n = this._getAtIndex(e);
            this._setAtIndex(e, this._getAtIndex(t)), this._setAtIndex(t, n)
        }
        _getAtIndex(e) {
            switch (e) {
                case 0:
                    return this._tlx;
                case 1:
                    return this._tly;
                case 2:
                    return this._trx;
                case 3:
                    return this._try;
                case 4:
                    return this._brx;
                case 5:
                    return this._bry;
                case 6:
                    return this._blx;
                case 7:
                    return this._bly;
                default:
                    throw new RangeError("invalid quad point index")
            }
        }
        _setAtIndex(e, t) {
            switch (t = +t, e) {
                case 0:
                    this._tlx = t;
                    break;
                case 1:
                    this._tly = t;
                    break;
                case 2:
                    this._trx = t;
                    break;
                case 3:
                    this._try = t;
                    break;
                case 4:
                    this._brx = t;
                    break;
                case 5:
                    this._bry = t;
                    break;
                case 6:
                    this._blx = t;
                    break;
                case 7:
                    this._bly = t;
                    break;
                default:
                    throw new RangeError("invalid quad point index")
            }
        }
    }
}
"use strict";
{
    const e = self.C3,
        s = self.assert,
        n = [0, 0, 1, 0, 1, 1, 0, 1],
        t = e.New(e.Quad);
    e.CollisionPoly = class CollisionPoly extends e.DefendedBase {
        constructor(t, s = !0) {
            super(), t || (t = n), this._ptsArr = Float64Array.from(t), this._bbox = new e.Rect, this._isBboxChanged = !0, this._enabled = s
        }
        Release() {}
        pointsArr() {
            return this._ptsArr
        }
        pointCount() {
            return this._ptsArr.length / 2
        }
        setPoints(e) {
            this._ptsArr.length === e.length ? this._ptsArr.set(e) : this._ptsArr = Float64Array.from(e), this._isBboxChanged = !0
        }
        setDefaultPoints() {
            this.setPoints(n)
        }
        copy(e) {
            this.setPoints(e._ptsArr)
        }
        setBboxChanged() {
            this._isBboxChanged = !0
        }
        _updateBbox() {
            if (!this._isBboxChanged) return;
            const e = this._ptsArr;
            let t = e[0],
                n = e[1],
                s = t,
                o = n;
            for (let i = 0, c = e.length; i < c; i += 2) {
                const a = e[i],
                    r = e[i + 1];
                a < t && (t = a), a > s && (s = a), r < n && (n = r), r > o && (o = r)
            }
            this._bbox.set(t, n, s, o), this._isBboxChanged = !1
        }
        setFromRect(e, t, n) {
            let s = this._ptsArr;
            s.length !== 8 && (s = new Float64Array(8), this._ptsArr = s), s[0] = e.getLeft() - t, s[1] = e.getTop() - n, s[2] = e.getRight() - t, s[3] = e.getTop() - n, s[4] = e.getRight() - t, s[5] = e.getBottom() - n, s[6] = e.getLeft() - t, s[7] = e.getBottom() - n, this._bbox.copy(e), (t !== 0 || n !== 0) && this._bbox.offset(-t, -n), this._isBboxChanged = !1
        }
        setFromQuad(e, n, s) {
            t.copy(e), t.offset(n, s), this.setPoints(t.toArray()), this._isBboxChanged = !0
        }
        transform(e, t, n) {
            let s = 0,
                o = 1;
            n !== 0 && (s = Math.sin(n), o = Math.cos(n)), this.transformPrecalc(e, t, s, o)
        }
        transformPrecalc(e, t, n, s) {
            const o = this._ptsArr;
            for (let i = 0, l = o.length; i < l; i += 2) {
                const a = i + 1,
                    r = o[i] * e,
                    c = o[a] * t;
                o[i] = r * s - c * n, o[a] = c * s + r * n
            }
            this._isBboxChanged = !0
        }
        offset(e, t) {
            const n = this._ptsArr;
            for (let s = 0, o = n.length; s < o; s += 2) n[s] += e, n[s + 1] += t
        }
        containsPoint(t, n) {
            const s = this._ptsArr;
            if (t === s[0] && n === s[1]) return !0;
            this._updateBbox();
            const o = this._bbox,
                i = o.getLeft() - 110,
                a = o.getTop() - 101,
                r = o.getRight() + 131,
                c = o.getBottom() + 120;
            let l = 0,
                d = 0,
                u = 0,
                h = 0,
                m = 0,
                f = 0,
                p = 0,
                g = 0;
            i < t ? (l = i, u = t) : (l = t, u = i), a < n ? (d = a, h = n) : (d = n, h = a), r < t ? (m = r, p = t) : (m = t, p = r), c < n ? (f = c, g = n) : (f = n, g = c);
            let v = 0,
                b = 0;
            for (let o = 0, j = s.length; o < j; o += 2) {
                const y = (o + 2) % j,
                    _ = s[o],
                    w = s[o + 1],
                    O = s[y],
                    x = s[y + 1];
                e.segmentsIntersectPreCalc(i, a, t, n, l, u, d, h, _, w, O, x) && ++v, e.segmentsIntersectPreCalc(r, c, t, n, m, p, f, g, _, w, O, x) && ++b
            }
            return v % 2 === 1 || b % 2 === 1
        }
        intersectsPoly(t, n, s) {
            const o = t._ptsArr,
                i = this._ptsArr;
            if (this.containsPoint(o[0] + n, o[1] + s)) return !0;
            if (t.containsPoint(i[0] - n, i[1] - s)) return !0;
            for (let t = 0, f = i.length; t < f; t += 2) {
                const p = (t + 2) % f,
                    a = i[t],
                    r = i[t + 1],
                    c = i[p],
                    l = i[p + 1];
                let d = 0,
                    u = 0,
                    h = 0,
                    m = 0;
                a < c ? (d = a, h = c) : (d = c, h = a), r < l ? (u = r, m = l) : (u = l, m = r);
                for (let t = 0, i = o.length; t < i; t += 2) {
                    const f = (t + 2) % i,
                        p = o[t] + n,
                        g = o[t + 1] + s,
                        v = o[f] + n,
                        b = o[f + 1] + s;
                    if (e.segmentsIntersectPreCalc(a, r, c, l, d, h, u, m, p, g, v, b)) return !0
                }
            }
            return !1
        }
        intersectsSegment(t, n, s, o, i, a) {
            if (this.containsPoint(s - t, o - n)) return !0;
            if (this.containsPoint(i - t, a - n)) return !0;
            let c = 0,
                l = 0,
                d = 0,
                u = 0;
            s < i ? (c = s, d = i) : (c = i, d = s), o < a ? (l = o, u = a) : (l = a, u = o);
            const r = this._ptsArr;
            for (let h = 0, m = r.length; h < m; h += 2) {
                const f = (h + 2) % m,
                    p = r[h] + t,
                    g = r[h + 1] + n,
                    v = r[f] + t,
                    b = r[f + 1] + n;
                if (e.segmentsIntersectPreCalc(s, o, i, a, c, d, l, u, p, g, v, b)) return !0
            }
            return !1
        }
        mirror(e) {
            const t = this._ptsArr;
            for (let n = 0, s = t.length; n < s; n += 2) t[n] = e * 2 - t[n];
            this._isBboxChanged = !0
        }
        flip(e) {
            const t = this._ptsArr;
            for (let n = 0, o = t.length; n < o; n += 2) {
                const s = n + 1;
                t[s] = e * 2 - t[s]
            }
            this._isBboxChanged = !0
        }
        diag() {
            const e = this._ptsArr;
            for (let t = 0, s = e.length; t < s; t += 2) {
                const n = t + 1,
                    o = e[t];
                e[t] = e[n], e[n] = o
            }
            this._isBboxChanged = !0
        }
        GetMidX() {
            const e = this._ptsArr;
            let t = 0;
            for (let n = 0, s = e.length; n < s; n += 2) t += e[n];
            return t / this.pointCount()
        }
        GetMidY() {
            const e = this._ptsArr;
            let t = 0;
            for (let n = 0, s = e.length; n < s; n += 2) t += e[n + 1];
            return t / this.pointCount()
        }
        GetPointsArray() {
            return this._ptsArr
        }
        GetPointCount() {
            return this.pointCount()
        }
        IsEnabled() {
            return this._enabled
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.PairMap = class PairMap extends e.DefendedBase {
        constructor(e) {
            if (super(), this._firstMap = new Map, e)
                for (const [t, n, s] of e) this.Set(t, n, s)
        }
        Release() {
            this.Clear(), this._firstMap = null
        }
        Clear() {
            const e = this._firstMap;
            for (const t of e.values()) t.clear();
            e.clear()
        }
        Set(e, t, n) {
            const o = this._firstMap;
            let s = o.get(e);
            s || (s = new Map, o.set(e, s)), s.set(t, n)
        }
        Get(e, t) {
            const n = this._firstMap.get(e);
            return n && n.get(t)
        }
        Has(e, t) {
            const n = this._firstMap.get(e);
            return !!n && n.has(t)
        }
        Delete(e, t) {
            const s = this._firstMap,
                n = s.get(e);
            if (!n) return !1;
            const o = n.delete(t);
            return o && n.size === 0 && s.delete(e), o
        }
        DeleteEither(e) {
            const t = this._firstMap,
                n = t.get(e);
            n && (n.clear(), t.delete(e));
            for (const [s, n] of t.entries()) n.delete(e) && n.size === 0 && t.delete(s)
        }
        GetSize() {
            let e = 0;
            for (const t of this._firstMap.values()) e += t.size;
            return e
        }* values() {
            for (const e of this._firstMap.values()) yield* e.values()
        }* keyPairs() {
            for (const [e, t] of this._firstMap.entries())
                for (const n of t.keys()) yield [e, n]
        }* entries() {
            for (const [e, t] of this._firstMap.entries())
                for (const [n, s] of t.entries()) yield [e, n, s]
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.ArraySet = class ArraySet extends e.DefendedBase {
        constructor() {
            super(), this._set = new Set, this._arr = [], this._needToRebuildArray = !1
        }
        Release() {
            this.Clear()
        }
        Clear() {
            this._set.clear(), e.clearArray(this._arr), this._needToRebuildArray = !1
        }
        Add(e) {
            if (this._set.has(e)) return;
            this._set.add(e), this._needToRebuildArray || this._arr.push(e)
        }
        Has(e) {
            return this._set.has(e)
        }
        Delete(e) {
            this._set.delete(e) && (this._needToRebuildArray = !0)
        }
        GetSize() {
            return this._set.size
        }
        IsEmpty() {
            return this._set.size === 0
        }
        GetArray() {
            return this._needToRebuildArray && (this._RebuildArray(), this._needToRebuildArray = !1), this._arr
        }
        _RebuildArray() {
            const t = this._arr;
            e.clearArray(t);
            for (const e of this._set) t.push(e)
        }
    }
}
"use strict";
{
    const b = self.C3,
        t = new Map,
        s = new Map,
        e = new Map,
        r = new Map,
        i = new Map,
        c = new Map;
    c.set("linear", "noease"), c.set("default", "noease"), self.Ease = class Ease {
        constructor() {}
        static InheritEase() {
            return "default"
        }
        static DefaultEase() {
            return "noease"
        }
        static GetEditorEaseNames(t, ...n) {
            this._CreateEaseMap(), e.has(t) || e.set(t, new Map);
            const o = e.get(t);
            return [...s.keys()].concat([...o.keys()]).filter(e => !n.includes(e))
        }
        static GetRuntimeEaseNames() {
            return this._CreateEaseMap(), [...s.keys()].concat([...r.keys()])
        }
        static IsNamePredefined(e) {
            return this._CreateEaseMap(), [...s.keys()].includes(e)
        }
        static _GetEase(e) {
            const n = c.get(e);
            if (n) return t.get(n);
            if (Ease.IsNamePredefined(e)) return t.get(e);
            if (i.has(e)) return i.get(e)
        }
        static GetEditorEase(t, n) {
            this._CreateEaseMap();
            const s = Ease._GetEase(t);
            return s || e.get(n).get(t)
        }
        static GetRuntimeEase(e) {
            this._CreateEaseMap();
            const t = Ease._GetEase(e);
            return t || r.get(e)
        }
        static GetEaseFromIndex(e) {
            this._CreateEaseMap();
            const t = this.GetRuntimeEaseNames();
            return t[e]
        }
        static GetIndexForEase(e, t) {
            this._CreateEaseMap();
            const n = this.GetEditorEaseNames(t);
            return n.indexOf(e)
        }
        static _CreateEaseMap() {
            if (t.size !== 0) return;
            this._AddPredifinedEase("default", () => {}), this._AddPredifinedEase("noease", this.NoEase), this._AddPredifinedEase("easeinsine", this.EaseInSine), this._AddPredifinedEase("easeoutsine", this.EaseOutSine), this._AddPredifinedEase("easeinoutsine", this.EaseInOutSine), this._AddPredifinedEase("easeinelastic", this.EaseInElastic), this._AddPredifinedEase("easeoutelastic", this.EaseOutElastic), this._AddPredifinedEase("easeinoutelastic", this.EaseInOutElastic), this._AddPredifinedEase("easeinback", this.EaseInBack), this._AddPredifinedEase("easeoutback", this.EaseOutBack), this._AddPredifinedEase("easeinoutback", this.EaseInOutBack), this._AddPredifinedEase("easeinbounce", this.EaseInBounce), this._AddPredifinedEase("easeoutbounce", this.EaseOutBounce), this._AddPredifinedEase("easeinoutbounce", this.EaseInOutBounce), this._AddPredifinedEase("easeincubic", this.EaseInCubic), this._AddPredifinedEase("easeoutcubic", this.EaseOutCubic), this._AddPredifinedEase("easeinoutcubic", this.EaseInOutCubic), this._AddPredifinedEase("easeinquad", this.EaseInQuad), this._AddPredifinedEase("easeoutquad", this.EaseOutQuad), this._AddPredifinedEase("easeinoutquad", this.EaseInOutQuad), this._AddPredifinedEase("easeinquart", this.EaseInQuart), this._AddPredifinedEase("easeoutquart", this.EaseOutQuart), this._AddPredifinedEase("easeinoutquart", this.EaseInOutQuart), this._AddPredifinedEase("easeinquint", this.EaseInQuint), this._AddPredifinedEase("easeoutquint", this.EaseOutQuint), this._AddPredifinedEase("easeinoutquint", this.EaseInOutQuint), this._AddPredifinedEase("easeincirc", this.EaseInCirc), this._AddPredifinedEase("easeoutcirc", this.EaseOutCirc), this._AddPredifinedEase("easeinoutcirc", this.EaseInOutCirc), this._AddPredifinedEase("easeinexpo", this.EaseInExpo), this._AddPredifinedEase("easeoutexpo", this.EaseOutExpo), this._AddPredifinedEase("easeinoutexpo", this.EaseInOutExpo), this._AddPrivateCustomEase("cubicbezier", this.EaseCubicBezier), this._AddPrivateCustomEase("spline", this.EaseSpline)
        }
        static _AddPredifinedEase(e, t) {
            Ease._AddEase(e, t, "predefined")
        }
        static _AddPrivateCustomEase(e, t) {
            Ease._AddEase(e, t, "private")
        }
        static AddCustomEase(e, t, n) {
            this._CreateEaseMap(), Ease._AddEase(e, t, "custom", n)
        }
        static RemoveCustomEase(t, n) {
            if (this.IsNamePredefined(t)) return;
            if ([...i.keys()].includes(t)) return;
            const s = e.get(n);
            s && s.delete(t)
        }
        static _AddEase(n, o, a, c) {
            switch (a) {
                case "predefined":
                    t.set(n, o), s.set(n, o);
                    break;
                case "custom":
                    if (c) {
                        e.has(c) || e.set(c, new Map);
                        const t = e.get(c);
                        t.set(n, o)
                    } else r.set(n, o);
                    break;
                case "private":
                    t.set(n, o), i.set(n, o);
                    break;
                default:
                    throw new Error("unexpected ease mode")
            }
        }
        static NoEase(e, t, n, s) {
            return n * e / s + t
        }
        static EaseInQuad(e, t, n, s) {
            return n * (e /= s) * e + t
        }
        static EaseOutQuad(e, t, n, s) {
            return -n * (e /= s) * (e - 2) + t
        }
        static EaseInOutQuad(e, t, n, s) {
            return (e /= s / 2) < 1 ? n / 2 * e * e + t : -n / 2 * (--e * (e - 2) - 1) + t
        }
        static EaseInCubic(e, t, n, s) {
            return n * (e /= s) * e * e + t
        }
        static EaseOutCubic(e, t, n, s) {
            return n * ((e = e / s - 1) * e * e + 1) + t
        }
        static EaseInOutCubic(e, t, n, s) {
            return (e /= s / 2) < 1 ? n / 2 * e * e * e + t : n / 2 * ((e -= 2) * e * e + 2) + t
        }
        static EaseInQuart(e, t, n, s) {
            return n * (e /= s) * e * e * e + t
        }
        static EaseOutQuart(e, t, n, s) {
            return -n * ((e = e / s - 1) * e * e * e - 1) + t
        }
        static EaseInOutQuart(e, t, n, s) {
            return (e /= s / 2) < 1 ? n / 2 * e * e * e * e + t : -n / 2 * ((e -= 2) * e * e * e - 2) + t
        }
        static EaseInQuint(e, t, n, s) {
            return n * (e /= s) * e * e * e * e + t
        }
        static EaseOutQuint(e, t, n, s) {
            return n * ((e = e / s - 1) * e * e * e * e + 1) + t
        }
        static EaseInOutQuint(e, t, n, s) {
            return (e /= s / 2) < 1 ? n / 2 * e * e * e * e * e + t : n / 2 * ((e -= 2) * e * e * e * e + 2) + t
        }
        static EaseInSine(e, t, n, s) {
            return -n * Math.cos(e / s * (Math.PI / 2)) + n + t
        }
        static EaseOutSine(e, t, n, s) {
            return n * Math.sin(e / s * (Math.PI / 2)) + t
        }
        static EaseInOutSine(e, t, n, s) {
            return -n / 2 * (Math.cos(Math.PI * e / s) - 1) + t
        }
        static EaseInExpo(e, t, n, s) {
            return e === 0 ? t : n * Math.pow(2, 10 * (e / s - 1)) + t
        }
        static EaseOutExpo(e, t, n, s) {
            return e === s ? t + n : n * (-Math.pow(2, -10 * e / s) + 1) + t
        }
        static EaseInOutExpo(e, t, n, s) {
            return e === 0 ? t : e === s ? t + n : (e /= s / 2) < 1 ? n / 2 * Math.pow(2, 10 * (e - 1)) + t : n / 2 * (-Math.pow(2, -10 * --e) + 2) + t
        }
        static EaseInCirc(e, t, n, s) {
            return -n * (Math.sqrt(1 - (e /= s) * e) - 1) + t
        }
        static EaseOutCirc(e, t, n, s) {
            return n * Math.sqrt(1 - (e = e / s - 1) * e) + t
        }
        static EaseInOutCirc(e, t, n, s) {
            return (e /= s / 2) < 1 ? -n / 2 * (Math.sqrt(1 - e * e) - 1) + t : n / 2 * (Math.sqrt(1 - (e -= 2) * e) + 1) + t
        }
        static EaseInElastic(e, t, n, s) {
            let a = 1.70158,
                o = 0,
                i = n;
            return e === 0 ? t : (e /= s) === 1 ? t + n : (o || (o = s * .3), i < Math.abs(n) ? (i = n, a = o / 4) : a = o / (2 * Math.PI) * Math.asin(n / i), -(i * Math.pow(2, 10 * (e -= 1)) * Math.sin((e * s - a) * (2 * Math.PI) / o)) + t)
        }
        static EaseOutElastic(e, t, n, s) {
            let a = 1.70158,
                o = 0,
                i = n;
            return e === 0 ? t : (e /= s) === 1 ? t + n : (o || (o = s * .3), i < Math.abs(n) ? (i = n, a = o / 4) : a = o / (2 * Math.PI) * Math.asin(n / i), i * Math.pow(2, -10 * e) * Math.sin((e * s - a) * (2 * Math.PI) / o) + n + t)
        }
        static EaseInOutElastic(e, t, n, s) {
            let a = 1.70158,
                o = 0,
                i = n;
            return e === 0 ? t : (e /= s / 2) === 2 ? t + n : (o || (o = s * (.3 * 1.5)), i < Math.abs(n) ? (i = n, a = o / 4) : a = o / (2 * Math.PI) * Math.asin(n / i), e < 1 ? -.5 * (i * Math.pow(2, 10 * (e -= 1)) * Math.sin((e * s - a) * (2 * Math.PI) / o)) + t : i * Math.pow(2, -10 * (e -= 1)) * Math.sin((e * s - a) * (2 * Math.PI) / o) * .5 + n + t)
        }
        static EaseInBack(e, t, n, s, o) {
            return o === void 0 && (o = 1.70158), n * (e /= s) * e * ((o + 1) * e - o) + t
        }
        static EaseOutBack(e, t, n, s, o) {
            return o === void 0 && (o = 1.70158), n * ((e = e / s - 1) * e * ((o + 1) * e + o) + 1) + t
        }
        static EaseInOutBack(e, t, n, s, o) {
            return o === void 0 && (o = 1.70158), (e /= s / 2) < 1 ? n / 2 * (e * e * (((o *= 1.525) + 1) * e - o)) + t : n / 2 * ((e -= 2) * e * (((o *= 1.525) + 1) * e + o) + 2) + t
        }
        static EaseInBounce(e, t, n, s) {
            return n - Ease.EaseOutBounce(s - e, 0, n, s) + t
        }
        static EaseOutBounce(e, t, n, s) {
            return (e /= s) < 1 / 2.75 ? n * (7.5625 * e * e) + t : e < 2 / 2.75 ? n * (7.5625 * (e -= 1.5 / 2.75) * e + .75) + t : e < 2.5 / 2.75 ? n * (7.5625 * (e -= 2.25 / 2.75) * e + .9375) + t : n * (7.5625 * (e -= 2.625 / 2.75) * e + .984375) + t
        }
        static EaseInOutBounce(e, t, n, s) {
            return e < s / 2 ? Ease.EaseInBounce(e * 2, 0, n, s) * .5 + t : Ease.EaseOutBounce(e * 2 - s, 0, n, s) * .5 + n * .5 + t
        }
        static EaseCubicBezier(e, t, n, s, o) {
            const i = t,
                a = 3 * e * (n - t),
                r = 3 * e ** 2 * (t + s - 2 * n),
                c = e ** 3 * (o - t + 3 * n - 3 * s);
            return i + a + r + c
        }
        static EaseSpline(e, t, n, s, i, a, r, c, h, m) {
            if (s === i && a === r) return e;
            const f = v(e, t, s, a, c, m),
                p = l(n, i, r, h),
                g = d(n, i, r, h),
                b = u(n, i, r, h);
            return o(f, p, g, b)
        }
        static GetBezierSamples(e, t, s, i) {
            const r = [],
                c = l(e, t, s, i),
                h = d(e, t, s, i),
                m = u(e, t, s, i);
            for (let e = 0; e < n; ++e) {
                const t = o(e * a, c, h, m);
                r.push(t)
            }
            return r
        }
    };
    const n = 11,
        a = 1 / (n - 1),
        m = 4,
        f = .02,
        p = 1e-7,
        g = 10,
        l = (e, t, n, s) => s - 3 * n + 3 * t - e,
        d = (e, t, n) => 3 * n - 6 * t + 3 * e,
        u = (e, t) => 3 * (t - e),
        o = (e, t, n, s) => ((t * e + n) * e + s) * e,
        h = (e, t, n, s) => 3 * t * e * e + 2 * n * e + s,
        v = (e, t, s, i, r, c) => {
            if (e == 1) return 1;
            let _ = 0,
                b = 1,
                j = c[b],
                M = n - 1,
                T = c[n - 1];
            for (; b != M && j <= e;) b++, j = c[b], _ += a;
            b--, j = c[b];
            const S = (e - j) / (c[b + 1] - j);
            let v = _ + S * a;
            const O = l(t, s, i, r),
                y = d(t, s, i, r),
                w = u(t, s, i, r),
                E = h(v, O, y, w);
            if (E === 0) return v;
            if (E >= f) {
                for (let t = 0; t < m; ++t) {
                    const n = o(v, O, y, w) - e,
                        s = h(v, O, y, w);
                    v -= n / s
                }
                return v
            }
            let x = _,
                C = _ + a,
                F = 0,
                k, A;
            do {
                v = x + (C - x) / 2;
                let t = o(v, O, y, w) - e;
                t > 0 ? C = v : x = v, k = Math.abs(t) > p, A = ++F < g
            } while (k && A) return v
        }
}
"use strict";
{
    const e = self.C3;

    function RequireStringOrNumber(t) {
        !e.IsString(t)
    }
    e.ProbabilityTable = class ProbabilityTable {
        constructor() {
            this._items = [], this._totalWeight = 0
        }
        Release() {
            this.Clear(), this._items = null
        }
        Clear() {
            e.clear2DArray(this._items), this._totalWeight = 0
        }
        GetTotalWeight() {
            return this._totalWeight
        }
        Sample(e = Math.random() * this.GetTotalWeight()) {
            let t = 0;
            for (const [n, s] of this._items)
                if (t += n, e < t) return s;
            return 0
        }
        AddItem(e, t) {
            RequireStringOrNumber(t), this._totalWeight += e, this._items.push([e, t])
        }
        RemoveItem(e, t) {
            RequireStringOrNumber(t);
            const n = e === 0;
            for (let s = 0; s < this._items.length; s++) {
                const o = this._items[s],
                    i = n || o[0] === e,
                    a = o[1] === t;
                if (i && a) {
                    this._items.splice(s, 1), this._totalWeight -= o[0];
                    break
                }
            }
        }
        asJSON() {
            return JSON.stringify(this._items)
        }
        static fromJSON(t) {
            const n = new e.ProbabilityTable,
                s = JSON.parse(t);
            for (const e of s) {
                const t = e[0],
                    o = e[1];
                n.AddItem(t, o)
            }
            return n
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Event = class Event {
        constructor(e, t) {
            this.type = e, this.cancelable = !!t, this.defaultPrevented = !1, this.propagationStopped = !1, this.isAsync = !1
        }
        preventDefault() {
            if (!this.cancelable) throw new Error(`event '${this.type}' is not cancelable`);
            this.defaultPrevented = !0
        }
        stopPropagation() {
            if (!this.cancelable) throw new Error(`event '${this.type}' cannot be stopped`);
            if (this.isAsync) throw new Error(`cannot stop async event '${this.type}' propagation`);
            this.propagationStopped = !0
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = self.assert;
    e.Event.Handler = class EventHandler extends e.DefendedBase {
        constructor(e) {
            super(), this._type = e, this._captureListeners = [], this._captureListenersSet = new Set, this._listeners = [], this._listenersSet = new Set, this._fireDepth = 0, this._queueAddListeners = [], this._queueRemoveCaptureListeners = [], this._queueRemoveListeners = []
        }
        Release() {
            if (this._fireDepth > 0) return;
            e.clearArray(this._captureListeners), this._captureListenersSet.clear(), e.clearArray(this._listeners), this._listenersSet.clear(), e.clearArray(this._queueAddListeners), e.clearArray(this._queueRemoveCaptureListeners), e.clearArray(this._queueRemoveListeners), e.Release(this)
        }
        _AddListener(e, t) {
            if (this._IsFiring()) {
                this._queueAddListeners.push([e, t]);
                return
            }
            if (t) {
                if (this._captureListenersSet.has(e)) return;
                this._captureListeners.push(e), this._captureListenersSet.add(e)
            } else {
                if (this._listenersSet.has(e)) return;
                this._listeners.push(e), this._listenersSet.add(e)
            }
        }
        _RemoveListener(t, n) {
            if (this._IsFiring()) {
                n ? this._queueRemoveCaptureListeners.push(t) : this._queueRemoveListeners.push(t);
                return
            }
            n ? this._captureListenersSet.has(t) && (this._captureListenersSet.delete(t), e.arrayFindRemove(this._captureListeners, t)) : this._listenersSet.has(t) && (this._listenersSet.delete(t), e.arrayFindRemove(this._listeners, t))
        }
        _IsEmpty() {
            return !this._captureListeners.length && !this._listeners.length
        }
        _IsFiring() {
            return this._fireDepth > 0
        }
        _ProcessQueuedListeners() {
            for (let e of this._queueAddListeners) this._AddListener(...e);
            e.clearArray(this._queueAddListeners);
            for (const e of this._queueRemoveListeners) this._listenersSet.delete(e);
            for (const e of this._queueRemoveCaptureListeners) this._captureListenersSet.delete(e);
            const t = new Set(this._queueRemoveListeners),
                n = new Set(this._queueRemoveCaptureListeners);
            e.arrayRemoveAllInSet(this._listeners, t), e.arrayRemoveAllInSet(this._captureListeners, n), e.clearArray(this._queueRemoveCaptureListeners), e.clearArray(this._queueRemoveListeners)
        }
        _FireCancellable(e) {
            this._IncreaseFireDepth();
            let t = !1;
            for (let n = 0, s = this._captureListeners.length; n < s; ++n)
                if (this._captureListeners[n](e), e.propagationStopped) {
                    t = !0;
                    break
                } if (!t)
                for (let t = 0, n = this._listeners.length; t < n; ++t)
                    if (this._listeners[t](e), e.propagationStopped) break;
            return this._DecreaseFireDepth(), !e.defaultPrevented
        }
        _FireNonCancellable(e) {
            this._IncreaseFireDepth();
            for (let t = 0, n = this._captureListeners.length; t < n; ++t) this._captureListeners[t](e);
            for (let t = 0, n = this._listeners.length; t < n; ++t) this._listeners[t](e);
            return this._DecreaseFireDepth(), !0
        }
        _IncreaseFireDepth() {
            this._fireDepth++
        }
        _DecreaseFireDepth() {
            this._fireDepth--, this._fireDepth === 0 && (this._queueAddListeners.length || this._queueRemoveCaptureListeners.length || this._queueRemoveListeners.length) && this._ProcessQueuedListeners()
        }
        SetDelayRemoveEventsEnabled(e) {
            e ? this._IncreaseFireDepth() : this._DecreaseFireDepth()
        }
        _FireAsync(t) {
            let n = [];
            for (let s = 0, o = this._captureListeners.length; s < o; ++s) {
                let i = this._captureListeners[s];
                n.push(e.Asyncify(() => i(t)))
            }
            for (let s = 0, o = this._listeners.length; s < o; ++s) {
                let i = this._listeners[s];
                n.push(e.Asyncify(() => i(t)))
            }
            return Promise.all(n).then(() => !t.defaultPrevented)
        }
        _FireAndWait_AsyncOptional(e) {
            const t = [];
            this._IncreaseFireDepth();
            for (let n = 0, o = this._captureListeners.length; n < o; ++n) {
                const s = this._captureListeners[n](e);
                s instanceof Promise && t.push(s)
            }
            for (let n = 0, o = this._listeners.length; n < o; ++n) {
                const s = this._listeners[n](e);
                s instanceof Promise && t.push(s)
            }
            return this._DecreaseFireDepth(), t.length ? Promise.all(t).then(() => !e.defaultPrevented) : !e.defaultPrevented
        }
        async _FireAndWaitAsync(e) {
            return await this._FireAndWait_AsyncOptional(e)
        }
        async _FireAndWaitAsyncSequential(e) {
            this._IncreaseFireDepth();
            for (let t = 0, s = this._captureListeners.length; t < s; ++t) {
                const n = this._captureListeners[t](e);
                n instanceof Promise && await n
            }
            for (let t = 0, s = this._listeners.length; t < s; ++t) {
                const n = this._listeners[t](e);
                n instanceof Promise && await n
            }
            return this._DecreaseFireDepth(), !e.defaultPrevented
        }* _FireAsGenerator(t) {
            this._IncreaseFireDepth();
            for (let n = 0, o = this._captureListeners.length; n < o; ++n) {
                const s = this._captureListeners[n](t);
                e.IsIterator(s) && (yield* s)
            }
            for (let n = 0, o = this._listeners.length; n < o; ++n) {
                const s = this._listeners[n](t);
                e.IsIterator(s) && (yield* s)
            }
            this._DecreaseFireDepth()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Event.Dispatcher = class EventDispatcher extends e.DefendedBase {
        constructor() {
            super(), this._eventHandlers = new Map, this._dispatcherWasReleased = !1
        }
        Release() {
            if (this._dispatcherWasReleased) throw new Error("already released");
            this.ClearEvents(), this._dispatcherWasReleased = !0, e.Release(this)
        }
        WasReleased() {
            return this._dispatcherWasReleased
        }
        ClearEvents() {
            for (let e of this._eventHandlers.values()) e.Release();
            this._eventHandlers.clear()
        }
        _GetHandlerByType(t, n) {
            let s = this._eventHandlers.get(t);
            return s ? s : n ? (s = e.New(e.Event.Handler, t), this._eventHandlers.set(t, s), s) : null
        }
        HasAnyHandlerFor(e) {
            return this._eventHandlers.has(e)
        }
        addEventListener(e, t, n) {
            let s = this._GetHandlerByType(e, !0);
            s._AddListener(t, !!n)
        }
        removeEventListener(e, t, n) {
            let s = this._GetHandlerByType(e, !1);
            if (!s) return;
            s._RemoveListener(t, !!n), s._IsEmpty() && this._eventHandlers.delete(e)
        }
        dispatchEvent(e) {
            const t = this._GetHandlerByType(e.type, !1);
            return !t || (e.cancelable ? t._FireCancellable(e) : t._FireNonCancellable(e))
        }
        dispatchEventAsync(e) {
            const t = this._GetHandlerByType(e.type, !1);
            return t ? (e.isAsync = !0, t._FireAsync(e)) : Promise.resolve(!0)
        }
        async dispatchEventAndClearAsync(e) {
            const t = this._GetHandlerByType(e.type, !1);
            if (!t) return !0;
            this._eventHandlers.delete(e.type), e.isAsync = !0;
            const n = await t._FireAsync(e);
            return t.Release(), n
        }
        async dispatchEventAndWaitAsync(e) {
            const t = this._GetHandlerByType(e.type, !1);
            return !t || await t._FireAndWaitAsync(e)
        }
        dispatchEventAndWait_AsyncOptional(e) {
            const t = this._GetHandlerByType(e.type, !1);
            return !t || t._FireAndWait_AsyncOptional(e)
        }
        async dispatchEventAndWaitAsyncSequential(e) {
            const t = this._GetHandlerByType(e.type, !1);
            return !t || await t._FireAndWaitAsyncSequential(e)
        }
        dispatchGeneratorEvent(e) {
            const t = this._GetHandlerByType(e.type, !1);
            if (!t) return null;
            if (e.cancelable) throw new Error("not supported");
            return t._FireAsGenerator(e)
        }
        SetDelayRemoveEventsEnabled(e) {
            for (const t of this._eventHandlers.values()) t.SetDelayRemoveEventsEnabled(e)
        }
    }
}
"use strict";
{
    const n = self.C3,
        r = 12,
        o = 16,
        c = 35,
        i = typeof requestIdleCallback != "undefined";
    let e = [],
        s = -1,
        t = 0;

    function SetNewCallback(e) {
        i && t === 0 ? s = requestIdleCallback(DoAsyncifiedWork, {
            timeout: c
        }) : s = setTimeout(DoAsyncifiedWork, t > 0 ? 1 : e)
    }

    function DoAsyncifiedWork(n) {
        if (s = -1, !e.length) return;
        let a = performance.now(),
            c = a,
            d = 0,
            l = 0;
        do DoNextAsyncifiedJob(e.shift()), c = performance.now(), ++d, l = (c - a) / d * 1.1; while (e.length && (i && t === 0 && typeof n != "undefined" ? l < n.timeRemaining() : c - a + l < r)) if (s === -1 && e.length) {
            let e = c - a,
                t = Math.max(o - e, 4);
            SetNewCallback(t)
        }
    }

    function DoNextAsyncifiedJob(e) {
        let t;
        try {
            t = e.func()
        } catch (t) {
            e.reject(t);
            return
        }
        e.resolve(t)
    }
    let a = n.QueryString.Has("disable-asyncify");
    a && console.warn("[Asyncify] Asyncify has been disabled due to disable-asyncify in the query string. Some work will now be done synchronously."), n.Asyncify = function(i) {
        let r = null;
        return n.isDebug && (r = n.GetCallStack()), new Promise((t, n) => {
            if (e.push({
                    func: i,
                    resolve: t,
                    reject: n,
                    stack: r
                }), a) {
                DoNextAsyncifiedJob(e.pop());
                return
            }
            s === -1 && SetNewCallback(o)
        })
    }, n.Asyncify.SetHighThroughputMode = function(n) {
        if (n) ++t;
        else if (--t, t < 0) throw new Error("already turned off high throughput mode")
    }
}
"use strict";
{
    const o = self.C3,
        a = 1e3,
        i = 100;
    let s = -1;

    function ClearTimeCache() {
        s = -1
    }
    o.FastGetDateNow = function() {
        return s === -1 && (s = Date.now(), self.setTimeout(ClearTimeCache, 16)), s
    };
    let t = -1,
        e = -1,
        n = new Set;

    function CheckActiveIdleTimeouts() {
        t = -1, e = -1;
        let s = Date.now();
        for (let t of n)
            if (t._CheckTimeout(s)) {
                let n = t._GetDeadline();
                (e === -1 || n < e) && (e = n)
            } else n.delete(t);
        if (e !== -1) {
            let n = Math.max(e - s + i, a);
            t = self.setTimeout(CheckActiveIdleTimeouts, n)
        }
    }
    o.IdleTimeout = class IdleTimeout {
        constructor(e, t) {
            this._callback = e, this._timeout = t * 1e3, this._deadline = 0, this._isActive = !1
        }
        Reset() {
            let s = o.FastGetDateNow();
            this._deadline = s + this._timeout, this._isActive || (n.add(this), this._isActive = !0), t === -1 ? (e = this._deadline, t = self.setTimeout(CheckActiveIdleTimeouts, this._timeout + i)) : this._deadline < e && e > s + a && (self.clearTimeout(t), e = this._deadline, t = self.setTimeout(CheckActiveIdleTimeouts, this._timeout + i))
        }
        _CheckTimeout(e) {
            return !(e >= this._deadline) || (this._callback() ? (this._deadline = e + this._timeout, !0) : (this._isActive = !1, !1))
        }
        _GetDeadline() {
            return this._deadline
        }
        Cancel() {
            this._isActive && (n.delete(this), this._isActive = !1, n.size === 0 && t !== -1 && (self.clearTimeout(t), t = -1, e = -1))
        }
        Release() {
            this.Cancel(), this._callback = null
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Disposable = class Disposable {
        constructor(e) {
            this._disposed = !1, this._disposeAction = e
        }
        Dispose() {
            if (this._disposed) return;
            this._disposed = !0, this._disposeAction && (this._disposeAction(), this._disposeAction = null)
        }
        IsDisposed() {
            return this._disposed
        }
        Release() {
            this.Dispose()
        }
        static Release(e) {
            return new Disposable(() => e.Release())
        }
        static From(t, n, s, o, i) {
            if (typeof o == "undefined" || o === null) o = !1;
            else if (typeof o != "boolean" && typeof o != "object") throw new TypeError("invalid event listener options");
            if (i && (s = s.bind(i)), n.includes(" ")) {
                n = n.split(" ");
                const i = new e.CompositeDisposable;
                for (let a of n) t.addEventListener(a, s, o), i.Add(e.New(e.Disposable, () => t.removeEventListener(a, s, o)));
                return i
            }
            return t.addEventListener(n, s, o), e.New(e.Disposable, () => t.removeEventListener(n, s, o))
        }
    }, e.StubDisposable = class StubDisposable extends e.Disposable {
        SetAction(e) {
            this._disposeAction = e
        }
    }, e.CompositeDisposable = class CompositeDisposable extends e.Disposable {
        constructor(...e) {
            super(), this._disposables = new Set;
            for (let t of e) this.Add(t)
        }
        Add(...e) {
            if (this._disposed) throw new Error("already disposed");
            for (let t of e) this._disposables.add(t)
        }
        Remove(e) {
            if (this._disposed) throw new Error("already disposed");
            this._disposables.delete(e)
        }
        RemoveAll() {
            if (this._disposed) throw new Error("already disposed");
            if (!this._disposables) return;
            for (let e of this._disposables) e.Dispose();
            this._disposables.clear()
        }
        IsDisposed() {
            return this._disposed
        }
        Dispose() {
            if (this._disposed) throw new Error("already disposed");
            this._disposed = !0;
            for (let e of this._disposables) e.Dispose();
            this._disposables.clear(), this._disposables = null
        }
        Release() {
            this.Dispose()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.KahanSum = class KahanSum extends e.DefendedBase {
        constructor() {
            super(), this._c = 0, this._y = 0, this._t = 0, this._sum = 0
        }
        Add(e) {
            e = +e, this._y = e - this._c, this._t = this._sum + this._y, this._c = this._t - this._sum - this._y, this._sum = this._t
        }
        Subtract(e) {
            this._sum -= +e
        }
        Get() {
            return this._sum
        }
        Reset() {
            this._c = 0, this._y = 0, this._t = 0, this._sum = 0
        }
        Set(e) {
            this._c = 0, this._y = 0, this._t = 0, this._sum = +e
        }
        Release() {}
    }
}
"use strict";
{
    const s = self.C3,
        e = {},
        n = !0,
        t = !1;
    e.RBnode = function(e) {
        this.tree = e, this.right = this.tree.sentinel, this.left = this.tree.sentinel, this.parent = null, this.color = !1, this.key = null
    }, e.RedBlackSet = function(n) {
        this.size = 0, this.sentinel = new e.RBnode(this), this.sentinel.color = t, this.root = this.sentinel, this.root.parent = this.sentinel, this.compare = n || this.default_compare
    }, e.RedBlackSet.prototype.default_compare = function(e, t) {
        return e < t ? -1 : t < e ? 1 : 0
    }, e.RedBlackSet.prototype.clone = function() {
        var t = new e.RedBlackSet(this.compare);
        return t.insertAll(this), t
    }, e.RedBlackSet.prototype.clear = function() {
        this.size = 0, this.sentinel = new e.RBnode(this), this.sentinel.color = t, this.root = this.sentinel, this.root.parent = this.sentinel
    }, e.RedBlackSet.prototype.leftRotate = function(e) {
        var t = e.right;
        e.right = t.left, t.left != this.sentinel && (t.left.parent = e), t.parent = e.parent, e.parent == this.sentinel ? this.root = t : e == e.parent.left ? e.parent.left = t : e.parent.right = t, t.left = e, e.parent = t
    }, e.RedBlackSet.prototype.rightRotate = function(e) {
        var t = e.left;
        e.left = t.right, t.right != this.sentinel && (t.right.parent = e), t.parent = e.parent, e.parent == this.sentinel ? this.root = t : e == e.parent.right ? e.parent.right = t : e.parent.left = t, t.right = e, e.parent = t
    }, e.RedBlackSet.prototype.insert = function(t) {
        if (this.contains(t)) a = this.get_(t), a.key = t;
        else {
            var o, i, a, s = new e.RBnode(this);
            for (s.key = t, i = this.sentinel, o = this.root; o != this.sentinel;) i = o, this.compare(s.key, o.key) < 0 ? o = o.left : o = o.right;
            s.parent = i, i == this.sentinel ? this.root = s : this.compare(s.key, i.key) < 0 ? i.left = s : i.right = s, s.left = this.sentinel, s.right = this.sentinel, s.color = n, this.insertFixup(s), this.size++
        }
    }, e.RedBlackSet.prototype.insertFixup = function(e) {
        for (; e != this.sentinel && e != this.root && e.parent.color == n;)
            if (e.parent == e.parent.parent.left) {
                var s = e.parent.parent.right;
                s.color == n ? (e.parent.color = t, s.color = t, e.parent.parent.color = n, e = e.parent.parent) : (e == e.parent.right && (e = e.parent, this.leftRotate(e)), e.parent.color = t, e.parent.parent.color = n, e.parent.parent != this.sentinel && this.rightRotate(e.parent.parent))
            } else s = e.parent.parent.left, s.color == n ? (e.parent.color = t, s.color = t, e.parent.parent.color = n, e = e.parent.parent) : (e == e.parent.left && (e = e.parent, this.rightRotate(e)), e.parent.color = t, e.parent.parent.color = n, e.parent.parent != this.sentinel && this.leftRotate(e.parent.parent));
        this.root.color = t
    }, e.RedBlackSet.prototype.delete_ = function(e) {
        var n, s;
        e.left == this.sentinel || e.right == this.sentinel ? n = e : n = this.successor_(e), n.left != this.sentinel ? s = n.left : s = n.right, s.parent = n.parent, n.parent == this.sentinel ? this.root = s : n == n.parent.left ? n.parent.left = s : n.parent.right = s, n != e && (e.key = n.key), n.color == t && this.deleteFixup(s), this.size--
    }, e.RedBlackSet.prototype.deleteFixup = function(e) {
        for (; e != this.root && e.color == t;)
            if (e == e.parent.left) {
                var s = e.parent.right;
                s.color == n && (s.color = t, e.parent.color = n, this.leftRotate(e.parent), s = e.parent.right), s.left.color == t && s.right.color == t ? (s.color = n, e = e.parent) : (s.right.color == t && (s.left.color = t, s.color = n, this.rightRotate(s), s = e.parent.right), s.color = e.parent.color, e.parent.color = t, s.right.color = t, this.leftRotate(e.parent), e = this.root)
            } else s = e.parent.left, s.color == n && (s.color = t, e.parent.color = n, this.rightRotate(e.parent), s = e.parent.left), s.right.color == t && s.left.color == t ? (s.color = n, e = e.parent) : (s.left.color == t && (s.right.color = t, s.color = n, this.leftRotate(s), s = e.parent.left), s.color = e.parent.color, e.parent.color = t, s.left.color = t, this.rightRotate(e.parent), e = this.root);
        e.color = t
    }, e.RedBlackSet.prototype.remove = function(e) {
        var n, t = this.get_(e);
        return t != this.sentinel ? (n = t.key, this.delete_(t), n) : null
    }, e.RedBlackSet.prototype.removeSwapped = function(e, t) {
        this.remove(t)
    }, e.RedBlackSet.prototype.min = function(e) {
        for (; e.left != this.sentinel;) e = e.left;
        return e
    }, e.RedBlackSet.prototype.max = function(e) {
        for (; e.right != this.sentinel;) e = e.right;
        return e
    }, e.RedBlackSet.prototype.successor_ = function(e) {
        if (e.right != this.sentinel) return this.min(e.right);
        for (var t = e.parent; t != this.sentinel && e == t.right;) e = t, t = t.parent;
        return t
    }, e.RedBlackSet.prototype.predeccessor_ = function(e) {
        if (e.left != this.sentinel) return this.max(e.left);
        for (var t = e.parent; t != this.sentinel && e == t.left;) e = t, t = t.parent;
        return t
    }, e.RedBlackSet.prototype.successor = function(e) {
        if (this.size > 0) {
            var t, n = this.get_(e);
            if (n == this.sentinel) return null;
            if (n.right != this.sentinel) return this.min(n.right).key;
            for (t = n.parent; t != this.sentinel && n == t.right;) n = t, t = t.parent;
            return t != this.sentinel ? t.key : null
        } else return null
    }, e.RedBlackSet.prototype.predecessor = function(e) {
        if (this.size > 0) {
            var t, n = this.get_(e);
            if (n == this.sentinel) return null;
            if (n.left != this.sentinel) return this.max(n.left).key;
            for (t = n.parent; t != this.sentinel && n == t.left;) n = t, t = t.parent;
            return t != this.sentinel ? t.key : null
        } else return null
    }, e.RedBlackSet.prototype.getMin = function() {
        return this.min(this.root).key
    }, e.RedBlackSet.prototype.getMax = function() {
        return this.max(this.root).key
    }, e.RedBlackSet.prototype.get_ = function(e) {
        for (var t = this.root; t != this.sentinel && this.compare(t.key, e) != 0;) this.compare(e, t.key) < 0 ? t = t.left : t = t.right;
        return t
    }, e.RedBlackSet.prototype.contains = function(e) {
        return this.get_(e).key != null
    }, e.RedBlackSet.prototype.getValues = function() {
        var e = [];
        return this.forEach(function(t) {
            e.push(t)
        }), e
    }, e.RedBlackSet.prototype.insertAll = function(t) {
        if (e.typeOf(t) == "array")
            for (var s, o, n = 0; n < t.length; n++) this.insert(t[n]);
        else if (e.typeOf(t.forEach) == "function") t.forEach(this.insert, this);
        else if (e.typeOf(t.getValues) == "function") {
            s = t.getValues();
            for (n = 0; n < s.length; n++) this.insert(s[n])
        } else if (e.typeOf(t) == "object")
            for (o in t) this.insert(t[o])
    }, e.RedBlackSet.prototype.removeAll = function(t) {
        if (e.typeOf(t) == "array")
            for (var s, o, n = 0; n < t.length; n++) this.remove(t[n]);
        else if (e.typeOf(t.forEach) == "function") t.forEach(this.removeSwapped, this);
        else if (e.typeOf(t.getValues) == "function") {
            s = t.getValues();
            for (n = 0; n < s.length; n++) this.remove(s[n])
        } else if (e.typeOf(t) == "object")
            for (o in t) this.remove(t[o])
    }, e.RedBlackSet.prototype.containsAll = function(t) {
        if (e.typeOf(t) == "array") {
            for (var s, o, n = 0; n < t.length; n++)
                if (!this.contains(t[n])) return !1;
            return !0
        }
        if (e.typeOf(t.forEach) == "function") return t.every(this.contains, this);
        if (e.typeOf(t.getValues) == "function") {
            s = t.getValues();
            for (n = 0; n < s.length; n++)
                if (!this.contains(s[n])) return !1;
            return !0
        }
        if (e.typeOf(t) == "object") {
            for (o in t)
                if (!this.contains(t[o])) return !1;
            return !0
        }
    }, e.RedBlackSet.prototype.range = function(e, t) {
        var n = [];
        return this.traverseFromTo(function(e) {
            n.push(e)
        }, e, t), n
    }, e.RedBlackSet.prototype.traverse = function(e, t) {
        if (this.isEmpty()) return;
        for (var n = this.min(this.root); n != this.sentinel;) {
            if (e.call(t, n.key, this)) return;
            n = this.successor_(n)
        }
    }, e.RedBlackSet.prototype.traverseFrom = function(e, t, n) {
        if (this.isEmpty()) return;
        for (var s = this.get_(t); s != this.sentinel;) {
            if (e.call(n, s.key, this)) return;
            s = this.successor_(s)
        }
    }, e.RedBlackSet.prototype.traverseTo = function(e, t, n) {
        if (this.isEmpty()) return;
        for (var s = this.min(this.root), o = this.get_(t); s != o;) {
            if (e.call(n, s.key, this)) return;
            s = this.successor_(s)
        }
    }, e.RedBlackSet.prototype.traverseFromTo = function(e, t, n, s) {
        if (this.isEmpty()) return;
        for (var o = this.get_(t), i = this.get_(n); o != i;) {
            if (e.call(s, o.key, this)) return;
            o = this.successor_(o)
        }
    }, e.RedBlackSet.prototype.traverseBackwards = function(e, t) {
        if (this.isEmpty()) return;
        for (var n = this.max(this.root); n != this.sentinel;) {
            if (e.call(t, n.key, this)) return;
            n = this.predeccessor_(n)
        }
    }, e.RedBlackSet.prototype.forEach = function(e, t) {
        if (this.isEmpty()) return;
        for (var n = this.min(this.root); n != this.sentinel; n = this.successor_(n)) e.call(t, n.key, n.key, this)
    }, e.RedBlackSet.prototype.some = function(e, t) {
        if (this.isEmpty()) return !1;
        for (var n = this.min(this.root); n != this.sentinel; n = this.successor_(n))
            if (e.call(t, n.key, n.key, this)) return !0;
        return !1
    }, e.RedBlackSet.prototype.every = function(e, t) {
        if (this.isEmpty()) return !1;
        for (var n = this.min(this.root); n != this.sentinel; n = this.successor_(n))
            if (!e.call(t, n.key, n.key, this)) return !1;
        return !0
    }, e.RedBlackSet.prototype.map = function(e, t) {
        var n, s = [];
        if (this.isEmpty()) return s;
        for (n = this.min(this.root); n != this.sentinel; n = this.successor_(n)) s.push(e.call(t, n.key, n.key, this));
        return s
    }, e.RedBlackSet.prototype.filter = function(e, t) {
        var n, s = [];
        if (this.isEmpty()) return s;
        for (n = this.min(this.root); n != this.sentinel; n = this.successor_(n)) e.call(t, n.key, n.key, this) && s.push(n.key);
        return s
    }, e.RedBlackSet.prototype.getCount = function() {
        return this.size
    }, e.RedBlackSet.prototype.isEmpty = function() {
        return this.size == 0
    }, e.RedBlackSet.prototype.isSubsetOf = function(t) {
        var n, s, o = e.getCount(t);
        if (this.getCount() > o) return !1;
        if (s = 0, this.isEmpty()) return !0;
        for (n = this.min(this.root); n != this.sentinel; n = this.successor_(n)) e.contains.call(t, t, n.key) && s++;
        return s == this.getCount()
    }, e.RedBlackSet.prototype.intersection = function(t) {
        var n, s = new e.RedBlackSet(this.compare);
        if (this.isEmpty()) return s;
        for (n = this.min(this.root); n != this.sentinel; n = this.successor_(n)) t.contains.call(t, n.key, n.key, this) && s.insert(n.key);
        return s
    }, s.RedBlackSet = class RedBlackSet extends s.DefendedBase {
        constructor(t) {
            super(), this._rbSet = new e.RedBlackSet(t), this._enableQueue = !1, this._queueInsert = new Set, this._queueRemove = new Set
        }
        Add(e) {
            this._enableQueue ? this._rbSet.contains(e) ? this._queueRemove.delete(e) : this._queueInsert.add(e) : this._rbSet.insert(e)
        }
        Remove(e) {
            this._enableQueue ? this._rbSet.contains(e) ? this._queueRemove.add(e) : this._queueInsert.delete(e) : this._rbSet.remove(e)
        }
        Has(e) {
            return this._enableQueue ? !!this._queueInsert.has(e) || !this._queueRemove.has(e) && this._rbSet.contains(e) : this._rbSet.contains(e)
        }
        Clear() {
            this._rbSet.clear(), this._queueInsert.clear(), this._queueRemove.clear()
        }
        toArray() {
            if (this._enableQueue) throw new Error("cannot be used in queueing mode");
            return this._rbSet.getValues()
        }
        GetSize() {
            return this._rbSet.getCount() + this._queueInsert.size - this._queueRemove.size
        }
        IsEmpty() {
            return this.GetSize() === 0
        }
        Front() {
            if (this.IsEmpty()) throw new Error("empty set");
            if (this._enableQueue) throw new Error("cannot be used in queueing mode");
            const e = this._rbSet,
                t = e.min(e.root);
            return t.key
        }
        Shift() {
            if (this.IsEmpty()) throw new Error("empty set");
            if (this._enableQueue) throw new Error("cannot be used in queueing mode");
            const e = this.Front();
            return this.Remove(e), e
        }
        SetQueueingEnabled(e) {
            if (e = !!e, this._enableQueue === e) return;
            if (this._enableQueue = e, !e) {
                for (const e of this._queueRemove) this._rbSet.remove(e);
                this._queueRemove.clear();
                for (const e of this._queueInsert) this._rbSet.insert(e);
                this._queueInsert.clear()
            }
        }
        ForEach(e) {
            this._rbSet.forEach(e)
        }* values() {
            if (this.IsEmpty()) return;
            const e = this._rbSet;
            for (let t = e.min(e.root); t != e.sentinel; t = e.successor_(t)) yield t.key
        } [Symbol.iterator]() {
            return this.values()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.PromiseThrottle = class PromiseThrottle {
        constructor(t = e.hardwareConcurrency) {
            this._maxParallel = t, this._queue = [], this._activeCount = 0
        }
        Add(e) {
            return new Promise((t, n) => {
                this._queue.push({
                    func: e,
                    resolve: t,
                    reject: n
                }), this._MaybeStartNext()
            })
        }
        _FindInQueue(e) {
            for (let t = 0, n = this._queue.length; t < n; ++t)
                if (this._queue[t].func === e) return t;
            return -1
        }
        RemoveAndResolve(e, t) {
            const n = this._FindInQueue(e);
            if (n === -1) throw new Error("cannot find promise to resolve");
            this._queue[n].resolve(t), this._queue.splice(n, 1)
        }
        RemoveAndReject(e, t) {
            const n = this._FindInQueue(e);
            if (n === -1) throw new Error("cannot find promise to reject");
            this._queue[n].reject(t), this._queue.splice(n, 1)
        }
        async _MaybeStartNext() {
            if (!this._queue.length) return;
            if (this._activeCount >= this._maxParallel) return;
            this._activeCount++;
            const e = this._queue.shift();
            try {
                const t = await e.func();
                e.resolve(t)
            } catch (t) {
                e.reject(t)
            }
            this._activeCount--, this._MaybeStartNext()
        }
        static async Batch(e, t) {
            const n = [];
            let s = !1;
            const i = async e => {
                let o;
                for (; o = t.pop();) {
                    if (s) return;
                    try {
                        n.push(await o())
                    } catch (e) {
                        throw s = !0, e
                    }
                }
            }, o = [];
            for (; e--;) o.push(i());
            return await Promise.all(o), n
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.RateLimiter = class RateLimiter {
        constructor(e, t, n) {
            this._callback = e, this._interval = t, this._intervalOnBattery = n || t * 2, this._timerId = -1, this._lastCallTime = -(1 / 0), this._timerCallFunc = () => this._OnTimer(), this._ignoreReset = !1, this._canRunImmediate = !1, this._callbackArguments = null
        }
        SetCanRunImmediate(e) {
            this._canRunImmediate = !!e
        }
        _GetInterval() {
            return typeof e.Battery != "undefined" && e.Battery.IsOnBatteryPower() ? this._intervalOnBattery : this._interval
        }
        Call(...o) {
            if (this._timerId !== -1) return;
            this._callbackArguments = o;
            let t = e.FastGetDateNow(),
                n = t - this._lastCallTime,
                s = this._GetInterval();
            n >= s && this._canRunImmediate ? (this._lastCallTime = t, this._RunCallback()) : this._timerId = self.setTimeout(this._timerCallFunc, Math.max(s - n, 4))
        }
        _RunCallback() {
            this._ignoreReset = !0;
            const e = this._callbackArguments;
            this._callbackArguments = null, e ? this._callback(...e) : this._callback(), this._ignoreReset = !1
        }
        Reset() {
            if (this._ignoreReset) return;
            this._CancelTimer(), this._callbackArguments = null, this._lastCallTime = e.FastGetDateNow()
        }
        _OnTimer() {
            this._timerId = -1, this._lastCallTime = e.FastGetDateNow(), this._RunCallback()
        }
        _CancelTimer() {
            this._timerId !== -1 && (self.clearTimeout(this._timerId), this._timerId = -1)
        }
        Release() {
            this._CancelTimer(), this._callback = null, this._callbackArguments = null, this._timerCallFunc = null
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.SVGRasterManager = class SVGRasterManager {
        constructor() {
            this._images = new Map, this._allowNpotSurfaces = !1, this._getBaseSizeCallback = null, this._rasterAtSizeCallback = null, this._releaseResultCallback = null, this._redrawCallback = null
        }
        SetNpotSurfaceAllowed(e) {
            this._allowNpotSurfaces = !!e
        }
        IsNpotSurfaceAllowed() {
            return this._allowNpotSurfaces
        }
        SetGetBaseSizeCallback(e) {
            this._getBaseSizeCallback = e
        }
        GetBaseSize(e) {
            if (!this._getBaseSizeCallback) throw new Error("no get base size callback set");
            return this._getBaseSizeCallback(e)
        }
        SetRasterAtSizeCallback(e) {
            this._rasterAtSizeCallback = e
        }
        RasterAtSize(e, t, n, s, o, i) {
            if (!this._rasterAtSizeCallback) throw new Error("no raster at size callback set");
            return this._rasterAtSizeCallback(e, t, n, s, o, i)
        }
        SetReleaseResultCallback(e) {
            this._releaseResultCallback = e
        }
        ReleaseResult(e) {
            if (!this._releaseResultCallback) throw new Error("no release result callback set");
            this._releaseResultCallback(e)
        }
        SetRedrawCallback(e) {
            this._redrawCallback = e
        }
        Redraw() {
            if (!this._redrawCallback) throw new Error("no redraw callback set");
            this._redrawCallback()
        }
        AddImage(t) {
            let n = this._images.get(t);
            return n || (n = e.New(e.SVGRasterImage, this, t), this._images.set(t, n)), n.IncReference(), n
        }
        _RemoveImage(e) {
            this._images.delete(e.GetDataSource())
        }
    }
}
"use strict";
{
    const t = self.C3,
        e = 2048;
    t.SVGRasterImage = class SVGRasterImage {
        constructor(e, t) {
            this._manager = e, this._dataSource = t, this._refCount = 0, this._baseWidth = 0, this._baseHeight = 0, this._getBaseSizePromise = this._manager.GetBaseSize(t).then(e => {
                this._baseWidth = e[0], this._baseHeight = e[1], this._manager.Redraw()
            }).catch(e => {
                console.error("[SVG] Error loading SVG: ", e), this._hadError = !0, this._manager.Redraw()
            }), this._rasterSurfaceWidth = 0, this._rasterSurfaceHeight = 0, this._rasterImageWidth = 0, this._rasterImageHeight = 0, this._isRasterizing = !1, this._rasterizedResult = null, this._forceRaster = !1, this._hadError = !1
        }
        Release() {
            if (this._refCount <= 0) throw new Error("already released");
            this._refCount--, this._refCount === 0 && this._Release()
        }
        _Release() {
            this._rasterizedResult && (this._manager.ReleaseResult(this._rasterizedResult), this._rasterizedResult = null), this._manager._RemoveImage(this), this._manager = null
        }
        GetDataSource() {
            return this._dataSource
        }
        IncReference() {
            this._refCount++
        }
        HasReferences() {
            return this._refCount > 0
        }
        GetRasterizedResult() {
            return this._rasterizedResult
        }
        ForceRasterAgain() {
            this._forceRaster = !0
        }
        async StartRasterForSize(n, s, o) {
            if (s === 0 || o === 0 || this._hadError) return;
            if (this._isRasterizing) return;
            let i = t.nextHighestPowerOfTwo(Math.ceil(s)),
                a = t.nextHighestPowerOfTwo(Math.ceil(o));
            const r = Math.max(i, a);
            if (r > e) {
                const t = e / r;
                s *= t, o *= t, i = Math.min(Math.ceil(i * t), e), a = Math.min(Math.ceil(a * t), e)
            }
            if (s < i && o < a) {
                const e = s / o,
                    t = i / a;
                t > e ? (s = a * e, o = a) : (s = i, o = i / e)
            }
            if (this._manager.IsNpotSurfaceAllowed() && (i = Math.ceil(s), a = Math.ceil(o)), i <= this._rasterSurfaceWidth && a <= this._rasterSurfaceHeight && !this._forceRaster) return;
            this._isRasterizing = !0, this._rasterSurfaceWidth = i, this._rasterSurfaceHeight = a;
            const c = await this._manager.RasterAtSize(this._dataSource, n, this._rasterSurfaceWidth, this._rasterSurfaceHeight, s, o);
            this._rasterizedResult && this._manager.ReleaseResult(this._rasterizedResult), this._rasterizedResult = c, this._rasterImageWidth = s, this._rasterImageHeight = o, this._isRasterizing = !1, this._forceRaster = !1, this._manager.Redraw()
        }
        WhenBaseSizeReady() {
            return this._getBaseSizePromise
        }
        GetBaseWidth() {
            return this._baseWidth
        }
        GetBaseHeight() {
            return this._baseHeight
        }
        GetRasterWidth() {
            return this._rasterImageWidth
        }
        GetRasterHeight() {
            return this._rasterImageHeight
        }
        HadError() {
            return this._hadError
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.UTF8_BOM = "";
    const o = new Set([..."0123456789"]);
    e.IsNumericChar = function(t) {
        return o.has(t)
    };
    const a = new Set([...` 	

 

`]);
    e.IsWhitespaceChar = function(t) {
        return a.has(t)
    }, e.FilterWhitespace = function(n) {
        return [...n].filter(t => !e.IsWhitespaceChar(t)).join("")
    }, e.IsStringAllWhitespace = function(n) {
        for (const t of n)
            if (!e.IsWhitespaceChar(t)) return !1;
        return !0
    }, e.IsUnprintableChar = function(t) {
        return t.length === 1 && t.charCodeAt(0) < 32
    }, e.FilterUnprintableChars = function(n) {
        return [...n].filter(t => !e.IsUnprintableChar(t)).join("")
    };
    const r = new Set([..."0123456789.+-e"]);
    e.IsStringNumber = function(t) {
        if (t = t.trim(), !t.length) return !1;
        let n = t.charAt(0);
        if (n !== "-" && !o.has(n)) return !1;
        for (let e of t)
            if (!r.has(e)) return !1;
        return !0
    }, e.RemoveTrailingDigits = function(n) {
        let s = n.length;
        for (; s > 0;) {
            let t = n.charAt(s - 1);
            if (!e.IsNumericChar(t)) break;
            --s
        }
        return n.substr(0, s)
    }, e.IncrementNumberAtEndOf = function(n) {
        let o = e.RemoveTrailingDigits(n),
            s = n.substr(o.length);
        return s ? s = (parseInt(s, 10) + 1).toString() : s = "2", o + s
    };
    const c = new Map([
        ["&", "&amp;"],
        ["<", "&lt;"],
        [">", "&gt;"],
        ['"', "&quot;"],
        ["'", "&#39;"]
    ]);

    function lookupHtmlEntity(e) {
        return c.get(e)
    }
    const l = /[&<>"']/g;
    e.EscapeHTML = function(t) {
        return t.replace(l, lookupHtmlEntity)
    }, e.EscapeJS = function(n) {
        let s = e.ReplaceAll(n, "\\", "\\\\");
        return s = e.ReplaceAll(s, '"', '\\"'), s = e.ReplaceAll(s, "	", "\\t"), s = e.ReplaceAll(s, `
`, ""), e.ReplaceAll(s, `
`, `\\n`)
    }, e.EscapeXML = function(n) {
        let s = e.ReplaceAll(n, "&", "&amp;");
        return s = e.ReplaceAll(s, "<", "&lt;"), s = e.ReplaceAll(s, ">", "&gt;"), e.ReplaceAll(s, '"', "&quot;")
    };
    const d = /[-[\]{}()*+?.,\\^$|#\s]/g;
    e.EscapeRegex = function(t) {
        return t.replace(d, "\\$&")
    }, e.FindAll = function(t, n, s = !1) {
        if (!n) return [];
        s || (t = t.toLowerCase(), n = n.toLowerCase());
        const r = n.length;
        let i = 0,
            o = 0,
            a = [];
        for (;
            (o = t.indexOf(n, i)) > -1;) a.push(o), i = o + r;
        return a
    }, e.ReplaceAll = function(t, n, s) {
        return t.replaceAll(n, () => s)
    }, e.ReplaceAllCaseInsensitive = function(n, s, o) {
        return n.replace(new RegExp(e.EscapeRegex(s), "gi"), () => o)
    }, e.SetElementContent = function(n, s) {
        typeof s == "string" ? n.textContent = s : s.isPlainText() ? n.textContent = s.toString() : (n.innerHTML = s.toHTML(), s instanceof e.BBString && s.attachLinkHandlers(n))
    }, e.StringLikeEquals = function(n, s) {
        return n instanceof e.HtmlString || n instanceof e.BBString ? n.equals(s) : s instanceof e.HtmlString || s instanceof e.BBString ? s.equals(n) : n === s
    }, e.StringSubstitute = function(t, ...n) {
        let e = t;
        for (let s = 0, i = n.length; s < i; ++s) {
            const o = `{${s}}`;
            if (!t.includes(o)) throw new Error(`missing placeholder '${o}' in string substitution`);
            e = e.replace(o, n[s].toString())
        }
        return e
    }, e.StringSubstituteAllowMissing = function(s, ...o) {
        let t = s,
            e = -1,
            n = -1;
        for (let i = 0, r = o.length; i < r; ++i) {
            const a = `{${i}}`;
            s.includes(a) ? (n = i, t = t.replace(a, o[i].toString())) : e === -1 && (e = i)
        }
        if (e >= 0 && n >= 0 && e < n) throw new Error(`missing placeholder '${e}' in string substitution`);
        return t
    }, e.StringSubstituteMap = function(t, n) {
        let s = t;
        for (let [e, t] of Object.entries(n)) s = s.replaceAll(e, t.toString());
        return s
    }, e.SortAZCaseInsensitive = function(t, n) {
        let s = t.toLowerCase(),
            o = n.toLowerCase();
        return s > o ? 1 : s < o ? -1 : 0
    };
    const t = 1024,
        n = t * 1024,
        s = n * 1024,
        i = s * 1024;
    e.FormatDataSize = function(o, a) {
        let c = "common." + (a ? "dataRates" : "dataSizes") + ".";
        const l = self.langSub;
        if (o < t) return l(c + "bytes", o);
        if (o < n) {
            let e = o / t;
            return e < 10 ? e = Math.round(e * 10) / 10 : e = Math.round(e), l(c + "kilobytes", e)
        }
        if (o < s) {
            let e = o / n;
            return e < 10 ? e = Math.round(e * 10) / 10 : e = Math.round(e), l(c + "megabytes", e)
        }
        if (o < i) {
            let e = o / s;
            return e < 10 ? e = Math.round(e * 10) / 10 : e = Math.round(e), l(c + "gigabytes", e)
        }
        let r = o / i;
        return r < 10 ? r = Math.round(r * 10) / 10 : r = Math.round(r), l(c + "terabytes", r)
    };
    const u = {
        approximate: !1,
        days: !0,
        hours: !0,
        minutes: !0,
        seconds: !0
    };
    e.FormatTime = function(n, s) {
        s = Object.assign({}, u, s), e.Lang.PushContext("common.time");
        const o = [],
            a = self.lang,
            i = self.langPluralSub;
        if (s.days) {
            const e = Math.floor(n / (24 * 3600));
            e > 0 && (n -= e * 24 * 3600, o.push(i(".days", null, e)))
        }
        if (s.hours) {
            const e = Math.floor(n / 3600);
            (e > 0 || o.length) && (n -= e * 3600, o.push(i(".hours", null, e)))
        }
        if (s.minutes) {
            const e = Math.floor(n / 60);
            (e > 0 || o.length || !s.seconds) && (n -= e * 60, o.push(i(".minutes", null, e)))
        }
        if (s.seconds) {
            const e = Math.floor(n % 60);
            o.push(i(".seconds", null, e))
        }
        const r = (s.approximate ? a(".approx-prefix") : "") + o.join(a(".separator"));
        return e.Lang.PopContext(), r
    }, e.ZeroPad = function(e, t) {
        let n = e < 0 ? "-" : "";
        e = Math.abs(e);
        let s = e.toString(),
            o = t - s.length;
        for (let e = 0; e < o; ++e) n += "0";
        return n + s
    }, e.StringToTitleCase = function(t) {
        return t.toLowerCase().replace(/\b\w/g, e => e.toUpperCase())
    }, e.CompareVersionStrings = function(n, s) {
        let o = n.split(".").map(e => e.trim()),
            i = s.split(".").map(e => e.trim());
        e.resizeArray(o, 4, "0"), e.resizeArray(i, 4, "0"), o = o.map(e => parseInt(e, 10)), i = i.map(e => parseInt(e, 10));
        for (let e = 0; e < 4; ++e) {
            const t = o[e] - i[e];
            if (t !== 0) return t < 0 ? -1 : 1
        }
        return 0
    }, e.CreateGUID = function() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, e => {
            const t = Math.floor(Math.random() * 16),
                n = e === "x" ? t : t & 3 | 8;
            return n.toString(16)
        })
    }, e.StringHammingDistance = function(t, n) {
        if (t.length !== n.length) throw new Error("strings must be same length");
        let s = 0;
        for (let e = 0, o = t.length; e < o; ++e) t.charAt(e) !== n.charAt(e) && ++s;
        return s
    }, e.StringLevenshteinDistance = function(t, n) {
        if (t.length === 0) return n.length;
        if (n.length === 0) return t.length;
        let c, s, o, a, r, i;
        t.length > n.length && (c = t, t = n, n = c), i = Array(t.length + 1);
        for (s = 0; s <= t.length; s++) i[s] = s;
        for (s = 1; s <= n.length; s++) {
            a = s;
            for (o = 1; o <= t.length; o++) n[s - 1] === t[o - 1] ? r = i[o - 1] : r = Math.min(i[o - 1] + 1, Math.min(a + 1, i[o] + 1)), i[o - 1] = a, a = r;
            i[t.length] = a
        }
        return i[t.length]
    }
}
"use strict";
{
    const e = self.C3,
        r = self.assert,
        i = new Map([
            ["b", "strong"],
            ["i", "em"],
            ["s", "s"],
            ["u", "u"],
            ["sub", "sub"],
            ["sup", "sup"],
            ["small", "small"],
            ["mark", "mark"],
            ["a1", "a"],
            ["a2", "a"],
            ["a3", "a"],
            ["a4", "a"],
            ["a5", "a"],
            ["a6", "a"],
            ["a7", "a"],
            ["a8", "a"],
            ["a9", "a"],
            ["bad", ["span", "bbCodeBad"]],
            ["good", ["span", "bbCodeGood"]],
            ["info", ["span", "bbCodeInfo"]],
            ["h1", ["span", "bbCodeH1"]],
            ["h2", ["span", "bbCodeH2"]],
            ["h3", ["span", "bbCodeH3"]],
            ["h4", ["span", "bbCodeH4"]],
            ["item", ["span", "bbCodeItem"]]
        ]),
        s = /\[(\/?)([a-zA-Z0-9]+)\]/g,
        n = /\[(\/?)([^[]*?)\]/g;
    let t = null,
        o = 0;

    function bbToHtmlReplacerFunc(e, n, s) {
        const a = i.get(s);
        if (a)
            if (typeof a == "string")
                if (a === "a" && !n) {
                    const e = parseInt(s.substring(1), 10) - 1;
                    if (e < 0 || e >= t.length) throw new Error("invalid bbcode link substitution");
                    const n = t[e];
                    if (typeof n == "string") return `<a href="${t[e]}">`;
                    if (typeof n == "function") return `<a class="bblink${e}">`;
                    throw new TypeError("invalid bbcode link action")
                } else return "<" + n + a + ">";
        else if (Array.isArray(a)) {
            let e = a[0],
                t = a[1];
            return n ? "</" + e + ">" : `<${e} class="${t}">`
        } else return s === "class" ? n ? "</span>" : `<span class="bbclass${o++}">` : e
    }
    const a = /\n/g;
    e.BBString = class BBString {
        constructor(t, n) {
            if (this._bbstr = n && n.noEscape ? t : e.EscapeHTML(t), this._htmlstr = "", this._convertLineBreaks = !1, this._linkActions = [], n && (this._convertLineBreaks = !!n.convertLineBreaks, n.links)) {
                if (n.links.length > 9) throw new Error("too many links");
                this._linkActions = n.links
            }
            this._hasAnyBBtags = this._bbstr.includes("["), this._needsLineBreakConversion = this._convertLineBreaks && this._bbstr.includes(`
`), this._isPlain = !this._hasAnyBBtags && !this._needsLineBreakConversion && !this._bbstr.includes("&"), this._hasParsedFragments = !1, this._fragments = []
        }
        toString() {
            return this._bbstr
        }
        valueOf() {
            return this._bbstr
        }
        isPlainText() {
            return this._isPlain
        }
        toPlainText() {
            return this._hasAnyBBtags ? this._bbstr.replace(s, "") : this._bbstr
        }
        toHTML() {
            if (this._isPlain) return this._bbstr;
            if (!this._htmlstr && this._bbstr) {
                let e = this._bbstr;
                this._hasAnyBBtags && (o = 0, t = this._linkActions, e = e.replace(s, bbToHtmlReplacerFunc), t = null), this._needsLineBreakConversion && (e = e.replace(a, "<br>")), this._htmlstr = e
            }
            return this._htmlstr
        }
        attachLinkHandlers(e) {
            if (!this._linkActions.length) return;
            for (let t = 0, o = this._linkActions.length; t < o; ++t) {
                const n = this._linkActions[t];
                if (typeof n != "function") continue;
                const s = e.querySelector(".bblink" + t);
                if (!s) throw new Error("unable to attach BBString link handler");
                s.onclick = n
            }
        }
        equals(t) {
            return t instanceof e.HtmlString ? this.toHTML() === t.toHTML() : t instanceof e.BBString ? this._bbstr === t._bbstr : this._bbstr === t
        }
        toFragmentList() {
            if (this._hasParsedFragments) return this._fragments;
            const t = this._bbstr,
                e = [];
            n.lastIndex = 0;
            let o = 0,
                s = null;
            for (;
                (s = n.exec(t)) !== null;) {
                const i = s.index;
                if (i > 0 && t.charAt(i - 1) === "\\") continue;
                const r = s[0],
                    c = s[1],
                    n = s[2],
                    a = t.substring(o, i);
                if (o = i + r.length, a && this._fragments.push({
                        text: a,
                        styles: e.slice(0)
                    }), !n) continue;
                if (c) {
                    {
                        const t = n.toLowerCase();
                        for (let n = e.length - 1; n >= 0; --n)
                            if (e[n].tag === t) {
                                e.splice(n, 1);
                                break
                            }
                    }
                } else {
                    let t = n,
                        o = null;
                    const s = n.indexOf("=");
                    s !== -1 ? (t = n.substring(0, s).toLowerCase(), o = n.substring(s + 1)) : t = t.toLowerCase(), e.push({
                        tag: t,
                        param: o
                    })
                }
            }
            o < t.length && this._fragments.push({
                text: t.substring(o),
                styles: e.slice(0)
            });
            for (const e of this._fragments) e.text = this._ProcessBBCodeEscapeSequences(e.text);
            return this._hasParsedFragments = !0, this._fragments
        }
        _ProcessBBCodeEscapeSequences(t) {
            return t = e.ReplaceAll(t, "\\[", "["), e.ReplaceAll(t, "\\\\", "\\")
        }
        static StripTags(t) {
            return e.New(e.BBString, t, {
                noEscape: !0
            }).toPlainText()
        }
        static StripAnyTags(e) {
            return e.replace(n, "")
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.WordWrap = class WordWrap {
        constructor() {
            this._lines = []
        }
        GetLines() {
            return this._lines
        }
        GetLineCount() {
            return this._lines.length
        }
        _MeasureLine(e, t) {
            let s = 0,
                n = 0;
            for (const o of e) {
                if (o.width === -1) {
                    const e = t(o.text, o.styles);
                    o.width = e.width, o.height = e.height
                }
                s += o.width, n = Math.max(n, o.height)
            }
            return {
                width: s,
                height: n
            }
        }
        _AddLine(e, t, n) {
            this._lines.push({
                fragments: e,
                width: t,
                height: n
            })
        }
        WordWrap(t, n, s, o, i) {
            if (typeof t == "string" && (t = [{
                    text: t,
                    styles: []
                }]), e.clearArray(this._lines), !t.length || t.length === 1 && !t[0].text.length || s < 2) return;
            if (t.length === 1) {
                const o = t[0],
                    e = o.text,
                    a = o.styles;
                if (e.length <= 100 && !e.includes(`
`)) {
                    let {
                        width: t,
                        height: o
                    } = n(e, a);
                    if (t += i, t <= s) {
                        this._AddLine([{
                            text: e,
                            styles: a,
                            width: t,
                            height: o
                        }], t, o);
                        return
                    }
                }
            }
            let a;
            if (o === "word") a = this._TokeniseWords(t);
            else {
                a = [];
                for (const n of t) e.appendArray(a, [...n.text].map(e => [{
                    text: e,
                    styles: n.styles
                }]))
            }
            this._WrapText(a, n, s, i)
        }
        _TokeniseWords(t) {
            const s = [];
            let n = [],
                o = !1;
            for (const a of t) {
                const r = a.text,
                    i = a.styles;
                for (const t of r)
                    if (t === `
`) n.length > 0 && s.push(n), s.push([{
                        text: `
`,
                        styles: i
                    }]), n = [];
                    else if (n.length === 0) n.push({
                    text: t,
                    styles: i
                }), o = e.IsWhitespaceChar(t);
                else {
                    const a = e.IsWhitespaceChar(t);
                    if (a === o) {
                        const e = n[n.length - 1];
                        e.styles === i ? e.text += t : n.push({
                            text: t,
                            styles: i
                        })
                    } else s.push(n), n = [], n.push({
                        text: t,
                        styles: i
                    }), o = a
                }
            }
            return n.length > 0 && s.push(n), s
        }
        _CopyLine(e) {
            return e.map(e => ({
                text: e.text,
                styles: e.styles,
                width: e.width,
                height: e.height
            }))
        }
        _AddWordToLine(e, t) {
            const n = e.length ? e[e.length - 1] : null;
            let s = 0;
            n && t[0].styles === n.styles && (n.text += t[0].text, n.width = -1, n.height = -1, s = 1);
            for (let o = t.length; s < o; ++s) {
                const n = t[s];
                e.push({
                    text: n.text,
                    styles: n.styles,
                    width: -1,
                    height: -1
                })
            }
        }
        _WrapText(t, n, s, o) {
            let i = [],
                r = 0,
                a = 0;
            for (const o of t) {
                if (o.length === 1 && o[0].text === `
`) {
                    a === 0 && (a = n(" ", o[0].styles).height), this._AddLine(i, r, a), i = [], r = 0, a = 0;
                    continue
                }
                const c = this._CopyLine(i);
                this._AddWordToLine(c, o);
                const l = this._MeasureLine(c, n),
                    d = l.width,
                    u = l.height;
                if (d >= s)
                    if (i.length > 0 && this._AddLine(i, r, a), i = [], e.IsStringAllWhitespace(o[0].text)) r = 0, a = 0;
                    else {
                        this._AddWordToLine(i, o);
                        const e = this._MeasureLine(i, n);
                        r = e.width, a = e.height
                    }
                else i = c, r = d, a = u
            }
            i.length > 0 && this._AddLine(i, r, a), this._TrimLinesTrailingWhitespace(n, o)
        }
        _TrimLinesTrailingWhitespace(e, t) {
            for (const o of this._lines) {
                const s = o.fragments;
                if (!s.length) continue;
                let n = s[s.length - 1];
                const a = n.text,
                    i = a.trimEnd();
                if (i) {
                    if (i.length < a.length) {
                        const t = e(i, n.styles).width,
                            s = n.width - t;
                        n.width = t, n.text = i, o.width -= s
                    }
                } else o.width -= n.width, s.pop();
                t !== 0 && s.length > 0 && (n = s[s.length - 1], n.width += t, o.width += t)
            }
        }
        Clear() {
            e.clearArray(this._lines)
        }
        GetMaxLineWidth() {
            return this._lines.reduce((e, t) => Math.max(e, t.width), 0)
        }
        GetTotalLineHeight() {
            return this._lines.reduce((e, t) => e + t.height, 0)
        }
    }
}
"use strict", self.C3.Gfx = {}, "use strict";
{
    const s = self.C3,
        a = 1,
        r = 1e4,
        e = [0, 0, 0, 0, 0, 0, 0, 0],
        i = self.glMatrix,
        o = i.vec3,
        t = i.mat4,
        n = o.fromValues(0, 0, 0);
    s.Gfx.RendererBase = class RendererBase {
        constructor() {
            this._width = 0, this._height = 0, this._cam = o.fromValues(0, 0, 100), this._look = o.fromValues(0, 0, 0), this._up = o.fromValues(0, 1, 0), this._worldScale = o.fromValues(1, 1, 1), this._matP = t.create(), this._matMV = t.create(), this._lastMV = t.create(), this._allShaderPrograms = [], this._shaderProgramsByName = new Map, this._spTextureFill = null, this._stateGroups = new Map, this._currentStateGroup = null, this._blendModeTable = [], this._namedBlendModeMap = new Map, this._frameNumber = 0, this._enableMipmaps = !0
        }
        FillIndexBufferData(e) {
            let t = 0,
                s = e.length,
                n = 0;
            for (; t < s;) e[t++] = n, e[t++] = n + 1, e[t++] = n + 2, e[t++] = n, e[t++] = n + 2, e[t++] = n + 3, n += 4
        }
        Project(t, n, s, o, i) {
            const a = this._matMV,
                r = this._matP;
            for (let t = 0, n = e.length; t < n; ++t) e[t] = 0;
            if (e[0] = a[0] * t + a[4] * n + a[12], e[1] = a[1] * t + a[5] * n + a[13], e[2] = a[2] * t + a[6] * n + a[14], e[3] = a[3] * t + a[7] * n + a[15], e[4] = r[0] * e[0] + r[4] * e[1] + r[8] * e[2] + r[12] * e[3], e[5] = r[1] * e[0] + r[5] * e[1] + r[9] * e[2] + r[13] * e[3], e[6] = r[2] * e[0] + r[6] * e[1] + r[10] * e[2] + r[14] * e[3], e[7] = -e[2], e[7] === 0) return;
            e[7] = 1 / e[7], e[4] *= e[7], e[5] *= e[7], e[6] *= e[7], i[0] = (e[4] * .5 + .5) * s, i[1] = (e[5] * .5 + .5) * o
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        GetNearZ() {
            return a
        }
        GetFarZ() {
            return r
        }
        SetCameraXYZ(e, t, n) {
            this._cam[0] = e * this._worldScale[0], this._cam[1] = t * this._worldScale[1], this._cam[2] = n
        }
        SetLookXYZ(e, t, n) {
            this._look[0] = e * this._worldScale[0], this._look[1] = t * this._worldScale[1], this._look[2] = n
        }
        ResetModelView(e) {
            t.lookAt(this._matMV, this._cam, this._look, e || this._up), t.scale(this._matMV, this._matMV, this._worldScale)
        }
        Translate(e, s) {
            if (e === 0 && s === 0) return;
            n[0] = e, n[1] = s, n[2] = 0, t.translate(this._matMV, this._matMV, n)
        }
        Scale(e, s) {
            if (e === 1 && s === 1) return;
            n[0] = e, n[1] = s, n[2] = 1, t.scale(this._matMV, this._matMV, n)
        }
        RotateZ(e) {
            if (e === 0) return;
            t.rotateZ(this._matMV, this._matMV, e)
        }
        _AddShaderProgram(e) {
            this._allShaderPrograms.push(e), this._shaderProgramsByName.set(e.GetName(), e)
        }
        _RemoveShaderProgram(e) {
            const t = this._allShaderPrograms.indexOf(e);
            t !== -1 && this._allShaderPrograms.splice(t, 1), this._shaderProgramsByName.delete(e.GetName())
        }
        _ClearAllShaderPrograms() {
            s.clearArray(this._allShaderPrograms), this._shaderProgramsByName.clear()
        }
        GetShaderProgramByName(e) {
            return this._shaderProgramsByName.get(e) || null
        }
        GetTextureFillShaderProgram() {
            return this._spTextureFill
        }
        _SetCurrentStateGroup(e) {
            this._currentStateGroup = e
        }
        GetCurrentStateGroup() {
            return this._currentStateGroup
        }
        AcquireStateGroup(e, t, n, o) {
            const a = s.Gfx.StateGroup.MakeKey(e, t, n, o);
            let i = this._stateGroups.get(a);
            return i || (i = s.New(s.Gfx.StateGroup, this, e, t, n, o), this._stateGroups.set(a, i)), i.AddRef(), i
        }
        ReleaseStateGroup(e) {
            e.DecRef(), e._GetRefCount() === 0 && (this._currentStateGroup === e && (this._currentStateGroup = null), this._stateGroups.delete(e.GetKey()), e.Release())
        }
        _InitBlendModeData(e) {
            s.clearArray(this._blendModeTable), this._namedBlendModeMap.clear();
            for (const t of e) {
                const o = t[0],
                    n = t[1],
                    s = t[2];
                this._blendModeTable.push([n, s]), this._namedBlendModeMap.set(o, {
                    srcBlend: n,
                    destBlend: s
                })
            }
        }
        _GetBlendByIndex(e) {
            return this._blendModeTable[e]
        }
        GetSrcBlendByIndex(e) {
            return this._GetBlendByIndex(e)[0]
        }
        GetDestBlendByIndex(e) {
            return this._GetBlendByIndex(e)[1]
        }
        GetNamedBlend(e) {
            const t = this._namedBlendModeMap.get(e);
            if (typeof t == "undefined") throw new Error("invalid blend name");
            return t
        }
        Finish() {
            this.EndBatch(), this._frameNumber++
        }
        GetFrameNumber() {
            return this._frameNumber
        }
        IncrementFrameNumber() {
            this._frameNumber++
        }
        SetMipmapsEnabled(e) {
            this._enableMipmaps = !!e
        }
        AreMipmapsEnabled() {
            return this._enableMipmaps
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Gfx.StateGroup = class StateGroup {
        constructor(t, n, s, o, i) {
            this._renderer = t, this._refCount = 0, this._shaderProgram = null, this._shaderProgramName = "", this._blendMode = s, this._color = e.New(e.Color), this._color.set(o), this._zElevation = i, typeof n == "string" ? this._shaderProgramName = n : (this._shaderProgram = n, this._shaderProgramName = this._shaderProgram.GetName())
        }
        Release() {
            if (this._refCount > 0) throw new Error("releasing state group still in use");
            this._renderer = null, this._shaderProgram = null, this._shaderProgramName = ""
        }
        Apply() {
            const e = this._renderer;
            e.SetProgram(this._shaderProgram), e.SetBlendMode(this._blendMode), e.SetColor(this._color), e.SetCurrentZ(this._zElevation), e._SetCurrentStateGroup(this)
        }
        GetKey() {
            return e.Gfx.StateGroup.MakeKey(this._shaderProgramName, this._blendMode, this._color, this._zElevation)
        }
        AddRef() {
            ++this._refCount
        }
        DecRef() {
            --this._refCount
        }
        _GetRefCount() {
            return this._refCount
        }
        OnContextLost() {
            this._shaderProgram = null
        }
        OnContextRestored(e) {
            if (this._shaderProgram = e.GetShaderProgramByName(this._shaderProgramName), !this._shaderProgram) throw new Error("failed to restore shader program")
        }
        static MakeKey(e, t, n, s) {
            const o = typeof e == "string" ? e : e.GetName();
            return o + "," + t + "," + n.getR() + "," + n.getG() + "," + n.getB() + "," + n.getA() + "," + s
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = e.New(e.Quad),
        n = e.New(e.Quad);

    function interpolateQuad(e, t, n) {
        const s = n.getTlx(),
            o = n.getTly(),
            i = n.getTrx() - s,
            a = n.getTry() - o,
            r = n.getBlx() - s,
            c = n.getBly() - o,
            l = i * e,
            d = a * e,
            u = r * t,
            h = c * t;
        return [s + l + u, o + d + h]
    }
    class s {
        constructor(e) {
            this._mesh = e, this._x = NaN, this._y = NaN, this._u = NaN, this._v = NaN, this._x = 0, this._y = 0, this._u = 0, this._v = 0
        }
        _Init(e, t, n, s) {
            this._x = e, this._y = t, this._u = n, this._v = s
        }
        GetX() {
            return this._x
        }
        SetX(e) {
            if (this._x === e) return;
            this._x = e, this._mesh._SetPointsChanged()
        }
        GetY() {
            return this._y
        }
        SetY(e) {
            if (this._y === e) return;
            this._y = e, this._mesh._SetPointsChanged()
        }
        GetU() {
            return this._u
        }
        SetU(e) {
            this._u = e
        }
        GetV() {
            return this._v
        }
        SetV(e) {
            this._v = e
        }
        _Interpolate_TexRect(t, n, s) {
            [this._x, this._y] = interpolateQuad(t._x, t._y, n), this._u = e.lerp(s.getLeft(), s.getRight(), t._u), this._v = e.lerp(s.getTop(), s.getBottom(), t._v)
        }
        _Interpolate_TexQuad(e, t, n) {
            [this._x, this._y] = interpolateQuad(e._x, e._y, t), [this._u, this._v] = interpolateQuad(e._u, e._v, n)
        }
    }
    e.Gfx.Mesh = class Mesh {
        constructor(t, n) {
            if (t < 2 || n < 2) throw new Error("invalid mesh size");
            this._hsize = t, this._vsize = n, this._pts = [], this._minX = 0, this._minY = 0, this._maxX = 1, this._maxY = 1, this._pointsChanged = !1;
            const o = t - 1,
                i = n - 1;
            for (let a = 0; a < n; ++a) {
                const r = [];
                for (let n = 0; n < t; ++n) {
                    const c = e.New(s, this),
                        l = n / o,
                        d = a / i;
                    c._Init(l, d, l, d), r.push(c)
                }
                this._pts.push(r)
            }
        }
        Release() {
            e.clearArray(this._pts)
        }
        GetHSize() {
            return this._hsize
        }
        GetVSize() {
            return this._vsize
        }
        _SetPointsChanged() {
            this._pointsChanged = !0
        }
        _MaybeComputeBounds() {
            if (!this._pointsChanged) return;
            let e = 1 / 0,
                t = 1 / 0,
                n = -(1 / 0),
                s = -(1 / 0);
            for (const o of this._pts)
                for (const i of o) {
                    const a = i.GetX(),
                        r = i.GetY();
                    e = Math.min(e, a), t = Math.min(t, r), n = Math.max(n, a), s = Math.max(s, r)
                }
            this._minX = e, this._minY = t, this._maxX = n, this._maxY = s, this._pointsChanged = !1
        }
        GetMinX() {
            return this._MaybeComputeBounds(), this._minX
        }
        GetMinY() {
            return this._MaybeComputeBounds(), this._minY
        }
        GetMaxX() {
            return this._MaybeComputeBounds(), this._maxX
        }
        GetMaxY() {
            return this._MaybeComputeBounds(), this._maxY
        }
        GetMeshPointAt(e, t) {
            return e = Math.floor(e), t = Math.floor(t), e < 0 || e >= this._hsize || t < 0 || t >= this._vsize ? null : this._pts[t][e]
        }
        CalculateTransformedMesh(t, n, s) {
            const i = s instanceof e.Rect;
            if (t.GetHSize() !== this.GetHSize() || t.GetVSize() !== this.GetVSize()) throw new Error("source mesh wrong size");
            const a = t._pts,
                o = this._pts;
            for (let e = 0, r = o.length; e < r; ++e) {
                const c = a[e],
                    t = o[e];
                for (let e = 0, r = t.length; e < r; ++e) {
                    const o = c[e],
                        a = t[e];
                    i ? a._Interpolate_TexRect(o, n, s) : a._Interpolate_TexQuad(o, n, s)
                }
            }
        }
        Draw(e) {
            const s = this._pts;
            let o = s[0];
            for (let c = 1, l = s.length; c < l; ++c) {
                const r = s[c];
                let i = o[0],
                    a = r[0];
                for (let l = 1, d = r.length; l < d; ++l) {
                    const s = o[l],
                        c = r[l];
                    t.set(i.GetX(), i.GetY(), s.GetX(), s.GetY(), c.GetX(), c.GetY(), a.GetX(), a.GetY()), n.set(i.GetU(), i.GetV(), s.GetU(), s.GetV(), c.GetU(), c.GetV(), a.GetU(), a.GetV()), e.Quad4(t, n), i = s, a = c
                }
                o = r
            }
        }
        Outline(e) {
            const t = this._pts;
            let n = t[0];
            for (let s = 1, r = t.length; s < r; ++s) {
                const o = t[s];
                let i = n[0],
                    a = o[0];
                for (let t = 1, f = o.length; t < f; ++t) {
                    const c = n[t],
                        l = o[t],
                        d = i.GetX(),
                        u = i.GetY(),
                        p = c.GetX(),
                        g = c.GetY(),
                        h = l.GetX(),
                        m = l.GetY(),
                        v = a.GetX(),
                        b = a.GetY();
                    e.Line(d, u, p, g), e.Line(d, u, h, m), e.Line(d, u, v, b), t === f - 1 && e.Line(p, g, h, m), s === r - 1 && e.Line(v, b, h, m), i = c, a = l
                }
                n = o
            }
        }
        InsertPolyMeshVertices(t) {
            const f = .001,
                h = 0,
                m = .99999999,
                a = t.pointsArr(),
                v = [],
                b = this.GetHSize() - 1,
                g = this.GetVSize() - 1,
                A = 1 / b,
                _ = 1 / g,
                y = b - 1,
                j = g - 1;
            let o = a[0],
                s = a[1],
                l = e.clamp(Math.floor(o * b), 0, y),
                r = e.clamp(Math.floor(s * g), 0, j),
                c = !0,
                u = 0,
                d = 0,
                n = 0;
            const k = -1,
                w = 0,
                O = 1,
                x = 2,
                C = 3,
                E = 4;
            let i = k;
            const p = () => {
                o = e.clamp(e.lerp(o, u, n), 0, 1), s = e.clamp(e.lerp(s, d, n), 0, 1), v.push(o, s)
            };
            for (let t = 0, S = a.length; t < S; t += 2) {
                o = a[t], s = a[t + 1], v.push(o, s), l = e.clamp(Math.floor(o * b), 0, y), r = e.clamp(Math.floor(s * g), 0, j);
                const M = (t + 2) % S;
                for (u = a[M], d = a[M + 1], i = k; !0;) {
                    if (v.length > 1e6) throw new Error("Too many mesh poly points");
                    const g = l * A,
                        t = r * _,
                        a = (l + 1) * A,
                        b = (r + 1) * _;
                    if (c = e.isPointInTriangleInclusive(o, s, g, t, a, t, a, b), i !== w && (n = e.rayIntersectExtended(o, s, u, d, g, t, a, b, -f), n >= h && n <= m)) {
                        p(), c = !c, i = w;
                        continue
                    }
                    if (r > 0 && i !== x && (n = e.rayIntersectExtended(o, s, u, d, g, t, a, t, f), n >= h && n <= m)) {
                        p(), r--, c = !1, i = E;
                        continue
                    }
                    if (l < y && i !== C && (n = e.rayIntersectExtended(o, s, u, d, a, t, a, b, f), n >= h && n <= m)) {
                        p(), l++, c = !1, i = O;
                        continue
                    }
                    if (l > 0 && i !== O && (n = e.rayIntersectExtended(o, s, u, d, g, t, g, b, f), n >= h && n <= m)) {
                        p(), l--, c = !0, i = C;
                        continue
                    }
                    if (r < j && i !== E && (n = e.rayIntersectExtended(o, s, u, d, g, b, a, b, f), n >= h && n <= m)) {
                        p(), r++, c = !0, i = x;
                        continue
                    }
                    break
                }
            }
            return e.New(e.CollisionPoly, v)
        }
        TransformCollisionPoly(e, t) {
            const n = this._TransformPolyPoints(e);
            this._SimplifyPoly(n), t.setPoints(n)
        }
        _TransformPolyPoints(e) {
            const n = [],
                t = e.pointsArr();
            for (let e = 0, s = t.length; e < s; e += 2) {
                const o = t[e],
                    i = t[e + 1],
                    [a, r] = this.TransformPoint(o, i);
                n.push(a, r)
            }
            return n
        }
        TransformPoint(t, n) {
            const h = this.GetHSize() - 1,
                d = this.GetVSize() - 1,
                l = 1 / h,
                c = 1 / d,
                s = e.clamp(Math.floor(t * h), 0, h - 1),
                i = e.clamp(Math.floor(n * d), 0, d - 1),
                r = s * l,
                o = i * c,
                u = (s + 1) * l,
                p = (i + 1) * c,
                m = this.GetMeshPointAt(s, i),
                f = this.GetMeshPointAt(s + 1, i + 1),
                a = e.isPointInTriangleInclusive(t, n, r, o, u, o, u, p),
                v = a ? r + l : r,
                b = a ? o : o + c,
                g = this.GetMeshPointAt(s + (a ? 1 : 0), i + (a ? 0 : 1)),
                [j, y, _] = e.triangleCartesianToBarycentric(t, n, r, o, v, b, u, p);
            return e.triangleBarycentricToCartesian(j, y, _, m.GetX(), m.GetY(), g.GetX(), g.GetY(), f.GetX(), f.GetY())
        }
        _SimplifyPoly(t) {
            const r = [],
                n = 1e-7;
            let s = t[0],
                o = t[1],
                i = s - t[t.length - 2],
                a = o - t[t.length - 1];
            for (let l = 0, d = t.length; l < d; l += 2) {
                const u = (l + 2) % d,
                    h = t[u],
                    m = t[u + 1],
                    e = h - s,
                    c = m - o,
                    f = Math.abs(e) < n && Math.abs(i) < n && Math.sign(c) === Math.sign(a),
                    p = Math.abs(c) < n && Math.abs(a) < n && Math.sign(e) === Math.sign(i);
                (!f && !p && Math.abs(e / i - c / a) > n || e == 0 && c === 0) && r.push(s, o), s = h, o = m, i = e, a = c
            }
            r.length < t.length && e.shallowAssignArray(t, r)
        }
    }
}
"use strict";
{
    const e = self.C3,
        s = new Set(["rgba8", "rgb8", "rgba4", "rgb5_a1", "rgb565"]),
        o = new Set(["nearest", "bilinear", "trilinear"]),
        i = new Set(["default", "low", "high"]),
        n = new Set(["clamp-to-edge", "repeat", "mirror-repeat"]);

    function GetFormatSpecifiers(e, t) {
        let n, s, o, i;
        switch (e) {
            case "rgba8":
                n = t.RGBA8, s = t.RGBA, o = t.RGBA, i = t.UNSIGNED_BYTE;
                break;
            case "rgb8":
                n = t.RGB8, s = t.RGB, o = t.RGB, i = t.UNSIGNED_BYTE;
                break;
            case "rgba4":
                n = t.RGBA4, s = t.RGBA, o = t.RGBA, i = t.UNSIGNED_SHORT_4_4_4_4;
                break;
            case "rgb5_a1":
                n = t.RGB5_A1, s = t.RGBA, o = t.RGBA, i = t.UNSIGNED_SHORT_5_5_5_1;
                break;
            case "rgb565":
                n = t.RGB565, s = t.RGB, o = t.RGB, i = t.UNSIGNED_SHORT_5_6_5;
                break;
            default:
                throw new Error("invalid pixel format")
        }
        return {
            sizedinternalformat: n,
            internalformat: s,
            format: o,
            type: i
        }
    }
    const a = {
            wrapX: "clamp-to-edge",
            wrapY: "clamp-to-edge",
            sampling: "trilinear",
            pixelFormat: "rgba8",
            mipMap: !0,
            mipMapQuality: "default",
            premultiplyAlpha: !0,
            isSvg: !1,
            width: -1,
            height: -1
        },
        r = {
            premultiplyAlpha: !0,
            flipY: !1
        },
        t = new Set;
    e.Gfx.WebGLRendererTexture = class WebGLRendererTexture {
        constructor(e) {
            this._renderer = e, this._texture = null, this._width = 0, this._height = 0, this._isStatic = !0, this._wrapX = "clamp-to-edge", this._wrapY = "clamp-to-edge", this._sampling = "trilinear", this._pixelFormat = "rgba8", this._isMipMapped = !1, this._mipMapQuality = "default", this._refCount = 0
        }
        _CreateStatic(r, c) {
            if ((typeof HTMLImageElement == "undefined" || !(r instanceof HTMLImageElement)) && (typeof HTMLCanvasElement == "undefined" || !(r instanceof HTMLCanvasElement)) && (typeof ImageBitmap == "undefined" || !(r instanceof ImageBitmap)) && (typeof OffscreenCanvas == "undefined" || !(r instanceof OffscreenCanvas)) && !(r instanceof ImageData) && !(r instanceof ArrayBuffer) && r !== null) throw new Error("invalid texture source");
            if (c = Object.assign({}, a, c), this._texture) throw new Error("already created texture");
            if (this._wrapX = c.wrapX, this._wrapY = c.wrapY, this._sampling = c.sampling, this._pixelFormat = c.pixelFormat, this._isMipMapped = !!c.mipMap && this._renderer.AreMipmapsEnabled(), this._mipMapQuality = c.mipMapQuality, !n.has(this._wrapX) || !n.has(this._wrapY)) throw new Error("invalid wrap mode");
            if (!o.has(this._sampling)) throw new Error("invalid sampling");
            if (!s.has(this._pixelFormat)) throw new Error("invalid pixel format");
            if (!i.has(this._mipMapQuality)) throw new Error("invalid mipmap quality");
            if (this._isStatic = !0, r instanceof ArrayBuffer || r === null || c.isSvg) {
                if (this._width = c.width, this._height = c.height, r instanceof ArrayBuffer && r.byteLength !== this._width * this._height * 4) throw new Error("ArrayBuffer wrong size")
            } else this._width = r.width, this._height = r.height;
            if (this._width <= 0 || this._height <= 0) throw new Error("invalid texture data size");
            if (c.isSvg) {
                const t = e.CreateCanvas(this._width, this._height),
                    n = t.getContext("2d");
                n.drawImage(r, 0, 0, this._width, this._height), r = t
            }
            const h = e.isPOT(this._width) && e.isPOT(this._height),
                u = this._renderer.GetMaxTextureSize();
            if (this._width > u || this._height > u) throw new Error("texture data exceeds maximum texture size");
            const l = this._renderer.GetContext(),
                m = this._renderer.GetWebGLVersionNumber();
            this._texture = l.createTexture(), l.bindTexture(l.TEXTURE_2D, this._texture), l.pixelStorei(l.UNPACK_PREMULTIPLY_ALPHA_WEBGL, c.premultiplyAlpha);
            const d = GetFormatSpecifiers(this._pixelFormat, l);
            if (!this._renderer.SupportsNPOTTextures() && !h && this._IsTiled()) {
                if (r === null) throw new Error("cannot pass null data when creating a NPOT tiled texture without NPOT support");
                if (r instanceof ArrayBuffer && (r = new ImageData(new Uint8ClampedArray(r), this._width, this._height)), r instanceof ImageData) {
                    const t = e.CreateCanvas(this._width, this._height),
                        n = t.getContext("2d");
                    n.putImageData(r, 0, 0), r = t
                }
                const t = e.CreateCanvas(e.nextHighestPowerOfTwo(this._width), e.nextHighestPowerOfTwo(this._height)),
                    n = t.getContext("2d");
                n.imageSmoothingEnabled = this._sampling !== "nearest", n.drawImage(r, 0, 0, this._width, this._height, 0, 0, t.width, t.height), l.texImage2D(l.TEXTURE_2D, 0, d.internalformat, d.format, d.type, t)
            } else if (m >= 2) {
                let e;
                this._isMipMapped ? e = Math.floor(Math.log2(Math.max(this._width, this._height)) + 1) : e = 1, l.texStorage2D(l.TEXTURE_2D, e, d.sizedinternalformat, this._width, this._height), r instanceof ArrayBuffer ? l.texSubImage2D(l.TEXTURE_2D, 0, 0, 0, this._width, this._height, d.format, d.type, new Uint8Array(r)) : r !== null && l.texSubImage2D(l.TEXTURE_2D, 0, 0, 0, d.format, d.type, r)
            } else r instanceof ArrayBuffer ? l.texImage2D(l.TEXTURE_2D, 0, d.internalformat, this._width, this._height, 0, d.format, d.type, new Uint8Array(r)) : r === null ? l.texImage2D(l.TEXTURE_2D, 0, d.internalformat, this._width, this._height, 0, d.format, d.type, null) : l.texImage2D(l.TEXTURE_2D, 0, d.internalformat, d.format, d.type, r);
            r !== null && this._SetTextureParameters(l), l.bindTexture(l.TEXTURE_2D, null), this._renderer._ResetLastTexture(), this._refCount = 1, t.add(this)
        }
        _CreateDynamic(r, c, l) {
            if (l = Object.assign({}, a, l), this._texture) throw new Error("already created texture");
            if (this._wrapX = l.wrapX, this._wrapY = l.wrapY, this._sampling = l.sampling, this._pixelFormat = l.pixelFormat, this._isMipMapped = !!l.mipMap && this._renderer.AreMipmapsEnabled(), this._mipMapQuality = l.mipMapQuality, !n.has(this._wrapX) || !n.has(this._wrapY)) throw new Error("invalid wrap mode");
            if (!o.has(this._sampling)) throw new Error("invalid sampling");
            if (!s.has(this._pixelFormat)) throw new Error("invalid pixel format");
            if (!i.has(this._mipMapQuality)) throw new Error("invalid mipmap quality");
            this._isStatic = !1, this._width = Math.floor(r), this._height = Math.floor(c);
            const m = e.isPOT(this._width) && e.isPOT(this._height),
                h = this._renderer.GetMaxTextureSize();
            if (this._width <= 0 || this._height <= 0) throw new Error("invalid texture size");
            if (this._width > h || this._height > h) throw new Error("texture exceeds maximum texture size");
            if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !m) throw new Error("non-power-of-two tiled textures not supported");
            const d = this._renderer.GetContext(),
                f = this._renderer.GetWebGLVersionNumber();
            this._texture = d.createTexture(), d.bindTexture(d.TEXTURE_2D, this._texture), d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL, l.premultiplyAlpha);
            const u = GetFormatSpecifiers(this._pixelFormat, d),
                p = f >= 2 ? u.sizedinternalformat : u.internalformat;
            d.texImage2D(d.TEXTURE_2D, 0, p, this._width, this._height, 0, u.format, u.type, null), this._SetTextureParameters(d), d.bindTexture(d.TEXTURE_2D, null), this._renderer._ResetLastTexture(), this._refCount = 1, t.add(this)
        }
        _GetMipMapHint(e) {
            if (this._mipMapQuality === "default") return this._isStatic ? e.NICEST : e.FASTEST;
            if (this._mipMapQuality === "low") return e.FASTEST;
            if (this._mipMapQuality === "high") return e.NICEST;
            throw new Error("invalid mipmap quality")
        }
        _IsTiled() {
            return this._wrapX !== "clamp-to-edge" || this._wrapY !== "clamp-to-edge"
        }
        _GetTextureWrapMode(e, t) {
            if (t === "clamp-to-edge") return e.CLAMP_TO_EDGE;
            if (t === "repeat") return e.REPEAT;
            if (t === "mirror-repeat") return e.MIRRORED_REPEAT;
            throw new Error("invalid wrap mode")
        }
        _SetTextureParameters(t) {
            const n = e.isPOT(this._width) && e.isPOT(this._height);
            if (t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, this._GetTextureWrapMode(t, this._wrapX)), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, this._GetTextureWrapMode(t, this._wrapY)), this._sampling === "nearest") t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), this._isMipMapped = !1;
            else if (t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR), (n || this._renderer.SupportsNPOTTextures()) && this._isMipMapped) {
                t.hint(t.GENERATE_MIPMAP_HINT, this._GetMipMapHint(t)), t.generateMipmap(t.TEXTURE_2D);
                const e = this._sampling === "trilinear" && !this._renderer.HasMajorPerformanceCaveat();
                t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, e ? t.LINEAR_MIPMAP_LINEAR : t.LINEAR_MIPMAP_NEAREST)
            } else t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), this._isMipMapped = !1
        }
        _Update(t, n) {
            if ((typeof HTMLImageElement == "undefined" || !(t instanceof HTMLImageElement)) && (typeof HTMLVideoElement == "undefined" || !(t instanceof HTMLVideoElement)) && (typeof HTMLCanvasElement == "undefined" || !(t instanceof HTMLCanvasElement)) && (typeof ImageBitmap == "undefined" || !(t instanceof ImageBitmap)) && (typeof OffscreenCanvas == "undefined" || !(t instanceof OffscreenCanvas)) && !(t instanceof ImageData)) throw new Error("invalid texture source");
            if (!this._texture || this._refCount <= 0) throw new Error("texture not created");
            if (this._isStatic) throw new Error("cannot update static texture");
            n = Object.assign({}, r, n);
            const i = t.width || t.videoWidth,
                a = t.height || t.videoHeight,
                c = this._renderer.GetWebGLVersionNumber(),
                s = this._renderer.GetContext();
            s.bindTexture(s.TEXTURE_2D, this._texture), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha), s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, !!n.flipY);
            const o = GetFormatSpecifiers(this._pixelFormat, s),
                l = c >= 2 ? o.sizedinternalformat : o.internalformat;
            try {
                if (this._width === i && this._height === a) {
                    const n = e.isPOT(this._width) && e.isPOT(this._height);
                    s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, o.format, o.type, t), (n || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (s.hint(s.GENERATE_MIPMAP_HINT, this._GetMipMapHint(s)), s.generateMipmap(s.TEXTURE_2D))
                } else {
                    this._width = i, this._height = a;
                    const n = e.isPOT(this._width) && e.isPOT(this._height);
                    if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !n) throw new Error("non-power-of-two tiled textures not supported");
                    s.texImage2D(s.TEXTURE_2D, 0, l, o.format, o.type, t), (n || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (s.hint(s.GENERATE_MIPMAP_HINT, this._GetMipMapHint(s)), s.generateMipmap(s.TEXTURE_2D))
                }
            } catch (e) {
                console.error("Error updating WebGL texture: ", e)
            }
            s.bindTexture(s.TEXTURE_2D, null), this._renderer._ResetLastTexture()
        }
        _Delete() {
            if (this._refCount > 0) throw new Error("texture still has references");
            if (!this._texture) throw new Error("already deleted texture");
            t.delete(this);
            const e = this._renderer.GetContext();
            e.deleteTexture(this._texture), this._texture = null
        }
        IsValid() {
            return !!this._texture
        }
        _GetTexture() {
            return this._texture
        }
        GetRenderer() {
            return this._renderer
        }
        AddReference() {
            this._refCount++
        }
        SubtractReference() {
            if (this._refCount <= 0) throw new Error("no more references");
            this._refCount--
        }
        GetReferenceCount() {
            return this._refCount
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        IsStatic() {
            return this._isStatic
        }
        GetEstimatedMemoryUsage() {
            let e = this._width * this._height;
            switch (this._pixelFormat) {
                case "rgba8":
                    e *= 4;
                    break;
                case "rgb8":
                    e *= 3;
                    break;
                case "rgba4":
                case "rgb5_a1":
                case "rgb565":
                    e *= 2;
                    break
            }
            return this._isMipMapped && (e += Math.floor(e / 3)), e
        }
        static OnContextLost() {
            t.clear()
        }
        static allTextures() {
            return t.values()
        }
    }
}
"use strict";
{
    const t = self.C3,
        o = self.assert,
        s = new Set(["nearest", "bilinear", "trilinear"]),
        n = {
            sampling: "trilinear",
            alpha: !0,
            readback: !0,
            isDefaultSize: !0,
            multisampling: 0
        },
        e = new Set;
    t.Gfx.WebGLRenderTarget = class WebGLRenderTarget {
        constructor(e) {
            this._renderer = e, this._frameBuffer = null, this._texture = null, this._renderBuffer = null, this._width = 0, this._height = 0, this._isDefaultSize = !0, this._sampling = "trilinear", this._alpha = !0, this._readback = !0, this._multisampling = 0
        }
        _Create(t, o, i) {
            i = Object.assign({}, n, i);
            const r = this._renderer.GetWebGLVersionNumber();
            if (this._texture || this._renderBuffer) throw new Error("already created render target");
            if (this._sampling = i.sampling, this._alpha = !!i.alpha, this._readback = !!i.readback, this._isDefaultSize = !!i.isDefaultSize, this._multisampling = i.multisampling, !s.has(this._sampling)) throw new Error("invalid sampling");
            if (this._multisampling > 0 && (r < 2 || this._readback)) throw new Error("invalid use of multisampling");
            if (r < 2 && (this._readback = !0), this._width = t, this._height = o, this._width <= 0 || this._height <= 0) throw new Error("invalid render target size");
            const a = this._renderer.GetContext();
            if (this._frameBuffer = a.createFramebuffer(), a.bindFramebuffer(a.FRAMEBUFFER, this._frameBuffer), this._readback) {
                this._texture = this._renderer.CreateDynamicTexture(this._width, this._height, {
                    sampling: this._sampling,
                    pixelFormat: this._alpha ? "rgba8" : "rgb8",
                    mipMap: !1
                });
                const e = this._texture._GetTexture();
                a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, e, 0)
            } else {
                this._renderBuffer = a.createRenderbuffer(), a.bindRenderbuffer(a.RENDERBUFFER, this._renderBuffer);
                const e = this._alpha ? a.RGBA8 : a.RGB8;
                if (this._multisampling > 0) {
                    const t = a.getInternalformatParameter(a.RENDERBUFFER, e, a.SAMPLES);
                    if (t && t[0]) {
                        const e = t[0];
                        this._multisampling > e && (this._multisampling = e)
                    } else this._multisampling = 0
                }
                this._multisampling === 0 ? a.renderbufferStorage(a.RENDERBUFFER, e, this._width, this._height) : a.renderbufferStorageMultisample(a.RENDERBUFFER, this._multisampling, e, this._width, this._height), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.RENDERBUFFER, this._renderBuffer), a.bindRenderbuffer(a.RENDERBUFFER, null)
            }
            a.bindFramebuffer(a.FRAMEBUFFER, null), e.add(this)
        }
        _Resize(e, t) {
            if (this._width === e && this._height === t) return;
            this._width = e, this._height = t;
            const n = this._renderer.GetContext();
            n.bindFramebuffer(n.FRAMEBUFFER, this._frameBuffer), this._texture ? this._texture._Update(new ImageData(this._width, this._height)) : (n.bindRenderbuffer(n.RENDERBUFFER, this._renderBuffer), n.renderbufferStorage(n.RENDERBUFFER, this._alpha ? n.RGBA8 : n.RGB8, this._width, this._height), n.bindRenderbuffer(n.RENDERBUFFER, null)), n.bindFramebuffer(n.FRAMEBUFFER, null)
        }
        _Delete() {
            if (!this._texture && !this._renderBuffer) throw new Error("already deleted render target");
            e.delete(this);
            const t = this._renderer.GetContext();
            t.bindFramebuffer(t.FRAMEBUFFER, this._frameBuffer), this._texture ? (t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0), this._renderer.DeleteTexture(this._texture), this._texture = null) : this._renderBuffer && (t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, null), t.deleteRenderbuffer(this._renderBuffer), this._renderBuffer = null), t.bindFramebuffer(t.FRAMEBUFFER, null), this._renderer.GetWebGLVersionNumber() >= 2 && (t.bindFramebuffer(t.READ_FRAMEBUFFER, null), t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null)), t.deleteFramebuffer(this._frameBuffer), this._renderer.GetBatchState().currentFramebuffer = null, this._frameBuffer = null
        }
        _GetFramebuffer() {
            return this._frameBuffer
        }
        GetWebGLRenderer() {
            return this._renderer
        }
        GetTexture() {
            return this._texture
        }
        IsLinearSampling() {
            return this._sampling !== "nearest"
        }
        HasAlpha() {
            return this._alpha
        }
        IsReadback() {
            return this._readback
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        IsDefaultSize() {
            return this._isDefaultSize
        }
        GetMultisampling() {
            return this._multisampling
        }
        GetOptions() {
            const e = {
                sampling: this._sampling,
                alpha: this._alpha,
                readback: this._readback
            };
            return this._isDefaultSize || (e.width = this._width, e.height = this._height), e
        }
        IsCompatibleWithOptions(e) {
            return e = Object.assign({}, n, e), e.sampling !== "nearest" === this.IsLinearSampling() && !!e.alpha === this.HasAlpha() && !(this._renderer.GetWebGLVersionNumber() >= 2 && !!e.readback !== this.IsReadback()) && (typeof e.width == "number" || typeof e.height == "number" ? !this.IsDefaultSize() && this.GetWidth() === e.width && this.GetHeight() === e.height : this.IsDefaultSize())
        }
        _GetWebGLTexture() {
            return this._texture ? this._texture._GetTexture() : null
        }
        GetEstimatedMemoryUsage() {
            return this._texture ? this._texture.GetEstimatedMemoryUsage() : this._width * this._height * (this._alpha ? 4 : 3)
        }
        static async DebugReadPixelsToBlob(e, n) {
            const s = await e.ReadBackRenderTargetToImageData(n, !0);
            return await t.ImageDataToBlob(s)
        }
        static OnContextLost() {
            e.clear()
        }
        static allRenderTargets() {
            return e.values()
        }
        static ResizeAll(t, n) {
            for (const s of e) s.IsDefaultSize() && s._Resize(t, n)
        }
    }
}
"use strict";
{
    const e = self.C3,
        n = self.glMatrix,
        s = n.vec3,
        t = n.mat4,
        o = new Set(["aPos", "aTex", "aPoints", "matP", "matMV", "samplerFront", "samplerBack", "destStart", "destEnd", "srcStart", "srcEnd", "srcOriginStart", "srcOriginEnd", "pixelSize", "seconds", "layerScale", "layerAngle", "layoutStart", "layoutEnd", "color", "color2_", "pointTexStart", "pointTexEnd", "zElevation", "tileSize", "tileSpacing", "outlineThickness"]);
    e.Gfx.WebGLShaderProgram = class WebGLShaderProgram {
        static async Compile(t, n, s, o) {
            const i = t.GetContext(),
                r = i.createShader(i.FRAGMENT_SHADER);
            i.shaderSource(r, n), i.compileShader(r);
            const c = i.createShader(i.VERTEX_SHADER);
            i.shaderSource(c, s), i.compileShader(c);
            const a = i.createProgram();
            i.attachShader(a, r), i.attachShader(a, c), i.bindAttribLocation(a, 0, "aPos"), i.bindAttribLocation(a, 1, "aTex"), i.bindAttribLocation(a, 2, "aPoints"), i.linkProgram(a);
            const d = t._GetParallelShaderCompileExtension();
            if (d ? await t._WaitForObjectReady(() => i.getProgramParameter(a, d.COMPLETION_STATUS_KHR)) : await e.Wait(5), !i.getShaderParameter(r, i.COMPILE_STATUS)) {
                const e = i.getShaderInfoLog(r);
                throw i.deleteShader(r), i.deleteShader(c), i.deleteProgram(a), new Error("Error compiling fragment shader: " + e)
            }
            if (!i.getShaderParameter(c, i.COMPILE_STATUS)) {
                const e = i.getShaderInfoLog(c);
                throw i.deleteShader(r), i.deleteShader(c), i.deleteProgram(a), new Error("Error compiling vertex shader: " + e)
            }
            if (!i.getProgramParameter(a, i.LINK_STATUS)) {
                const e = i.getProgramInfoLog(a);
                throw i.deleteShader(r), i.deleteShader(c), i.deleteProgram(a), new Error("Error linking shader program: " + e)
            }
            const l = e.FilterUnprintableChars(i.getProgramInfoLog(a) || "").trim();
            return l && !e.IsStringAllWhitespace(l) && console.info(`[WebGL] Shader program '${o}' compilation log: `, l), i.deleteShader(r), i.deleteShader(c), a
        }
        static async Create(t, n, s, o) {
            const i = await e.Gfx.WebGLShaderProgram.Compile(t, n.src, s, o);
            return new e.Gfx.WebGLShaderProgram(t, i, n, o)
        }
        constructor(t, n, s, o) {
            const i = t.GetContext(),
                a = t.GetBatchState();
            t.EndBatch(), i.useProgram(n), this._gl = i, this._renderer = t, this._name = o, this._shaderProgram = n, this._isDeviceTransform = o === "<default-device-transform>";
            const r = i.getAttribLocation(n, "aPos"),
                c = i.getAttribLocation(n, "aTex"),
                l = i.getAttribLocation(n, "aPoints");
            r !== -1 && (i.bindBuffer(i.ARRAY_BUFFER, t._vertexBuffer), i.vertexAttribPointer(r, t.GetNumVertexComponents(), i.FLOAT, !1, 0, 0), i.enableVertexAttribArray(r)), c !== -1 && (i.bindBuffer(i.ARRAY_BUFFER, t._texcoordBuffer), i.vertexAttribPointer(c, 2, i.FLOAT, !1, 0, 0), i.enableVertexAttribArray(c)), l !== -1 && (i.bindBuffer(i.ARRAY_BUFFER, t._pointBuffer), i.vertexAttribPointer(l, 4, i.FLOAT, !1, 0, 0), i.enableVertexAttribArray(l)), i.bindBuffer(i.ARRAY_BUFFER, null), this._uMatP = new e.Gfx.WebGLShaderUniform(this, "matP", "mat4"), this._uMatMV = new e.Gfx.WebGLShaderUniform(this, "matMV", "mat4"), this._uColor = new e.Gfx.WebGLShaderUniform(this, "color", "vec4"), this._uSamplerFront = new e.Gfx.WebGLShaderUniform(this, "samplerFront", "sampler"), this._uPointTexStart = new e.Gfx.WebGLShaderUniform(this, "pointTexStart", "vec2"), this._uPointTexEnd = new e.Gfx.WebGLShaderUniform(this, "pointTexEnd", "vec2"), this._uZElevation = new e.Gfx.WebGLShaderUniform(this, "zElevation", "float"), this._uTileSize = new e.Gfx.WebGLShaderUniform(this, "tileSize", "vec2"), this._uTileSpacing = new e.Gfx.WebGLShaderUniform(this, "tileSpacing", "vec2"), this._uColor2 = new e.Gfx.WebGLShaderUniform(this, "color2_", "vec4"), this._uOutlineThickness = new e.Gfx.WebGLShaderUniform(this, "outlineThickness", "float"), this._uSamplerBack = new e.Gfx.WebGLShaderUniform(this, "samplerBack", "sampler"), this._uDestStart = new e.Gfx.WebGLShaderUniform(this, "destStart", "vec2"), this._uDestEnd = new e.Gfx.WebGLShaderUniform(this, "destEnd", "vec2"), this._uSrcStart = new e.Gfx.WebGLShaderUniform(this, "srcStart", "vec2"), this._uSrcEnd = new e.Gfx.WebGLShaderUniform(this, "srcEnd", "vec2"), this._uSrcOriginStart = new e.Gfx.WebGLShaderUniform(this, "srcOriginStart", "vec2"), this._uSrcOriginEnd = new e.Gfx.WebGLShaderUniform(this, "srcOriginEnd", "vec2"), this._uPixelSize = new e.Gfx.WebGLShaderUniform(this, "pixelSize", "vec2"), this._uSeconds = new e.Gfx.WebGLShaderUniform(this, "seconds", "float"), this._uLayerScale = new e.Gfx.WebGLShaderUniform(this, "layerScale", "float"), this._uLayerAngle = new e.Gfx.WebGLShaderUniform(this, "layerAngle", "float"), this._uLayoutStart = new e.Gfx.WebGLShaderUniform(this, "layoutStart", "vec2"), this._uLayoutEnd = new e.Gfx.WebGLShaderUniform(this, "layoutEnd", "vec2"), this._hasAnyOptionalUniforms = !!(this._uPixelSize.IsUsed() || this._uSeconds.IsUsed() || this._uSamplerBack.IsUsed() || this._uDestStart.IsUsed() || this._uDestEnd.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed() || this._uLayerScale.IsUsed() || this._uLayerAngle.IsUsed() || this._uLayoutStart.IsUsed() || this._uLayoutEnd.IsUsed()), this._extendBoxHorizontal = s.extendBoxHorizontal || 0, this._extendBoxVertical = s.extendBoxVertical || 0, this._crossSampling = !!s.crossSampling, this._mustPreDraw = !!s.mustPreDraw, this._preservesOpaqueness = !!s.preservesOpaqueness, this._animated = !!s.animated;
            const u = s.parameters || [];
            this._uCustomParameters = [], this._usesDest = this._uDestStart.IsUsed() || this._uDestEnd.IsUsed(), this._usesAnySrcRectOrPixelSize = this._uPixelSize.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed(), this._needsPostDrawOrExtendBox = this._crossSampling || this._usesDest || this._extendBoxHorizontal !== 0 || this._extendBoxVertical !== 0, this._hasCurrentMatP = !1, this._hasCurrentMatMV = !1, this._uColor.Init4f(1, 1, 1, 1), this._uColor2.Init4f(1, 1, 1, 1), this._uSamplerFront.Init1i(0), this._uSamplerBack.Init1i(1), this._uPointTexStart.Init2f(0, 0), this._uPointTexEnd.Init2f(1, 1), this._uZElevation.Init1f(0), this._uTileSize.Init2f(0, 0), this._uTileSpacing.Init2f(0, 0), this._uDestStart.Init2f(0, 0), this._uDestEnd.Init2f(1, 1), this._uSrcStart.Init2f(0, 0), this._uSrcEnd.Init2f(0, 0), this._uSrcOriginStart.Init2f(0, 0), this._uSrcOriginEnd.Init2f(0, 0), this._uPixelSize.Init2f(0, 0), this._uLayerScale.Init1f(1), this._uLayerAngle.Init1f(0), this._uSeconds.Init1f(0), this._uLayoutStart.Init2f(0, 0), this._uLayoutEnd.Init2f(0, 0), this._uOutlineThickness.Init1f(1);
            for (const n of u) {
                const o = n[0],
                    s = n[2],
                    t = new e.Gfx.WebGLShaderUniform(this, o, s);
                s === "color" ? t.Init3f(0, 0, 0) : t.Init1f(0), this._uCustomParameters.push(t)
            }
            this._isDeviceTransform ? this._UpdateDeviceTransformUniforms(a.currentMatP) : (this.UpdateMatP(a.currentMatP, !0), this.UpdateMatMV(a.currentMV, !0));
            const d = a.currentShader;
            i.useProgram(d ? d._shaderProgram : null)
        }
        Release() {
            this._gl.deleteProgram(this._shaderProgram), this._shaderProgram = null, this._renderer._RemoveShaderProgram(this), this._gl = null, this._renderer = null
        }
        GetName() {
            return this._name
        }
        GetWebGLContext() {
            return this._gl
        }
        GetShaderProgram() {
            return this._shaderProgram
        }
        UsesDest() {
            return this._usesDest
        }
        UsesCrossSampling() {
            return this._crossSampling
        }
        MustPreDraw() {
            return this._mustPreDraw
        }
        PreservesOpaqueness() {
            return this._preservesOpaqueness
        }
        ExtendsBox() {
            return this._extendBoxHorizontal !== 0 || this._extendBoxVertical !== 0
        }
        GetBoxExtendHorizontal() {
            return this._extendBoxHorizontal
        }
        GetBoxExtendVertical() {
            return this._extendBoxVertical
        }
        UsesAnySrcRectOrPixelSize() {
            return this._usesAnySrcRectOrPixelSize
        }
        NeedsPostDrawOrExtendsBox() {
            return this._needsPostDrawOrExtendBox
        }
        GetParameterCount() {
            return this._uCustomParameters.length
        }
        GetParameterType(e) {
            return this._uCustomParameters[e].GetType()
        }
        AreCustomParametersAlreadySetInBatch(e) {
            for (let t = 0, n = e.length; t < n; ++t)
                if (!this._uCustomParameters[t].IsSetToCustomInBatch(e[t])) return !1;
            return !0
        }
        SetCustomParametersInBatch(e) {
            for (let t = 0, n = e.length; t < n; ++t) this._uCustomParameters[t].SetBatchValueCustom(e[t])
        }
        AreOptionalUniformsAlreadySetInBatch(e, t, n, s, o, i, a, r, c) {
            return !this._uSamplerBack.IsUsed() && !(this._uPixelSize.IsUsed() && !this._uPixelSize.IsSetTo2InBatch(o, i)) && !(this._uDestStart.IsUsed() && !this._uDestStart.IsSetTo2InBatch(e.getLeft(), e.getTop())) && !(this._uDestEnd.IsUsed() && !this._uDestEnd.IsSetTo2InBatch(e.getRight(), e.getBottom())) && !(this._uLayerScale.IsUsed() && !this._uLayerScale.IsSetTo1InBatch(a)) && !(this._uLayerAngle.IsUsed() && !this._uLayerAngle.IsSetTo1InBatch(r)) && !(this._uSrcStart.IsUsed() && !this._uSrcStart.IsSetTo2InBatch(t.getLeft(), t.getTop())) && !(this._uSrcEnd.IsUsed() && !this._uSrcEnd.IsSetTo2InBatch(t.getRight(), t.getBottom())) && !(this._uSrcOriginStart.IsUsed() && !this._uSrcOriginStart.IsSetTo2InBatch(n.getLeft(), n.getTop())) && !(this._uSrcOriginEnd.IsUsed() && !this._uSrcOriginEnd.IsSetTo2InBatch(n.getRight(), n.getBottom())) && !(this._uLayoutStart.IsUsed() && !this._uLayoutStart.IsSetTo2InBatch(s.getLeft(), s.getTop())) && !(this._uLayoutEnd.IsUsed() && !this._uLayoutEnd.IsSetTo2InBatch(s.getTop(), s.getBottom())) && (!this._uSeconds.IsUsed() || !!this._uSeconds.IsSetTo1InBatch(c))
        }
        SetOptionalUniformsInBatch(e, t, n, s, o, i, a, r, c) {
            if (this._uSamplerBack.IsUsed()) return;
            this._uPixelSize.IsUsed() && this._uPixelSize.SetBatch2(o, i), this._uDestStart.IsUsed() && this._uDestStart.SetBatch2(e.getLeft(), e.getTop()), this._uDestEnd.IsUsed() && this._uDestEnd.SetBatch2(e.getRight(), e.getBottom()), this._uLayerScale.IsUsed() && this._uLayerScale.SetBatch1(a), this._uLayerAngle.IsUsed() && this._uLayerAngle.SetBatch1(r), this._uSrcStart.IsUsed() && this._uSrcStart.SetBatch2(t.getLeft(), t.getTop()), this._uSrcEnd.IsUsed() && this._uSrcEnd.SetBatch2(t.getRight(), t.getBottom()), this._uSrcOriginStart.IsUsed() && this._uSrcOriginStart.SetBatch2(n.getLeft(), n.getTop()), this._uSrcOriginEnd.IsUsed() && this._uSrcOriginEnd.SetBatch2(n.getRight(), n.getBottom()), this._uLayoutStart.IsUsed() && this._uLayoutStart.SetBatch2(s.getLeft(), s.getTop()), this._uLayoutEnd.IsUsed() && this._uLayoutEnd.SetBatch2(s.getTop(), s.getBottom()), this._uSeconds.IsUsed() && this._uSeconds.SetBatch1(c)
        }
        IsAnimated() {
            return this._animated
        }
        UpdateMatP(e, t) {
            if (this._hasCurrentMatP && !t) return;
            if (this._isDeviceTransform) return;
            this._uMatP.IsUsed() && this._uMatP.UpdateMatrix4fv(e), this._hasCurrentMatP = !0
        }
        SetMatPStale() {
            this._hasCurrentMatP = !1
        }
        UpdateMatMV(e, t) {
            if (this._hasCurrentMatMV && !t) return;
            if (this._isDeviceTransform) return;
            this._uMatMV.IsUsed() && this._uMatMV.UpdateMatrix4fv(e), this._hasCurrentMatMV = !0
        }
        SetMatMVStale() {
            this._hasCurrentMatMV = !1
        }
        _UpdateDeviceTransformUniforms(e) {
            if (!this._isDeviceTransform) throw new Error("not device transform shader");
            this._uMatP.UpdateMatrix4fv(e);
            const o = this._renderer,
                a = o.GetWidth() / 2,
                r = o.GetHeight() / 2,
                n = o._worldScale,
                c = s.fromValues(a * n[0], r * n[1], 100 * self.devicePixelRatio),
                l = s.fromValues(a * n[0], r * n[1], 0),
                i = t.create();
            t.lookAt(i, c, l, o._up), t.scale(i, i, n), this._uMatMV.UpdateMatrix4fv(i)
        }
        UpdateColor(e) {
            this._uColor.IsUsed() && this._uColor.Update4f(e[0], e[1], e[2], e[3])
        }
        static GetReservedUniformNames() {
            return o
        }
        static GetDefaultVertexShaderSource(e, t) {
            const n = t ? "highmedp" : "mediump";
            return [`#ifdef GL_FRAGMENT_PRECISION_HIGH`, `#define highmedp highp`, `#else`, `#define highmedp mediump`, `#endif`, `attribute highp ${e?"vec3":"vec2"} aPos;`, `attribute ${n} vec2 aTex;`, `varying ${n} vec2 vTex;`, `uniform highp mat4 matP;`, `uniform highp mat4 matMV;`, `void main(void) {`, `	gl_Position = matP * matMV * vec4(aPos, ${e?"":"0.0,"} 1.0);`, `	vTex = aTex;`, `}`].join(`
`)
        }
        static GetTextureFillFragmentShaderSource() {
            return ["varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "	gl_FragColor = texture2D(samplerFront, vTex) * color;", "}"].join(`
`)
        }
        static GetTilemapFragmentShaderSource() {
            return ["#ifdef GL_FRAGMENT_PRECISION_HIGH", "#define highmedp highp", "#else", "#define highmedp mediump", "#endif", "varying highmedp vec2 vTex;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "uniform highmedp vec2 srcStart;", "uniform highmedp vec2 pixelSize;", "uniform highmedp vec2 tileSize;", "uniform highmedp vec2 tileSpacing;", "void main(void) {", "	highmedp vec2 tile = floor(vTex);", "	highmedp vec2 tex = fract(vTex);", "	highmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "	highmedp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "	highmedp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "	gl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;", "}"].join(`
`)
        }
        static GetPointVertexShaderSource() {
            return ["attribute vec4 aPoints;", "varying float pointOpacity;", "uniform float zElevation;", "uniform mat4 matP;", "uniform mat4 matMV;", "void main(void) {", "	gl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);", "	gl_PointSize = aPoints.z;", "	pointOpacity = aPoints.w;", "}"].join(`
`)
        }
        static GetPointFragmentShaderSource() {
            return ["uniform lowp sampler2D samplerFront;", "varying lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "void main(void) {", "	gl_FragColor = texture2D(samplerFront, mix(pointTexStart, pointTexEnd, gl_PointCoord)) * color * pointOpacity;", "}"].join(`
`)
        }
        static GetColorFillFragmentShaderSource() {
            return ["uniform lowp vec4 color;", "void main(void) {", "	gl_FragColor = color;", "}"].join(`
`)
        }
        static GetLinearGradientFillFragmentShaderSource() {
            return ["precision lowp float;", "varying mediump vec2 vTex;", "uniform vec4 color;", "uniform vec4 color2_;", "vec3 fromLinear(vec3 linearRGB)", "{", "	bvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));", "	vec3 higher = vec3(1.055) * pow(abs(linearRGB), vec3(1.0/2.4)) - vec3(0.055);", "	vec3 lower = linearRGB * vec3(12.92);", "	return mix(higher, lower, vec3(cutoff));", "}", "vec3 toLinear(vec3 sRGB)", "{", "	bvec3 cutoff = lessThan(sRGB, vec3(0.04045));", "	vec3 higher = pow(abs((sRGB + vec3(0.055))/vec3(1.055)), vec3(2.4));", "	vec3 lower = sRGB/vec3(12.92);", "	return mix(higher, lower, vec3(cutoff));", "}", "void main(void) {", "	vec3 linearGrad = mix(toLinear(color.rgb), toLinear(color2_.rgb), vTex.x);", "	float a = mix(color.a, color2_.a, vTex.x);", "	gl_FragColor = vec4(fromLinear(linearGrad) * a, a);", "}"].join(`
`)
        }
        static GetSmoothLineFillFragmentShaderSource() {
            return ["varying mediump vec2 vTex;", "uniform lowp vec4 color;", "void main(void) {", "	lowp float f = 1.0 - abs(vTex.y - 0.5) * 2.0;", "	gl_FragColor = color * f;", "}"].join(`
`)
        }
        static GetHardEllipseFillFragmentShaderSource() {
            return ["varying mediump vec2 vTex;", "uniform lowp vec4 color;", "void main(void) {", "	mediump vec2 diff = vTex - vec2(0.5, 0.5);", "	mediump vec2 diffSq = diff * diff;", "	mediump float f = step(diffSq.x + diffSq.y, 0.25);", "	gl_FragColor = color * f;", "}"].join(`
`)
        }
        static GetHardEllipseOutlineFragmentShaderSource() {
            return ["varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform mediump vec2 pixelSize;", "uniform mediump float outlineThickness;", "void main(void) {", "	mediump vec2 diff = vTex - vec2(0.5, 0.5);", "	mediump vec2 diffSq = diff * diff;", "	mediump float distSq = diffSq.x + diffSq.y;", "	mediump vec2 norm = normalize(diff);", "	mediump vec2 halfNorm = norm * 0.5;", "	mediump float innerF = step(distSq, 0.25);", "	mediump vec2 innerEdge = halfNorm - pixelSize * norm * outlineThickness;", "	mediump vec2 innerEdgeSq = innerEdge * innerEdge;", "	mediump float outerF = step(innerEdgeSq.x + innerEdgeSq.y, distSq);", "	gl_FragColor = color * innerF * outerF;", "}"].join(`
`)
        }
        static GetSmoothEllipseFillFragmentShaderSource() {
            return ["varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform mediump vec2 pixelSize;", "void main(void) {", "	mediump vec2 diff = vTex - vec2(0.5, 0.5);", "	mediump vec2 diffSq = diff * diff;", "	mediump vec2 norm = normalize(diff);", "	mediump vec2 halfNorm = norm * 0.5;", "	mediump vec2 halfNormSq = halfNorm * halfNorm;", "	mediump vec2 innerEdge = halfNorm - pixelSize * norm;", "	mediump vec2 innerEdgeSq = innerEdge * innerEdge;", "	mediump float f = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);", "	gl_FragColor = color * f;", "}"].join(`
`)
        }
        static GetSmoothEllipseOutlineFragmentShaderSource() {
            return ["varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform mediump vec2 pixelSize;", "uniform mediump float outlineThickness;", "void main(void) {", "	mediump vec2 diff = vTex - vec2(0.5, 0.5);", "	mediump vec2 diffSq = diff * diff;", "	mediump float distSq = diffSq.x + diffSq.y;", "	mediump vec2 norm = normalize(diff);", "	mediump vec2 halfNorm = norm * 0.5;", "	mediump vec2 halfNormSq = halfNorm * halfNorm;", "	mediump vec2 pxNorm = pixelSize * norm;", "	mediump vec2 innerEdge1 = halfNorm - pxNorm;", "	mediump vec2 innerEdge1Sq = innerEdge1 * innerEdge1;", "	mediump float innerF = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);", "	mediump vec2 innerEdge2 = halfNorm - pxNorm * outlineThickness;", "	mediump vec2 innerEdge2Sq = innerEdge2 * innerEdge2;", "	mediump vec2 innerEdge3 = halfNorm - pxNorm * (outlineThickness + 1.0);", "	mediump vec2 innerEdge3Sq = innerEdge3 * innerEdge3;", "	mediump float outerF = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);", "	gl_FragColor = color * innerF * outerF;", "}"].join(`
`)
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = new Map([
            ["float", 1],
            ["percent", 1],
            ["sampler", 1],
            ["vec2", 2],
            ["vec3", 3],
            ["color", 3],
            ["vec4", 4],
            ["mat4", 16]
        ]);

    function areMat4sEqual(e, t) {
        return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[11] === t[11] && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[15] === t[15]
    }
    e.Gfx.WebGLShaderUniform = class WebGLShaderUniform {
        constructor(e, n, s) {
            if (!t.has(s)) throw new Error("invalid uniform type");
            this._owner = e, this._gl = this._owner.GetWebGLContext(), this._name = n, this._type = s, this._isColorType = this._type === "color", this._location = this._gl.getUniformLocation(this._owner.GetShaderProgram(), n), this._isUsed = !!this._location;
            const o = t.get(s);
            this._lastValue = new Float32Array(o), this._lastBatchValue = new Float32Array(o)
        }
        Release() {
            this._owner = null, this._gl = null, this._location = null
        }
        IsUsed() {
            return this._isUsed
        }
        GetType() {
            return this._type
        }
        IsColorType() {
            return this._isColorType
        }
        Init1f(e) {
            if (!this.IsUsed()) return;
            this._lastValue[0] = e, this._lastBatchValue.set(this._lastValue), this._gl.uniform1f(this._location, e)
        }
        Init1i(e) {
            if (!this.IsUsed()) return;
            this._lastValue[0] = e, this._lastBatchValue.set(this._lastValue), this._gl.uniform1i(this._location, e)
        }
        Init2f(e, t) {
            if (!this.IsUsed()) return;
            this._lastValue[0] = e, this._lastValue[1] = t, this._lastBatchValue.set(this._lastValue), this._gl.uniform2f(this._location, e, t)
        }
        Init3f(e, t, n) {
            if (!this.IsUsed()) return;
            this._lastValue[0] = e, this._lastValue[1] = t, this._lastValue[2] = n, this._lastBatchValue.set(this._lastValue), this._gl.uniform3f(this._location, e, t, n)
        }
        Init4f(e, t, n, s) {
            if (!this.IsUsed()) return;
            this._lastValue[0] = e, this._lastValue[1] = t, this._lastValue[2] = n, this._lastValue[3] = s, this._lastBatchValue.set(this._lastValue), this._gl.uniform4f(this._location, e, t, n, s)
        }
        Update1f(e) {
            e = Math.fround(e);
            const t = this._lastValue;
            if (t[0] === e) return;
            t[0] = e, this._gl.uniform1f(this._location, e)
        }
        Update1i(e) {
            const t = this._lastValue;
            if (t[0] === e) return;
            t[0] = e, this._gl.uniform1i(this._location, e)
        }
        Update2f(e, t) {
            e = Math.fround(e), t = Math.fround(t);
            const n = this._lastValue;
            if (n[0] === e && n[1] === t) return;
            n[0] = e, n[1] = t, this._gl.uniform2f(this._location, e, t)
        }
        Update3f(e, t, n) {
            e = Math.fround(e), t = Math.fround(t), n = Math.fround(n);
            const s = this._lastValue;
            if (s[0] === e && s[1] === t && s[2] === n) return;
            s[0] = e, s[1] = t, s[2] = n, this._gl.uniform3f(this._location, e, t, n)
        }
        Update4f(e, t, n, s) {
            e = Math.fround(e), t = Math.fround(t), n = Math.fround(n), s = Math.fround(s);
            const o = this._lastValue;
            if (o[0] === e && o[1] === t && o[2] === n && o[3] === s) return;
            o[0] = e, o[1] = t, o[2] = n, o[3] = s, this._gl.uniform4f(this._location, e, t, n, s)
        }
        UpdateMatrix4fv(t) {
            const n = this._lastValue;
            if (areMat4sEqual(n, t)) return;
            e.typedArraySet16(n, t, 0), this._gl.uniformMatrix4fv(this._location, !1, t)
        }
        IsSetToCustomInBatch(e) {
            const t = this._lastBatchValue;
            return this.IsColorType() ? t[0] === Math.fround(e.getR()) && t[1] === Math.fround(e.getG()) && t[2] === Math.fround(e.getB()) : t[0] === Math.fround(e)
        }
        SetBatchValueCustom(e) {
            const t = this._lastBatchValue;
            this.IsColorType() ? (t[0] = e.getR(), t[1] = e.getG(), t[2] = e.getB()) : t[0] = e
        }
        IsSetTo1InBatch(e) {
            return this._lastBatchValue[0] === Math.fround(e)
        }
        IsSetTo2InBatch(e, t) {
            const n = this._lastBatchValue;
            return n[0] === Math.fround(e) && n[1] === Math.fround(t)
        }
        SetBatch1(e) {
            this._lastBatchValue[0] = e
        }
        SetBatch2(e, t) {
            const n = this._lastBatchValue;
            n[0] = e, n[1] = t
        }
    }
}
"use strict";
{
    const e = self.C3,
        s = self.glMatrix,
        o = s.vec4,
        t = s.mat4,
        O = 0,
        u = 1,
        f = 2,
        r = 3,
        c = 4,
        l = 5,
        d = 6,
        n = 7,
        i = 8,
        m = 9,
        a = 10,
        p = 11,
        g = 12,
        v = 13,
        b = 14,
        j = 15,
        y = 16,
        _ = 17,
        w = 18,
        h = 19;
    e.Gfx.BatchState = class BatchState {
        constructor(n) {
            this.renderer = n, this.currentMV = t.create(), this.currentMatP = t.create(), this.currentFramebuffer = null, this.currentColor = o.fromValues(1, 1, 1, 1), this.currentShader = null, this.pointTexCoords = new e.Rect, this.clearColor = e.New(e.Color, 0, 0, 0, 0)
        }
    }, e.Gfx.WebGLBatchJob = class WebGLBatchJob {
        constructor(e) {
            const t = new ArrayBuffer(96);
            this._type = 0, this._batchState = e, this._gl = e.renderer.GetContext(), this._startIndex = 0, this._indexCount = 0, this._texParam = null, this._mat4param = new Float32Array(t, 0, 16), this._colorParam = new Float32Array(t, 64, 4), this._srcOriginRect = new Float32Array(t, 80, 4), this._shaderParams = []
        }
        InitQuad(e, t) {
            this._type = u, this._startIndex = e, this._indexCount = t
        }
        DoQuad() {
            const e = this._gl;
            e.drawElements(e.TRIANGLES, this._indexCount, e.UNSIGNED_SHORT, this._startIndex)
        }
        InitSetTexture(e) {
            this._type = f, this._texParam = e
        }
        DoSetTexture() {
            const e = this._gl,
                t = this._texParam;
            e.bindTexture(e.TEXTURE_2D, t ? t._GetTexture() : null)
        }
        InitSetColor(e) {
            this._type = r, e.writeToTypedArray(this._colorParam, 0)
        }
        DoSetColor() {
            const e = this._colorParam,
                t = this._batchState;
            o.copy(t.currentColor, e), t.currentShader.UpdateColor(e)
        }
        InitSetGradientColor(e) {
            this._type = h, e.writeToTypedArray(this._colorParam, 0)
        }
        DoSetGradientColor() {
            const e = this._colorParam,
                t = this._batchState.currentShader;
            t._uColor2.IsUsed() && t._uColor2.Update4f(e[0], e[1], e[2], e[3])
        }
        InitSetBlend(e, t) {
            this._type = c, this._startIndex = e, this._indexCount = t
        }
        DoSetBlend() {
            this._gl.blendFunc(this._startIndex, this._indexCount)
        }
        InitUpdateModelView(e) {
            this._type = l, t.copy(this._mat4param, e)
        }
        DoUpdateModelView() {
            const e = this._batchState,
                n = e.renderer._allShaderPrograms,
                o = e.currentShader,
                s = this._mat4param;
            for (let e = 0, i = n.length; e < i; ++e) {
                const t = n[e];
                t === o ? t.UpdateMatMV(s, !0) : t.SetMatMVStale()
            }
            t.copy(e.currentMV, s)
        }
        InitSetRenderTarget(e, n, s) {
            this._type = d, this._texParam = e, this._startIndex = n ? 1 : 0, n && t.copy(this._mat4param, s)
        }
        DoSetRenderTarget() {
            const e = this._gl,
                t = this._texParam,
                a = this._startIndex !== 0,
                r = this._mat4param,
                n = this._batchState,
                s = n.renderer;
            let o, i;
            if (t) {
                const s = t._GetFramebuffer();
                n.currentFramebuffer = s, e.bindFramebuffer(e.FRAMEBUFFER, s), o = t.GetWidth(), i = t.GetHeight()
            } else n.currentFramebuffer = null, e.bindFramebuffer(e.FRAMEBUFFER, null), o = s.GetScissoredViewportWidth(), i = s.GetScissoredViewportHeight();
            a && s._UpdateViewportBatch(o, i, r)
        }
        InitClearSurface(e) {
            this._type = n, e.writeToTypedArray(this._mat4param, 0)
        }
        InitClearSurface2(e, t, s, o) {
            this._type = n;
            const i = this._mat4param;
            i[0] = e, i[1] = t, i[2] = s, i[3] = o
        }
        DoClearSurface() {
            const t = this._gl,
                n = this._mat4param,
                r = this._batchState,
                d = r.renderer,
                c = r.clearColor,
                l = d._isScissorViewport && e.isDebug;
            l && t.disable(t.SCISSOR_TEST);
            const s = n[0],
                o = n[1],
                i = n[2],
                a = n[3];
            c.equalsRgba(s, o, i, a) || (t.clearColor(s, o, i, a), c.setRgba(s, o, i, a)), t.clear(t.COLOR_BUFFER_BIT), l && t.enable(t.SCISSOR_TEST)
        }
        InitClearRect(e, t, n, s, o, a, r, c) {
            this._type = i;
            const l = this._mat4param;
            l[0] = e, l[1] = t, l[2] = n, l[3] = s, l[4] = o, l[5] = a, l[6] = r, l[7] = c
        }
        DoClearRectangle() {
            const e = this._gl,
                t = this._mat4param,
                r = this._batchState,
                n = r.renderer,
                c = r.clearColor;
            n._isScissorViewport || e.enable(e.SCISSOR_TEST), e.scissor(t[0], t[1], t[2], t[3]);
            const s = t[4],
                o = t[5],
                i = t[6],
                a = t[7];
            c.equalsRgba(s, o, i, a) || (e.clearColor(s, o, i, a), c.setRgba(s, o, i, a)), e.clear(e.COLOR_BUFFER_BIT), n._isScissorViewport ? e.scissor(0, 0, n._viewportScissorWidth, n._viewportScissorHeight) : e.disable(e.SCISSOR_TEST)
        }
        InitSetPointTexCoords(e) {
            this._type = v, e.writeToTypedArray(this._mat4param, 0)
        }
        DoSetPointTextureCoords() {
            const e = this._mat4param;
            this._batchState.pointTexCoords.set(e[0], e[1], e[2], e[3])
        }
        InitPoints(e, t) {
            this._type = m, this._startIndex = e, this._indexCount = 1, this._mat4param[0] = t
        }
        DoPoints() {
            const n = this._gl,
                t = this._batchState,
                o = t.renderer,
                e = o._spPoints;
            n.useProgram(e._shaderProgram), e.UpdateMatP(t.currentMatP, !1), e.UpdateMatMV(t.currentMV, !1);
            const s = t.pointTexCoords;
            e._uPointTexStart.IsUsed() && e._uPointTexStart.Update2f(s.getLeft(), s.getTop()), e._uPointTexEnd.IsUsed() && e._uPointTexEnd.Update2f(s.getRight(), s.getBottom());
            const i = this._mat4param[0];
            if (e._uZElevation.IsUsed() && e._uZElevation.Update1f(i), e._uColor.IsUsed()) {
                const n = t.currentColor;
                e._uColor.Update4f(n[0], n[1], n[2], n[3])
            }
            n.drawArrays(n.POINTS, this._startIndex / 4, this._indexCount), n.useProgram(t.currentShader._shaderProgram)
        }
        InitSetProgram(e) {
            this._type = a, this._texParam = e
        }
        DoSetProgram() {
            const n = this._gl,
                t = this._batchState,
                e = this._texParam;
            if (t.currentShader = e, n.useProgram(e._shaderProgram), e.UpdateMatP(t.currentMatP, !1), e.UpdateMatMV(t.currentMV, !1), e._uColor.IsUsed()) {
                const n = t.currentColor;
                e._uColor.Update4f(n[0], n[1], n[2], n[3])
            }
        }
        InitSetProgramParameters() {
            this._type = p
        }
        DoSetProgramParameters() {
            const e = this._batchState.currentShader;
            e._hasAnyOptionalUniforms && this._DoSetOptionalUniformProgramParameters(e), e._uCustomParameters.length && this._DoUpdateCustomProgramParameters(e)
        }
        _DoSetOptionalUniformProgramParameters(e) {
            const n = this._gl,
                t = this._mat4param,
                s = this._colorParam,
                o = this._srcOriginRect;
            if (e._uSamplerBack.IsUsed()) {
                const t = this._batchState.renderer,
                    e = this._texParam;
                t._lastTexture1 !== e && (n.activeTexture(n.TEXTURE1), n.bindTexture(n.TEXTURE_2D, e ? e._GetTexture() : null), t._lastTexture1 = e, n.activeTexture(n.TEXTURE0))
            }
            e._uPixelSize.IsUsed() && e._uPixelSize.Update2f(t[0], t[1]), e._uDestStart.IsUsed() && e._uDestStart.Update2f(t[2], t[3]), e._uDestEnd.IsUsed() && e._uDestEnd.Update2f(t[4], t[5]), e._uLayerScale.IsUsed() && e._uLayerScale.Update1f(t[6]), e._uLayerAngle.IsUsed() && e._uLayerAngle.Update1f(t[7]), e._uSrcStart.IsUsed() && e._uSrcStart.Update2f(t[12], t[13]), e._uSrcEnd.IsUsed() && e._uSrcEnd.Update2f(t[14], t[15]), e._uSrcOriginStart.IsUsed() && e._uSrcOriginStart.Update2f(o[0], o[1]), e._uSrcOriginEnd.IsUsed() && e._uSrcOriginEnd.Update2f(o[2], o[3]), e._uLayoutStart.IsUsed() && e._uLayoutStart.Update2f(s[0], s[1]), e._uLayoutEnd.IsUsed() && e._uLayoutEnd.Update2f(s[2], s[3]), e._uSeconds.IsUsed() && e._uSeconds.Update1f(this._startIndex)
        }
        _DoUpdateCustomProgramParameters(e) {
            const t = e._uCustomParameters,
                n = this._shaderParams;
            for (let e = 0, i = t.length; e < i; ++e) {
                const o = t[e],
                    s = n[e];
                o.IsColorType() ? o.Update3f(s.getR(), s.getG(), s.getB()) : o.Update1f(s)
            }
        }
        InitInvalidateFramebuffer(e) {
            this._type = g, this._texParam = e
        }
        DoInvalidateFramebuffer() {
            const e = this._gl,
                t = this._texParam,
                n = this._batchState.currentFramebuffer;
            t !== n && e.bindFramebuffer(e.FRAMEBUFFER, t), e.invalidateFramebuffer(e.FRAMEBUFFER, [e.COLOR_ATTACHMENT0]), t !== n && e.bindFramebuffer(e.FRAMEBUFFER, n)
        }
        InitBlitFramebuffer(t, n, s) {
            this._type = j;
            const o = this._mat4param,
                a = this._batchState.renderer;
            o[0] = t.GetWidth(), o[1] = t.GetHeight(), o[2] = n ? n.GetWidth() : a.GetWidth(), o[3] = n ? n.GetHeight() : a.GetHeight(), o[4] = t.IsLinearSampling() ? 1 : 0, o[5] = s === "stretch";
            const i = this._shaderParams;
            e.clearArray(i), i.push(t._GetFramebuffer()), i.push(n ? n._GetFramebuffer() : null)
        }
        DoBlitFramebuffer() {
            const t = this._mat4param,
                o = this._shaderParams,
                e = this._gl,
                i = t[0],
                n = t[1],
                a = t[2],
                s = t[3],
                r = t[4] !== 0,
                c = t[5] !== 0,
                l = o[0],
                d = o[1];
            if (e.bindFramebuffer(e.READ_FRAMEBUFFER, l), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, d), c) e.blitFramebuffer(0, 0, i, n, 0, 0, a, s, e.COLOR_BUFFER_BIT, r ? e.LINEAR : e.NEAREST);
            else {
                const t = Math.min(i, a),
                    o = Math.min(n, s),
                    r = Math.max(n - s, 0),
                    c = Math.max(s - n, 0);
                e.blitFramebuffer(0, r, t, o + r, 0, c, t, o + c, e.COLOR_BUFFER_BIT, e.NEAREST)
            }
        }
        InitStartQuery(e) {
            this._type = y, this._texParam = e
        }
        DoStartQuery() {
            this._texParam.BeginTimeElapsed(), this._texParam = null
        }
        InitEndQuery(e) {
            this._type = _, this._texParam = e
        }
        DoEndQuery() {
            this._texParam.EndTimeElapsed(), this._texParam = null
        }
        InitSetEllipseParams(e, t, n) {
            this._type = w;
            const s = this._mat4param;
            s[0] = e, s[1] = t, s[2] = n
        }
        DoSetEllipseParams() {
            const e = this._batchState.currentShader,
                t = this._mat4param;
            e._uPixelSize.IsUsed() && e._uPixelSize.Update2f(t[0], t[1]), e._uOutlineThickness.IsUsed() && e._uOutlineThickness.Update1f(t[2])
        }
        InitSetTilemapInfo(e, t, n, s, o, i, a) {
            this._type = b;
            const r = this._mat4param;
            e.writeToTypedArray(r, 0), r[4] = 1 / t, r[5] = 1 / n, r[6] = s / t, r[7] = o / n, r[8] = i / t, r[9] = a / n
        }
        DoSetTilemapInfo() {
            const e = this._batchState.currentShader,
                t = this._mat4param;
            e._uSrcStart.IsUsed() && e._uSrcStart.Update2f(t[0], t[1]), e._uPixelSize.IsUsed() && e._uPixelSize.Update2f(t[4], t[5]), e._uTileSize.IsUsed() && e._uTileSize.Update2f(t[6], t[7]), e._uTileSpacing.IsUsed() && e._uTileSpacing.Update2f(t[8], t[9])
        }
        Run() {
            switch (this._type) {
                case 1:
                    this.DoQuad();
                    return;
                case 2:
                    this.DoSetTexture();
                    return;
                case 3:
                    this.DoSetColor();
                    return;
                case 4:
                    this.DoSetBlend();
                    return;
                case 5:
                    this.DoUpdateModelView();
                    return;
                case 6:
                    this.DoSetRenderTarget();
                    return;
                case 7:
                    this.DoClearSurface();
                    return;
                case 8:
                    this.DoClearRectangle();
                    return;
                case 9:
                    this.DoPoints();
                    return;
                case 10:
                    this.DoSetProgram();
                    return;
                case 11:
                    this.DoSetProgramParameters();
                    return;
                case 12:
                    this.DoInvalidateFramebuffer();
                    return;
                case 13:
                    this.DoSetPointTextureCoords();
                    return;
                case 14:
                    this.DoSetTilemapInfo();
                    return;
                case 15:
                    this.DoBlitFramebuffer();
                    return;
                case 16:
                    this.DoStartQuery();
                    return;
                case 17:
                    this.DoEndQuery();
                    return;
                case 18:
                    this.DoSetEllipseParams();
                    return;
                case 19:
                    this.DoSetGradientColor();
                    return
            }
        }
    }
}
"use strict";
{
    const e = self.C3,
        o = 2048,
        n = 4,
        i = {
            timeout: 60
        },
        s = new e.Color(0, 0, 0, 1),
        a = new Set(["left", "center", "right"]),
        r = new Set(["top", "center", "bottom"]),
        c = new Set(["word", "character"]),
        t = new Set;
    e.FontManager && e.FontManager.addEventListener("fontload", n => {
        const s = n.font.GetName();
        for (const n of t)(n.IsBBCodeEnabled() || e.equalsNoCase(n.GetFontName(), s)) && n._SetTextChanged()
    });

    function fillOrStrokeText(t, n, s, o, i, a) {
        n ? e.Platform.BrowserEngine === "Gecko" ? t.strokeText(s, o, i, a) : t.strokeText(s, o, i) : e.Platform.BrowserEngine === "Gecko" ? t.fillText(s, o, i, a) : t.fillText(s, o, i)
    }

    function fillOrStrokeRect(e, t, n, s, o, i) {
        t ? e.strokeRect(n, s, o, i) : e.fillRect(n, s, o, i)
    }

    function ptToPx(e) {
        return e * (4 / 3)
    }
    e.Gfx.RendererText = class RendererText {
        constructor(n, s) {
            s = Object.assign({}, i, s), this._renderer = n, this._fontName = "Arial", this._fontSize = 16, this._lineHeight = 0, this._isBold = !1, this._isItalic = !1, this._colorStr = "black", this._isBBcodeEnabled = !1, this.onloadfont = null, this._alreadyLoadedFonts = new Set, this._horizontalAlign = "left", this._verticalAlign = "top", this._text = "", this._bbString = null, this._wrappedText = e.New(e.WordWrap), this._wrapMode = "word", this._textChanged = !1, this._isUpdating = !1, this._isAsync = !0, this._drawMaxCharCount = -1, this._drawCharCount = 0, this._cssWidth = 0, this._cssHeight = 0, this._width = 0, this._height = 0, this._zoom = 1, this._changed = !1, this._textCanvas = null, this._textContext = null, this._measureContext = null, this._lastCanvasWidth = -1, this._lastCanvasHeight = -1, this._lastTextCanvasFont = "", this._lastMeasureCanvasFont = "", this._lastTextCanvasFillStyle = "", this._lastTextCanvasOpacity = 1, this._lastTextCanvasLineWidth = 1, this._measureTextCallback = (e, t) => this._MeasureText(e, t), this._texture = null, this._textureWidth = 0, this._textureHeight = 0, this._rcTex = new e.Rect, this._scaleFactor = 1, this._needToRecreateTexture = !1, this._textureTimeout = new e.IdleTimeout(() => {
                this.ReleaseTexture(), this._SetTextCanvasSize(8, 8)
            }, s.timeout), this.ontextureupdate = null, this._wasReleased = !1, t.add(this)
        }
        Release() {
            this.onloadfont = null, this._alreadyLoadedFonts.clear(), this._bbString = null, this._textCanvas = null, this._textContext = null, this._measureContext = null, this._measureTextCallback = null, this._textureTimeout.Release(), this.ontextureupdate = null, this.ReleaseTexture(), this._wrappedText.Clear(), this._wrappedText = null, this._renderer = null, this._wasReleased = !0, t.delete(this)
        }
        _SetChanged() {
            this._changed = !0
        }
        _SetTextChanged() {
            this._SetChanged(), this._wrappedText.Clear(), this._textChanged = !0
        }
        SetIsAsync(e) {
            this._isAsync = !!e
        }
        IsAsync() {
            return this._isAsync
        }
        SetBBCodeEnabled(e) {
            if (e = !!e, this._isBBcodeEnabled === e) return;
            this._isBBcodeEnabled = e, this._textContext && (this._textContext.textBaseline = this._isBBcodeEnabled ? "alphabetic" : "top"), this._SetTextChanged()
        }
        IsBBCodeEnabled() {
            return this._isBBcodeEnabled
        }
        SetFontName(e) {
            if (e || (e = "serif"), this._fontName === e) return;
            this._fontName = e, this._SetTextChanged()
        }
        GetFontName() {
            return this._fontName
        }
        SetFontSize(e) {
            if (e < .1 && (e = .1), this._fontSize === e) return;
            this._fontSize = e, this._SetTextChanged()
        }
        SetLineHeight(e) {
            if (this._lineHeight === e) return;
            this._lineHeight = e, this._SetChanged()
        }
        SetBold(e) {
            if (e = !!e, this._isBold === e) return;
            this._isBold = e, this._SetTextChanged()
        }
        SetItalic(e) {
            if (e = !!e, this._isItalic === e) return;
            this._isItalic = e, this._SetTextChanged()
        }
        SetDrawMaxCharacterCount(e) {
            if (e = Math.floor(e), this._drawMaxCharCount === e) return;
            this._drawMaxCharCount = e, this._SetChanged()
        }
        GetDrawMaxCharacterCount() {
            return this._drawMaxCharCount
        }
        _GetStyleTag(e, t) {
            for (let n = e.length - 1; n >= 0; --n) {
                const s = e[n];
                if (s.tag === t) return s
            }
            return null
        }
        _HasStyleTag(e, t) {
            return !!this._GetStyleTag(e, t)
        }
        _GetFontString(e, t) {
            let n = "";
            (this._isBold || this._HasStyleTag(t, "b")) && (n += "bold"), (this._isItalic || this._HasStyleTag(t, "i")) && (n += " italic");
            const i = this._GetStyleTag(t, "size"),
                a = i ? parseFloat(i.param) : this._fontSize;
            e ? n += " " + a + "pt" : n += " " + a * this._scaleFactor * this._zoom * self.devicePixelRatio + "pt";
            let s = this._fontName;
            const o = this._GetStyleTag(t, "font");
            return o && o.param && (s = o.param, this.onloadfont && !this._alreadyLoadedFonts.has(s) && (this.onloadfont(s), this._alreadyLoadedFonts.add(s))), s && (n += ' "' + s + '"'), n
        }
        SetColor(t) {
            if (t instanceof e.Color && (t = t.getCssRgb()), this._colorStr === t) return;
            this._colorStr = t, this._SetChanged()
        }
        SetColorRgb(e, t, n) {
            s.setRgb(e, t, n), this.SetColor(s)
        }
        SetHorizontalAlignment(e) {
            if (!a.has(e)) throw new Error("invalid horizontal alignment");
            if (this._horizontalAlign === e) return;
            this._horizontalAlign = e, this._SetChanged()
        }
        SetVerticalAlignment(e) {
            if (!r.has(e)) throw new Error("invalid vertical alignment");
            if (this._verticalAlign === e) return;
            this._verticalAlign = e, this._SetChanged()
        }
        SetWordWrapMode(e) {
            if (!c.has(e)) throw new Error("invalid word wrap mode");
            if (this._wrapMode === e) return;
            this._wrapMode = e, this._SetTextChanged()
        }
        SetText(e) {
            if (this._text === e) return;
            this._text = e, this._SetTextChanged()
        }
        SetSize(e, t, n) {
            if (typeof n == "undefined" && (n = 1), e <= 0 || e <= 0) return;
            if (this._cssWidth === e && this._cssHeight === t && this._zoom === n) return;
            this._zoom === 1 !== (n === 1) && (this._needToRecreateTexture = !0);
            const c = this._cssWidth,
                l = this._zoom;
            this._cssWidth = e, this._cssHeight = t, this._zoom = n;
            const a = self.devicePixelRatio;
            this._width = this._cssWidth * this._zoom * a, this._height = this._cssHeight * this._zoom * a;
            const r = Math.max(this._width, this._height),
                s = Math.min(this._renderer.GetMaxTextureSize(), o);
            let i = 1;
            r > s && (i = s / r, this._width = Math.min(this._width * i, s), this._height = Math.min(this._height * i, s)), this._scaleFactor = i, this._textureWidth > 0 && this._textureHeight > 0 && this._zoom === l && this._rcTex.set(0, 0, this._width / this._textureWidth, this._height / this._textureHeight), this._cssWidth !== c ? this._SetTextChanged() : this._SetChanged()
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        GetTextWidth() {
            return this._MaybeWrapText(), this._wrappedText.GetMaxLineWidth()
        }
        GetTextHeight() {
            return this._MaybeWrapText(), this._wrappedText.GetTotalLineHeight() + this._wrappedText.GetLineCount() * (this._lineHeight + n) - this._lineHeight
        }
        GetTexture() {
            return this._textureTimeout.Reset(), this._MaybeUpdate(), this._texture
        }
        _MaybeUpdate() {
            if (this._texture && !this._changed && !this._textChanged) return;
            if (this._isUpdating) return;
            if (this._width <= 0 || this._height <= 0) return;
            this._changed = !1, this._isUpdating = !0, this._isAsync ? e.Asyncify(() => this._DoUpdate()) : this._DoUpdate()
        }
        _DoUpdate() {
            if (this._wasReleased) return;
            this._SetTextCanvasSize(Math.ceil(this._width), Math.ceil(this._height)), this._MaybeWrapText(), this._DrawTextToCanvas(), this._UpdateTexture(), this._textureTimeout.Reset(), this._isUpdating = !1
        }
        _SetTextCanvasSize(t, n) {
            this._textCanvas || (this._textCanvas = e.CreateCanvas(16, 16));
            let s = !1;
            (this._lastCanvasWidth !== t || this._lastCanvasHeight !== n) && (this._lastCanvasWidth = t, this._lastCanvasHeight = n, this._textCanvas.width = t, this._textCanvas.height = n, s = !0), this._textContext || (this._textContext = this._textCanvas.getContext("2d"), s = !0), s ? (this._textContext.textBaseline = this._isBBcodeEnabled ? "alphabetic" : "top", this._textContext.font = this._lastTextCanvasFont, this._textContext.fillStyle = this._lastTextCanvasFillStyle, this._textContext.strokeStyle = this._lastTextCanvasFillStyle, this._textContext.globalAlpha = this._lastTextCanvasOpacity, this._textContext.lineWidth = this._lastTextCanvasLineWidth) : this._textContext.clearRect(0, 0, t, n)
        }
        _MaybeCreateMeasureContext() {
            if (this._measureContext) return;
            this._measureContext = e.CreateCanvas(16, 16).getContext("2d")
        }
        _SetMeasureFontString(e) {
            if (this._lastMeasureCanvasFont === e) return;
            this._lastMeasureCanvasFont = e, this._measureContext.font = e
        }
        _MaybeWrapText() {
            if (!this._textChanged) return;
            this._MaybeCreateMeasureContext(), this._isBBcodeEnabled && (!this._bbString || this._bbString.toString() !== this._text) && (this._bbString = new e.BBString(this._text, {
                noEscape: !0
            })), this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text, this._measureTextCallback, this._cssWidth, this._wrapMode, 0), this._textChanged = !1
        }
        _MeasureText(e, t) {
            this._SetMeasureFontString(this._GetFontString(!0, t));
            const n = this._GetStyleTag(t, "size"),
                s = n ? parseFloat(n.param) : this._fontSize;
            return {
                width: this._measureContext.measureText(e).width,
                height: ptToPx(s)
            }
        }
        _SetDrawFontString(e) {
            if (this._lastTextCanvasFont === e) return;
            this._lastTextCanvasFont = e, this._textContext.font = e
        }
        _SetDrawCanvasColor(e) {
            if (this._lastTextCanvasFillStyle === e) return;
            this._lastTextCanvasFillStyle = e, this._textContext.fillStyle = e, this._textContext.strokeStyle = e
        }
        _SetDrawCanvasOpacity(e) {
            if (this._lastTextCanvasOpacity === e) return;
            this._lastTextCanvasOpacity = e, this._textContext.globalAlpha = e
        }
        _SetDrawCanvasLineWith(e) {
            if (this._lastTextCanvasLineWidth === e) return;
            this._lastTextCanvasLineWidth = e, this._textContext.lineWidth = e
        }
        _DrawTextToCanvas() {
            this._drawCharCount = 0;
            const t = this._scaleFactor * this._zoom * self.devicePixelRatio,
                o = (n + this._lineHeight) * t;
            let e = 0;
            const s = this._wrappedText.GetLines(),
                i = s.reduce((e, n) => e + n.height * t + o, 0) - this._lineHeight * t;
            this._verticalAlign === "center" ? e = Math.max(this._height / 2 - i / 2, 0) : this._verticalAlign === "bottom" && (e = this._height - i - 2);
            for (let i = 0, c = s.length; i < c; ++i) {
                const r = s[i],
                    a = r.height * t,
                    l = e;
                if (this._isBBcodeEnabled) {
                    if (e += a, i > 0 && e > this._height - n * t) break
                } else if (i > 0 && e >= this._height - a) break;
                l >= 0 && this._DrawTextLine(r, e, t), this._isBBcodeEnabled || (e += a), e += o
            }
        }
        _DrawTextLine(e, t, n) {
            let s = 0;
            this._horizontalAlign === "center" ? s = (this._width - e.width * n) / 2 : this._horizontalAlign === "right" && (s = this._width - e.width * n);
            for (const o of e.fragments) this._DrawTextFragment(o, s, t, n, e.height), s += o.width * n
        }
        _DrawTextFragment(t, s, o, i, a) {
            const u = this._textContext,
                _ = a / 16;
            let l = t.width * i;
            const f = t.height * i,
                m = t.height / 16,
                w = (n + this._lineHeight) * i,
                r = t.styles;
            let c = t.text;
            if (this._drawMaxCharCount !== -1) {
                if (this._drawCharCount >= this._drawMaxCharCount) return;
                this._drawCharCount + c.length > this._drawMaxCharCount && (c = c.substr(0, this._drawMaxCharCount - this._drawCharCount), l = this._MeasureText(c, r).width * i), this._drawCharCount += c.length
            }
            const h = this._GetStyleTag(r, "background"),
                p = this._HasStyleTag(r, "u"),
                g = this._HasStyleTag(r, "s");
            if (e.IsStringAllWhitespace(c) && !h && !p && !g || this._HasStyleTag(r, "hide")) return;
            const v = this._GetStyleTag(r, "offsetx");
            s += v ? parseFloat(v.param) * i : 0;
            const b = this._GetStyleTag(r, "offsety");
            o += b ? parseFloat(b.param) * i : 0, h && (this._SetDrawCanvasColor(h.param), u.fillRect(s, o - f, l, f + w));
            const j = this._GetStyleTag(r, "color");
            this._SetDrawCanvasColor(j ? j.param : this._colorStr);
            const y = this._GetStyleTag(r, "opacity");
            this._SetDrawCanvasOpacity(y ? parseFloat(y.param) / 100 : 1);
            const d = this._HasStyleTag(r, "stroke");
            if (d && this._SetDrawCanvasLineWith(m * this._scaleFactor * this._zoom), p && fillOrStrokeRect(u, d, s, o + i * _, l, i * _), g && fillOrStrokeRect(u, d, s, o - f / 4, l, i * m), this._SetDrawFontString(this._GetFontString(!1, r)), fillOrStrokeText(u, d, c, s, o, l), !d) {
                this._SetDrawCanvasLineWith(m * this._scaleFactor * this._zoom);
                const e = this._GetStyleTag(r, "outline");
                e && (this._SetDrawCanvasColor(e.param), fillOrStrokeText(u, !0, c, s, o, l))
            }
        }
        _UpdateTexture() {
            if (this._renderer.IsContextLost()) return;
            this._textureWidth = Math.ceil(this._width), this._textureHeight = Math.ceil(this._height), this._rcTex.set(0, 0, this._width / this._textureWidth, this._height / this._textureHeight), this._needToRecreateTexture && (this.ReleaseTexture(), this._needToRecreateTexture = !1), this._texture || (this._texture = this._renderer.CreateDynamicTexture(this._textureWidth, this._textureHeight, {
                mipMap: this._zoom === 1,
                mipMapQuality: "high"
            })), this._renderer.UpdateTexture(this._textCanvas, this._texture), this.ontextureupdate && this.ontextureupdate()
        }
        GetTexRect() {
            return this._rcTex
        }
        ReleaseTexture() {
            this._texture && (this._renderer.IsContextLost() || this._renderer.DeleteTexture(this._texture), this._texture = null)
        }
        static OnContextLost() {
            for (const e of t) e.ReleaseTexture()
        }
        static GetAll() {
            return t.values()
        }
    }
}
"use strict";
{
    const e = self.C3;
    class t {
        constructor(e) {
            this._gl = e.GetContext(), this._version = e.GetWebGLVersionNumber(), this._timerExt = e._GetDisjointTimerQueryExtension(), this._query = null, this._isActive = !1, this._hasResult = !1, this._result = 0, this._version === 1 ? this._query = this._timerExt.createQueryEXT() : this._query = this._gl.createQuery()
        }
        Release() {
            this._DeleteQueryObject(), this._gl = null, this._timerExt = null, this._hasResult = !1
        }
        _DeleteQueryObject() {
            if (!this._query) return;
            this._version === 1 ? this._timerExt.deleteQueryEXT(this._query) : this._gl.deleteQuery(this._query), this._query = null
        }
        BeginTimeElapsed() {
            if (this._isActive) throw new Error("query already active");
            this._version === 1 ? this._timerExt.beginQueryEXT(this._timerExt.TIME_ELAPSED_EXT, this._query) : this._gl.beginQuery(this._timerExt.TIME_ELAPSED_EXT, this._query), this._isActive = !0
        }
        EndTimeElapsed() {
            if (!this._isActive) throw new Error("query not active");
            this._version === 1 ? this._timerExt.endQueryEXT(this._timerExt.TIME_ELAPSED_EXT) : this._gl.endQuery(this._timerExt.TIME_ELAPSED_EXT), this._isActive = !1
        }
        CheckForResult() {
            if (!this._query || this._hasResult || this._isActive) return;
            let e = !1;
            this._version === 1 ? e = this._timerExt.getQueryObjectEXT(this._query, this._timerExt.QUERY_RESULT_AVAILABLE_EXT) : e = this._gl.getQueryParameter(this._query, this._gl.QUERY_RESULT_AVAILABLE);
            const t = this._gl.getParameter(this._timerExt.GPU_DISJOINT_EXT);
            e && !t && (this._version === 1 ? this._result = this._timerExt.getQueryObjectEXT(this._query, this._timerExt.QUERY_RESULT_EXT) : this._result = this._gl.getQueryParameter(this._query, this._gl.QUERY_RESULT), this._result /= 1e9, this._hasResult = !0), (e || t) && this._DeleteQueryObject()
        }
        HasResult() {
            return this._hasResult
        }
        GetResult() {
            if (!this._hasResult) throw new Error("no result available");
            return this._result
        }
    }
    e.Gfx.WebGLTimeElapsedQuery = class WebGLTimeElapsedQuery {
        constructor(e) {
            this._renderer = e, this._frameNumber = e.GetFrameNumber(), this._isActive = !1, this._parentQuery = null, this._isNested = !1, this._realQuery = null, this._queries = []
        }
        Release() {
            for (const e of this._queries) e instanceof t && e.Release();
            e.clearArray(this._queries), this._parentQuery = null, this._realQuery = null, this._renderer = null
        }
        BeginTimeElapsed() {
            if (this._isActive) throw new Error("query already active");
            const e = this._renderer._GetTimeQueryStack();
            e.length > 0 ? (this._isNested = !0, this._parentQuery = e[e.length - 1], this._parentQuery._EndReal(), this._parentQuery._queries.push(this)) : (this._isNested = !1, this._parentQuery = null), this._isActive = !0, e.push(this), this._StartReal()
        }
        EndTimeElapsed() {
            if (!this._isActive) throw new Error("query not active");
            const e = this._renderer._GetTimeQueryStack().pop();
            if (e !== this) throw new Error("can only end most nested query");
            this._isActive = !1, this._EndReal(), this._parentQuery && (this._parentQuery._StartReal(), this._parentQuery = null)
        }
        _StartReal() {
            this._realQuery = e.New(t, this._renderer), this._queries.push(this._realQuery), this._realQuery.BeginTimeElapsed()
        }
        _EndReal() {
            this._realQuery.EndTimeElapsed(), this._realQuery = null
        }
        CheckForResult() {
            for (const e of this._queries) e.CheckForResult()
        }
        IsNested() {
            return this._isNested
        }
        HasResult() {
            return this._queries.every(e => e.HasResult())
        }
        GetResult() {
            return this._queries.reduce((e, t) => e + t.GetResult(), 0)
        }
        GetFrameNumber() {
            return this._frameNumber
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Gfx.WebGLQueryResultBuffer = class WebGLQueryResultBuffer {
        constructor(e, t = 1e3) {
            this._renderer = e, this._maxQueries = t, this._buffer = [], this._renderer._AddQueryResultBuffer(this)
        }
        Release() {
            this.Clear(), this._renderer._RemoveQueryResultBuffer(this), this._renderer = null
        }
        Clear() {
            for (const e of this._buffer) e.Release();
            e.clearArray(this._buffer)
        }
        AddTimeElapsedQuery() {
            const t = new e.Gfx.WebGLTimeElapsedQuery(this._renderer);
            if (this._buffer.push(t), this._buffer.length > this._maxQueries) {
                const e = this._buffer.shift();
                e.Release()
            }
            return t
        }
        CheckForResults(e) {
            for (const t of this._buffer) {
                if (t.GetFrameNumber() >= e) return;
                if (t.IsNested()) return;
                t.CheckForResult()
            }
        }
        GetFrameRangeResultSum(e, t) {
            if (t <= e) return NaN;
            let n = 0;
            for (const s of this._buffer) {
                if (s.GetFrameNumber() >= t) break;
                if (s.GetFrameNumber() < e) continue;
                if (s.HasResult()) n += s.GetResult();
                else return NaN
            }
            return n
        }
        DeleteAllBeforeFrameNumber(e) {
            for (let t = 0, s = this._buffer.length; t < s; ++t) {
                const n = this._buffer[t];
                if (n.GetFrameNumber() < e) n.Release();
                else {
                    t > 0 && this._buffer.splice(0, t);
                    return
                }
            }
        }
    }
}
"use strict";
{
    const e = self.C3,
        _ = self.assert,
        l = self.glMatrix,
        o = l.vec3,
        j = l.vec4,
        s = l.mat4,
        b = {
            powerPreference: "default",
            enableGpuProfiling: !0,
            alpha: !1,
            lowLatency: !1,
            maxWebGLVersion: 2
        },
        v = new Set(["default", "low-power", "high-performance"]),
        c = 8e3,
        g = c / 2 * 3,
        d = 8e3,
        p = d - 4,
        y = 256 * 1024;

    function areMat4sEqual(e, t) {
        return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[11] === t[11] && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[15] === t[15]
    }
    const u = new e.Quad(0, 0, 1, 0, 1, 1, 0, 1),
        h = o.fromValues(0, 0, 0),
        m = o.fromValues(0, 0, 0),
        f = s.create(),
        n = new e.Quad,
        t = new e.Rect;
    let i = null;
    e.isDebug && (self.debug_lose_context = function() {
        if (!i) {
            console.warn("WEBGL_lose_context not supported");
            return
        }
        i.loseContext()
    }, self.debug_restore_context = function() {
        if (!i) {
            console.warn("WEBGL_lose_context not supported");
            return
        }
        i.restoreContext()
    });
    const r = new Set;
    let a = -1;

    function CheckPendingPolls() {
        a = -1;
        for (const e of r) e.checkFunc() && (e.resolve(), r.delete(e));
        r.size > 0 && (a = self.requestAnimationFrame(CheckPendingPolls))
    }

    function GetWebGLContext(e, t, n) {
        let s = null;
        if (n >= 2 && (s = e.getContext("webgl2", t), s)) return {
            gl: s,
            version: 2
        };
        if (s = e.getContext("webgl", t), !s) try {
            s = e.getContext("experimental-webgl", t)
        } catch (e) {
            console.warn("Error requesting 'experimental-webgl' context: ", e)
        }
        return {
            gl: s,
            version: 1
        }
    }
    e.Gfx.WebGLRenderer = class WebGLRenderer extends e.Gfx.RendererBase {
        constructor(t, n) {
            if (super(), n = Object.assign({}, b, n), !v.has(n.powerPreference)) throw new Error("invalid power preference");
            let a = !1;
            const s = {
                alpha: !!n.alpha,
                depth: !1,
                antialias: !1,
                powerPreference: n.powerPreference,
                failIfMajorPerformanceCaveat: !0
            };
            n.lowLatency && (s.desynchronized = !0, s.preserveDrawingBuffer = !0);
            let o = GetWebGLContext(t, s, n.maxWebGLVersion);
            if (o.gl || (a = !0, s.failIfMajorPerformanceCaveat = !1, o = GetWebGLContext(t, s, n.maxWebGLVersion)), !o.gl) throw new Error("failed to initialise WebGL context");
            const i = o.gl;
            this._gl = i, this._attribs = i.getContextAttributes(), n.lowLatency && !this._attribs.desynchronized && console.info("[WebGLRenderer] Low-latency mode specified but is not supported here"), this._versionString = i.getParameter(i.VERSION), this._version = o.version, this._is3d = !0, this._lastBackbufferWidth = 0, this._lastBackbufferHeight = 0, this._vertexBuffer = null, this._texcoordBuffer = null, this._indexBuffer = null, this._pointBuffer = null, this._vertexData = new Float32Array(c * this.GetNumVertexComponents()), this._indexData = new Uint16Array(g), this._texcoordData = new Float32Array(c * 2), this._pointData = new Float32Array(d * 4), this._vertexPtr = 0, this._texPtr = 0, this._pointPtr = 0, this._lastVertexPtr = 0, this._lastProgram = null, this._spDeviceTransformTextureFill = null, this._spColorFill = null, this._spLinearGradientFill = null, this._spHardEllipseFill = null, this._spHardEllipseOutline = null, this._spSmoothEllipseFill = null, this._spSmoothEllipseOutline = null, this._spSmoothLineFill = null, this._spPoints = null, this._spTilemapFill = null, this._batch = [], this._batchPtr = 0, this._topOfBatch = 0, this._currentRenderTarget = null, this._baseZ = 0, this._currentZ = 0, this._lastPointZ = 0, this._batchState = e.New(e.Gfx.BatchState, this), this._lastColor = e.New(e.Color, 1, 1, 1, 1), this._lastTexture0 = null, this._lastTexture1 = null, this._lastSrcBlend = 0, this._lastDestBlend = 0, this._lineWidth = 1, this._lineWidthStack = [this._lineWidth], this._lineCap = 1, this._lineCapStack = [this._lineCap], this._lineOffset = .5, this._lineOffsetStack = [this._lineOffset], this._isScissorViewport = !1, this._viewportScissorWidth = -1, this._viewportScissorHeight = -1, this._lastPointTexCoords = new e.Rect, this._maxTextureSize = -1, this._minPointSize = 0, this._maxPointSize = 0, this._highpPrecision = 0, this._unmaskedVendor = "(unavailable)", this._unmaskedRenderer = "(unavailable)", this._extensions = [], this._hasMajorPerformanceCaveat = a, this._isInitialisingAfterContextRestored = !1, this._parallelShaderCompileExt = null, this._isGpuProfilingEnabled = !!n.enableGpuProfiling, this._timerExt = null, this._allQueryResultBuffers = new Set, this._timeQueryStack = [], this.FillIndexBufferData(this._indexData)
        }
        async InitState() {
            const t = this._gl,
                l = this.GetNumVertexComponents();
            this._lastColor.setRgba(1, 1, 1, 1), this._lastTexture0 = null, this._lastTexture1 = null, this._vertexPtr = 0, this._pointPtr = 0, this._lastVertexPtr = c * l - 4 * l, e.clearArray(this._batch), this._batchPtr = 0, this._topOfBatch = 0, this._lastProgram = null, this._currentRenderTarget = null, this._lastPointTexCoords.set(0, 0, 1, 1), this._baseZ = 0, this._currentZ = 0, this._lastPointZ = 0;
            const a = this._batchState;
            a.currentShader = null, a.currentFramebuffer = null, j.set(a.currentColor, 1, 1, 1, 1), a.clearColor.setRgba(0, 0, 0, 0), a.pointTexCoords.set(0, 0, 1, 1), t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT), t.enable(t.BLEND), t.blendFunc(t.ONE, t.ONE_MINUS_SRC_ALPHA), this._lastSrcBlend = t.ONE, this._lastDestBlend = t.ONE_MINUS_SRC_ALPHA, this._InitBlendModes(t), t.disable(t.CULL_FACE), t.disable(t.STENCIL_TEST), t.disable(t.DITHER), t.disable(t.DEPTH_TEST), this._pointBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._pointBuffer), t.bufferData(t.ARRAY_BUFFER, this._pointData.byteLength, t.DYNAMIC_DRAW), this._vertexBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this._vertexData.byteLength, t.DYNAMIC_DRAW), this._texcoordBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._texcoordBuffer), t.bufferData(t.ARRAY_BUFFER, this._texcoordData.byteLength, t.DYNAMIC_DRAW), this._indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this._indexData, t.STATIC_DRAW), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, null), this._maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE);
            const d = t.getParameter(t.ALIASED_POINT_SIZE_RANGE);
            this._minPointSize = d[0], this._maxPointSize = d[1];
            const u = t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT),
                h = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT);
            u && h ? this._highpPrecision = Math.min(u.precision, h.precision) : this._highpPrecision = 0, this._maxPointSize > 2048 && (this._maxPointSize = 2048), this._extensions = t.getSupportedExtensions();
            const r = t.getExtension("WEBGL_debug_renderer_info");
            r && (this._unmaskedVendor = t.getParameter(r.UNMASKED_VENDOR_WEBGL), this._unmaskedRenderer = t.getParameter(r.UNMASKED_RENDERER_WEBGL)), this._parallelShaderCompileExt = t.getExtension("KHR_parallel_shader_compile"), e.isDebug && (i = t.getExtension("WEBGL_lose_context")), this._isGpuProfilingEnabled && (this.GetWebGLVersionNumber() === 1 ? (e.Platform.BrowserEngine !== "Chromium" || e.Platform.BrowserVersionNumber >= 81 || typeof document != "undefined") && (this._timerExt = t.getExtension("EXT_disjoint_timer_query")) : this._timerExt = t.getExtension("EXT_disjoint_timer_query_webgl2") || t.getExtension("EXT_disjoint_timer_query")), this._ClearAllShaderPrograms();
            const n = e.Gfx.WebGLShaderProgram,
                o = n.GetDefaultVertexShaderSource(this._is3d, !1),
                m = [
                    [n.GetTextureFillFragmentShaderSource(), o, "<default>"],
                    [n.GetTextureFillFragmentShaderSource(), o, "<default-device-transform>"],
                    [n.GetPointFragmentShaderSource(), n.GetPointVertexShaderSource(), "<point>"],
                    [n.GetColorFillFragmentShaderSource(), o, "<fill>"],
                    [n.GetLinearGradientFillFragmentShaderSource(), o, "<lineargradient>"],
                    [n.GetHardEllipseFillFragmentShaderSource(), o, "<hardellipse>"],
                    [n.GetHardEllipseOutlineFragmentShaderSource(), o, "<hardellipseoutline>"],
                    [n.GetSmoothEllipseFillFragmentShaderSource(), o, "<smoothellipse>"],
                    [n.GetSmoothEllipseOutlineFragmentShaderSource(), o, "<smoothellipseoutline>"],
                    [n.GetSmoothLineFillFragmentShaderSource(), o, "<smoothline>"],
                    [n.GetTilemapFragmentShaderSource(), n.GetDefaultVertexShaderSource(this._is3d, !0), "<tilemap>"]
                ],
                s = await Promise.all(m.map(e => this.CreateShaderProgram({
                    src: e[0]
                }, e[1], e[2])));
            this._spTextureFill = s[0], this._spDeviceTransformTextureFill = s[1], this._spPoints = s[2], this._spColorFill = s[3], this._spLinearGradientFill = s[4], this._spHardEllipseFill = s[5], this._spHardEllipseOutline = s[6], this._spSmoothEllipseFill = s[7], this._spSmoothEllipseOutline = s[8], this._spSmoothLineFill = s[9], this._spTilemapFill = s[10], this._currentStateGroup = null, this.SetTextureFillMode()
        }
        Is3D() {
            return this._is3d
        }
        GetNumVertexComponents() {
            return this._is3d ? 3 : 2
        }
        SetBaseZ(e) {
            this._baseZ = e
        }
        GetBaseZ() {
            return this._baseZ
        }
        SetCurrentZ(e) {
            this._currentZ = e, this._currentStateGroup = null
        }
        GetCurrentZ() {
            return this._currentZ
        }
        async CreateShaderProgram(t, n, s) {
            const o = await e.Gfx.WebGLShaderProgram.Create(this, t, n, s);
            return this._AddShaderProgram(o), o
        }
        ResetLastProgram() {
            this._lastProgram = null
        }
        SetSize(e, t, n) {
            if (this._width === e && this._height === t && !n) return;
            this.EndBatch();
            const s = this._gl,
                a = this._batchState;
            this._width = e, this._height = t;
            const o = this.GetScissoredViewportWidth(),
                i = this.GetScissoredViewportHeight();
            this._UpdateViewportRenderer(o, i, this._width, this._height), this._UpdateViewportBatch(o, i, this._matP), this._spDeviceTransformTextureFill && (s.useProgram(this._spDeviceTransformTextureFill.GetShaderProgram()), this._spDeviceTransformTextureFill._UpdateDeviceTransformUniforms(this._matP), this._lastProgram = this._spDeviceTransformTextureFill, this._batchState.currentShader = this._spDeviceTransformTextureFill), s.bindTexture(s.TEXTURE_2D, null), s.activeTexture(s.TEXTURE1), s.bindTexture(s.TEXTURE_2D, null), s.activeTexture(s.TEXTURE0), this._lastTexture0 = null, this._lastTexture1 = null, this._currentRenderTarget && this._currentRenderTarget._Resize(this._width, this._height), s.bindFramebuffer(s.FRAMEBUFFER, null), this._currentRenderTarget = null, a.currentFramebuffer = null
        }
        _UpdateViewportRenderer(e, t, n, o) {
            this._cam[2] = 100, s.lookAt(this._matMV, this._cam, this._look, this._up), s.perspective(this._matP, 45, e / t, this.GetNearZ(), this.GetFarZ());
            const i = [0, 0],
                a = [0, 0],
                r = self.devicePixelRatio;
            this.Project(0, 0, e, t, i), this.Project(1, 1, e, t, a), this._worldScale[0] = r / (a[0] - i[0]), this._worldScale[1] = -r / (a[1] - i[1]), this._lastBackbufferWidth = n, this._lastBackbufferHeight = o
        }
        _UpdateViewportBatch(e, t, n) {
            const a = this._gl,
                o = this._batchState;
            a.viewport(0, 0, e, t);
            const i = this._allShaderPrograms,
                r = o.currentShader;
            for (let e = 0, s = i.length; e < s; ++e) {
                const t = i[e];
                t === r ? t.UpdateMatP(n, !0) : t.SetMatPStale()
            }
            s.copy(o.currentMatP, n)
        }
        SetViewportScissor(e, t) {
            const n = this._gl;
            if (this._width === e && this._height === t) {
                this._isScissorViewport && (this.EndBatch(), n.disable(n.SCISSOR_TEST), this._isScissorViewport = !1, this._viewportScissorWidth = -1, this._viewportScissorHeight = -1, this.SetSize(this._width, this._height, !0));
                return
            }
            this._isScissorViewport || (this.EndBatch(), n.enable(n.SCISSOR_TEST), this._isScissorViewport = !0), (this._viewportScissorWidth !== e || this._viewportScissorHeight !== t) && (this.EndBatch(), n.scissor(0, 0, e, t), this._viewportScissorWidth = e, this._viewportScissorHeight = t, this.SetSize(this._width, this._height, !0))
        }
        RemoveViewportScissor() {
            const e = this._gl;
            this._isScissorViewport && (this.EndBatch(), e.disable(e.SCISSOR_TEST), this._isScissorViewport = !1), this._viewportScissorWidth = -1, this._viewportScissorHeight = -1
        }
        GetScissoredViewportWidth() {
            return this._isScissorViewport ? this._viewportScissorWidth : this.GetWidth()
        }
        GetScissoredViewportHeight() {
            return this._isScissorViewport ? this._viewportScissorHeight : this.GetHeight()
        }
        UpdateModelView() {
            if (areMat4sEqual(this._lastMV, this._matMV)) return;
            const e = this.PushBatch();
            e.InitUpdateModelView(this._matMV), s.copy(this._lastMV, this._matMV), this._topOfBatch = 0
        }
        GetBatchState() {
            return this._batchState
        }
        PushBatch() {
            const t = this._batch;
            return this._batchPtr === t.length && t.push(new e.Gfx.WebGLBatchJob(this._batchState)), t[this._batchPtr++]
        }
        EndBatch() {
            if (this._batchPtr === 0) return;
            if (this.IsContextLost()) return;
            this._WriteBuffers(), this._ExecuteBatch(), this._batchPtr = 0, this._vertexPtr = 0, this._texPtr = 0, this._pointPtr = 0, this._topOfBatch = 0
        }
        _WriteBuffers() {
            const e = this._gl;
            this._pointPtr > 0 && (e.bindBuffer(e.ARRAY_BUFFER, this._pointBuffer), e.bufferSubData(e.ARRAY_BUFFER, 0, this._pointData.subarray(0, this._pointPtr))), this._vertexPtr > 0 && (e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferSubData(e.ARRAY_BUFFER, 0, this._vertexData.subarray(0, this._vertexPtr)), e.bindBuffer(e.ARRAY_BUFFER, this._texcoordBuffer), e.bufferSubData(e.ARRAY_BUFFER, 0, this._texcoordData.subarray(0, this._texPtr)))
        }
        _ExecuteBatch() {
            const e = this._batch;
            for (let t = 0, n = this._batchPtr; t < n; ++t) e[t].Run()
        }
        GetOpacity() {
            return this._lastColor.getA()
        }
        SetColorRgba(e, t, n, s) {
            const o = this._lastColor;
            if (o.equalsRgba(e, t, n, s)) return;
            o.setRgba(e, t, n, s);
            const i = this.PushBatch();
            i.InitSetColor(o), this._topOfBatch = 0, this._currentStateGroup = null
        }
        SetOpacity(e) {
            const t = this._lastColor;
            if (t.getA() === e) return;
            t.setA(e);
            const n = this.PushBatch();
            n.InitSetColor(t), this._topOfBatch = 0, this._currentStateGroup = null
        }
        SetColor(e) {
            const t = this._lastColor;
            if (t.equals(e)) return;
            t.set(e);
            const n = this.PushBatch();
            n.InitSetColor(t), this._topOfBatch = 0, this._currentStateGroup = null
        }
        ResetColor() {
            this.SetColorRgba(1, 1, 1, 1)
        }
        GetColor() {
            return this._lastColor
        }
        SetTexture(e) {
            if (e === this._lastTexture0) return;
            const t = this.PushBatch();
            t.InitSetTexture(e), this._lastTexture0 = e, this._topOfBatch = 0
        }
        _ResetLastTexture() {
            this._lastTexture0 = null
        }
        SetBlendMode(e) {
            const t = this._GetBlendByIndex(e);
            this._SetBlend(t[0], t[1])
        }
        SetNamedBlendMode(e) {
            const t = this.GetNamedBlend(e);
            this._SetBlend(t.srcBlend, t.destBlend)
        }
        _SetBlend(e, t) {
            if (e === this._lastSrcBlend && t === this._lastDestBlend) return;
            const n = this.PushBatch();
            n.InitSetBlend(e, t), this._lastSrcBlend = e, this._lastDestBlend = t, this._topOfBatch = 0, this._currentStateGroup = null
        }
        IsPremultipliedAlphaBlend() {
            return this._lastSrcBlend === this._gl.ONE && this._lastDestBlend === this._gl.ONE_MINUS_SRC_ALPHA
        }
        SetAlphaBlend() {
            this._SetBlend(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA)
        }
        SetNoPremultiplyAlphaBlend() {
            this._SetBlend(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA)
        }
        SetCopyBlend() {
            this._SetBlend(this._gl.ONE, this._gl.ZERO)
        }
        Rect(e) {
            this.Rect2(e.getLeft(), e.getTop(), e.getRight(), e.getBottom())
        }
        Rect2(e, t, n, s) {
            this.Quad2(e, t, n, t, n, s, e, s)
        }
        _ExtendQuadBatch() {
            let e = this._vertexPtr;
            if (e >= this._lastVertexPtr && (this.EndBatch(), e = 0), this._topOfBatch === 1) this._batch[this._batchPtr - 1]._indexCount += 6;
            else {
                const t = this.PushBatch();
                t.InitQuad(this._is3d ? e : e / 2 * 3, 6), this._topOfBatch = 1
            }
        }
        _WriteQuadToVertexBuffer(e) {
            e.writeToTypedArray3D(this._vertexData, this._vertexPtr, this._baseZ + this._currentZ), this._vertexPtr += 12
        }
        Quad(e) {
            this._ExtendQuadBatch(), this._WriteQuadToVertexBuffer(e), u.writeToTypedArray(this._texcoordData, this._texPtr), this._texPtr += 8
        }
        Quad2(e, t, n, s, o, i, a, r) {
            this._ExtendQuadBatch();
            const l = this._vertexData;
            let c = this._vertexPtr;
            const d = this._baseZ + this._currentZ;
            this._is3d ? (l[c++] = e, l[c++] = t, l[c++] = d, l[c++] = n, l[c++] = s, l[c++] = d, l[c++] = o, l[c++] = i, l[c++] = d, l[c++] = a, l[c++] = r, l[c++] = d) : (l[c++] = e, l[c++] = t, l[c++] = n, l[c++] = s, l[c++] = o, l[c++] = i, l[c++] = a, l[c++] = r), this._vertexPtr = c, u.writeToTypedArray(this._texcoordData, this._texPtr), this._texPtr += 8
        }
        Quad3(e, t) {
            this._ExtendQuadBatch(), this._WriteQuadToVertexBuffer(e), t.writeAsQuadToTypedArray(this._texcoordData, this._texPtr), this._texPtr += 8
        }
        Quad4(e, t) {
            this._ExtendQuadBatch(), this._WriteQuadToVertexBuffer(e), t.writeToTypedArray(this._texcoordData, this._texPtr), this._texPtr += 8
        }
        FullscreenQuad(e, i) {
            if (s.copy(f, this._lastMV), o.copy(h, this._cam), o.copy(m, this._look), this._cam[0] = 0, this._cam[1] = 0, this._cam[2] = 100 * self.devicePixelRatio, this._look[0] = 0, this._look[1] = 0, this._look[2] = 0, this.ResetModelView(), this.UpdateModelView(), this._isScissorViewport) {
                const e = this._viewportScissorWidth / 2,
                    s = this._viewportScissorHeight / 2;
                t.set(-e, s, -e + this._viewportScissorWidth, s - this._viewportScissorHeight), n.setFromRect(t), t.set(0, 0, this._viewportScissorWidth / this._width, this._viewportScissorHeight / this._height), this.Quad3(n, t)
            } else if (e === "crop" && this._currentRenderTarget && i) {
                const o = this._width / 2,
                    a = this._height / 2,
                    r = i.GetWidth(),
                    e = i.GetHeight(),
                    h = this._currentRenderTarget.GetWidth(),
                    s = this._currentRenderTarget.GetHeight(),
                    c = Math.min(h, r),
                    l = Math.min(s, e),
                    d = Math.max(e - s, 0),
                    u = Math.max(s - e, 0);
                t.set(-o, a - u, -o + c, a - l - u), n.setFromRect(t), t.set(0, d, c, l + d), t.divide(r, e), this.Quad3(n, t)
            } else {
                let [n, s] = this.GetRenderTargetSize(this._currentRenderTarget);
                const e = n / 2,
                    t = s / 2;
                this.Rect2(-e, t, e, -t)
            }
            s.copy(this._matMV, f), o.copy(this._cam, h), o.copy(this._look, m), this.UpdateModelView()
        }
        ConvexPoly(e) {
            const t = e.length / 2;
            if (t < 3) throw new Error("need at least 3 points");
            const n = t - 2,
                i = n - 1,
                s = e[0],
                o = e[1];
            for (let a = 0; a < n; a += 2) {
                const t = a * 2,
                    l = e[t + 2],
                    d = e[t + 3],
                    r = e[t + 4],
                    c = e[t + 5];
                if (a === i) this.Quad2(s, o, l, d, r, c, r, c);
                else {
                    const n = e[t + 6],
                        i = e[t + 7];
                    this.Quad2(s, o, l, d, r, c, n, i)
                }
            }
        }
        Line(t, n, s, o) {
            const r = e.angleTo(t, n, s, o),
                d = Math.sin(r),
                u = Math.cos(r),
                c = this._lineWidth * .5,
                i = d * c,
                a = u * c,
                l = this._lineCap;
            l === 2 ? this.LinePreCalc_LineCap2(t, n, s, o, i, a) : l === 1 ? this.LinePreCalc_LineCap1(t, n, s, o, i, a) : this.LinePreCalc_LineCap0(t, n, s, o, i, a)
        }
        LinePreCalc_LineCap2(e, t, n, s, o, i) {
            const a = this._lineOffset,
                r = e + a - i,
                c = t + a - o,
                l = n + a + i,
                d = s + a + o,
                u = i * 2,
                h = o * 2,
                m = r + o,
                f = c - i,
                p = r - o + u,
                g = c + i + h,
                v = l + o,
                b = d - i,
                j = l - o - u,
                y = d + i - h;
            this.Quad2(m, f, v, b, j, y, p, g)
        }
        LinePreCalc_LineCap1(e, t, n, s, o, i) {
            const a = this._lineOffset,
                r = e + a - i,
                c = t + a - o,
                l = n + a + i,
                d = s + a + o,
                u = r + o,
                h = c - i,
                m = r - o,
                f = c + i,
                p = l + o,
                g = d - i,
                v = l - o,
                b = d + i;
            this.Quad2(u, h, p, g, v, b, m, f)
        }
        LinePreCalc_LineCap0(e, t, n, s, o, i) {
            const a = this._lineOffset,
                r = e + a,
                c = t + a,
                l = n + a,
                d = s + a,
                u = r + o,
                h = c - i,
                m = r - o,
                f = c + i,
                p = l + o,
                g = d - i,
                v = l - o,
                b = d + i;
            this.Quad2(u, h, p, g, v, b, m, f)
        }
        TexturedLine(t, n, s, o, i, a) {
            const l = e.angleTo(t, n, s, o),
                h = Math.sin(l),
                m = Math.cos(l),
                d = this._lineWidth * .5,
                r = h * d,
                c = m * d,
                u = this._lineCap;
            u === 2 ? this.TexturedLinePreCalc_LineCap2(t, n, s, o, r, c, i, a) : u === 1 ? this.TexturedLinePreCalc_LineCap1(t, n, s, o, r, c, i, a) : this.TexturedLinePreCalc_LineCap0(t, n, s, o, r, c, i, a)
        }
        TexturedLinePreCalc_LineCap2(e, s, o, i, a, r, c, l) {
            const d = this._lineOffset,
                u = e + d - r,
                h = s + d - a,
                m = o + d + r,
                f = i + d + a,
                p = r * 2,
                g = a * 2,
                v = u + a,
                b = h - r,
                j = u - a + p,
                y = h + r + g,
                _ = m + a,
                w = f - r,
                O = m - a - p,
                x = f + r - g;
            n.set(v, b, _, w, O, x, j, y), t.set(c, 0, l, 0), this.Quad3(n, t)
        }
        TexturedLinePreCalc_LineCap1(e, s, o, i, a, r, c, l) {
            const d = this._lineOffset,
                u = e + d - r,
                h = s + d - a,
                m = o + d + r,
                f = i + d + a,
                p = u + a,
                g = h - r,
                v = u - a,
                b = h + r,
                j = m + a,
                y = f - r,
                _ = m - a,
                w = f + r;
            n.set(p, g, j, y, _, w, v, b), t.set(c, 0, l, 0), this.Quad3(n, t)
        }
        TexturedLinePreCalc_LineCap0(e, s, o, i, a, r, c, l) {
            const d = this._lineOffset,
                u = e + d,
                h = s + d,
                m = o + d,
                f = i + d,
                p = u + a,
                g = h - r,
                v = u - a,
                b = h + r,
                j = m + a,
                y = f - r,
                _ = m - a,
                w = f + r;
            n.set(p, g, j, y, _, w, v, b), t.set(c, 0, l, 0), this.Quad3(n, t)
        }
        LineRect(e, t, n, s) {
            const o = this._lineWidth * .5,
                i = this._lineCap;
            i === 2 ? this._LineRectPreCalc_LineCap2(e, t, n, s, o) : i === 1 ? this._LineRectPreCalc_LineCap1(e, t, n, s, o) : this._LineRectPreCalc_LineCap0(e, t, n, s, o)
        }
        _LineRectPreCalc_LineCap2(e, t, n, s, o) {
            this.LinePreCalc_LineCap2(e, t, n, t, 0, o), this.LinePreCalc_LineCap2(n, t, n, s, o, 0), this.LinePreCalc_LineCap2(n, s, e, s, 0, -o), this.LinePreCalc_LineCap2(e, s, e, t, -o, 0)
        }
        _LineRectPreCalc_LineCap1(e, t, n, s, o) {
            this.LinePreCalc_LineCap1(e, t, n, t, 0, o), this.LinePreCalc_LineCap1(n, t, n, s, o, 0), this.LinePreCalc_LineCap1(n, s, e, s, 0, -o), this.LinePreCalc_LineCap1(e, s, e, t, -o, 0)
        }
        _LineRectPreCalc_LineCap0(e, t, n, s, o) {
            this.LinePreCalc_LineCap0(e, t, n, t, 0, o), this.LinePreCalc_LineCap0(n, t, n, s, o, 0), this.LinePreCalc_LineCap0(n, s, e, s, 0, -o), this.LinePreCalc_LineCap0(e, s, e, t, -o, 0)
        }
        LineRect2(e) {
            this.LineRect(e.getLeft(), e.getTop(), e.getRight(), e.getBottom())
        }
        LineQuad(t) {
            const o = e.angleTo(t.getTlx(), t.getTly(), t.getTrx(), t.getTry()),
                r = Math.sin(o),
                c = Math.cos(o),
                i = this._lineWidth * .5,
                n = r * i,
                s = c * i,
                a = this._lineCap;
            a === 2 ? this._LineQuadPreCalc_LineCap2(t, n, s) : a === 1 ? this._LineQuadPreCalc_LineCap1(t, n, s) : this._LineQuadPreCalc_LineCap0(t, n, s)
        }
        _LineQuadPreCalc_LineCap2(e, t, n) {
            this.LinePreCalc_LineCap2(e.getTlx(), e.getTly(), e.getTrx(), e.getTry(), t, n), this.LinePreCalc_LineCap2(e.getTrx(), e.getTry(), e.getBrx(), e.getBry(), n, -t), this.LinePreCalc_LineCap2(e.getBrx(), e.getBry(), e.getBlx(), e.getBly(), -t, -n), this.LinePreCalc_LineCap2(e.getBlx(), e.getBly(), e.getTlx(), e.getTly(), -n, t)
        }
        _LineQuadPreCalc_LineCap1(e, t, n) {
            this.LinePreCalc_LineCap1(e.getTlx(), e.getTly(), e.getTrx(), e.getTry(), t, n), this.LinePreCalc_LineCap1(e.getTrx(), e.getTry(), e.getBrx(), e.getBry(), n, -t), this.LinePreCalc_LineCap1(e.getBrx(), e.getBry(), e.getBlx(), e.getBly(), -t, -n), this.LinePreCalc_LineCap1(e.getBlx(), e.getBly(), e.getTlx(), e.getTly(), -n, t)
        }
        _LineQuadPreCalc_LineCap0(e, t, n) {
            this.LinePreCalc_LineCap0(e.getTlx(), e.getTly(), e.getTrx(), e.getTry(), t, n), this.LinePreCalc_LineCap0(e.getTrx(), e.getTry(), e.getBrx(), e.getBry(), n, -t), this.LinePreCalc_LineCap0(e.getBrx(), e.getBry(), e.getBlx(), e.getBly(), -t, -n), this.LinePreCalc_LineCap0(e.getBlx(), e.getBly(), e.getTlx(), e.getTly(), -n, t)
        }
        SetLineWidth(e) {
            this._lineWidth = e, this._lineWidthStack[this._lineWidthStack.length - 1] = e
        }
        GetLineWidth() {
            return this._lineWidth
        }
        PushLineWidth(e) {
            if (this._lineWidthStack.length >= 100) throw new Error("pushed too many line widths - check push/pop pairs");
            this._lineWidthStack.push(e), this._lineWidth = e
        }
        PopLineWidth() {
            if (this._lineWidthStack.length <= 1) throw new Error("cannot pop last line width - check push/pop pairs");
            this._lineWidthStack.pop(), this._lineWidth = this._lineWidthStack[this._lineWidthStack.length - 1]
        }
        SetLineCapButt() {
            this._lineCap = 0, this._lineCapStack[this._lineCapStack.length - 1] = 0
        }
        SetLineCapSquare() {
            this._lineCap = 1, this._lineCapStack[this._lineCapStack.length - 1] = 0
        }
        SetLineCapZag() {
            this._lineCap = 2, this._lineCapStack[this._lineCapStack.length - 1] = 0
        }
        PushLineCap(e) {
            if (e === "butt") this.PushLineCapButt();
            else if (e === "square") this.PushLineCapSquare();
            else if (e === "zag") this.PushLineCapZag();
            else throw new Error("invalid line cap")
        }
        PushLineCapButt() {
            if (this._lineCapStack.length >= 100) throw new Error("pushed too many line caps - check push/pop pairs");
            this._lineCapStack.push(0), this._lineCap = 0
        }
        PushLineCapSquare() {
            if (this._lineCapStack.length >= 100) throw new Error("pushed too many line caps - check push/pop pairs");
            this._lineCapStack.push(1), this._lineCap = 1
        }
        PushLineCapZag() {
            if (this._lineCapStack.length >= 100) throw new Error("pushed too many line caps - check push/pop pairs");
            this._lineCapStack.push(2), this._lineCap = 2
        }
        PopLineCap() {
            if (this._lineCapStack.length <= 1) throw new Error("cannot pop last line cap - check push/pop pairs");
            this._lineCapStack.pop(), this._lineCap = this._lineCapStack[this._lineCapStack.length - 1]
        }
        SetLineOffset(e) {
            this._lineOffset = e, this._lineOffsetStack[this._lineOffsetStack.length - 1] = e
        }
        GetLineOffset() {
            return this._lineOffset
        }
        PushLineOffset(e) {
            if (this._lineOffsetStack.length >= 100) throw new Error("pushed too many line offsets - check push/pop pairs");
            this._lineOffsetStack.push(e), this._lineOffset = e
        }
        PopLineOffset() {
            if (this._lineOffsetStack.length <= 1) throw new Error("cannot pop last line offset - check push/pop pairs");
            this._lineOffsetStack.pop(), this._lineOffset = this._lineOffsetStack[this._lineOffsetStack.length - 1]
        }
        SetPointTextureCoords(e) {
            if (this._lastPointTexCoords.equals(e)) return;
            this._lastPointTexCoords.copy(e);
            const t = this.PushBatch();
            t.InitSetPointTexCoords(e), this._topOfBatch = 0
        }
        Point(e, t, n, s) {
            this._pointPtr >= p && this.EndBatch();
            let o = this._pointPtr;
            const a = this._baseZ + this._currentZ;
            if (this._topOfBatch === 2 && this._lastPointZ === a) this._batch[this._batchPtr - 1]._indexCount++;
            else {
                const e = this.PushBatch();
                e.InitPoints(o, a), this._topOfBatch = 2, this._lastPointZ = a
            }
            const i = this._pointData;
            i[o++] = e, i[o++] = t, i[o++] = n, i[o++] = s, this._pointPtr = o
        }
        SetProgram(e) {
            if (this._lastProgram === e) return;
            const t = this.PushBatch();
            t.InitSetProgram(e), this._lastProgram = e, this._topOfBatch = 0, this._currentStateGroup = null
        }
        SetTextureFillMode() {
            this.SetProgram(this._spTextureFill)
        }
        SetDeviceTransformTextureFillMode() {
            this.SetProgram(this._spDeviceTransformTextureFill)
        }
        SetColorFillMode() {
            this.SetProgram(this._spColorFill)
        }
        SetLinearGradientFillMode() {
            this.SetProgram(this._spLinearGradientFill)
        }
        SetGradientColor(e) {
            const t = this.PushBatch();
            t.InitSetGradientColor(e), this._topOfBatch = 0
        }
        SetHardEllipseFillMode() {
            this.SetProgram(this._spHardEllipseFill)
        }
        SetHardEllipseOutlineMode() {
            this.SetProgram(this._spHardEllipseOutline)
        }
        SetSmoothEllipseFillMode() {
            this.SetProgram(this._spSmoothEllipseFill)
        }
        SetSmoothEllipseOutlineMode() {
            this.SetProgram(this._spSmoothEllipseOutline)
        }
        SetEllipseParams(e, t, n = 1) {
            const s = this.PushBatch();
            s.InitSetEllipseParams(e, t, n), this._topOfBatch = 0
        }
        SetSmoothLineFillMode() {
            this.SetProgram(this._spSmoothLineFill)
        }
        SetTilemapFillMode() {
            this.SetProgram(this._spTilemapFill)
        }
        SetTilemapInfo(e, t, n, s, o, i, a) {
            if (this._lastProgram !== this._spTilemapFill) throw new Error("must set tilemap fill mode first");
            const r = this.PushBatch();
            r.InitSetTilemapInfo(e, t, n, s, o, i, a), this._topOfBatch = 0
        }
        SetProgramParameters(t, n, s, o, i, a, r, c, l, d, u) {
            const m = this._lastProgram,
                f = m._hasAnyOptionalUniforms,
                p = !!u.length;
            if ((!f || m.AreOptionalUniformsAlreadySetInBatch(n, s, o, i, a, r, c, l, d)) && (!p || m.AreCustomParametersAlreadySetInBatch(u))) return;
            const h = this.PushBatch();
            if (h.InitSetProgramParameters(), f) {
                m.SetOptionalUniformsInBatch(n, s, o, i, a, r, c, l, d);
                const e = h._mat4param;
                e[0] = a, e[1] = r, n.writeToTypedArray(e, 2), e[6] = c, e[7] = l, s.writeToTypedArray(e, 12);
                const u = h._colorParam;
                i.writeToTypedArray(u, 0);
                const f = u[1];
                u[1] = u[3], u[3] = f, o.writeToTypedArray(h._srcOriginRect, 0), h._startIndex = d, m._uSamplerBack.IsUsed() ? h._texParam = t ? t.GetTexture() : null : h._texParam = null
            }
            p && (m.SetCustomParametersInBatch(u), e.shallowAssignArray(h._shaderParams, u)), this._topOfBatch = 0
        }
        ClearRgba(e, t, n, s) {
            const o = this.PushBatch();
            o.InitClearSurface2(e, t, n, s), this._topOfBatch = 0
        }
        Clear(e) {
            const t = this.PushBatch();
            t.InitClearSurface(e), this._topOfBatch = 0
        }
        ClearRect(e, t, n, s) {
            this.ClearRect4(e, t, n, s, 0, 0, 0, 0)
        }
        ClearRect2(e) {
            this.ClearRect4(e.getLeft(), e.getTop(), e.width(), e.height(), 0, 0, 0, 0)
        }
        ClearRect3(e, t) {
            this.ClearRect4(e.getLeft(), e.getTop(), e.width(), e.height(), t.getR(), t.getG(), t.getB(), t.getA())
        }
        ClearRect4(e, t, n, s, o, i, a, r) {
            if (n < 0 || s < 0) return;
            const c = this.PushBatch();
            c.InitClearRect(e, t, n, s, o, i, a, r), this._topOfBatch = 0
        }
        Start() {}
        Finish() {
            super.Finish(), this._gl.flush()
        }
        CheckForQueryResults() {
            for (const e of this._allQueryResultBuffers) e.CheckForResults(this._frameNumber)
        }
        IsContextLost() {
            return !this._gl || this._gl.isContextLost() || this._isInitialisingAfterContextRestored
        }
        OnContextLost() {
            e.Gfx.WebGLRendererTexture.OnContextLost(), e.Gfx.WebGLRenderTarget.OnContextLost(), e.Gfx.RendererText.OnContextLost();
            for (const e of this._allQueryResultBuffers) e.Clear();
            this._extensions = [], this._timerExt = null, this._parallelShaderCompileExt = null, this._unmaskedVendor = "(unavailable)", this._unmaskedRenderer = "(unavailable)", this._lastProgram = null, this._spTextureFill = null, this._spDeviceTransformTextureFill = null, this._spColorFill = null, this._spLinearGradientFill = null, this._spHardEllipseFill = null, this._spHardEllipseOutline = null, this._spSmoothEllipseFill = null, this._spSmoothEllipseOutline = null, this._spSmoothLineFill = null, this._spPoints = null, this._spTilemapFill = null;
            for (const e of this._stateGroups.values()) e.OnContextLost();
            for (const e of this._allShaderPrograms) e.Release();
            this._ClearAllShaderPrograms()
        }
        async OnContextRestored() {
            this._isInitialisingAfterContextRestored = !0, await this.InitState(), this._isInitialisingAfterContextRestored = !1;
            for (const e of this._stateGroups.values()) e.OnContextRestored(this);
            this.SetSize(this._width, this._height, !0)
        }
        CreateStaticTexture(t, n) {
            if (this.IsContextLost()) throw new Error("context lost");
            this.EndBatch();
            const s = e.New(e.Gfx.WebGLRendererTexture, this);
            return s._CreateStatic(t, n), s
        }
        CreateStaticTextureAsync(t, n) {
            if (this.IsContextLost()) return Promise.reject("context lost");
            n = Object.assign({}, n);
            const s = n.wrapX && n.wrapX !== "clamp-to-edge" || n.wrapY && n.wrapY !== "clamp-to-edge";
            return e.Supports.ImageBitmapOptions && (this.SupportsNPOTTextures() || !s) ? (n.premultiplyAlpha = !1, createImageBitmap(t, {
                premultiplyAlpha: "premultiply"
            }).then(t => e.Asyncify(() => this.CreateStaticTexture(t, n)))) : e.Supports.ImageBitmap ? createImageBitmap(t).then(t => e.Asyncify(() => this.CreateStaticTexture(t, n))) : t instanceof Blob ? e.BlobToImage(t, !0).then(e => this.CreateStaticTextureAsync(e, n)) : typeof HTMLImageElement != "undefined" && t instanceof HTMLImageElement && typeof t.decode == "function" ? t.decode().then(() => e.Asyncify(() => this.CreateStaticTexture(t, n))) : e.Asyncify(() => this.CreateStaticTexture(t, n))
        }
        CreateDynamicTexture(t, n, s) {
            this.EndBatch();
            const o = e.New(e.Gfx.WebGLRendererTexture, this);
            return o._CreateDynamic(t, n, s), o
        }
        UpdateTexture(e, t, n) {
            this.EndBatch(), t._Update(e, n)
        }
        DeleteTexture(e) {
            if (!e) return;
            if (e.SubtractReference(), e.GetReferenceCount() > 0) return;
            this.EndBatch(), e === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._lastTexture0 = null), e === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0), this._lastTexture1 = null), e._Delete()
        }
        CreateRenderTarget(t) {
            let n = this._width,
                s = this._height,
                o = !0;
            if (t && (typeof t.width == "number" && (n = t.width, o = !1), typeof t.height == "number" && (s = t.height, o = !1)), n <= 0 || s <= 0) throw new Error("invalid size");
            this.EndBatch();
            const i = e.New(e.Gfx.WebGLRenderTarget, this);
            return i._Create(n, s, Object.assign({
                isDefaultSize: o
            }, t)), this._currentRenderTarget = null, this._batchState.currentFramebuffer = null, i
        }
        SetRenderTarget(e) {
            if (e === this._currentRenderTarget) return;
            let s, o, t, n;
            e ? (e.IsDefaultSize() && e._Resize(this._width, this._height), t = e.GetWidth(), n = e.GetHeight(), s = t, o = n) : (t = this._width, n = this._height, s = this.GetScissoredViewportWidth(), o = this.GetScissoredViewportHeight());
            const i = this._lastBackbufferWidth !== t || this._lastBackbufferHeight !== n;
            i && this._UpdateViewportRenderer(s, o, t, n);
            const a = this.PushBatch();
            a.InitSetRenderTarget(e, i, this._matP), this._currentRenderTarget = e, this._topOfBatch = 0
        }
        GetRenderTarget() {
            return this._currentRenderTarget
        }
        GetRenderTargetSize(e) {
            return e ? [e.GetWidth(), e.GetHeight()] : [this._width, this._height]
        }
        CopyRenderTarget(e, t = "stretch") {
            if (this._version < 2 || this._currentRenderTarget && this._currentRenderTarget.GetMultisampling() > 0) this.SetCopyBlend(), this.ResetColor(), this.DrawRenderTarget(e, t);
            else {
                const n = this.PushBatch();
                n.InitBlitFramebuffer(e, this._currentRenderTarget, t), this._topOfBatch = 0
            }
        }
        DrawRenderTarget(e, t = "stretch") {
            const n = e.GetTexture();
            if (!n) throw new Error("not a texture-backed render target");
            this.SetTexture(n), this.FullscreenQuad(t, n)
        }
        InvalidateRenderTarget(e) {
            if (this._version < 2) return;
            const t = this.PushBatch();
            t.InitInvalidateFramebuffer(e._GetFramebuffer()), this._topOfBatch = 0
        }
        DeleteRenderTarget(e) {
            this.SetRenderTarget(null), this.EndBatch();
            const t = e.GetTexture();
            t === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._lastTexture0 = null), t === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0), this._lastTexture1 = null), e._Delete()
        }
        async ReadBackRenderTargetToImageData(t, n, s) {
            this.EndBatch();
            const f = this._currentRenderTarget;
            let c, i, h;
            t ? (c = t.GetWidth(), i = t.GetHeight(), h = t._GetFramebuffer()) : (c = this.GetWidth(), i = this.GetHeight(), h = null);
            let d = 0,
                a = 0,
                l = c,
                r = i;
            if (s) {
                d = e.clamp(Math.floor(s.getLeft()), 0, c - 1), a = e.clamp(Math.floor(s.getTop()), 0, i - 1);
                let t = s.width();
                t === 0 ? t = c - d : t = e.clamp(Math.floor(t), 0, c - d);
                let n = s.height();
                n === 0 ? n = i - a : n = e.clamp(Math.floor(n), 0, i - a), l = t, r = n, a = i - (a + r)
            }
            const o = this._gl;
            o.bindFramebuffer(o.FRAMEBUFFER, h);
            const m = () => {
                o.bindFramebuffer(o.FRAMEBUFFER, null), this._currentRenderTarget = null, this._batchState.currentFramebuffer = null, this.SetRenderTarget(f)
            };
            let u;
            if (!n && this.GetWebGLVersionNumber() >= 2) {
                o.bindFramebuffer(o.READ_FRAMEBUFFER, h);
                const t = o.createBuffer(),
                    n = l * r * 4,
                    e = o.PIXEL_PACK_BUFFER;
                o.bindBuffer(e, t), o.bufferData(e, n, o.STREAM_READ), o.readPixels(d, a, l, r, o.RGBA, o.UNSIGNED_BYTE, 0), o.bindFramebuffer(o.READ_FRAMEBUFFER, null), o.bindBuffer(e, null), m();
                const s = o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE, 0);
                await this._WaitForObjectReady(() => o.getSyncParameter(s, o.SYNC_STATUS) === o.SIGNALED), o.deleteSync(s), u = new ImageData(l, r), o.bindBuffer(e, t), o.getBufferSubData(e, 0, new Uint8Array(u.data.buffer), 0, n), o.bindBuffer(e, null), o.deleteBuffer(t)
            } else u = new ImageData(l, r), o.readPixels(d, a, l, r, o.RGBA, o.UNSIGNED_BYTE, new Uint8Array(u.data.buffer)), m();
            return u
        }
        StartQuery(e) {
            if (!this.SupportsGPUProfiling()) return;
            const t = this.PushBatch();
            t.InitStartQuery(e), this._topOfBatch = 0
        }
        EndQuery(e) {
            if (!this.SupportsGPUProfiling()) return;
            const t = this.PushBatch();
            t.InitEndQuery(e), this._topOfBatch = 0
        }
        _WaitForObjectReady(e) {
            const t = new Promise(t => r.add({
                resolve: t,
                checkFunc: e
            }));
            return a === -1 && (a = self.requestAnimationFrame(CheckPendingPolls)), t
        }
        IsDesynchronized() {
            return !!this._attribs.desynchronized
        }
        GetEstimatedBackBufferMemoryUsage() {
            return this._width * this._height * (this._attribs.alpha ? 4 : 3)
        }
        GetEstimatedRenderBufferMemoryUsage() {
            let t = 0;
            for (const n of e.Gfx.WebGLRenderTarget.allRenderTargets()) {
                if (n.GetTexture()) continue;
                t += n.GetEstimatedMemoryUsage()
            }
            return t
        }
        GetEstimatedTextureMemoryUsage() {
            let t = 0;
            for (const n of e.Gfx.WebGLRendererTexture.allTextures()) t += n.GetEstimatedMemoryUsage();
            return t
        }
        GetEstimatedTotalMemoryUsage() {
            return this.GetEstimatedBackBufferMemoryUsage() + this.GetEstimatedRenderBufferMemoryUsage() + this.GetEstimatedTextureMemoryUsage()
        }
        GetWebGLVersionString() {
            return this._versionString
        }
        GetWebGLVersionNumber() {
            return this._version
        }
        SupportsNPOTTextures() {
            return this.GetWebGLVersionNumber() >= 2
        }
        GetMaxTextureSize() {
            return this._maxTextureSize
        }
        GetMinPointSize() {
            return this._minPointSize
        }
        GetMaxPointSize() {
            return this._maxPointSize
        }
        SupportsHighP() {
            return this._highpPrecision !== 0
        }
        GetHighPPrecision() {
            return this._highpPrecision
        }
        GetUnmaskedVendor() {
            return this._unmaskedVendor
        }
        GetUnmaskedRenderer() {
            return this._unmaskedRenderer
        }
        GetExtensions() {
            return this._extensions
        }
        HasMajorPerformanceCaveat() {
            return this._hasMajorPerformanceCaveat
        }
        SupportsGPUProfiling() {
            return !!this._timerExt
        }
        _GetDisjointTimerQueryExtension() {
            return this._timerExt
        }
        _GetParallelShaderCompileExtension() {
            return this._parallelShaderCompileExt
        }
        _AddQueryResultBuffer(e) {
            this._allQueryResultBuffers.add(e)
        }
        _RemoveQueryResultBuffer(e) {
            this._allQueryResultBuffers.delete(e)
        }
        _GetTimeQueryStack() {
            return this._timeQueryStack
        }
        GetContext() {
            return this._gl
        }
        _InitBlendModes(e) {
            this._InitBlendModeData([
                ["normal", e.ONE, e.ONE_MINUS_SRC_ALPHA],
                ["additive", e.ONE, e.ONE],
                ["xor", e.ONE, e.ONE_MINUS_SRC_ALPHA],
                ["copy", e.ONE, e.ZERO],
                ["destination-over", e.ONE_MINUS_DST_ALPHA, e.ONE],
                ["source-in", e.DST_ALPHA, e.ZERO],
                ["destination-in", e.ZERO, e.SRC_ALPHA],
                ["source-out", e.ONE_MINUS_DST_ALPHA, e.ZERO],
                ["destination-out", e.ZERO, e.ONE_MINUS_SRC_ALPHA],
                ["source-atop", e.DST_ALPHA, e.ONE_MINUS_SRC_ALPHA],
                ["destination-atop", e.ONE_MINUS_DST_ALPHA, e.SRC_ALPHA]
            ])
        }
        CreateRendererText() {
            return e.New(e.Gfx.RendererText, this)
        }
        CreateWebGLText() {
            return this.CreateRendererText()
        }
    }
}
"use strict";
{
    const o = self.C3;
    let e = null;
    const n = new Set;

    function SortZOrderList(e, t) {
        const s = e[0],
            o = t[0],
            n = s - o;
        if (n !== 0) return n;
        const i = e[1],
            a = t[1];
        return i - a
    }
    const t = [],
        s = [];
    let i = !1;
    self.IRuntime = class IRuntime {
        constructor(t, s) {
            e = t, Object.defineProperties(this, {
                assets: {
                    value: e.GetAssetManager().GetIAssetManager(),
                    writable: !1
                },
                objects: {
                    value: s,
                    writable: !1
                },
                globalVars: {
                    value: {},
                    writable: !1
                },
                projectName: {
                    value: e.GetProjectName(),
                    writable: !1
                },
                projectVersion: {
                    value: e.GetProjectVersion(),
                    writable: !1
                },
                storage: {
                    value: new self.IStorage(e),
                    writable: !1
                },
                isInWorker: {
                    value: e.IsInWorker(),
                    writable: !1
                }
            }), e.UserScriptDispatcher().addEventListener("keydown", e => {
                if (n.has(e.key)) {
                    e.stopPropagation();
                    return
                }
                n.add(e.key)
            }), e.UserScriptDispatcher().addEventListener("keyup", e => n.delete(e.key)), e.Dispatcher().addEventListener("window-blur", () => n.clear()), e.IsInWorker() && (self.alert = e => (i || (i = !0, console.warn("[Construct 3] alert() was called from a Web Worker, because the project 'Use worker' setting is enabled. This method is not normally available in a Web Worker. Construct has implemented the alert for you, but note that other features may be missing in worker mode. You may wish to disable 'Use worker', or use a more convenient function like console.log(). For more information please refer to the scripting section of the manual.")), this.alert(e)))
        }
        _InitGlobalVars(e) {
            Object.defineProperties(this.globalVars, e)
        }
        addEventListener(t, n) {
            e.UserScriptDispatcher().addEventListener(t, n)
        }
        removeEventListener(t, n) {
            e.UserScriptDispatcher().removeEventListener(t, n)
        }
        callFunction(s, ...o) {
            const n = e.GetEventSheetManager(),
                t = n.GetFunctionBlockByName(s);
            if (!t) throw new Error(`cannot find function name '${s}'`);
            if (!t.IsEnabled()) return t.GetDefaultReturnValue();
            if (o.length < t.GetFunctionParameterCount()) throw new Error(`not enough function parameters passed for '${s}' (${o.length} passed, ${t.GetFunctionParameterCount()} expected)`);
            const a = t.GetEventBlock();
            let i = null;
            const r = n.GetCurrentEvent();
            if (r) {
                const e = r.GetSolModifiersIncludingParents();
                e.length > 0 && (i = e, n.PushCleanSol(e))
            }
            const c = a.RunAsExpressionFunctionCall(a.GetSolModifiersIncludingParents(), t.GetReturnType(), t.GetDefaultReturnValue(), ...o);
            return i && n.PopSol(i), c
        }
        setReturnValue(t) {
            const n = e.GetEventStack().GetCurrentExpFuncStackFrame();
            if (!n) throw new Error("not in a function which returns a value");
            switch (n.GetFunctionReturnType()) {
                case 1:
                    typeof t == "number" && n.SetFunctionReturnValue(t);
                    break;
                case 2:
                    typeof t == "string" && n.SetFunctionReturnValue(t);
                    break;
                case 3:
                    (typeof t == "number" || typeof t == "string") && n.SetFunctionReturnValue(t);
                    break
            }
        }
        get dt() {
            return e.GetDt()
        }
        get gameTime() {
            return e.GetGameTime()
        }
        get wallTime() {
            return e.GetWallTime()
        }
        random() {
            return e.Random()
        }
        get layout() {
            return e.GetMainRunningLayout().GetILayout()
        }
        getLayout(t) {
            const s = e.GetLayoutManager();
            let n = null;
            if (typeof t == "number" || typeof t == "string") n = s.GetLayout(t);
            else throw new TypeError("expected string or number");
            if (!n) throw new Error("invalid layout");
            return n.GetILayout()
        }
        getAllLayouts() {
            return e.GetLayoutManager().GetAllLayouts().map(e => e.GetILayout())
        }
        goToLayout(t) {
            const n = e.GetLayoutManager();
            let s = null;
            if (typeof t == "number" || typeof t == "string") s = n.GetLayout(t);
            else throw new TypeError("expected string or number");
            if (!s) throw new Error("invalid layout");
            if (n.IsPendingChangeMainLayout()) return;
            n.ChangeMainLayout(s)
        }
        get keyboard() {
            const t = e._GetCommonScriptInterfaces().keyboard;
            if (!t) throw new Error("runtime.keyboard used but Keyboard object missing - add it to your project first");
            return t
        }
        get mouse() {
            const t = e._GetCommonScriptInterfaces().mouse;
            if (!t) throw new Error("runtime.mouse used but Mouse object missing - add it to your project first");
            return t
        }
        get touch() {
            const t = e._GetCommonScriptInterfaces().touch;
            if (!t) throw new Error("runtime.touch used but Touch object missing - add it to your project first");
            return t
        }
        invokeDownload(t, n) {
            e.InvokeDownload(t, n)
        }
        getInstanceByUid(t) {
            const n = e.GetInstanceByUID(t);
            return n ? n.GetInterfaceClass() : null
        }
        sortZOrder(n, i) {
            const r = e.GetCurrentLayout();
            for (const a of n) {
                const o = e._UnwrapScriptInterface(a);
                if (!o || !o.GetWorldInfo()) throw new Error("invalid instance");
                const i = o.GetWorldInfo();
                t.push([i.GetLayer().GetIndex(), i.GetZIndex()]), s.push(o)
            }
            if (t.length === 0) return;
            t.sort(SortZOrderList), s.sort((e, t) => i(e.GetInterfaceClass(), t.GetInterfaceClass()));
            let a = !1;
            for (let e = 0, l = t.length; e < l; ++e) {
                const n = s[e],
                    o = r.GetLayerByIndex(t[e][0]),
                    i = t[e][1],
                    c = o._GetInstances();
                c[i] !== n && (c[i] = n, n.GetWorldInfo()._SetLayer(o), o.SetZIndicesChanged(), a = !0)
            }
            a && e.UpdateRender(), o.clearArray(t), o.clearArray(s)
        }
        alert(t) {
            return e.PostComponentMessageToDOMAsync("runtime", "alert", {
                message: t + (e.IsInWorker() ? " [via Web Worker]" : "")
            })
        }
    }
}
"use strict";
{
    const t = self.C3;
    let e = null;
    self.IAssetManager = class IAssetManager {
        constructor(t) {
            e = t, Object.defineProperties(this, {
                isWebMOpusSupported: {
                    value: e.IsAudioFormatSupported("audio/webm; codecs=opus"),
                    writable: !1
                }
            })
        }
        fetchText(t) {
            return e.FetchText(t)
        }
        fetchJson(t) {
            return e.FetchJson(t)
        }
        fetchBlob(t) {
            return e.FetchBlob(t)
        }
        fetchArrayBuffer(t) {
            return e.FetchArrayBuffer(t)
        }
        getProjectFileUrl(t) {
            return e.GetProjectFileUrl(t)
        }
        getMediaFileUrl(n) {
            return t.IsRelativeURL(n) && (n = n.toLowerCase()), e.GetMediaFileUrl(n, e.GetMediaSubfolder())
        }
        get mediaFolder() {
            return e.GetMediaSubfolder()
        }
        async decodeWebMOpus(t, n) {
            if (this.isWebMOpusSupported) throw new Error("decodeWebMOpus(): not supported because WebM Opus is supported by the platform");
            const i = await e.GetRuntime()._WasmDecodeWebMOpus(n),
                s = new Float32Array(i),
                o = t.createBuffer(1, s.length, 48e3),
                a = o.getChannelData(0);
            return a.set(s), o
        }
        loadScripts(...t) {
            return e.LoadScripts(...t)
        }
        compileWebAssembly(t) {
            return e.CompileWebAssembly(t)
        }
        loadStyleSheet(t) {
            return e.LoadStyleSheet(t)
        }
    }
}
"use strict", self.IStorage = class IStorage {
    constructor(e) {
        this._storage = e._GetProjectStorage()
    }
    getItem(e) {
        return this._storage.getItem(e)
    }
    setItem(e, t) {
        return this._storage.setItem(e, t)
    }
    removeItem(e) {
        return this._storage.removeItem(e)
    }
    clear() {
        return this._storage.clear()
    }
    keys() {
        return this._storage.keys()
    }
}, "use strict";
{
    const t = self.C3,
        e = new WeakMap;
    self.IObjectClass = class IObjectClass {
        constructor(t) {
            e.set(this, t), Object.defineProperties(this, {
                name: {
                    value: t.GetName(),
                    writable: !1
                }
            }), t.GetRuntime()._MapScriptInterface(this, t)
        }
        addEventListener(t, n) {
            e.get(this).UserScriptDispatcher().addEventListener(t, n)
        }
        removeEventListener(t, n) {
            e.get(this).UserScriptDispatcher().removeEventListener(t, n)
        }
        getAllInstances() {
            return e.get(this).GetInstances().map(e => e.GetInterfaceClass())
        }
        getFirstInstance() {
            const t = e.get(this).GetInstances();
            return t.length > 0 ? t[0].GetInterfaceClass() : null
        }
        getPickedInstances() {
            return e.get(this).GetCurrentSol().GetInstances().map(e => e.GetInterfaceClass())
        }
        getFirstPickedInstance() {
            const t = e.get(this).GetCurrentSol().GetInstances();
            return t.length > 0 ? t[0].GetInterfaceClass() : null
        }* instances() {
            for (const t of e.get(this).GetInstances()) yield t.GetInterfaceClass()
        }* pickedInstances() {
            for (const t of e.get(this).GetCurrentSol().GetInstances()) yield t.GetInterfaceClass()
        }
        setInstanceClass(t) {
            const n = e.get(this);
            if (n.GetInstanceCount() > 0) throw new Error("setInstanceClass() called too late, because instances have already been created - call in runOnStartup");
            e.get(this)._SetUserScriptInstanceClass(t)
        }
        createInstance(t, n, s) {
            if (typeof t != "number" && typeof t != "string") throw new TypeError("invalid layer parameter");
            const a = e.get(this),
                i = a.GetRuntime(),
                r = i.GetMainRunningLayout().GetLayer(t);
            if (!r) throw new Error("invalid layer");
            const o = i.CreateInstance(a, r, n, s),
                c = i.GetEventSheetManager();
            if (c.BlockFlushingInstances(!0), o._TriggerOnCreated(), o.IsInContainer())
                for (const e of o.siblings()) e._TriggerOnCreated();
            return c.BlockFlushingInstances(!1), o.GetInterfaceClass()
        }
    }
}
"use strict";
{
    const e = new WeakMap;
    self.ILayout = class ILayout {
        constructor(t) {
            e.set(this, t);
            const n = [],
                s = t.GetEffectList(),
                o = s.GetAllEffectTypes().length;
            for (let e = 0; e < o; ++e) n.push(new self.IEffectInstance(s, e));
            Object.defineProperties(this, {
                name: {
                    value: t.GetName(),
                    writable: !1
                },
                index: {
                    value: t.GetIndex(),
                    writable: !1
                },
                effects: {
                    value: n,
                    writable: !1
                }
            })
        }
        addEventListener(t, n) {
            e.get(this).UserScriptDispatcher().addEventListener(t, n)
        }
        removeEventListener(t, n) {
            e.get(this).UserScriptDispatcher().removeEventListener(t, n)
        }
        get width() {
            return e.get(this).GetWidth()
        }
        set width(t) {
            e.get(this).SetWidth(t)
        }
        get height() {
            return e.get(this).GetHeight()
        }
        set height(t) {
            e.get(this).SetHeight(t)
        }
        scrollTo(t, n) {
            const s = e.get(this);
            s.SetScrollX(t), s.SetScrollY(n)
        }
        getLayer(t) {
            const s = e.get(this);
            let n = null;
            if (typeof t == "number" || typeof t == "string") n = s.GetLayer(t);
            else throw new TypeError("expected string or number");
            if (!n) throw new Error("invalid layer");
            return n.GetILayer()
        }
        getAllLayers() {
            return e.get(this).GetLayers().map(e => e.GetILayer())
        }
    }
}
"use strict";
{
    const t = self.C3,
        e = new WeakMap;
    self.ILayer = class ILayer {
        constructor(t) {
            e.set(this, t);
            const n = [],
                s = t.GetEffectList(),
                o = s.GetAllEffectTypes().length;
            for (let e = 0; e < o; ++e) n.push(new self.IEffectInstance(s, e));
            Object.defineProperties(this, {
                name: {
                    value: t.GetName(),
                    writable: !1
                },
                index: {
                    value: t.GetIndex(),
                    writable: !1
                },
                layout: {
                    value: t.GetLayout().GetILayout(),
                    writable: !1
                },
                effects: {
                    value: n,
                    writable: !1
                }
            })
        }
        static _Unwrap(t) {
            return e.get(t)
        }
        get isVisible() {
            return e.get(this).IsVisible()
        }
        set isVisible(t) {
            e.get(this).SetVisible(t)
        }
        get opacity() {
            return e.get(this).GetOpacity()
        }
        set opacity(n) {
            if (n = t.clamp(+n, 0, 1), isNaN(n)) return;
            e.get(this).SetOpacity(n)
        }
        getViewport() {
            return e.get(this).GetViewport().toDOMRect()
        }
        cssPxToLayer(t, n, s = 0) {
            const o = e.get(this),
                i = o.GetRuntime();
            return o.CanvasCssToLayer(t - i.GetCanvasClientX(), n - i.GetCanvasClientY(), s)
        }
        layerToCssPx(t, n, s = 0) {
            const o = e.get(this),
                i = o.GetRuntime(),
                [a, r] = o.LayerToCanvasCss(t, n, s);
            return [a + i.GetCanvasClientX(), r + i.GetCanvasClientY()]
        }
    }
}
"use strict";
{
    const s = self.C3,
        n = new WeakMap,
        t = new WeakMap;

    function GetDispatcher(e) {
        let n = t.get(e);
        return n || (n = s.New(s.Event.Dispatcher), t.set(e, n), n)
    }
    let e = null;
    self.IInstance = class IInstance {
        constructor() {
            n.set(this, e);
            const t = {
                runtime: {
                    value: e.GetRuntime().GetIRuntime(),
                    writable: !1
                },
                objectType: {
                    value: e.GetObjectClass().GetIObjectClass(),
                    writable: !1
                },
                uid: {
                    value: e.GetUID(),
                    writable: !1
                }
            };
            e._GetInstVarsScriptDescriptor(t), e._GetBehaviorsScriptDescriptor(t), Object.defineProperties(this, t), e.GetRuntime()._MapScriptInterface(this, e)
        }
        static _Init(t) {
            e = t
        }
        static _GetInitInst() {
            return e
        }
        _Release() {
            const e = t.get(this);
            e && (e.Release(), t.delete(this)), n.delete(this)
        }
        addEventListener(e, t, n) {
            GetDispatcher(this).addEventListener(e, t, n)
        }
        removeEventListener(e, t, n) {
            GetDispatcher(this).removeEventListener(e, t, n)
        }
        dispatchEvent(e) {
            GetDispatcher(this).dispatchEvent(e)
        }
        destroy() {
            const e = n.get(this);
            e.GetRuntime().DestroyInstance(e)
        }
    }
}
"use strict";
{
    const t = self.C3,
        s = self.IInstance,
        i = self.ILayer,
        e = new WeakMap,
        o = new Map([
            ["normal", 0],
            ["additive", 1],
            ["copy", 3],
            ["destination-over", 4],
            ["source-in", 5],
            ["destination-in", 6],
            ["source-out", 7],
            ["destination-out", 8],
            ["source-atop", 9],
            ["destination-atop", 10]
        ]),
        a = new Map([...o.entries()].map(e => [e[1], e[0]])),
        n = t.New(t.Color);
    self.IWorldInstance = class IWorldInstance extends s {
        constructor() {
            super();
            const t = s._GetInitInst();
            e.set(this, t);
            const n = [],
                o = t.GetWorldInfo(),
                i = o.GetInstanceEffectList();
            if (i) {
                const e = o.GetObjectClass().GetEffectList().GetAllEffectTypes().length;
                for (let t = 0; t < e; ++t) n.push(new self.IEffectInstance(i, t))
            }
            const a = {
                effects: {
                    value: n,
                    writable: !1
                }
            };
            Object.defineProperties(this, a)
        }
        get layout() {
            return e.get(this).GetWorldInfo().GetLayout().GetILayout()
        }
        get layer() {
            return e.get(this).GetWorldInfo().GetLayer().GetILayer()
        }
        get x() {
            return e.get(this).GetWorldInfo().GetX()
        }
        set x(t) {
            t = +t;
            const n = e.get(this).GetWorldInfo();
            if (isNaN(t) || n.GetX() === t) return;
            n.SetX(t), n.SetBboxChanged()
        }
        get y() {
            return e.get(this).GetWorldInfo().GetY()
        }
        set y(t) {
            t = +t;
            const n = e.get(this).GetWorldInfo();
            if (isNaN(t) || n.GetY() === t) return;
            n.SetY(t), n.SetBboxChanged()
        }
        get zElevation() {
            return e.get(this).GetWorldInfo().GetZElevation()
        }
        set zElevation(t) {
            t = +t;
            const n = e.get(this),
                s = n.GetWorldInfo();
            if (s.GetZElevation() === t) return;
            s.SetZElevation(t), n.GetRuntime().UpdateRender()
        }
        get totalZElevation() {
            return e.get(this).GetWorldInfo().GetTotalZElevation()
        }
        get width() {
            return e.get(this).GetWorldInfo().GetWidth()
        }
        set width(t) {
            t = +t;
            const n = e.get(this).GetWorldInfo();
            if (isNaN(t) || n.GetWidth() === t) return;
            n.SetWidth(t), n.SetBboxChanged()
        }
        get height() {
            return e.get(this).GetWorldInfo().GetHeight()
        }
        set height(t) {
            t = +t;
            const n = e.get(this).GetWorldInfo();
            if (isNaN(t) || n.GetHeight() === t) return;
            n.SetHeight(t), n.SetBboxChanged()
        }
        get angle() {
            return e.get(this).GetWorldInfo().GetAngle()
        }
        set angle(n) {
            n = t.clampAngle(+n);
            const s = e.get(this).GetWorldInfo();
            if (isNaN(n) || s.GetAngle() === n) return;
            s.SetAngle(n), s.SetBboxChanged()
        }
        get angleDegrees() {
            return t.toDegrees(this.angle)
        }
        set angleDegrees(e) {
            this.angle = t.toRadians(e)
        }
        getBoundingBox() {
            return e.get(this).GetWorldInfo().GetBoundingBox().toDOMRect()
        }
        getBoundingQuad() {
            return e.get(this).GetWorldInfo().GetBoundingQuad().toDOMQuad()
        }
        get isVisible() {
            return e.get(this).GetWorldInfo().IsVisible()
        }
        set isVisible(t) {
            t = !!t;
            const n = e.get(this),
                s = n.GetWorldInfo();
            if (s.IsVisible() === t) return;
            s.SetVisible(t), n.GetRuntime().UpdateRender()
        }
        get opacity() {
            return e.get(this).GetWorldInfo().GetOpacity()
        }
        set opacity(n) {
            n = t.clamp(+n, 0, 1);
            const s = e.get(this),
                o = s.GetWorldInfo();
            if (isNaN(n) || o.GetOpacity() === n) return;
            o.SetOpacity(n), s.GetRuntime().UpdateRender()
        }
        set colorRgb(t) {
            if (t.length < 3) throw new Error("expected 3 elements");
            n.setRgb(t[0], t[1], t[2]);
            const s = e.get(this),
                o = s.GetWorldInfo();
            if (o.GetUnpremultipliedColor().equalsIgnoringAlpha(n)) return;
            o.SetUnpremultipliedColor(n), s.GetRuntime().UpdateRender()
        }
        get colorRgb() {
            const t = e.get(this).GetWorldInfo().GetUnpremultipliedColor();
            return [t.getR(), t.getG(), t.getB()]
        }
        set blendMode(t) {
            const n = o.get(t);
            if (typeof n != "number") throw new Error("invalid blend mode");
            const s = e.get(this),
                i = s.GetWorldInfo();
            i.SetBlendMode(n), s.GetRuntime().UpdateRender()
        }
        get blendMode() {
            return a.get(e.get(this).GetWorldInfo().GetBlendMode())
        }
        moveToTop() {
            e.get(this).GetWorldInfo().ZOrderMoveToTop()
        }
        moveToBottom() {
            e.get(this).GetWorldInfo().ZOrderMoveToBottom()
        }
        moveToLayer(t) {
            const n = i._Unwrap(t);
            if (!n) throw new Error("invalid layer");
            e.get(this).GetWorldInfo().ZOrderMoveToLayer(n)
        }
        moveAdjacentToInstance(t, n) {
            e.get(this).GetWorldInfo().ZOrderMoveAdjacentToInstance(e.get(t), n)
        }
        containsPoint(t, n) {
            return e.get(this).GetWorldInfo().ContainsPoint(+t, +n)
        }
        testOverlap(t) {
            const n = e.get(this),
                s = e.get(t);
            return n.GetRuntime().GetCollisionEngine().TestOverlap(n, s)
        }
        testOverlapSolid() {
            const t = e.get(this),
                n = t.GetRuntime().GetCollisionEngine().TestOverlapSolid(t);
            return n ? n.GetInterfaceClass() : null
        }
        getParent() {
            const t = e.get(this).GetParent();
            return t ? t.GetInterfaceClass() : null
        }
        getTopParent() {
            const t = e.get(this).GetTopParent();
            return t ? t.GetInterfaceClass() : null
        }* parents() {
            for (const t of e.get(this).parents()) yield t.GetInterfaceClass()
        }
        getChildCount() {
            return e.get(this).GetChildCount()
        }
        getChildAt(t) {
            const n = e.get(this).GetChildAt(t);
            return n ? n.GetInterfaceClass() : null
        }* children() {
            for (const t of e.get(this).children()) yield t.GetInterfaceClass()
        }* allChildren() {
            for (const t of e.get(this).allChildren()) yield t.GetInterfaceClass()
        }
        addChild(t, n) {
            n || (n = {});
            const s = e.get(this),
                o = e.get(t);
            s.AddChild(o, n)
        }
        removeChild(t) {
            const n = e.get(this),
                s = e.get(t);
            n.RemoveChild(s)
        }
        removeFromParent() {
            const t = e.get(this);
            if (!t.HasParent()) return;
            const n = t.GetParent();
            n.RemoveChild(t)
        }
        createMesh(t, n) {
            e.get(this).GetWorldInfo().CreateMesh(t, n)
        }
        releaseMesh() {
            const t = e.get(this).GetWorldInfo();
            t.ReleaseMesh(), t.SetBboxChanged()
        }
        setMeshPoint(t, n, s) {
            const o = e.get(this).GetWorldInfo();
            o.SetMeshPoint(t, n, s) && o.SetBboxChanged()
        }
    }
}
"use strict";
{
    const t = self.C3,
        e = new WeakMap;
    self.IDOMInstance = class IDOMInstance extends self.IWorldInstance {
        constructor() {
            super(), e.set(this, self.IInstance._GetInitInst())
        }
        getElement() {
            return e.get(this).GetSdkInstance()._GetElementInDOMMode()
        }
        focus() {
            e.get(this).GetSdkInstance().FocusElement()
        }
        blur() {
            e.get(this).GetSdkInstance().BlurElement()
        }
        setCssStyle(t, n) {
            e.get(this).GetSdkInstance().SetElementCSSStyle(t, n)
        }
    }
}
"use strict";
{
    const s = self.C3,
        n = new WeakMap,
        t = new WeakMap;

    function GetDispatcher(e) {
        let n = t.get(e);
        return n || (n = s.New(s.Event.Dispatcher), t.set(e, n), n)
    }
    let e = null;
    self.IBehaviorInstance = class IBehaviorInstance {
        constructor() {
            n.set(this, e);
            const t = {
                runtime: {
                    value: e.GetRuntime().GetIRuntime(),
                    writable: !1
                },
                behavior: {
                    value: e.GetBehavior().GetIBehavior(),
                    writable: !1
                }
            };
            Object.defineProperties(this, t)
        }
        static _Init(t) {
            e = t
        }
        static _GetInitInst() {
            return e
        }
        get instance() {
            return n.get(this).GetObjectInstance().GetInterfaceClass()
        }
        _Release() {
            const e = t.get(this);
            e && (e.Release(), t.delete(this)), n.delete(this)
        }
        addEventListener(e, t, n) {
            GetDispatcher(this).addEventListener(e, t, n)
        }
        removeEventListener(e, t, n) {
            GetDispatcher(this).removeEventListener(e, t, n)
        }
        dispatchEvent(e) {
            GetDispatcher(this).dispatchEvent(e)
        }
    }
}
"use strict";
{
    const e = new WeakMap;
    self.IBehavior = class IBehavior {
        constructor(t) {
            e.set(this, t);
            const n = {
                runtime: {
                    value: t.GetRuntime().GetIRuntime(),
                    writable: !1
                }
            };
            Object.defineProperties(this, n)
        }
        getAllInstances() {
            return e.get(this).GetInstances().map(e => e.GetInterfaceClass())
        }
    }
}
"use strict";
{
    const t = self.C3,
        e = new WeakMap;
    self.IEffectInstance = class IEffectInstance {
        constructor(t, n) {
            e.set(this, t);
            const s = {
                index: {
                    value: n,
                    writable: !1
                }
            };
            Object.defineProperties(this, s)
        }
        get name() {
            const t = e.get(this).GetAllEffectTypes();
            return t[this.index].GetName()
        }
        get isActive() {
            return e.get(this).IsEffectIndexActive(this.index)
        }
        set isActive(t) {
            t = !!t;
            const n = e.get(this);
            if (n.IsEffectIndexActive(this.index) === t) return;
            n.SetEffectIndexActive(this.index, t), n.UpdateActiveEffects(), n.GetRuntime().UpdateRender()
        }
        setParameter(n, s) {
            n = Math.floor(+n);
            const i = e.get(this),
                a = i.GetEffectParametersForIndex(this.index);
            if (n < 0 || n >= a.length) throw new RangeError("invalid effect parameter index");
            const o = a[n];
            if (o instanceof t.Color) {
                if (!Array.isArray(s) || s.length < 3) throw new TypeError("expected array with 3 elements");
                const e = s[0],
                    t = s[1],
                    n = s[2];
                if (o.equalsRgb(e, t, n)) return;
                o.setRgb(e, t, n)
            } else {
                if (typeof s != "number") throw new TypeError("expected number");
                if (o === s) return;
                a[n] = s
            }
            i.IsEffectIndexActive(this.index) && i.GetRuntime().UpdateRender()
        }
        getParameter(n) {
            n = Math.floor(+n);
            const i = e.get(this),
                o = i.GetEffectParametersForIndex(this.index);
            if (n < 0 || n >= o.length) throw new RangeError("invalid effect parameter index");
            const s = o[n];
            return s instanceof t.Color ? [s.getR(), s.getG(), s.getB()] : s
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = new Set(["local", "remote"]),
        n = new Map([
            ["mp4", "video/mp4"],
            ["webm", "video/webm"],
            ["m4a", "audio/mp4"],
            ["mp3", "audio/mpeg"],
            ["js", "application/javascript"],
            ["wasm", "application/wasm"],
            ["svg", "image/svg+xml"],
            ["html", "text/html"]
        ]);

    function GetTypeFromFileExtension(e) {
        if (!e) return "";
        const t = e.split(".");
        if (t.length < 2) return "";
        const s = t[t.length - 1].toLowerCase();
        return n.get(s) || ""
    }

    function AddScript(e, t) {
        return new Promise((n, s) => {
            const o = document.createElement("script");
            o.onload = n, o.onerror = s, o.async = !1, t === "module" && (o.type = "module"), o.src = e, document.head.appendChild(o)
        })
    }
    e.AssetManager = class AssetManager extends e.DefendedBase {
        constructor(t, n) {
            super();
            const s = n.exportType;
            this._runtime = t, this._scriptsType = n.scriptsType, this._localUrlBlobs = new Map, this._localBlobUrlCache = new Map, this._isCordova = s === "cordova", this._isiOSCordova = !!n.isiOSCordova, this._isFileProtocol = location.protocol === "file:", this._swClientId = n.swClientId, this._supportedAudioFormats = n.supportedAudioFormats || {}, this._audioFiles = new Map, this._preloadSounds = !1, this._mediaSubfolder = "", this._fontsSubfolder = "", this._iconsSubfolder = "";
            const a = s === "html5" || s === "scirra-arcade" || s === "instant-games";
            this._defaultLoadPolicy = a ? "remote" : "local", this._allAssets = [], this._assetsByUrl = new Map, this._webFonts = [], this._loadPromises = [], this._hasFinishedInitialLoad = !1, this._totalAssetSizeToLoad = 0, this._assetSizeLoaded = 0, this._lastLoadProgress = 0, this._hasHadErrorLoading = !1, this._loadingRateLimiter = e.New(e.RateLimiter, () => this._FireLoadingProgressEvent(), 50), this._promiseThrottle = new e.PromiseThrottle(Math.max(e.hardwareConcurrency, 8));
            const o = n.previewImageBlobs;
            if (o) {
                const e = n.previewProjectFileBlobs;
                e && Object.assign(o, e);
                const t = n.projectData;
                t && (o["https://cdn.jsdelivr.net/gh/gahaden/ags@f4f7f1596bda19448c9534261835ec7a356baa17/data.json"] = t);
                for (const [e, t] of Object.entries(o)) this._localUrlBlobs.set(e.toLowerCase(), t)
            }
            const i = n.previewProjectFileUrls;
            if (i)
                for (const [e, t] of Object.entries(i)) this._localBlobUrlCache.set(e, t);
            this._iAssetManager = new self.IAssetManager(this)
        }
        Release() {
            this._localUrlBlobs.clear();
            for (const e of this._localBlobUrlCache.values()) e.startsWith("blob:") && URL.revokeObjectURL(e);
            this._localBlobUrlCache.clear();
            for (const e of this._allAssets) e.Release();
            e.clearArray(this._allAssets), this._assetsByUrl.clear(), e.clearArray(this._loadPromises), this._runtime = null
        }
        GetRuntime() {
            return this._runtime
        }
        _SetMediaSubfolder(e) {
            this._mediaSubfolder = e
        }
        GetMediaSubfolder() {
            return this._mediaSubfolder
        }
        _SetFontsSubfolder(e) {
            this._fontsSubfolder = e
        }
        GetFontsSubfolder() {
            return this._fontsSubfolder
        }
        _SetIconsSubfolder(e) {
            this._iconsSubfolder = e
        }
        GetIconsSubfolder() {
            return this._iconsSubfolder
        }
        _HasLocalUrlBlob(e) {
            return this._localUrlBlobs.has(e.toLowerCase())
        }
        _GetLocalUrlBlob(e) {
            return this._localUrlBlobs.get(e.toLowerCase()) || null
        }
        GetLocalUrlAsBlobUrl(e) {
            if (!this._HasLocalUrlBlob(e)) return e;
            const n = e.toLowerCase();
            let t = this._localBlobUrlCache.get(n);
            if (!t) {
                const e = this._GetLocalUrlBlob(n);
                t = URL.createObjectURL(e), this._localBlobUrlCache.set(n, t)
            }
            return t
        }
        FetchBlob(t, n) {
            n = n || this._defaultLoadPolicy;
            const s = this._GetLocalUrlBlob(t);
            if (s) return Promise.resolve(s);
            if (e.IsRelativeURL(t)) {
                const s = t.toLowerCase();
                return this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlob(s) : n === "local" ? this._promiseThrottle.Add(() => e.FetchBlob(s)) : e.FetchBlob(s)
            } else return e.FetchBlob(t)
        }
        FetchArrayBuffer(t) {
            const n = this._GetLocalUrlBlob(t);
            if (n) return e.BlobToArrayBuffer(n);
            if (e.IsRelativeURL(t)) {
                const n = t.toLowerCase();
                return this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsArrayBuffer(n) : this._defaultLoadPolicy === "local" ? this._promiseThrottle.Add(() => e.FetchArrayBuffer(n)) : e.FetchArrayBuffer(n)
            } else return e.FetchArrayBuffer(t)
        }
        FetchText(t) {
            const n = this._GetLocalUrlBlob(t);
            if (n) return e.BlobToString(n);
            if (e.IsRelativeURL(t)) {
                const n = t.toLowerCase();
                return this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsText(n) : this._defaultLoadPolicy === "local" ? this._promiseThrottle.Add(() => e.FetchText(n)) : e.FetchText(n)
            } else return e.FetchText(t)
        }
        async FetchJson(e) {
            const t = await this.FetchText(e);
            return JSON.parse(t)
        }
        _CordovaFetchLocalFileAs(e, t) {
            return this._runtime.PostComponentMessageToDOMAsync("runtime", "cordova-fetch-local-file", {
                filename: e,
                as: t
            })
        }
        CordovaFetchLocalFileAsText(e) {
            return this._CordovaFetchLocalFileAs(e, "text")
        }
        async CordovaFetchLocalFileAsBlob(e) {
            const t = await this._CordovaFetchLocalFileAs(e, "buffer"),
                n = GetTypeFromFileExtension(e);
            return new Blob([t], {
                type: n
            })
        }
        async CordovaFetchLocalFileAsBlobURL(e) {
            e = e.toLowerCase();
            let t = this._localBlobUrlCache.get(e);
            if (t) return t;
            const n = await this.CordovaFetchLocalFileAsBlob(e);
            return t = URL.createObjectURL(n), this._localBlobUrlCache.set(e, t), t
        }
        CordovaFetchLocalFileAsArrayBuffer(e) {
            return this._CordovaFetchLocalFileAs(e, "buffer")
        }
        GetMediaFileUrl(e) {
            return this._HasLocalUrlBlob(e) ? this.GetLocalUrlAsBlobUrl(e) : this._mediaSubfolder + e.toLowerCase()
        }
        GetProjectFileUrl(t, n = "") {
            if (e.IsAbsoluteURL(t)) {
                if (n) throw new Error("cannot specify subfolder with remote URL");
                return Promise.resolve(t)
            }
            return this._HasLocalUrlBlob(t) ? Promise.resolve(this.GetLocalUrlAsBlobUrl(t)) : this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlobURL(n + t) : Promise.resolve(n + t.toLowerCase())
        }
        GetProjectFileIframeUrl(t) {
            if (e.IsAbsoluteURL(t)) return Promise.resolve(t);
            const n = t.indexOf("?"),
                o = n === -1 ? "" : t.substr(n),
                s = n === -1 ? t : t.substr(0, n);
            if (this._HasLocalUrlBlob(s)) {
                let e = this.GetLocalUrlAsBlobUrl(s);
                if (!e.startsWith("blob:") && this._swClientId) {
                    const t = new URL(e),
                        n = new URLSearchParams(o);
                    n.set("__c3_client_id", this._swClientId), t.search = n.toString(), e = t.toString()
                }
                return Promise.resolve(e)
            }
            return this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlobURL(s) : Promise.resolve(t.toLowerCase())
        }
        LoadProjectFileUrl(e) {
            return this.GetProjectFileUrl(e)
        }
        LoadImage(n) {
            if (n.loadPolicy && !t.has(n.loadPolicy)) throw new Error("invalid load policy");
            let s = this._assetsByUrl.get(n.url);
            return s || (s = e.New(e.ImageAsset, this, {
                url: n.url,
                size: n.size || 0,
                loadPolicy: n.loadPolicy || this._defaultLoadPolicy
            }), this._allAssets.push(s), this._assetsByUrl.set(s.GetURL(), s), this._hasFinishedInitialLoad || (this._totalAssetSizeToLoad += s.GetSize(), this._loadPromises.push(s.Load().then(() => this._AddLoadedSize(s.GetSize())))), s)
        }
        async WaitForAllToLoad() {
            try {
                await Promise.all(this._loadPromises), this._lastLoadProgress = 1
            } catch (e) {
                console.error("Error loading: ", e), this._hasHadErrorLoading = !0, this._FireLoadingProgressEvent()
            }
        }
        SetInitialLoadFinished() {
            this._hasFinishedInitialLoad = !0
        }
        HasHadErrorLoading() {
            return this._hasHadErrorLoading
        }
        _AddLoadedSize(e) {
            this._assetSizeLoaded += e, this._loadingRateLimiter.Call()
        }
        _FireLoadingProgressEvent() {
            const t = e.New(e.Event, "loadingprogress");
            this._lastLoadProgress = e.clamp(this._assetSizeLoaded / this._totalAssetSizeToLoad, 0, 1), t.progress = this._lastLoadProgress, this._runtime.Dispatcher().dispatchEvent(t)
        }
        GetLoadProgress() {
            return this._lastLoadProgress
        }
        _SetWebFonts(t) {
            e.shallowAssignArray(this._webFonts, t), this._webFonts.length && this._loadPromises.push(this._LoadWebFonts())
        }
        _LoadWebFonts() {
            if (typeof FontFace == "undefined") return Promise.resolve();
            const e = [];
            for (const [n, s, t] of this._webFonts) this._totalAssetSizeToLoad += t, e.push(this._LoadWebFont(n, s).then(() => this._AddLoadedSize(t)));
            return Promise.all(e)
        }
        async _LoadWebFont(e, t) {
            try {
                const s = await this.GetProjectFileUrl(t, this._fontsSubfolder),
                    n = new FontFace(e, `url('${s}')`);
                this._runtime.IsInWorker() ? self.fonts.add(n) : document.fonts.add(n), await n.load()
            } catch (t) {
                console.warn(`[C3 runtime] Failed to load web font '${e}': `, t)
            }
        }
        IsAudioFormatSupported(e) {
            return !!this._supportedAudioFormats[e]
        }
        _SetAudioFiles(e, t) {
            this._preloadSounds = !!t;
            for (const [t, n, s] of e) this._audioFiles.set(t, {
                fileName: t,
                formats: n.map(e => ({
                    type: e[0],
                    fileExtension: e[1],
                    fullName: t + e[1],
                    fileSize: e[2]
                })),
                isMusic: s
            })
        }
        GetPreferredAudioFile(e) {
            const n = this._audioFiles.get(e.toLowerCase());
            if (!n) return null;
            let t = null;
            for (const e of n.formats)
                if (!t && e.type === "audio/webm; codecs=opus" && (t = e), this.IsAudioFormatSupported(e.type)) return e;
            return t
        }
        GetProjectAudioFileUrl(e) {
            const t = this.GetPreferredAudioFile(e);
            return t ? {
                url: this.GetMediaFileUrl(t.fullName),
                type: t.type
            } : null
        }
        GetAudioToPreload() {
            if (this._preloadSounds) {
                const e = [];
                for (const n of this._audioFiles.values()) {
                    if (n.isMusic) continue;
                    const t = this.GetPreferredAudioFile(n.fileName);
                    if (!t) continue;
                    e.push({
                        originalUrl: n.fileName,
                        url: this.GetMediaFileUrl(t.fullName),
                        type: t.type,
                        fileSize: t.fileSize
                    })
                }
                return e
            }
            return []
        }
        GetIAssetManager() {
            return this._iAssetManager
        }
        GetScriptsType() {
            return this._scriptsType
        }
        async LoadScripts(...t) {
            const n = await Promise.all(t.map(e => this.GetProjectFileUrl(e)));
            if (this._runtime.IsInWorker())
                if (this._scriptsType === "classic") importScripts(...n);
                else if (t.length === 1) {
                const n = t[0];
                await self.c3_import((e.IsRelativeURL(n) ? "./" : "") + n)
            } else {
                const n = t.map(t => `import "${e.IsRelativeURL(t)?"./":""}${t}";`).join(`
`),
                    s = URL.createObjectURL(new Blob([n], {
                        type: "application/javascript"
                    }));
                await self.c3_import(s)
            } else await Promise.all(n.map(e => AddScript(e, this._scriptsType)))
        }
        async CompileWebAssembly(t) {
            if (WebAssembly.compileStreaming) {
                const e = await this.GetProjectFileUrl(t);
                return await WebAssembly.compileStreaming(fetch(e))
            }
            const n = await e.FetchArrayBuffer(t);
            return await WebAssembly.compile(n)
        }
        async LoadStyleSheet(e) {
            const t = await this.GetProjectFileUrl(e);
            return await this._runtime.PostComponentMessageToDOMAsync("runtime", "add-stylesheet", {
                url: t
            })
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Asset = class Asset extends e.DefendedBase {
        constructor(e, t) {
            super(), this._assetManager = e, this._runtime = e.GetRuntime(), this._url = t.url, this._size = t.size, this._loadPolicy = t.loadPolicy, this._blob = null, this._isLoaded = !1, this._loadPromise = null
        }
        Release() {
            this._loadPromise = null, this._assetManager = null, this._runtime = null, this._blob = null
        }
        GetURL() {
            return this._url
        }
        GetSize() {
            return this._size
        }
        Load() {
            return this._loadPolicy === "local" || this._blob ? (this._isLoaded = !0, Promise.resolve()) : this._loadPromise ? this._loadPromise : (this._loadPromise = this._assetManager.FetchBlob(this._url, this._loadPolicy).then(e => {
                this._isLoaded = !0, this._loadPromise = null, this._blob = e
            }).catch(e => console.error("Error loading resource: ", e)), this._loadPromise)
        }
        IsLoaded() {
            return this._isLoaded
        }
        GetBlob() {
            return this._blob ? Promise.resolve(this._blob) : this._assetManager.FetchBlob(this._url, this._loadPolicy)
        }
    }
}
"use strict";
{
    const e = self.C3,
        n = new e.PromiseThrottle,
        t = new Set;
    e.ImageAsset = class ImageAsset extends e.Asset {
        constructor(e, n) {
            super(e, n), this._texturePromise = null, this._webglTexture = null, this._refCount = 0, this._imageWidth = -1, this._imageHeight = -1, t.add(this)
        }
        Release() {
            if (this.ReleaseTexture(), this._refCount !== 0) throw new Error("released image asset which still has texture references");
            this._texturePromise = null, t.delete(this), super.Release()
        }
        static OnWebGLContextLost() {
            for (const e of t) e._texturePromise = null, e._webglTexture = null, e._refCount = 0
        }
        LoadStaticTexture(e, t) {
            return this._refCount++, this._webglTexture ? Promise.resolve(this._webglTexture) : this._texturePromise ? this._texturePromise : (this._texturePromise = this.GetBlob().then(s => n.Add(() => e.CreateStaticTextureAsync(s, t).then(t => (this._texturePromise = null, this._refCount === 0 ? (e.DeleteTexture(t), null) : (this._webglTexture = t, this._imageWidth = t.GetWidth(), this._imageHeight = t.GetHeight(), this._webglTexture))))).catch(e => {
                throw console.error("Failed to load texture: ", e), e
            }), this._texturePromise)
        }
        ReleaseTexture() {
            if (this._refCount <= 0) throw new Error("texture released too many times");
            if (this._refCount--, this._refCount === 0 && this._webglTexture) {
                const e = this._webglTexture.GetRenderer();
                e.DeleteTexture(this._webglTexture), this._webglTexture = null
            }
        }
        GetTexture() {
            return this._webglTexture
        }
        GetWidth() {
            return this._imageWidth
        }
        GetHeight() {
            return this._imageHeight
        }
        async LoadToDrawable() {
            const t = await this.GetBlob();
            return e.Supports.ImageBitmapOptions ? await createImageBitmap(t, {
                premultiplyAlpha: "none"
            }) : e.Supports.ImageBitmap ? await createImageBitmap(t) : await e.BlobToImage(t)
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = self.assert;

    function SortByInstLastCachedZIndex(e, t) {
        return e.GetWorldInfo()._GetLastCachedZIndex() - t.GetWorldInfo()._GetLastCachedZIndex()
    }
    e.RenderCell = class RenderCell extends e.DefendedBase {
        constructor(e, t, n) {
            super(), this._grid = e, this._x = t, this._y = n, this._instances = [], this._isSorted = !0, this._pendingRemoval = new Set, this._isAnyPendingRemoval = !1
        }
        Release() {
            e.clearArray(this._instances), this._pendingRemoval.clear(), this._grid = null
        }
        Reset() {
            e.clearArray(this._instances), this._isSorted = !0, this._pendingRemoval.clear(), this._isAnyPendingRemoval = !1
        }
        SetChanged() {
            this._isSorted = !1
        }
        IsEmpty() {
            return !this._instances.length || !(this._instances.length > this._pendingRemoval.size) && (this._FlushPending(), !0)
        }
        Insert(e) {
            if (this._pendingRemoval.has(e)) {
                this._pendingRemoval.delete(e), this._pendingRemoval.size === 0 && (this._isAnyPendingRemoval = !1);
                return
            }
            this._instances.push(e), this._isSorted = this._instances.length === 1
        }
        Remove(e) {
            this._pendingRemoval.add(e), this._isAnyPendingRemoval = !0, this._pendingRemoval.size >= 50 && this._FlushPending()
        }
        _FlushPending() {
            if (!this._isAnyPendingRemoval) return;
            if (this._instances.length === this._pendingRemoval.size) {
                this.Reset();
                return
            }
            e.arrayRemoveAllInSet(this._instances, this._pendingRemoval), this._pendingRemoval.clear(), this._isAnyPendingRemoval = !1
        }
        _EnsureSorted() {
            if (this._isSorted) return;
            this._instances.sort(SortByInstLastCachedZIndex), this._isSorted = !0
        }
        Dump(e) {
            this._FlushPending(), this._EnsureSorted(), this._instances.length && e.push(this._instances)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.RenderGrid = class RenderGrid extends e.DefendedBase {
        constructor(t, n) {
            super(), this._cellWidth = t, this._cellHeight = n, this._cells = e.New(e.PairMap)
        }
        Release() {
            this._cells.Release(), this._cells = null
        }
        GetCell(t, n, s) {
            let o = this._cells.Get(t, n);
            return o ? o : s ? (o = e.New(e.RenderCell, this, t, n), this._cells.Set(t, n, o), o) : null
        }
        XToCell(e) {
            return Math.floor(e / this._cellWidth)
        }
        YToCell(e) {
            return Math.floor(e / this._cellHeight)
        }
        Update(e, t, n) {
            if (t)
                for (let s = t.getLeft(), o = t.getRight(); s <= o; ++s)
                    for (let o = t.getTop(), a = t.getBottom(); o <= a; ++o) {
                        if (n && n.containsPoint(s, o)) continue;
                        const i = this.GetCell(s, o, !1);
                        if (!i) continue;
                        i.Remove(e), i.IsEmpty() && this._cells.Delete(s, o)
                    }
            if (n)
                for (let s = n.getLeft(), o = n.getRight(); s <= o; ++s)
                    for (let o = n.getTop(), i = n.getBottom(); o <= i; ++o) {
                        if (t && t.containsPoint(s, o)) continue;
                        this.GetCell(s, o, !0).Insert(e)
                    }
        }
        QueryRange(e, t) {
            let n = this.XToCell(e.getLeft());
            const s = this.YToCell(e.getTop()),
                o = this.XToCell(e.getRight()),
                i = this.YToCell(e.getBottom());
            for (; n <= o; ++n)
                for (let e = s; e <= i; ++e) {
                    const o = this.GetCell(n, e, !1);
                    if (!o) continue;
                    o.Dump(t)
                }
        }
        MarkRangeChanged(e) {
            let t = e.getLeft();
            const n = e.getTop(),
                s = e.getRight(),
                o = e.getBottom();
            for (; t <= s; ++t)
                for (let e = n; e <= o; ++e) {
                    const s = this.GetCell(t, e, !1);
                    if (!s) continue;
                    s.SetChanged()
                }
        }
    }
}
"use strict";
{
    const e = self.C3,
        n = new e.Rect,
        i = new e.Quad,
        s = [],
        a = new e.Rect,
        t = new e.Rect,
        r = self.glMatrix,
        o = r.vec3,
        c = o.fromValues(0, 1, 0);

    function SortByInstLastCachedZIndex(e, t) {
        return e.GetWorldInfo()._GetLastCachedZIndex() - t.GetWorldInfo()._GetLastCachedZIndex()
    }

    function SortByInstZElevation(e, t) {
        return e.GetWorldInfo().GetZElevation() - t.GetWorldInfo().GetZElevation()
    }
    e.Layer = class Layer extends e.DefendedBase {
        constructor(t, n, s) {
            super(), this._layout = t, this._runtime = t.GetRuntime(), this._name = s[0], this._index = n, this._sid = s[2], this._isVisible = !!s[3], this._backgroundColor = e.New(e.Color), this._backgroundColor.setFromJSON(s[4].map(e => e / 255)), this._isTransparent = !!s[5], this._parallaxX = s[6], this._parallaxY = s[7], this._color = e.New(e.Color, 1, 1, 1, s[8]), this._premultipliedColor = e.New(e.Color), this._isForceOwnTexture = s[9], this._useRenderCells = s[10], this._scaleRate = s[11], this._blendMode = s[12], this._curRenderTarget = null, this._scale = 1, this._zElevation = s[16], this._angle = 0, this._isAngleEnabled = !0, this._viewport = e.New(e.Rect), this._viewportZ0 = e.New(e.Rect), this._startupInitialInstances = [], this._initialInstances = [], this._createdGlobalUids = [], this._initialUIDsToInstanceData = new Map, this._instances = [], this._zIndicesUpToDate = !1, this._anyInstanceZElevated = !1, this._effectList = e.New(e.EffectList, this, s[15]), this._renderGrid = null, this._lastRenderList = [], this._isRenderListUpToDate = !1, this._lastRenderCells = e.New(e.Rect, 0, 0, -1, -1), this._curRenderCells = e.New(e.Rect, 0, 0, -1, -1), this._iLayer = new self.ILayer(this), this._UpdatePremultipliedColor(), this._useRenderCells && (this._renderGrid = e.New(e.RenderGrid, this._runtime.GetOriginalViewportWidth(), this._runtime.GetOriginalViewportHeight()));
            for (const e of s[14]) {
                const t = this._runtime.GetObjectClassByIndex(e[1]);
                this._layout._AddInitialObjectClass(t), t.GetDefaultInstanceData() || (t.SetDefaultInstanceData(e), t._SetDefaultLayerIndex(this._index)), this._initialInstances.push(e), this._initialUIDsToInstanceData.set(e[2], e)
            }
            e.shallowAssignArray(this._startupInitialInstances, this._initialInstances)
        }
        static Create(t, n, s) {
            return e.New(e.Layer, t, n, s)
        }
        Release() {
            this._layout = null, this._runtime = null
        }
        GetInitialInstanceData(e) {
            return this._initialUIDsToInstanceData.get(e)
        }
        CreateInitialInstances(t) {
            const o = this._layout.IsFirstVisit();
            let s = 0;
            const n = this._initialInstances;
            for (let e = 0, c = n.length; e < c; ++e) {
                const i = n[e],
                    a = this._runtime.GetObjectClassByIndex(i[1]);
                let r = !0;
                if (!a.HasPersistBehavior() || o) {
                    const e = this._runtime.CreateInstanceFromData(i, this, !0);
                    t.push(e), a.IsGlobal() && (r = !1, this._createdGlobalUids.push(e.GetUID()))
                }
                r && (n[s] = n[e], ++s)
            }
            e.truncateArray(n, s), this._runtime.FlushPendingInstances(), this.SetZIndicesChanged()
        }
        _AddInstance(e, t) {
            const n = e.GetWorldInfo();
            if (n.GetLayer() !== this) throw new Error("instance added to wrong layer");
            this._instances.push(e), n.GetZElevation() !== 0 && (this._anyInstanceZElevated = !0), t && this._useRenderCells && e.GetWorldInfo().SetBboxChanged(), this.SetZIndicesChanged()
        }
        _MaybeAddInstance(e) {
            if (this._instances.includes(e)) return;
            this._instances.push(e), e.GetWorldInfo().GetZElevation() !== 0 && (this._anyInstanceZElevated = !0), this.SetZIndicesChanged()
        }
        _PrependInstance(e, t) {
            const n = e.GetWorldInfo();
            if (n.GetLayer() !== this) throw new Error("instance added to wrong layer");
            this._instances.unshift(e), n.GetZElevation() !== 0 && (this._anyInstanceZElevated = !0), this.SetZIndicesChanged(), t && this._useRenderCells && e.GetWorldInfo().SetBboxChanged()
        }
        _RemoveInstance(e, t) {
            const n = this._instances.indexOf(e);
            if (n < 0) return;
            t && this._useRenderCells && e.GetWorldInfo()._RemoveFromRenderCells(), this._instances.splice(n, 1), this.SetZIndicesChanged(), this._MaybeResetAnyInstanceZElevatedFlag()
        }
        _SetAnyInstanceZElevated() {
            this._anyInstanceZElevated = !0
        }
        _MaybeResetAnyInstanceZElevatedFlag() {
            this._instances.length === 0 && (this._anyInstanceZElevated = !1)
        }
        _SortInstancesByLastCachedZIndex(e) {
            if (e) {
                const t = new Set;
                for (const n of this._instances) {
                    const e = n.GetWorldInfo()._GetLastCachedZIndex();
                    e >= 0 && t.add(e)
                }
                let e = -1;
                for (const s of this._instances) {
                    const n = s.GetWorldInfo();
                    if (n._GetLastCachedZIndex() >= 0) continue;
                    for (++e; t.has(e);) ++e;
                    n._SetZIndex(e)
                }
            }
            this._instances.sort(SortByInstLastCachedZIndex)
        }
        _Start() {}
        _End() {
            for (const e of this._instances) e.GetObjectClass().IsGlobal() || this._runtime.DestroyInstance(e);
            this._runtime.FlushPendingInstances(), e.clearArray(this._instances), this._anyInstanceZElevated = !1, this.SetZIndicesChanged()
        }
        RecreateInitialObjects(e, t, n, s, o) {
            const i = this._runtime.GetEventSheetManager(),
                r = this._runtime.GetAllObjectClasses(),
                c = e.IsFamily(),
                a = [];
            for (const d of this._initialInstances) {
                const m = d[0],
                    g = m[0],
                    v = m[1];
                if (!t.containsPoint(g, v)) continue;
                const f = r[d[1]];
                if (f !== e)
                    if (c) {
                        if (!e.FamilyHasMember(f)) continue
                    } else continue;
                let l = this;
                const u = this._runtime.GetCurrentLayout();
                this.GetLayout() !== u && (l = u.GetLayerByName(this.GetName()), l || (l = u.GetLayerByIndex(this.GetIndex())));
                const h = this._runtime.CreateInstanceFromData(d, l, !1, void 0, void 0, !1, o),
                    p = h.GetWorldInfo();
                p.OffsetXY(n, s), p.SetBboxChanged(), i.BlockFlushingInstances(!0), h._TriggerOnCreatedOnSelfAndRelated(), i.BlockFlushingInstances(!1), a.push(h)
            }
            return a
        }
        GetInstanceCount() {
            return this._instances.length
        }
        GetLayout() {
            return this._layout
        }
        GetName() {
            return this._name
        }
        GetIndex() {
            return this._index
        }
        GetSID() {
            return this._sid
        }
        GetRuntime() {
            return this._runtime
        }
        GetDevicePixelRatio() {
            return this._runtime.GetDevicePixelRatio()
        }
        GetEffectList() {
            return this._effectList
        }
        UsesRenderCells() {
            return this._useRenderCells
        }
        GetRenderGrid() {
            return this._renderGrid
        }
        SetRenderListStale() {
            this._isRenderListUpToDate = !1
        }
        IsVisible() {
            return this._isVisible
        }
        SetVisible(e) {
            if (e = !!e, this._isVisible === e) return;
            this._isVisible = e, this._runtime.UpdateRender()
        }
        GetViewport() {
            return this._viewport
        }
        GetViewportForZ(e, t) {
            const n = this._viewportZ0;
            if (e === 0) t.copy(n);
            else {
                const s = this.Get2DScaleFactorToZ(e),
                    o = n.midX(),
                    i = n.midY(),
                    a = .5 * n.width() / s,
                    r = .5 * n.height() / s;
                t.set(o - a, i - r, o + a, i + r)
            }
        }
        GetOpacity() {
            return this._color.getA()
        }
        SetOpacity(t) {
            if (t = e.clamp(t, 0, 1), this._color.getA() === t) return;
            this._color.setA(t), this._UpdatePremultipliedColor(), this._runtime.UpdateRender()
        }
        _UpdatePremultipliedColor() {
            this._premultipliedColor.copy(this._color), this._premultipliedColor.premultiply()
        }
        GetPremultipliedColor() {
            return this._premultipliedColor
        }
        HasDefaultColor() {
            return this._color.equalsRgba(1, 1, 1, 1)
        }
        GetScaleRate() {
            return this._scaleRate
        }
        SetScaleRate(e) {
            if (this._scaleRate === e) return;
            this._scaleRate = e, this._runtime.UpdateRender()
        }
        GetParallaxX() {
            return this._parallaxX
        }
        GetParallaxY() {
            return this._parallaxY
        }
        SetParallax(e, t) {
            if (this._parallaxX === e && this._parallaxY === t) return;
            if (this._parallaxX = e, this._parallaxY = t, this._runtime.UpdateRender(), this._parallaxX !== 1 || this._parallaxY !== 1)
                for (const e of this._instances) e.GetObjectClass()._SetAnyInstanceParallaxed(!0)
        }
        SetParallaxX(e) {
            this.SetParallax(e, this.GetParallaxY())
        }
        SetParallaxY(e) {
            this.SetParallax(this.GetParallaxX(), e)
        }
        SetZElevation(e) {
            if (e = +e, this._zElevation === e) return;
            this._zElevation = e, this._runtime.UpdateRender()
        }
        GetZElevation() {
            return this._zElevation
        }
        SetAngle(t) {
            this._angle = e.clampAngle(t)
        }
        GetAngle() {
            return this._isAngleEnabled ? e.clampAngle(this._layout.GetAngle() + this._angle) : 0
        }
        GetOwnAngle() {
            return this._angle
        }
        HasInstances() {
            return this._instances.length > 0
        }
        _GetInstances() {
            return this._instances
        }
        GetBackgroundColor() {
            return this._backgroundColor
        }
        IsTransparent() {
            return this._isTransparent
        }
        SetTransparent(e) {
            this._isTransparent = !!e
        }
        IsForceOwnTexture() {
            return this._isForceOwnTexture
        }
        SetForceOwnTexture(e) {
            this._isForceOwnTexture = !!e
        }
        SetBlendMode(e) {
            if (this._blendMode === e) return;
            this._blendMode = e, this._runtime.UpdateRender()
        }
        GetBlendMode() {
            return this._blendMode
        }
        IsTransformCompatibleWith(e) {
            return this === e || this._parallaxX === e._parallaxX && this._parallaxY === e._parallaxY && this._scale === e._scale && this._scaleRate === e._scaleRate && this._angle === e._angle
        }
        _RemoveAllInstancesInSet(t) {
            if (t.size === 0) return;
            const n = e.arrayRemoveAllInSet(this._instances, t);
            n > 0 && (this._MaybeResetAnyInstanceZElevatedFlag(), this.SetZIndicesChanged())
        }
        SetZIndicesChanged() {
            this._zIndicesUpToDate = !1, this._isRenderListUpToDate = !1
        }
        _UpdateZIndices() {
            if (this._zIndicesUpToDate) return;
            if (this._instances.sort(SortByInstZElevation), this._useRenderCells)
                for (let e = 0, n = this._instances.length; e < n; ++e) {
                    const t = this._instances[e].GetWorldInfo();
                    t._SetZIndex(e), this._renderGrid.MarkRangeChanged(t.GetRenderCellRange())
                } else
                    for (let e = 0, t = this._instances.length; e < t; ++e) this._instances[e].GetWorldInfo()._SetZIndex(e);
            this._zIndicesUpToDate = !0
        }
        MoveInstanceAdjacent(t, n, s) {
            const a = t.GetWorldInfo(),
                r = n.GetWorldInfo();
            if (a.GetLayer() !== this || r.GetLayer() !== this) throw new Error("can't arrange Z order unless both objects on this layer");
            const i = a.GetZIndex();
            let o = r.GetZIndex();
            return i !== o + (s ? 1 : -1) && (e.arrayRemove(this._instances, i), i < o && o--, s && o++, o === this._instances.length ? this._instances.push(t) : this._instances.splice(o, 0, t), this.SetZIndicesChanged(), !0)
        }
        _MergeSortedZArrays(e, t) {
            const o = [];
            let n = 0,
                s = 0,
                i = e.length,
                a = t.length;
            for (; n < i && s < a;) {
                const i = e[n],
                    a = t[s];
                i.GetWorldInfo()._GetLastCachedZIndex() < a.GetWorldInfo()._GetLastCachedZIndex() ? (o.push(i), ++n) : (o.push(a), ++s)
            }
            for (; n < i; ++n) o.push(e[n]);
            for (; s < a; ++s) o.push(t[s]);
            return o
        }
        _MergeAllSortedZArrays_pass(e) {
            const t = [],
                n = e.length;
            for (let s = 0; s < n - 1; s += 2) {
                const o = e[s],
                    i = e[s + 1];
                t.push(this._MergeSortedZArrays(o, i))
            }
            return n % 2 === 1 && t.push(e[n - 1]), t
        }
        _MergeAllSortedZArrays(e) {
            for (; e.length > 1;) e = this._MergeAllSortedZArrays_pass(e);
            return e[0]
        }
        _GetRenderCellInstancesToDraw() {
            return this._UpdateZIndices(), e.clearArray(s), this._renderGrid.QueryRange(this._viewport, s), s.length ? s.length === 1 ? s[0] : this._MergeAllSortedZArrays(s) : []
        }
        _IsOpaque() {
            return !this.UsesOwnTexture() && !this.IsTransparent()
        }
        ShouldDraw() {
            return this.IsVisible() && this.GetOpacity() > 0 && (this.HasInstances() || !this.IsTransparent())
        }
        UsesOwnTexture() {
            return this.IsForceOwnTexture() || !this.HasDefaultColor() || this.GetBlendMode() !== 0 || this._effectList.HasAnyActiveEffect()
        }
        GetRenderTarget() {
            return this._curRenderTarget
        }
        _CanFastPathDrawLayer(e) {
            if (e.length === 0) return !0;
            if (e.length >= 2) return !1;
            const n = e[0],
                t = n.GetShaderProgram();
            return !t.MustPreDraw() && !t.UsesDest() && !t.UsesCrossSampling() && this.HasDefaultColor()
        }
        Get2DScaleFactorToZ(e) {
            const t = this.GetCameraZ();
            return t / (t - e)
        }
        GetCameraZ() {
            return 100 / this.GetNormalScale()
        }
        _SetTransform(e, t = 0, n = 0) {
            const s = this._runtime.GetRenderScale(),
                r = (this._viewport.midX() + t) * s,
                l = (this._viewport.midY() + n) * s,
                d = this.GetCameraZ();
            e.SetCameraXYZ(r, l, d), e.SetLookXYZ(r, l, d - 100);
            const i = this.GetAngle(),
                a = c;
            i === 0 ? o.set(a, 0, 1, 0) : o.set(a, Math.sin(i), Math.cos(i), 0), e.ResetModelView(a), e.Scale(s, s), e.UpdateModelView()
        }
        Draw(e, t, n) {
            const s = this._runtime.GetCanvasManager(),
                a = this.UsesOwnTexture();
            let o = null,
                i = null;
            if (this._runtime.IsGPUProfiling() && e.SupportsGPUProfiling()) {
                const t = s.GetLayerTimingsBuffer(this);
                t && (i = t.AddTimeElapsedQuery(), e.StartQuery(i))
            }
            if (a) {
                const t = {
                    sampling: this._runtime.GetSampling()
                };
                s.GetCurrentFullscreenScalingQuality() === "low" && (t.width = s.GetDrawWidth(), t.height = s.GetDrawHeight()), o = this._runtime.GetAdditionalRenderTarget(t), e.SetRenderTarget(o), this.IsTransparent() && e.ClearRgba(0, 0, 0, 0)
            } else e.SetRenderTarget(t);
            if (this.IsTransparent() || e.Clear(this._backgroundColor), this._curRenderTarget = o || t, this._SetTransform(e), e.SetBaseZ(this.GetZElevation()), this.GetNormalScale() > Number.EPSILON) {
                this._UpdateZIndices();
                const t = this._useRenderCells && this.GetZElevation() === 0 && !this._anyInstanceZElevated;
                t ? this._DrawInstances_RenderCells(e) : this._DrawInstances(e, this._instances)
            }
            e.SetBaseZ(0), e.SetCurrentZ(0), e.SetCameraXYZ(0, 0, 100), e.SetLookXYZ(0, 0, 0), a && this._DrawLayerOwnTextureToRenderTarget(e, o, t, n), i && e.EndQuery(i), this._curRenderTarget = null
        }
        _DrawInstances(e, t) {
            const s = this._viewport,
                o = this._curRenderTarget;
            let n = null;
            for (let r = 0, c = t.length; r < c; ++r) {
                const i = t[r];
                if (i === n) continue;
                n = i;
                const a = i.GetWorldInfo();
                a.IsVisible() && a.IsInViewport(s) && (a.HasAnyActiveEffect() ? this._DrawInstanceWithEffectsAndRestore(i, a, e, o) : this._DrawInstance(i, a, e))
            }
        }
        _DrawInstances_RenderCells(t) {
            const s = this._renderGrid,
                i = this._curRenderCells,
                a = this._lastRenderCells,
                o = this._viewport;
            let n;
            i.set(s.XToCell(o.getLeft()), s.YToCell(o.getTop()), s.XToCell(o.getRight()), s.YToCell(o.getBottom())), !this._isRenderListUpToDate || !i.equals(a) ? (n = this._GetRenderCellInstancesToDraw(), this._isRenderListUpToDate = !0, a.copy(i)) : n = this._lastRenderList, this._DrawInstances(t, n), n !== this._lastRenderList && e.shallowAssignArray(this._lastRenderList, n)
        }
        _DrawInstance(e, t, n) {
            const s = t.GetRendererStateGroup();
            n.GetCurrentStateGroup() !== s && s.Apply(), e.Draw(n)
        }
        _DrawInstanceWithEffectsAndRestore(e, t, n, s) {
            this._DrawInstanceWithEffects(e, t, n, s, null) && this._SetTransform(n)
        }
        _DrawInstanceWithEffects(t, n, s, o, i) {
            const a = n.GetInstanceEffectList().GetActiveEffectTypes();
            if (a.length === 1) {
                const e = a[0],
                    o = e.GetShaderProgram();
                if (!o.NeedsPostDrawOrExtendsBox() && n.HasDefaultColor() && !t.MustPreDraw()) return this._DrawInstanceWithEffects_FastPath(t, n, e, o, s), !1
            }
            const r = e.RenderEffectChain(s, this._runtime, t, o, a, i);
            return s.SetBaseZ(this.GetZElevation()), r
        }
        _DrawInstanceWithEffects_FastPath(e, n, s, o, i) {
            i.SetProgram(o), i.SetBlendMode(n.GetBlendMode()), o.IsAnimated() && this._runtime.UpdateRender();
            let r = 0,
                c = 0;
            if (o.UsesAnySrcRectOrPixelSize()) {
                const [s, o] = e.GetCurrentSurfaceSize();
                r = 1 / s, c = 1 / o;
                const n = e.GetCurrentTexRect();
                n ? t.copy(n) : t.set(0, 0, 0, 0)
            }
            const l = n.GetInstanceEffectList().GetEffectParametersForIndex(s.GetIndex());
            i.SetCurrentZ(n.GetZElevation()), i.SetProgramParameters(null, a, t, t, n.GetBoundingBox(), r, c, this.GetOwnScale(), this.GetAngle(), this._runtime.GetGameTime(), l), e.Draw(i)
        }
        _DrawLayerOwnTextureToRenderTarget(n, s, o, i) {
            const c = this._effectList.GetActiveEffectTypes(),
                r = this._runtime;
            if (this._CanFastPathDrawLayer(c)) {
                if (n.SetRenderTarget(o), c.length === 1) {
                    const e = c[0],
                        s = e.GetShaderProgram();
                    n.SetProgram(s), t.set(0, 0, 1, 1);
                    const o = this._effectList.GetEffectParametersForIndex(e.GetIndex());
                    n.SetProgramParameters(null, a, t, t, this._viewport, 1 / r.GetDrawWidth(), 1 / r.GetDrawHeight(), this.GetNormalScale(), this.GetAngle(), r.GetGameTime(), o), s.IsAnimated() && r.UpdateRender()
                } else n.SetTextureFillMode();
                i && this._blendMode === 0 && this.HasDefaultColor() && c.length === 0 ? n.CopyRenderTarget(s) : (n.SetBlendMode(this._blendMode), n.SetColor(this._premultipliedColor), n.DrawRenderTarget(s)), n.InvalidateRenderTarget(s), r.ReleaseAdditionalRenderTarget(s)
            } else e.RenderEffectChain(n, r, this, o, c)
        }
        GetOwnScale() {
            return this._scale
        }
        SetOwnScale(e) {
            if (this._scale === e) return;
            this._scale = e, this._layout.BoundScrolling(), this._runtime.UpdateRender()
        }
        GetRenderScale() {
            return this.GetNormalScale() * this._runtime.GetRenderScale()
        }
        GetDisplayScale() {
            return this.GetNormalScale() * this._runtime.GetDisplayScale()
        }
        GetNormalScale() {
            return (this._scale * this._layout.GetScale() - 1) * this._scaleRate + 1
        }
        UpdateViewport() {
            this._isAngleEnabled = !1;
            let [t, s] = this.CanvasCssToLayer(0, 0);
            this._isAngleEnabled = !0, this._runtime.IsPixelRoundingEnabled() && (t = Math.round(t), s = Math.round(s));
            const o = 1 / this.GetNormalScale(),
                e = this._viewportZ0;
            e.set(t, s, t + this._runtime.GetViewportWidth() * o, s + this._runtime.GetViewportHeight() * o);
            const a = this.GetAngle();
            a !== 0 && (n.copy(e), n.offset(-e.midX(), -e.midY()), i.setFromRotatedRect(n, a), i.getBoundingBox(n), n.offset(e.midX(), e.midY()), e.copy(n)), this.GetViewportForZ(this._zElevation, this._viewport)
        }
        CanvasCssToLayer(e, t, n = 0) {
            return this._CanvasToLayer(e, t, n, this.GetDisplayScale())
        }
        DrawSurfaceToLayer(e, t, n = 0) {
            return this._CanvasToLayer(e, t, n, this.GetRenderScale() * this.GetDevicePixelRatio())
        }
        _CanvasToLayer(e, t, n, s) {
            const l = this._runtime.GetParallaxXOrigin(),
                d = this._runtime.GetParallaxYOrigin(),
                a = (this._layout.GetScrollX() - l) * this._parallaxX + l,
                r = (this._layout.GetScrollY() - d) * this._parallaxY + d,
                u = this.GetNormalScale(),
                h = this._runtime.GetViewportWidth() / u,
                m = this._runtime.GetViewportHeight() / u,
                f = a - h / 2,
                p = r - m / 2;
            let o = f + e / s,
                i = p + t / s;
            const c = this.GetAngle();
            if (c !== 0) {
                o -= a, i -= r;
                const e = Math.cos(c),
                    t = Math.sin(c),
                    n = o * e - i * t;
                i = i * e + o * t, o = n, o += a, i += r
            }
            if (n !== 0) {
                const e = this._viewportZ0.midX(),
                    t = this._viewportZ0.midY(),
                    s = this.Get2DScaleFactorToZ(n);
                o = (o - e) / s + e, i = (i - t) / s + t
            }
            return [o, i]
        }
        CanvasCssToLayer_DefaultTransform(e, t) {
            const n = this._scale,
                s = this._scaleRate,
                o = this._parallaxX,
                i = this._parallaxY,
                a = this._angle;
            this._scale = 1, this._scaleRate = 1, this._parallaxX = 1, this._parallaxY = 1, this._angle = 0;
            const r = this.CanvasCssToLayer(e, t);
            return this._scale = n, this._scaleRate = s, this._parallaxX = o, this._parallaxY = i, this._angle = a, r
        }
        LayerToCanvasCss(e, t, n = 0) {
            return this._LayerToCanvas(e, t, n, this.GetDisplayScale())
        }
        LayerToDrawSurface(e, t, n = 0) {
            return this._LayerToCanvas(e, t, n, this.GetRenderScale() * this.GetDevicePixelRatio())
        }
        _LayerToCanvas(e, t, n, s) {
            const o = this._runtime,
                c = this._layout;
            if (n !== 0) {
                const s = this._viewportZ0.midX(),
                    o = this._viewportZ0.midY(),
                    i = this.Get2DScaleFactorToZ(n);
                e = (e - s) * i + s, t = (t - o) * i + o
            }
            const l = o.GetParallaxXOrigin(),
                d = o.GetParallaxYOrigin(),
                i = (c.GetScrollX() - l) * this._parallaxX + l,
                a = (c.GetScrollY() - d) * this._parallaxY + d,
                r = this.GetAngle();
            if (r !== 0) {
                e -= i, t -= a;
                const n = Math.cos(-r),
                    s = Math.sin(-r),
                    o = e * n - t * s;
                t = t * n + e * s, e = o, e += i, t += a
            }
            const u = this.GetNormalScale(),
                h = o.GetViewportWidth() / u,
                m = o.GetViewportHeight() / u,
                f = i - h / 2,
                p = a - m / 2,
                g = e - f,
                v = t - p,
                b = g * s,
                j = v * s;
            return [b, j]
        }
        _GetLayerToDrawSurfaceScale(e, t) {
            return e *= this.GetRenderScale() * this.GetDevicePixelRatio(), t !== 0 && (e *= this.Get2DScaleFactorToZ(t)), e
        }
        _SaveToJson() {
            const e = {
                s: this.GetOwnScale(),
                a: this.GetOwnAngle(),
                vl: this._viewport.getLeft(),
                vt: this._viewport.getTop(),
                vr: this._viewport.getRight(),
                vb: this._viewport.getBottom(),
                v: this.IsVisible(),
                bc: this._backgroundColor.toJSON(),
                t: this.IsTransparent(),
                px: this.GetParallaxX(),
                py: this.GetParallaxY(),
                c: this._color.toJSON(),
                sr: this.GetScaleRate(),
                fx: this._effectList.SaveToJson(),
                cg: this._createdGlobalUids
            };
            return e
        }
        _LoadFromJson(t) {
            this._scale = t.s, this._angle = t.a, this._viewport.set(t.vl, t.vt, t.vr, t.vb), this._isVisible = !!t.v, this._backgroundColor.setFromJSON(t.bc), this._isTransparent = !!t.t, this._parallaxX = t.px, this._parallaxY = t.py, this._color.setFromJSON(t.c), this._scaleRate = t.sr, e.shallowAssignArray(this._createdGlobalUids, t.cg), e.shallowAssignArray(this._initialInstances, this._startupInitialInstances);
            const s = new Set(this._createdGlobalUids);
            let n = 0;
            for (let e = 0, t = this._initialInstances.length; e < t; ++e) s.has(this._initialInstances[e][2]) || (this._initialInstances[n] = this._initialInstances[e], ++n);
            e.truncateArray(this._initialInstances, n), this._effectList.LoadFromJson(t.fx), this._SortInstancesByLastCachedZIndex(!1), this.SetZIndicesChanged()
        }
        GetILayer() {
            return this._iLayer
        }
    }
}
"use strict";
{
    const e = self.C3,
        n = self.C3Debugger,
        i = self.assert,
        o = e.New(e.Rect),
        t = e.New(e.Rect),
        s = e.New(e.Rect);
    e.Layout = class Layout extends e.DefendedBase {
        constructor(t, n, s) {
            super(), this._layoutManager = t, this._runtime = t.GetRuntime(), this._name = s[0], this._originalWidth = s[1], this._originalHeight = s[2], this._width = s[1], this._height = s[2], this._isUnboundedScrolling = !!s[3], this._eventSheetName = s[4], this._eventSheet = null, this._sid = s[5], this._index = n, this._scrollX = 0, this._scrollY = 0, this._scale = 1, this._angle = 0, this._initialObjectClasses = new Set, this._textureLoadedTypes = new Set, this._textureLoadPendingPromises = new Set, this._createdInstances = [], this._initialNonWorld = [], this._layers = [], this._layersByName = new Map, this._layersBySid = new Map, this._effectList = e.New(e.EffectList, this, s[8]), this._curRenderTarget = null, this._persistData = {}, this._isFirstVisit = !0, this._iLayout = new self.ILayout(this), this._userScriptDispatcher = e.New(e.Event.Dispatcher);
            for (const n of s[6]) {
                const t = e.Layer.Create(this, this._layers.length, n);
                this._layers.push(t), this._layersByName.set(t.GetName().toLowerCase(), t), this._layersBySid.set(t.GetSID(), t)
            }
            for (const t of s[7]) {
                const e = this._runtime.GetObjectClassByIndex(t[1]);
                if (!e) throw new Error("missing nonworld object class");
                e.GetDefaultInstanceData() || e.SetDefaultInstanceData(t), this._initialNonWorld.push(t), this._AddInitialObjectClass(e)
            }
        }
        Release() {
            for (const e of this._layers) e.Release();
            e.clearArray(this._layers), this._textureLoadPendingPromises.clear(), this._eventSheet = null, this._layoutManager = null, this._runtime = null
        }
        GetRuntime() {
            return this._runtime
        }
        GetName() {
            return this._name
        }
        GetSID() {
            return this._sid
        }
        GetIndex() {
            return this._index
        }
        GetEffectList() {
            return this._effectList
        }
        GetMinLayerScale() {
            let e = this._layers[0].GetNormalScale();
            for (let t = 1, s = this._layers.length; t < s; ++t) {
                const n = this._layers[t];
                if (n.GetParallaxX() === 0 && n.GetParallaxY() === 0) continue;
                e = Math.min(e, n.GetNormalScale())
            }
            return e
        }
        SetScrollX(e) {
            if (!this._isUnboundedScrolling) {
                const t = this._runtime.GetViewportWidth() * (1 / this.GetMinLayerScale()) / 2;
                e > this._width - t && (e = this._width - t), e < t && (e = t)
            }
            this._scrollX !== e && (this._scrollX = e, this._runtime.UpdateRender())
        }
        GetScrollX() {
            return this._scrollX
        }
        SetScrollY(e) {
            if (!this._isUnboundedScrolling) {
                const t = this._runtime.GetViewportHeight() * (1 / this.GetMinLayerScale()) / 2;
                e > this._height - t && (e = this._height - t), e < t && (e = t)
            }
            this._scrollY !== e && (this._scrollY = e, this._runtime.UpdateRender())
        }
        GetScrollY() {
            return this._scrollY
        }
        BoundScrolling() {
            this.SetScrollX(this.GetScrollX()), this.SetScrollY(this.GetScrollY())
        }
        GetScale() {
            return this._scale
        }
        SetScale(e) {
            if (e = +e, this._scale === e) return;
            this._scale = e, this.BoundScrolling()
        }
        SetAngle(t) {
            this._angle = e.clampAngle(t)
        }
        GetAngle() {
            return this._angle
        }
        GetWidth() {
            return this._width
        }
        SetWidth(e) {
            if (!isFinite(e) || e < 1) return;
            this._width = e
        }
        GetHeight() {
            return this._height
        }
        SetHeight(e) {
            if (!isFinite(e) || e < 1) return;
            this._height = e
        }
        GetEventSheet() {
            return this._eventSheet
        }
        GetLayers() {
            return this._layers
        }
        GetLayerCount() {
            return this._layers.length
        }
        GetLayer(e) {
            return typeof e == "number" ? this.GetLayerByIndex(e) : this.GetLayerByName(e.toString())
        }
        GetLayerByIndex(t) {
            return t = e.clamp(Math.floor(t), 0, this._layers.length - 1), this._layers[t]
        }
        GetLayerByName(e) {
            return this._layersByName.get(e.toLowerCase()) || null
        }
        GetLayerBySID(e) {
            return this._layersBySid.get(e) || null
        }
        HasOpaqueBottomLayer() {
            for (const e of this._layers)
                if (e.ShouldDraw()) return e._IsOpaque();
            return !1
        }
        IsFirstVisit() {
            return this._isFirstVisit
        }
        _GetInitialObjectClasses() {
            return [...this._initialObjectClasses]
        }
        _AddInitialObjectClass(e) {
            if (e.IsInContainer())
                for (const t of e.GetContainer().GetObjectTypes()) this._initialObjectClasses.add(t);
            else this._initialObjectClasses.add(e)
        }
        _GetTextureLoadedObjectTypes() {
            return [...this._textureLoadedTypes]
        }
        _Load(t, n) {
            if (t === this || !n) return Promise.resolve();
            t && (e.CopySet(this._textureLoadedTypes, t._textureLoadedTypes), t._textureLoadedTypes.clear());
            const s = [];
            for (const e of this._initialObjectClasses) this._textureLoadedTypes.has(e) || (s.push(e.LoadTextures(n)), this._textureLoadedTypes.add(e));
            return Promise.all(s)
        }
        async MaybeLoadTexturesFor(e) {
            if (e.IsFamily()) throw new Error("cannot load textures for family");
            const t = this._runtime.GetWebGLRenderer();
            if (!t || t.IsContextLost() || this._textureLoadedTypes.has(e)) return;
            this._textureLoadedTypes.add(e);
            const n = e.LoadTextures(t);
            this._AddPendingTextureLoadPromise(n), await n, e.OnDynamicTextureLoadComplete(), this._runtime.UpdateRender()
        }
        _AddPendingTextureLoadPromise(e) {
            this._textureLoadPendingPromises.add(e), e.then(() => this._textureLoadPendingPromises.delete(e)).catch(() => this._textureLoadPendingPromises.delete(e))
        }
        WaitForPendingTextureLoadsToComplete() {
            return Promise.all([...this._textureLoadPendingPromises])
        }
        MaybeUnloadTexturesFor(e) {
            if (e.IsFamily() || e.GetInstanceCount() > 0) throw new Error("cannot unload textures");
            const t = this._runtime.GetWebGLRenderer();
            if (!t || !this._textureLoadedTypes.has(e)) return;
            this._textureLoadedTypes.delete(e), e.ReleaseTextures(t)
        }
        _Unload(e, t) {
            if (e === this || !t) return;
            for (const t of this._textureLoadedTypes) !t.IsGlobal() && !e._initialObjectClasses.has(t) && (t.ReleaseTextures(), this._textureLoadedTypes.delete(t))
        }
        _OnWebGLContextLost() {
            this._textureLoadedTypes.clear()
        }
        async _StartRunning(t) {
            const n = this._runtime,
                s = this._layoutManager,
                o = n.GetEventSheetManager();
            this._eventSheetName && (this._eventSheet = o.GetEventSheetByName(this._eventSheetName), this._eventSheet._UpdateDeepIncludes()), s._SetMainRunningLayout(this), this._width = this._originalWidth, this._height = this._originalHeight, this._scrollX = n.GetOriginalViewportWidth() / 2, this._scrollY = n.GetOriginalViewportHeight() / 2, this.BoundScrolling(), this._MoveGlobalObjectsToThisLayout(t), this._runtime.SetUsingCreatePromises(!0), this._CreateInitialInstances(), this._isFirstVisit || this._CreatePersistedInstances(), this._CreateAndLinkContainerInstances(this._createdInstances), this._CreateInitialNonWorldInstances(), s.ClearPendingChangeLayout(), n.FlushPendingInstances(), this._runtime.SetUsingCreatePromises(!1);
            const i = this._runtime.GetCreatePromises();
            if (await Promise.all(i), e.clearArray(i), !n.IsLoadingState()) {
                for (const e of this._createdInstances) e.SetupInitialSceneGraphConnections();
                for (const e of this._createdInstances) e._TriggerOnCreated()
            }
            e.clearArray(this._createdInstances), await Promise.all([...this._initialObjectClasses].map(e => e.PreloadTexturesWithInstances(this._runtime.GetWebGLRenderer()))), t && (n.Dispatcher().dispatchEvent(new e.Event("beforefirstlayoutstart")), await n.DispatchUserScriptEventAsyncWait(new e.Event("beforeprojectstart"))), await this.DispatchUserScriptEventAsyncWait(new e.Event("beforelayoutstart")), n.IsLoadingState() || await n.TriggerAsync(e.Plugins.System.Cnds.OnLayoutStart, null, null), await this.DispatchUserScriptEventAsyncWait(new e.Event("afterlayoutstart")), t && (n.Dispatcher().dispatchEvent(new e.Event("afterfirstlayoutstart")), await n.DispatchUserScriptEventAsyncWait(new e.Event("afterprojectstart"))), o._RunQueuedTriggers(s), await this.WaitForPendingTextureLoadsToComplete(), this._isFirstVisit = !1
        }
        _MoveGlobalObjectsToThisLayout(t) {
            for (const t of this._runtime.GetAllObjectClasses()) {
                if (t.IsFamily() || !t.IsWorldType()) continue;
                for (const n of t.GetInstances()) {
                    const s = n.GetWorldInfo(),
                        i = s.GetLayer(),
                        a = e.clamp(i.GetIndex(), 0, this._layers.length - 1),
                        o = this._layers[a];
                    s._SetLayer(o), o._MaybeAddInstance(n)
                }
            }
            if (!t)
                for (const e of this._layers) e._SortInstancesByLastCachedZIndex(!1)
        }
        _CreateInitialInstances() {
            for (const e of this._layers) e.CreateInitialInstances(this._createdInstances), e.UpdateViewport(), e._Start()
        }
        _CreatePersistedInstances() {
            let t = !1;
            for (const [o, s] of Object.entries(this._persistData)) {
                const n = this._runtime.GetObjectClassBySID(parseInt(o, 10));
                if (!n || n.IsFamily() || !n.HasPersistBehavior()) continue;
                for (const o of s) {
                    let e = null;
                    if (n.IsWorldType() && (e = this.GetLayerBySID(o.w.l), !e)) continue;
                    const i = this._runtime.CreateInstanceFromData(n, e, !1, 0, 0, !0);
                    i.LoadFromJson(o), t = !0, this._createdInstances.push(i)
                }
                e.clearArray(s)
            }
            for (const e of this._layers) e._SortInstancesByLastCachedZIndex(!0), e.SetZIndicesChanged();
            t && (this._runtime.FlushPendingInstances(), this._runtime._RefreshUidMap())
        }
        _CreateAndLinkContainerInstances(e) {
            for (const t of e) {
                if (!t.IsInContainer()) continue;
                const n = t.GetWorldInfo(),
                    s = t.GetIID();
                for (const o of t.GetObjectClass().GetContainer().objectTypes()) {
                    if (o === t.GetObjectClass()) continue;
                    const i = o.GetInstances();
                    if (i.length > s) t._AddSibling(i[s]);
                    else {
                        let s;
                        n ? s = this._runtime.CreateInstanceFromData(o, n.GetLayer(), !0, n.GetX(), n.GetY(), !0) : s = this._runtime.CreateInstanceFromData(o, null, !0, 0, 0, !0), this._runtime.FlushPendingInstances(), o._UpdateIIDs(), t._AddSibling(s), e.push(s)
                    }
                }
            }
        }
        _CreateInitialNonWorldInstances() {
            for (const e of this._initialNonWorld) {
                const t = this._runtime.GetObjectClassByIndex(e[1]);
                t.IsInContainer() || this._runtime.CreateInstanceFromData(e, null, !0)
            }
        }
        _CreateGlobalNonWorlds() {
            const s = [],
                t = this._initialNonWorld;
            let n = 0;
            for (let e = 0, a = t.length; e < a; ++e) {
                const o = t[e],
                    i = this._runtime.GetObjectClassByIndex(o[1]);
                i.IsGlobal() ? (!i.IsInContainer() || !i.GetContainer().HasAnyWorldType()) && s.push(this._runtime.CreateInstanceFromData(o, null, !0)) : (t[n] = o, ++n)
            }
            e.truncateArray(t, n), this._runtime.FlushPendingInstances(), this._CreateAndLinkContainerInstances(s)
        }
        RecreateInitialObjects(e, t, n, s, o, i) {
            if (n) return n.RecreateInitialObjects(e, t, s, o, i);
            const a = [];
            for (const n of this._layers) a.push(n.RecreateInitialObjects(e, t, s, o, i));
            return a.flat()
        }
        async _StopRunning() {
            const t = this._layoutManager;
            this._runtime.IsLoadingState() || await this._runtime.TriggerAsync(e.Plugins.System.Cnds.OnLayoutEnd, null, null), t.SetIsEndingLayout(!0), this._runtime.GetEventSheetManager().ClearAllScheduledWaits(), this._isFirstVisit || this._SavePersistData();
            for (const e of this._layers) e._End();
            for (const e of this._runtime.GetAllObjectClasses()) {
                if (e.IsGlobal() || e.IsWorldType() || e.GetPlugin().IsSingleGlobal() || e.IsFamily()) continue;
                for (const t of e.GetInstances()) this._runtime.DestroyInstance(t);
                this._runtime.FlushPendingInstances()
            }
            t.SetIsEndingLayout(!1), t.GetMainRunningLayout() === this && t._SetMainRunningLayout(null)
        }
        _SaveInstanceToPersist(e) {
            const t = e.GetObjectClass().GetSID().toString();
            this._persistData.hasOwnProperty(t) || (this._persistData[t] = []);
            const n = this._persistData[t];
            n.push(e.SaveToJson())
        }
        _SavePersistData() {
            for (const e of this._layers) {
                e._UpdateZIndices();
                for (const t of e._GetInstances()) {
                    const n = t.GetObjectClass();
                    !n.IsGlobal() && n.HasPersistBehavior() && this._SaveInstanceToPersist(t)
                }
            }
        }
        ResetPersistData() {
            this._persistData = {}, this._isFirstVisit = !0
        }
        GetRenderTarget() {
            return this._curRenderTarget
        }
        UsesOwnTexture() {
            return this._runtime.GetCanvasManager().GetCurrentFullscreenScalingQuality() === "low" || this._runtime.UsesAnyBackgroundBlending() || this._runtime.GetCompositingMode() === "low-latency" || this._effectList.HasAnyActiveEffect()
        }
        _CanFastPathDrawLayout(e) {
            if (e.length === 0) return !0;
            if (e.length >= 2) return !1;
            const t = e[0],
                n = t.GetShaderProgram();
            return !n.MustPreDraw()
        }
        Draw(e) {
            const n = this._runtime.GetCanvasManager(),
                s = this.UsesOwnTexture();
            let t = null;
            if (s) {
                this._runtime.GetCompositingMode() !== "low-latency" && (e.SetRenderTarget(null), e.ClearRgba(0, 0, 0, 0));
                const s = {
                    sampling: this._runtime.GetSampling(),
                    readback: this._runtime.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect()
                };
                n.GetCurrentFullscreenScalingQuality() === "low" && (s.width = n.GetDrawWidth(), s.height = n.GetDrawHeight()), t = this._runtime.GetAdditionalRenderTarget(s), e.SetRenderTarget(t)
            } else e.SetRenderTarget(null);
            this.HasOpaqueBottomLayer() || e.ClearRgba(0, 0, 0, 0), this._curRenderTarget = t;
            let o = !0;
            for (const n of this._layers) n.UpdateViewport(), n.ShouldDraw() && (n.Draw(e, t, o), o = !1);
            s && this._DrawLayoutOwnTextureToRenderTarget(e, t), this._curRenderTarget = null
        }
        _DrawLayoutOwnTextureToRenderTarget(n, i) {
            const r = this._effectList.GetActiveEffectTypes(),
                a = this._runtime;
            if (this._CanFastPathDrawLayout(r)) {
                if (n.SetRenderTarget(null), r.length === 1) {
                    const e = r[0],
                        i = e.GetShaderProgram();
                    n.SetProgram(i), t.set(0, 0, 1, 1), s.set(0, 0, a.GetViewportWidth(), a.GetViewportHeight());
                    const c = this._effectList.GetEffectParametersForIndex(e.GetIndex());
                    n.SetProgramParameters(null, o, t, t, s, 1 / a.GetDrawWidth(), 1 / a.GetDrawHeight(), this.GetScale(), this.GetAngle(), a.GetGameTime(), c), i.IsAnimated() && a.UpdateRender()
                } else n.SetTextureFillMode();
                r.length === 0 ? n.CopyRenderTarget(i) : (n.SetAlphaBlend(), n.ResetColor(), n.DrawRenderTarget(i)), n.InvalidateRenderTarget(i), a.ReleaseAdditionalRenderTarget(i)
            } else e.RenderEffectChain(n, a, this, null, r)
        }
        _SaveToJson() {
            const e = {
                sx: this.GetScrollX(),
                sy: this.GetScrollY(),
                s: this.GetScale(),
                a: this.GetAngle(),
                w: this.GetWidth(),
                h: this.GetHeight(),
                fv: this._isFirstVisit,
                persist: this._persistData,
                fx: this._effectList.SaveToJson(),
                layers: {}
            };
            for (const t of this._layers) e.layers[t.GetSID().toString()] = t._SaveToJson();
            return e
        }
        _LoadFromJson(e) {
            this._scrollX = e.sx, this._scrollY = e.sy, this._scale = e.s, this._angle = e.a, this._width = e.w, this._height = e.h, this._isFirstVisit = !!e.fv, this._persistData = e.persist, this._effectList.LoadFromJson(e.fx);
            for (const [n, s] of Object.entries(e.layers)) {
                const o = parseInt(n, 10),
                    t = this.GetLayerBySID(o);
                if (!t) continue;
                t._LoadFromJson(s)
            }
        }
        GetILayout() {
            return this._iLayout
        }
        UserScriptDispatcher() {
            return this._userScriptDispatcher
        }
        DispatchUserScriptEvent(e) {
            e.layout = this.GetILayout();
            const t = this._runtime,
                s = t.IsDebug() && !t.GetEventSheetManager().IsInEventEngine();
            s && n.StartMeasuringScriptTime(), this._userScriptDispatcher.dispatchEvent(e), s && n.AddScriptTime()
        }
        DispatchUserScriptEventAsyncWait(e) {
            return e.layout = this.GetILayout(), this._userScriptDispatcher.dispatchEventAndWaitAsync(e)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.LayoutManager = class LayoutManager extends e.DefendedBase {
        constructor(e) {
            super(), this._runtime = e, this._allLayouts = [], this._layoutsByName = new Map, this._layoutsBySid = new Map, this._mainRunningLayout = null, this._runningSubLayouts = [], this._firstLayout = null, this._isEndingLayout = 0, this._pendingChangeLayout = null
        }
        Release() {
            this._runtime = null, this._mainRunningLayout = null, this._firstLayout = null, this._pendingChangeLayout = null, e.clearArray(this._allLayouts), this._layoutsByName.clear(), this._layoutsBySid.clear(), e.clearArray(this._runningSubLayouts)
        }
        Create(t) {
            const n = e.New(e.Layout, this, this._allLayouts.length, t);
            this._allLayouts.push(n), this._layoutsByName.set(n.GetName().toLowerCase(), n), this._layoutsBySid.set(n.GetSID(), n)
        }
        GetRuntime() {
            return this._runtime
        }
        SetFirstLayout(e) {
            this._firstLayout = e
        }
        GetFirstLayout() {
            if (this._firstLayout) return this._firstLayout;
            if (this._allLayouts.length) return this._allLayouts[0];
            throw new Error("no first layout")
        }
        GetLayoutByName(e) {
            return this._layoutsByName.get(e.toLowerCase()) || null
        }
        GetLayoutBySID(e) {
            return this._layoutsBySid.get(e) || null
        }
        GetLayoutByIndex(t) {
            return t = e.clamp(Math.floor(t), 0, this._allLayouts.length - 1), this._allLayouts[t]
        }
        GetLayout(e) {
            return typeof e == "number" ? this.GetLayoutByIndex(e) : this.GetLayoutByName(e.toString())
        }
        GetAllLayouts() {
            return this._allLayouts
        }
        _SetMainRunningLayout(e) {
            this._mainRunningLayout = e
        }
        GetMainRunningLayout() {
            return this._mainRunningLayout
        }
        _AddRunningSubLayout(e) {
            if (this._runningSubLayouts.includes(e)) throw new Error("layout already running");
            this._runningSubLayouts.push(e)
        }
        _RemoveRunningSubLayout(e) {
            const t = this._runningSubLayouts.indexOf(e);
            if (t === -1) throw new Error("layout not running");
            this._runningSubLayouts.splice(t, 1)
        }* runningLayouts() {
            this._mainRunningLayout && (yield this._mainRunningLayout), this._runningSubLayouts.length && (yield* this._runningSubLayouts)
        }
        IsLayoutRunning(e) {
            return this._mainRunningLayout === e || this._runningSubLayouts.includes(e)
        }
        SetIsEndingLayout(e) {
            if (e) this._isEndingLayout++;
            else {
                if (this._isEndingLayout <= 0) throw new Error("already unset");
                this._isEndingLayout--
            }
        }
        IsEndingLayout() {
            return this._isEndingLayout > 0
        }
        ChangeMainLayout(e) {
            this._pendingChangeLayout = e
        }
        ClearPendingChangeLayout() {
            this._pendingChangeLayout = null
        }
        IsPendingChangeMainLayout() {
            return !!this._pendingChangeLayout
        }
        GetPendingChangeMainLayout() {
            return this._pendingChangeLayout
        }
    }
}
"use strict";
{
    const e = self.C3;
    class a {
        constructor() {
            this.renderer = null, this.runtime = null, this.drawWidth = 0, this.drawHeight = 0, this.surfaceWidth = 0, this.surfaceHeight = 0, this.layoutRect = new e.Rect, this.rcTexBounce = new e.Rect, this.rcTexDest = new e.Rect, this.rcTexOrigin = new e.Rect, this.screenRect = new e.Rect, this.clearRect = new e.Rect, this.srcRect = new e.Rect, this.fxTex = [null, null], this.fxIndex = 0, this.otherFxIndex = 1, this.boxExtendHorizontal = 0, this.boxExtendVertical = 0, this.layerScale = 0, this.layerAngle = 0, this.layout = null, this.layer = null, this.inst = null, this.wi = null, this.renderTarget = null, this.preDraw = !1, this.postDraw = !1, this.didChangeTransform = !1, this.opts = null
        }
        Clear() {
            this.renderer = null, this.runtime = null, this.layout = null, this.layer = null, this.inst = null, this.wi = null, this.renderTarget = null, this.opts = null
        }
        ShouldPreDraw(e) {
            const t = e.GetShaderProgram();
            if (t.MustPreDraw()) return !0;
            if (this.inst) return t.UsesDest() && (this.wi.GetAngle() !== 0 || this.wi.GetWidth() < 0 || this.wi.GetHeight() < 0) || this.boxExtendHorizontal !== 0 || this.boxExtendVertical !== 0 || !this.wi.HasDefaultColor() || this.inst.MustPreDraw();
            if (this.layer) return !this.layer.HasDefaultColor()
        }
        ShouldPostDraw(e) {
            const t = e.GetShaderProgram();
            return t.UsesDest() || t.UsesCrossSampling() || this.layout && this.runtime.GetCanvasManager().GetCurrentFullscreenScalingQuality() === "low"
        }
        GetEffectRenderTarget(e) {
            if (e !== 0 && e !== 1) throw new Error("invalid effect target");
            const t = this.fxTex;
            if (!t[e]) {
                const o = this.runtime,
                    n = o.GetCanvasManager(),
                    s = {
                        sampling: o.GetSampling()
                    };
                n.GetCurrentFullscreenScalingQuality() === "low" && (s.width = n.GetDrawWidth(), s.height = n.GetDrawHeight()), t[e] = n.GetAdditionalRenderTarget(s)
            }
            return t[e]
        }
        ReleaseEffectRenderTargets() {
            const e = this.fxTex,
                t = this.runtime.GetCanvasManager();
            e[0] && (t.ReleaseAdditionalRenderTarget(e[0]), e[0] = null), e[1] && (t.ReleaseAdditionalRenderTarget(e[1]), e[1] = null)
        }
    }
    const s = [];
    let o = 0;

    function AllocRenderEffectChainState() {
        return o === s.length && s.push(new a), s[o++]
    }

    function ReleaseRenderEffectChainState(e) {
        e.ReleaseEffectRenderTargets(), e.Clear(), o--
    }
    const n = new e.Quad;
    let i = !1,
        t = !1;
    async function DebugLogRenderTargetContents(t, n, s) {
        const o = await e.Gfx.WebGLRenderTarget.DebugReadPixelsToBlob(n, s),
            i = URL.createObjectURL(o);
        console.log("[FX] " + t + " " + (s ? "" : " [to display]") + ": ", i)
    }
    e.RenderEffectChain = function(s, o, i, a, r, c) {
        const l = AllocRenderEffectChainState();
        if (l.renderer = s, l.runtime = o, i instanceof e.Instance) l.inst = i, l.wi = l.inst.GetWorldInfo();
        else if (i instanceof e.Layer) l.layer = i;
        else if (i instanceof e.Layout) l.layout = i;
        else throw new Error("invalid effects object");
        const d = o.GetCanvasManager();
        if (l.renderTarget = a, l.drawWidth = d.GetDrawWidth(), l.drawHeight = d.GetDrawHeight(), l.surfaceWidth = l.drawWidth, l.surfaceHeight = l.drawHeight, l.fxIndex = 0, l.otherFxIndex = 1, l.boxExtendHorizontal = 0, l.boxExtendVertical = 0, l.screenRect.set(0, 0, l.drawWidth, l.drawHeight), l.clearRect.set(0, 0, l.drawWidth, l.drawHeight), l.didChangeTransform = !1, l.opts = c, l.inst) {
            const e = l.wi;
            l.layerScale = e.GetLayer().GetRenderScale(), l.layerAngle = e.GetLayer().GetAngle(), l.layoutRect.copy(e.GetBoundingBox())
        } else if (l.layer) {
            const e = l.layer;
            l.layerScale = e.GetRenderScale(), l.layerAngle = e.GetAngle(), l.layoutRect.copy(e.GetViewport())
        } else {
            const e = l.layout;
            l.layerScale = e.GetScale(), l.layerAngle = e.GetAngle(), l.layoutRect.set(0, 0, l.drawWidth, l.drawHeight)
        }
        l.inst ? GetInstanceBox(l, r) : (l.rcTexBounce.set(0, 0, l.drawWidth / l.surfaceWidth, l.drawHeight / l.surfaceHeight), l.rcTexDest.copy(l.rcTexBounce), l.rcTexOrigin.copy(l.rcTexBounce), l.rcTexBounce.swapTopBottom(), l.rcTexDest.swapTopBottom(), l.rcTexOrigin.swapTopBottom()), s.SetAlphaBlend(), s.ResetColor(), s.SetBaseZ(0), s.SetCurrentZ(0), l.preDraw = l.ShouldPreDraw(r[0]), l.preDraw && PreDraw(l), s.ResetColor();
        const u = r.length - 1;
        l.postDraw = l.ShouldPostDraw(r[u]);
        for (let e = 0, i = r.length; e < i; ++e) {
            const t = r[e],
                n = t.GetShaderProgram();
            if (s.SetProgram(n), n.IsAnimated() && o.UpdateRender(), e === 0 && !l.preDraw) RenderFirstBounce(l, t);
            else {
                s.SetCopyBlend();
                const n = e === u && !l.postDraw;
                RenderBounce(l, t, n, e)
            }
            l.fxIndex === 0 ? (l.fxIndex = 1, l.otherFxIndex = 0) : (l.fxIndex = 0, l.otherFxIndex = 1)
        }
        l.postDraw && PostDraw(l, r);
        const h = l.didChangeTransform;
        return ReleaseRenderEffectChainState(l), t = !1, h
    };

    function GetInstanceBox(e, t) {
        for (let n = 0, o = t.length; n < o; ++n) {
            const s = t[n].GetShaderProgram();
            e.boxExtendHorizontal += s.GetBoxExtendHorizontal(), e.boxExtendVertical += s.GetBoxExtendVertical()
        }
        const h = e.wi,
            o = h.GetLayer(),
            p = o.GetAngle(),
            s = h.GetBoundingBox(),
            a = h.GetTotalZElevation();
        let [r, i] = o.LayerToDrawSurface(s.getLeft(), s.getTop(), a), [c, l] = o.LayerToDrawSurface(s.getRight(), s.getBottom(), a);
        if (p !== 0) {
            const [t, n] = o.LayerToDrawSurface(s.getRight(), s.getTop(), a), [d, u] = o.LayerToDrawSurface(s.getLeft(), s.getBottom(), a);
            let e = Math.min(r, c, t, d);
            c = Math.max(r, c, t, d), r = e, e = Math.min(i, l, n, u), l = Math.max(i, l, n, u), i = e
        }
        const n = e.screenRect,
            u = e.rcTexOrigin,
            m = e.rcTexDest,
            d = e.clearRect,
            f = e.rcTexBounce;
        n.set(r, i, c, l), n.shuntY(e.drawHeight), u.copy(n), u.divide(e.surfaceWidth, e.surfaceHeight), u.swapTopBottom(), n.inflate(e.boxExtendHorizontal, e.boxExtendVertical), m.copy(n), m.divide(e.surfaceWidth, e.surfaceHeight), m.swapTopBottom(), d.copy(n), d.roundOuter(), d.inflate(e.boxExtendHorizontal + 1, e.boxExtendVertical + 1), n.clamp(0, 0, e.drawWidth, e.drawHeight), d.clamp(0, 0, e.drawWidth, e.drawHeight), f.copy(n), f.divide(e.surfaceWidth, e.surfaceHeight), f.swapTopBottom()
    }

    function PreDraw(e) {
        const n = e.renderer;
        n.SetTextureFillMode();
        const o = e.GetEffectRenderTarget(e.fxIndex);
        n.SetRenderTarget(o);
        const s = e.opts;
        if (s && s.preTransform && s.preTransform(), i && n.ClearRgba(1, 0, 0, 1), n.ClearRect2(e.clearRect), e.inst) n.SetColor(e.wi.GetPremultipliedColor()), n.SetCurrentZ(e.wi.GetTotalZElevation()), e.inst.Draw(n), n.SetCurrentZ(0);
        else {
            const t = (e.layer || e.layout).GetRenderTarget();
            e.layer ? n.SetColor(e.layer.GetPremultipliedColor()) : n.ResetColor(), n.DrawRenderTarget(t), n.InvalidateRenderTarget(t), e.runtime.GetCanvasManager().ReleaseAdditionalRenderTarget(t)
        }
        e.rcTexDest.clampFlipped(0, 1, 1, 0), e.fxIndex = 1, e.otherFxIndex = 0, t && DebugLogRenderTargetContents("Pre-draw", n, o)
    }

    function RenderFirstBounce(e, n) {
        const s = e.renderer,
            o = e.runtime,
            a = e.GetEffectRenderTarget(e.fxIndex);
        s.SetRenderTarget(a);
        const r = e.opts;
        if (r && r.preTransform && r.preTransform(), i && s.ClearRgba(1, 0, 0, 1), s.ClearRect2(e.clearRect), e.inst) {
            const [r, c] = e.inst.GetCurrentSurfaceSize(), i = e.inst.GetCurrentTexRect();
            i ? e.srcRect.copy(i) : e.srcRect.set(0, 0, 0, 0);
            const l = e.wi.GetInstanceEffectList().GetEffectParametersForIndex(n.GetIndex());
            s.SetProgramParameters(e.renderTarget, e.rcTexDest, e.srcRect, e.srcRect, e.layoutRect, 1 / r, 1 / c, e.layerScale, e.layerAngle, o.GetGameTime(), l), s.SetCurrentZ(e.wi.GetTotalZElevation()), e.inst.Draw(s), s.SetCurrentZ(0), e.rcTexDest.clampFlipped(0, 1, 1, 0), e.screenRect.shuntY(e.drawHeight), t && DebugLogRenderTargetContents("First bounce", s, a)
        } else {
            const r = (e.layer || e.layout).GetEffectList().GetEffectParametersForIndex(n.GetIndex());
            s.SetProgramParameters(e.renderTarget, e.rcTexDest, e.rcTexBounce, e.rcTexOrigin, e.layoutRect, 1 / e.drawWidth, 1 / e.drawHeight, e.layerScale, e.layerAngle, o.GetGameTime(), r);
            const i = (e.layer || e.layout).GetRenderTarget();
            t && DebugLogRenderTargetContents("Layer target", s, i), s.DrawRenderTarget(i), s.InvalidateRenderTarget(i), o.GetCanvasManager().ReleaseAdditionalRenderTarget(i), t && DebugLogRenderTargetContents("First bounce", s, a)
        }
    }

    function RenderBounce(e, s, o, a) {
        const r = e.renderer,
            d = e.runtime;
        let c, l;
        a === 0 && e.preDraw && e.inst && e.screenRect.shuntY(e.drawHeight), o ? (e.inst ? r.SetBlendMode(e.wi.GetBlendMode()) : e.layer && r.SetBlendMode(e.layer.GetBlendMode()), c = e.renderTarget, r.SetRenderTarget(c)) : (c = e.GetEffectRenderTarget(e.fxIndex), r.SetRenderTarget(c), i && r.ClearRgba(1, 0, 0, 1), r.ClearRect2(e.clearRect)), e.inst ? l = e.wi.GetInstanceEffectList().GetEffectParametersForIndex(s.GetIndex()) : l = (e.layer || e.layout).GetEffectList().GetEffectParametersForIndex(s.GetIndex()), r.SetProgramParameters(e.renderTarget, e.rcTexDest, e.rcTexBounce, e.rcTexOrigin, e.layoutRect, 1 / e.surfaceWidth, 1 / e.surfaceHeight, e.layerScale, e.layerAngle, d.GetGameTime(), l);
        const u = e.GetEffectRenderTarget(e.otherFxIndex);
        r.SetTexture(u.GetTexture()), d.GetCanvasManager().SetDeviceTransform(r), e.didChangeTransform = !0, n.setFromRect(e.screenRect), r.Quad3(n, e.rcTexBounce), e.inst || r.InvalidateRenderTarget(u), t && DebugLogRenderTargetContents("Bounce " + a, r, c)
    }

    function PostDraw(e) {
        const o = e.renderer;
        if (e.layout) {
            o.SetTextureFillMode(), o.SetRenderTarget(e.renderTarget);
            const t = e.GetEffectRenderTarget(e.otherFxIndex);
            o.CopyRenderTarget(t), o.InvalidateRenderTarget(t);
            return
        }
        const i = e.runtime.GetCanvasManager();
        i.GetCurrentFullscreenScalingQuality() === "low" ? (o.SetTextureFillMode(), i.SetDeviceTransform(o, i.GetDrawWidth(), i.GetDrawHeight()), e.didChangeTransform = !0) : o.SetDeviceTransformTextureFillMode(), e.inst ? o.SetBlendMode(e.wi.GetBlendMode()) : e.layer && o.SetBlendMode(e.layer.GetBlendMode()), o.SetRenderTarget(e.renderTarget);
        const a = e.GetEffectRenderTarget(e.otherFxIndex);
        o.SetTexture(a.GetTexture()), n.setFromRect(e.screenRect), o.Quad3(n, e.rcTexBounce), e.inst || o.InvalidateRenderTarget(a), t && DebugLogRenderTargetContents("Post-draw", o, e.renderTarget)
    }
}
"use strict";
{
    const e = self.C3,
        t = new RegExp("<(.+?)>", "g");
    e.TimelineManager = class TimelineManager extends e.DefendedBase {
        constructor(t) {
            super(), this._runtime = t, this._timelineDataManager = e.New(e.TimelineDataManager), this._pluginInstance = null, this._timelines = [], this._timelinesByName = new Map, this._objectClassToTimelineMap = new Map, this._timelinesCreatedByTemplate = new Map, this._scheduledTimelines = [], this._playingTimelines = [], this._hasRuntimeListeners = !1, this._changingLayout = !1, this._isTickingTimelines = !1, this._tickFunc = () => this._OnTick(), this._tick2Func = () => this._OnTick2(), this._beforeLayoutChange = () => this._OnBeforeChangeLayout(), this._layoutChange = () => this._OnAfterChangeLayout(), this._instanceDestroy = e => this._OnInstanceDestroy(e.instance), this._afterLoad = e => this._OnAfterLoad(), this._destroyedWhileLoadingState = []
        }
        Release() {
            this.RemoveRuntimeListeners(), this._tickFunc = null, this._tick2Func = null, this._beforeLayoutChange = null, this._layoutChange = null, this._instanceDestroy = null, this._afterLoad = null;
            for (const e of this._timelines) e.Stop(), e.Release();
            e.clearArray(this._timelines), this._timelines = null, this._timelineDataManager.Release(), this._timelineDataManager = null, e.clearArray(this._scheduledTimelines), this._scheduledTimelines = null, e.clearArray(this._playingTimelines), this._playingTimelines = null, this._timelinesByName.clear(), this._timelinesByName = null, this._objectClassToTimelineMap.clear(), this._objectClassToTimelineMap = null, this._timelinesCreatedByTemplate.clear(), this._timelinesCreatedByTemplate = null, e.clearArray(this._destroyedWhileLoadingState), this._destroyedWhileLoadingState = null, this._runtime = null
        }
        AddRuntimeListeners() {
            const e = this._runtime.Dispatcher();
            e.addEventListener("pretick", this._tickFunc), e.addEventListener("tick2", this._tick2Func), e.addEventListener("beforelayoutchange", this._beforeLayoutChange), e.addEventListener("layoutchange", this._layoutChange), e.addEventListener("instancedestroy", this._instanceDestroy), e.addEventListener("afterload", this._afterLoad)
        }
        RemoveRuntimeListeners() {
            const e = this._runtime.Dispatcher();
            e.removeEventListener("pretick", this._tickFunc), e.removeEventListener("tick2", this._tick2Func), e.removeEventListener("beforelayoutchange", this._beforeLayoutChange), e.removeEventListener("layoutchange", this._layoutChange), e.removeEventListener("instancedestroy", this._instanceDestroy), e.removeEventListener("afterload", this._afterLoad)
        }
        Create(t) {
            this._timelineDataManager.Add(t);
            const n = e.TimelineState.CreateInitial(t, this);
            this.Add(n), this.SetTimelineObjectClassesToMap(n), this._timelinesCreatedByTemplate.set(n.GetName(), 0)
        }
        CreateFromTemplate(t) {
            const o = this.GetTimelineDataManager(),
                n = t.GetTemplateName(),
                i = o.Get(n),
                s = e.TimelineState.CreateFromTemplate(`${n}:${this._timelinesCreatedByTemplate.get(n)}`, i, this);
            return this._IncreaseTemplateTimelinesCount(n), this.Add(s), s
        }
        _IncreaseTemplateTimelinesCount(e) {
            this._timelinesCreatedByTemplate.set(e, this._timelinesCreatedByTemplate.get(e) + 1)
        }
        _SetCreatedTemplateTimelinesCount() {
            for (const e of this._timelines) {
                if (e.IsTemplate()) continue;
                const t = e.GetTemplateName();
                this._IncreaseTemplateTimelinesCount(t)
            }
        }
        _ClearCreatedTemplateTimelinesCount() {
            for (const e of this._timelinesCreatedByTemplate.keys()) this._timelinesCreatedByTemplate.set(e, 0)
        }
        Add(e) {
            this._timelines.push(e), this._timelinesByName.set(e.GetName().toLowerCase(), e)
        }
        Remove(t) {
            if (t.IsTemplate()) return;
            e.arrayFindRemove(this._timelines, t), e.arrayFindRemove(this._scheduledTimelines, t), e.arrayFindRemove(this._playingTimelines, t), this._timelinesByName.delete(t.GetName().toLowerCase()), this.RemoveTimelineFromObjectClassMap(t), t.IsReleased() || t.Release()
        }
        Trigger(e) {
            this._runtime.Trigger(e, this._pluginInstance, null)
        }
        GetRuntime() {
            return this._runtime
        }
        GetTimelineDataManager() {
            return this._timelineDataManager
        }
        SetPluginInstance(e) {
            this._pluginInstance = e
        }
        GetPluginInstance() {
            return this._pluginInstance
        }* GetTimelines() {
            for (const e of this._timelines) yield e
        }
        SetTimelineObjectClassToMap(e, t) {
            this._objectClassToTimelineMap.has(e) || this._objectClassToTimelineMap.set(e, new Set), this._objectClassToTimelineMap.get(e).add(t)
        }
        SetTimelineObjectClassesToMap(e) {
            for (const t of e.GetObjectClasses()) this.SetTimelineObjectClassToMap(t, e)
        }
        RemoveTimelineFromObjectClassMap(e) {
            for (const [n, t] of this._objectClassToTimelineMap.entries()) t.has(e) && (t.delete(e), t.size === 0 && this._objectClassToTimelineMap.delete(n))
        }
        GetTimelinesForObjectClass(e) {
            if (!this._objectClassToTimelineMap.has(e)) return;
            return this._objectClassToTimelineMap.get(e)
        }
        GetTimelineOfTemplateForInstances(e, t) {
            if (!t) return;
            for (const n of this._timelines) {
                const s = t.every(e => n.HasTrackInstance(e.instance, e.trackId));
                if (s && n.GetName().includes(e.GetName())) return n
            }
        }
        GetTimelineByName(e) {
            return this._timelinesByName.get(e.toLowerCase()) || null
        }
        GetScheduledOrPlayingTimelineByName(e) {
            for (const t of this._scheduledTimelines)
                if (t.GetName() === e) return t;
            for (const t of this._playingTimelines)
                if (t.GetName() === e) return t;
            return null
        }* GetTimelinesByName(e) {
            if (t.test(e)) {
                t.lastIndex = 0;
                let n;
                const s = new Set;
                do
                    if (n = t.exec(e), n) {
                        const e = n[1].split(",");
                        for (const t of e) s.add(t)
                    } while (n)
                    for (const t of s.values()) {
                        const e = this.GetTimelineByName(t);
                        e && (yield e)
                    }
                s.clear()
            } else {
                const t = this.GetTimelineByName(e);
                t && (yield t)
            }
        }* GetTimelinesByTags(e) {
            for (const t of this._timelines) t.HasTags(e) && (yield t)
        }
        AddScheduledTimeline(e) {
            this._scheduledTimelines.includes(e) || this._scheduledTimelines.push(e), this._MaybeEnableRuntimeListeners()
        }
        RemovePlayingTimeline(t) {
            e.arrayFindRemove(this._playingTimelines, t), this._MaybeDisableRuntimeListeners()
        }
        ScheduleTimeline(e) {
            this._playingTimelines.includes(e) ? (e.SetPlaying(!0), e.SetScheduled(!1), e.SetMarkedForRemoval(!1)) : (e.SetPlaying(!1), e.SetScheduled(!0), e.SetMarkedForRemoval(!1), this._scheduledTimelines.includes(e) || this._scheduledTimelines.push(e)), this._MaybeEnableRuntimeListeners()
        }
        DeScheduleTimeline(t) {
            t.SetPlaying(!1), t.SetScheduled(!1), t.ResolvePlayPromise(), e.arrayFindRemove(this._scheduledTimelines, t), this._MaybeDisableRuntimeListeners()
        }
        CompleteTimeline(e) {
            e.SetPlaying(!1), e.SetScheduled(!1), e.SetMarkedForRemoval(!0)
        }
        CompleteTimelineAndResolve(e) {
            this.CompleteTimeline(e), e.ResolvePlayPromise()
        }
        _OnTick() {
            if (this.GetRuntime().IsLoadingState()) return;
            if (!this._hasRuntimeListeners) return;
            if (this._changingLayout) return;
            let e = !1;
            for (this._isTickingTimelines = !0; this._scheduledTimelines.length;) {
                const e = this._scheduledTimelines.pop();
                e.SetInitialState(), this._playingTimelines.push(e)
            }
            const t = this._runtime.GetDt(),
                n = this._runtime.GetTimeScale();
            for (const s of this._playingTimelines) {
                if (s.IsMarkedForRemoval()) continue;
                const o = s.Tick(t, n);
                !e && o && (e = !0)
            }
            this._isTickingTimelines = !1, e && this.GetRuntime().UpdateRender()
        }
        _OnTick2() {
            if (this.GetRuntime().IsLoadingState()) return;
            if (!this._hasRuntimeListeners) return;
            if (this._changingLayout) return;
            let t;
            for (const e of this._playingTimelines) {
                if (!e.IsMarkedForRemoval()) continue;
                t || (t = new Set), this._MaybeExecuteTimelineFinishTriggers(e), t.add(e)
            }
            t && e.arrayRemoveAllInSet(this._playingTimelines, t), this._MaybeDisableRuntimeListeners()
        }
        _MaybeExecuteTimelineFinishTriggers(e) {
            if (e.IsReleased()) return;
            if (!e.HasValidTracks()) return;
            e.IsComplete() && e.InitialStateSet() && e.FinishTriggers()
        }
        _MaybeEnableRuntimeListeners() {
            if (this._hasRuntimeListeners) return;
            this._hasRuntimeListeners = !0
        }
        _MaybeDisableRuntimeListeners() {
            if (this._playingTimelines.length) return;
            if (this._scheduledTimelines.length) return;
            if (this._isTickingTimelines) return;
            this._hasRuntimeListeners = !1
        }
        _OnBeforeChangeLayout() {
            for (this._changingLayout = !0; this._scheduledTimelines.length;) this.DeScheduleTimeline(this._scheduledTimelines.pop());
            const t = new Set;
            for (const e of this._playingTimelines) {
                const n = e._OnBeforeChangeLayout();
                n && t.add(e)
            }
            e.arrayRemoveAllInSet(this._playingTimelines, t), this._MaybeDisableRuntimeListeners();
            for (const e of this._timelines) e.CleanCaches()
        }
        _OnAfterChangeLayout() {
            this._changingLayout = !1
        }
        _OnInstanceDestroy(e) {
            const n = e.GetObjectClass(),
                t = this.GetTimelinesForObjectClass(n);
            if (!t) return;
            if (this._runtime.IsLoadingState()) this._destroyedWhileLoadingState.push(e);
            else
                for (const e of t) {
                    if (e.IsTemplate()) continue;
                    if (e.IsReleased()) {
                        this.Remove(e);
                        continue
                    }
                    e.HasValidTracks() || (this._MaybeExecuteTimelineFinishTriggers(e), this.Remove(e))
                }
        }
        _OnAfterLoad() {
            for (const e of this._destroyedWhileLoadingState) this._OnInstanceDestroy(e);
            e.clearArray(this._destroyedWhileLoadingState)
        }
        _SaveToJson() {
            return {
                timelinesJson: this._SaveTimelinesToJson(),
                scheduledTimelinesJson: this._SaveScheduledTimelinesToJson(),
                playingTimelinesJson: this._SavePlayingTimelinesToJson(),
                hasRuntimeListeners: this._hasRuntimeListeners,
                changingLayout: this._changingLayout,
                isTickingTimelines: this._isTickingTimelines
            }
        }
        _LoadFromJson(e) {
            if (!e) return;
            this._ClearCreatedTemplateTimelinesCount(), this._LoadTimelinesFromJson(e.timelinesJson), this._LoadScheduledTimelinesFromJson(e.scheduledTimelinesJson), this._LoadPlayingTimelinesFromJson(e.playingTimelinesJson), this._hasRuntimeListeners = !e.hasRuntimeListeners, this._changingLayout = !!e.changingLayout, this._isTickingTimelines = !!e.isTickingTimelines, this._SetCreatedTemplateTimelinesCount(), this._MaybeEnableRuntimeListeners(), this._MaybeDisableRuntimeListeners()
        }
        _SaveTimelinesToJson() {
            return this._timelines.map(e => e._SaveToJson())
        }
        _LoadTimelinesFromJson(e) {
            for (const n of e) {
                let t = this.GetTimelineByName(n.name);
                if (t) t._LoadFromJson(n);
                else {
                    const e = this._GetTemplateNameFromJson(n);
                    if (!e) continue;
                    const s = this.GetTimelineByName(e);
                    t = this.CreateFromTemplate(s), t._LoadFromJson(n)
                }
                t.HasTracks() || this.Remove(t)
            }
        }
        _GetTemplateNameFromJson(e) {
            const n = e.name,
                t = n.split(":");
            return !t || t.length !== 2 ? null : t[0]
        }
        _SaveScheduledTimelinesToJson() {
            return this._SaveTimelines(this._scheduledTimelines)
        }
        _LoadScheduledTimelinesFromJson(e) {
            this._LoadTimelines(e, this._scheduledTimelines)
        }
        _SavePlayingTimelinesToJson() {
            return this._SaveTimelines(this._playingTimelines)
        }
        _LoadPlayingTimelinesFromJson(e) {
            this._LoadTimelines(e, this._playingTimelines)
        }
        _IsTimelineInJson(e, t) {
            for (const n of t)
                if (n === e.GetName()) return !0;
            return !1
        }
        _SaveTimelines(e) {
            return e.map(e => e.GetName())
        }
        _LoadTimelines(t, n) {
            const s = new Set;
            for (const e of n) this._IsTimelineInJson(e, t) || s.add(e);
            e.arrayRemoveAllInSet(n, s);
            const o = e => t => t.GetName() === e;
            for (const e of t) {
                const s = this.GetTimelineByName(e);
                if (s) {
                    const t = n.find(o(e));
                    t || n.push(s)
                }
            }
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = 0,
        n = 1;
    e.TimelineState = class Timeline extends e.DefendedBase {
        constructor(n, s, o) {
            super(), this._runtime = o.GetRuntime(), this._timelineManager = o, this._timelineDataItem = s, this._name = n, this._tracks = [];
            for (const t of this._timelineDataItem.GetTrackData().trackDataItems()) this._tracks.push(e.TrackState.Create(this, t));
            this._playPromise = null, this._playResolve = null, this._playheadTime = e.New(e.KahanSum), this._playheadTime.Set(0), this._playbackRate = 1, this._pingPongState = t, this._currentRepeatCount = 1, this._isPlaying = !1, this._isScheduled = !1, this._initialStateSet = !1, this._complete = !0, this._released = !1, this._markedForRemoval = !1, this._completedTick = -1, this._implicitPause = !1, this._isTemplate = !1, this._finishedTriggers = !1, this._firstTick = !1, this._lastDelta = NaN, this._tags = [""], this._stringTags = "", this._tagsChanged = !1
        }
        static CreateInitial(t, n) {
            const s = n.GetTimelineDataManager(),
                o = s.GetNameId(),
                a = s.Get(t[o]),
                i = e.New(e.TimelineState, t[o], a, n);
            return i.SetIsTemplate(!0), i
        }
        static CreateFromTemplate(t, n, s) {
            return e.New(e.TimelineState, t, n, s)
        }
        static get WORLD_INSTANCE_BOX_CHANGE() {
            return 1
        }
        static get LAYOUT_RENDER_CHANGE() {
            return e.nextHighestPowerOfTwo(1)
        }
        Release() {
            if (this.IsReleased()) return;
            this._timelineManager.DeScheduleTimeline(this), this._timelineManager.CompleteTimelineAndResolve(this);
            for (const e of this._tracks) e.Release();
            e.clearArray(this._tracks), this._tracks = null, this._playheadTime.Release(), this._playheadTime = null, this._runtime = null, this._timelineManager = null, this._timelineDataItem = null, this._released = !0, this._playPromise = null, this._playResolve = null
        }
        GetTimelineManager() {
            return this._timelineManager
        }
        GetRuntime() {
            return this._runtime
        }
        GetTracks() {
            return this._tracks
        }
        GetSimilarPropertyTracks(e, t, n) {
            const s = [];
            for (const i of this._tracks) {
                if (e !== i.GetInstance()) continue;
                const o = i.GetPropertyTrack(n);
                if (!o) continue;
                if (t.constructor !== o.GetSourceAdapter().constructor) continue;
                s.push(o)
            }
            return s
        }
        HasTracks() {
            return !!this._tracks.length
        }
        GetTrackById(t) {
            for (const n of this._tracks)
                if (e.equalsNoCase(n.GetId(), t)) return n;
            return null
        }
        SetName(e) {
            this._name = e
        }
        GetName() {
            return this._name
        }
        GetTimelineDataItem() {
            return this._timelineDataItem
        }
        GetTemplateName() {
            return this._timelineDataItem.GetName()
        }
        GetTotalTime() {
            return this._timelineDataItem.GetTotalTime()
        }
        SetTotalTime(e) {
            this._timelineDataItem.SetTotalTime(e)
        }
        GetStep() {
            return this._timelineDataItem.GetStep()
        }
        SetStep(e) {
            this._timelineDataItem.SetStep(e)
        }
        GetInterpolationMode() {
            return this._timelineDataItem.GetInterpolationMode()
        }
        SetInterpolationMode(e) {
            this._timelineDataItem.SetInterpolationMode(e)
        }
        GetResultMode() {
            return this._timelineDataItem.GetResultMode()
        }
        SetResultMode(e) {
            this._timelineDataItem.GetResultMode(e)
        }
        SetEase(e) {
            for (const t of this.GetTracks()) t.SetEase(e)
        }
        GetLoop() {
            return this._timelineDataItem.GetLoop()
        }
        SetLoop(e) {
            return this._timelineDataItem.SetLoop(e)
        }
        GetPingPong() {
            return this._timelineDataItem.GetPingPong()
        }
        SetPingPong(e) {
            return this._timelineDataItem.SetPingPong(e)
        }
        GetRepeatCount() {
            return this._timelineDataItem.GetRepeatCount()
        }
        SetPlaybackRate(e) {
            return this._playbackRate = e
        }
        GetPlaybackRate() {
            return this._playbackRate
        }
        IsForwardPlayBack() {
            return !this.IsPlaying() || this._playbackRate > 0
        }
        GetPlayPromise() {
            return this._playPromise ? this._playPromise : (this._playPromise = new Promise(e => {
                this._playResolve = e
            }), this._playPromise)
        }
        ResolvePlayPromise() {
            if (!this._playPromise) return;
            this._playResolve(), this._playPromise = null, this._playResolve = null
        }
        SetTags(t) {
            this._tags = e.TimelineState._GetTagArray(t), this._tagsChanged = !0
        }
        GetTags() {
            return this._tags
        }
        GetStringTags() {
            return this._tagsChanged && (this._stringTags = this._tags.join(" ")), this._tagsChanged = !1, this._stringTags
        }
        HasTags(t) {
            if (!this._tags) return !1;
            if (!this._tags.length) return !1;
            const n = e.TimelineState._GetTagArray(t);
            return !!n && !!n.length && n.every(e.TimelineState._HasTag, this)
        }
        OnStarted() {
            e.Plugins.Timeline.Cnds.SetTriggerTimeline(this), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineStarted), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineStartedByName), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineStartedByTags), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnAnyTimelineStarted), e.Plugins.Timeline.Cnds.SetTriggerTimeline(null)
        }
        OnCompleted() {
            this._completedTick = this._runtime.GetTickCount()
        }
        FinishTriggers() {
            if (this._finishedTriggers) return;
            this._finishedTriggers = !0, e.Plugins.Timeline.Cnds.SetTriggerTimeline(this), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineFinished), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineFinishedByName), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineFinishedByTags), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnAnyTimelineFinished), e.Plugins.Timeline.Cnds.SetTriggerTimeline(null)
        }
        SetPlaying(e) {
            this._isPlaying = e
        }
        IsCompletedTick() {
            return this._completedTick === this._runtime.GetTickCount()
        }
        IsPlaying(e = !1) {
            return !!this.IsCompletedTick() || !!(this.IsScheduled() && !e) || this._isPlaying
        }
        _IsPlaying() {
            return this.IsPlaying(!0)
        }
        IsPaused() {
            return this._IsPaused()
        }
        _IsPaused() {
            return !this.IsReleased() && !this.IsScheduled() && !this._IsPlaying() && !this.IsComplete()
        }
        SetScheduled(e) {
            this._isScheduled = e
        }
        IsScheduled() {
            return this._isScheduled
        }
        SetComplete(e) {
            this._complete = e;
            const t = this.GetTime();
            (t <= 0 || t >= this.GetTotalTime()) && (this._complete = !0)
        }
        IsComplete() {
            return this._complete
        }
        IsReleased() {
            return this._released
        }
        SetMarkedForRemoval(e) {
            this._markedForRemoval = e
        }
        IsMarkedForRemoval() {
            return this._markedForRemoval
        }
        SetImplicitPause(e) {
            this._implicitPause = e
        }
        IsImplicitPause() {
            return this._implicitPause
        }
        SetIsTemplate(e) {
            this._isTemplate = !!e
        }
        IsTemplate() {
            return this._isTemplate
        }
        InitialStateSet() {
            return this._initialStateSet
        }
        GetTime() {
            return this._playheadTime.Get()
        }
        SetTime(e) {
            const t = this.GetTime();
            this._SetTime(e), this.SetComplete(!1), this.IsComplete() || this.SetImplicitPause(!0), !this._IsPlaying() && !this.IsScheduled() && this._initialStateSet || (!this._IsPlaying() && !this.IsScheduled() && !this._initialStateSet ? this.SetInitialStateFromSetTime() : this._IsPlaying() ? this.Stop() : this.IsScheduled() && (this._timelineManager.DeScheduleTimeline(this), this.SetInitialStateFromSetTime()));
            const n = this._Interpolate(e, !1, !0, !0, t);
            n && this.GetRuntime().UpdateRender(), this._OnSetTime()
        }
        _SetTime(e) {
            e < 0 ? this._playheadTime.Set(0) : e >= this.GetTotalTime() ? this._playheadTime.Set(this.GetTotalTime()) : this._playheadTime.Set(e)
        }
        _OnSetTime() {
            if (!e.Plugins.Timeline || this.constructor !== e.TimelineState) return;
            e.Plugins.Timeline.Cnds.SetTriggerTimeline(this), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimeSet), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimeSetByName), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimeSetByTags), e.Plugins.Timeline.Cnds.SetTriggerTimeline(null)
        }
        _CanResume() {
            if (this.GetLoop()) return !0;
            if (this.GetPingPong() && this._pingPongState === n) {
                if (this.IsForwardPlayBack()) {
                    if (this.GetTime() >= this.GetTotalTime()) return !1
                } else if (this.GetTime() <= 0) return !1
            } else if (!this.GetLoop() && !this.GetPingPong())
                if (this.IsForwardPlayBack()) {
                    if (this.GetTime() >= this.GetTotalTime()) return !1
                } else if (this.GetTime() <= 0) return !1;
            return !0
        }
        Resume() {
            if (this.IsReleased()) return;
            this._CanResume() && this.Play(!0)
        }
        Play(e = !1) {
            return !this.IsReleased() && !this.IsScheduled() && (this._IsPlaying() && this.IsCompletedTick() ? this._SchedulePlayingTimeline() : !this._IsPlaying() && !(!this.IsComplete() && !e && !this.IsImplicitPause()) && this._ScheduleStoppedTimeline())
        }
        _SchedulePlayingTimeline() {
            return this.SetImplicitPause(!1), this._timelineManager.RemovePlayingTimeline(this), this._timelineManager.ScheduleTimeline(this), this.GetPlayPromise(), !0
        }
        _ScheduleStoppedTimeline() {
            return this.SetImplicitPause(!1), this._timelineManager.ScheduleTimeline(this), this.GetPlayPromise(), !0
        }
        Stop(e = !1) {
            if (this.IsReleased()) return;
            this.SetComplete(e), this._timelineManager.CompleteTimeline(this), this.IsComplete() && this.ResolvePlayPromise()
        }
        Reset(e = !0, t = !1) {
            if (this.IsReleased()) return;
            if (!this._IsPlaying() && this.IsScheduled()) return this._timelineManager.DeScheduleTimeline(this);
            if (this.IsComplete()) return;
            this.Stop(!0), this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime());
            let n;
            const s = this.GetTime();
            t ? n = this._InterpolateBeforeChangeLayout(s) : n = this._Interpolate(s, !1, !1, !0), e && this._OnSetTime(), n && e && this.GetRuntime().UpdateRender()
        }
        ResetBeforeChangeLayout() {
            this.Reset(!1, !0)
        }
        _InterpolateBeforeChangeLayout(e) {
            this._Interpolate(e, !1, !1, !0, NaN, !1, !0)
        }
        _OnBeforeChangeLayout() {
            return !!this.IsReleased() || !this.HasValidGlobalTracks() && (this._timelineManager.CompleteTimeline(this), this.ResetBeforeChangeLayout(), !0)
        }
        SetInitialStateFromSetTime() {
            this.SetInitialState(!0)
        }
        SetInitialState(e) {
            if (this.IsMarkedForRemoval()) return;
            if (e) {
                this._initialStateSet = !0, this._firstTick = !0;
                for (const e of this._tracks) e.SetInitialState()
            } else if (this.SetPlaying(!0), this.SetScheduled(!1), this.OnStarted(), this.IsComplete()) {
                this._completedTick = -1, this._pingPongState = t, this._currentRepeatCount = 1, this._complete = !1, this._finishedTriggers = !1, this._initialStateSet = !0, this._firstTick = !0, this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime());
                for (const e of this._tracks) e.SetInitialState()
            } else {
                this._firstTick = !0;
                for (const e of this._tracks) e.SetResumeState()
            }
        }
        Tick(e, t) {
            if (e === 0 && this._lastDelta === 0) return;
            this._lastDelta = e;
            const s = this.GetTime(),
                o = e * t * this._playbackRate;
            this._SetTime(s + o);
            let n;
            if (!this.GetLoop() && !this.GetPingPong() ? n = this._SimpleCompleteCheck() : this.GetLoop() && !this.GetPingPong() ? n = this._LoopCompleteCheck() : !this.GetLoop() && this.GetPingPong() ? n = this._PingPongCompleteCheck() : this.GetLoop() && this.GetPingPong() && (n = this._LoopPingPongCompleteCheck()), n) {
                for (const e of this._tracks) e.SetEndState();
                return this.Stop(!0), this.OnCompleted(), !0
            }
            return this._Interpolate(this.GetTime(), !0, !1, !1, s, !0)
        }
        _Interpolate(e, t = !1, n = !1, s = !1, o = NaN, i = !1, a = !1) {
            let r = !1;
            for (const e of this._tracks) e.BeforeInterpolate();
            for (const i of this._tracks) {
                let c = e;
                if (typeof o == "number") {
                    const e = this.GetTime(),
                        t = e - i.GetStartOffset(),
                        n = o - i.GetStartOffset();
                    t < 0 && n > 0 && (c = i.GetStartOffset(), this._SetTime(c))
                }
                const l = i.Interpolate(c, t, n, s, this._firstTick, a);
                !r && l && (r = !0)
            }
            for (const e of this._tracks) e.AfterInterpolate();
            return this._firstTick && i && (this._firstTick = !1), r
        }
        _SimpleCompleteCheck() {
            if (this.IsForwardPlayBack()) {
                if (this.GetTime() >= this.GetTotalTime())
                    if (this._currentRepeatCount < this.GetRepeatCount()) this._currentRepeatCount++, this._SetTime(0);
                    else return this._SetTime(this.GetTotalTime()), !0
            } else if (this.GetTime() <= 0)
                if (this._currentRepeatCount < this.GetRepeatCount()) this._currentRepeatCount++, this._SetTime(this.GetTotalTime());
                else return this._SetTime(0), !0;
            return !1
        }
        _LoopCompleteCheck() {
            return this.IsForwardPlayBack() ? this.GetTime() >= this.GetTotalTime() && this._SetTime(0) : this.GetTime() <= 0 && this._SetTime(this.GetTotalTime()), !1
        }
        _PingPongCompleteCheck() {
            if (this.IsForwardPlayBack()) {
                if (this.GetTime() >= this.GetTotalTime())
                    if (this._SetTime(this.GetTotalTime()), this.SetPlaybackRate(this.GetPlaybackRate() * -1), this._pingPongState === n)
                        if (this._currentRepeatCount < this.GetRepeatCount()) this._currentRepeatCount++, this._pingPongState = t;
                        else return !0;
                else this._pingPongState === t && (this._pingPongState = n)
            } else if (this.GetTime() <= 0)
                if (this._SetTime(0), this.SetPlaybackRate(this.GetPlaybackRate() * -1), this._pingPongState === n)
                    if (this._currentRepeatCount < this.GetRepeatCount()) this._currentRepeatCount++, this._pingPongState = t;
                    else return !0;
            else this._pingPongState === t && (this._pingPongState = n);
            return !1
        }
        _LoopPingPongCompleteCheck() {
            return this.IsForwardPlayBack() ? this.GetTime() >= this.GetTotalTime() && (this._SetTime(this.GetTotalTime()), this.SetPlaybackRate(this.GetPlaybackRate() * -1)) : this.GetTime() <= 0 && (this._SetTime(0), this.SetPlaybackRate(this.GetPlaybackRate() * -1)), !1
        }
        AddTrack() {
            const n = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem(),
                t = e.TrackState.Create(this, n);
            return this._tracks.push(t), t
        }
        CleanCaches() {
            for (const e of this._tracks) e.CleanCaches()
        }
        ClearTrackInstances() {
            for (const e of this._tracks) e.ClearInstance()
        }
        SetTrackInstance(e, t) {
            if (!t) return;
            for (const n of this._tracks) {
                if (e) {
                    if (n.GetId() !== e) continue;
                    n.SetInstance(t), this._timelineManager.SetTimelineObjectClassToMap(t.GetObjectClass(), this);
                    break
                }
                if (n.HasInstance()) continue;
                n.SetInstance(t), this._timelineManager.SetTimelineObjectClassToMap(t.GetObjectClass(), this);
                break
            }
        }
        HasTrackInstance(e, t) {
            for (const n of this._tracks)
                if (t) {
                    if (t === n.GetId() && e === n.GetInstance()) return !0
                } else if (e === n.GetInstance()) return !0;
            return !1
        }
        HasValidTracks() {
            return this._tracks.some(e => e.CanInstanceBeValid())
        }
        HasValidGlobalTracks() {
            return this._tracks.some(e => {
                if (!e.CanInstanceBeValid()) return !1;
                const t = e.GetObjectClass();
                return !!t && t.IsGlobal()
            })
        }
        GetPropertyTrack(e) {
            for (const t of this.GetTracks())
                for (const n of t.GetPropertyTracks())
                    if (n.GetPropertyName() === e) return n
        }
        GetKeyframeWithTags(e) {
            let t = e ? e.split(" ") : [];
            const n = new Set(t.map(e => e.toLowerCase().trim()));
            t = [...n.values()];
            for (const e of this.GetTracks())
                for (const n of e.GetKeyframeDataItems()) {
                    const s = t.every(e => n.HasTag(e));
                    if (s) return n
                }
        }
        GetObjectClasses() {
            const e = [];
            for (const t of this.GetTracks()) e.push(t.GetObjectClass());
            return e.filter(e => e)
        }
        _SaveToJson() {
            return {
                tracksJson: this._SaveTracksToJson(),
                name: this._name,
                playheadTime: this.GetTime(),
                playbackRate: this._playbackRate,
                pingPongState: this._pingPongState,
                currentRepeatCount: this._currentRepeatCount,
                isPlaying: this._isPlaying,
                isScheduled: this._isScheduled,
                initialStateSet: this._initialStateSet,
                finishedTriggers: this._finishedTriggers,
                complete: this._complete,
                released: this._released,
                markedForRemoval: this._markedForRemoval,
                completedTick: this._completedTick,
                implicitPause: this._implicitPause,
                isTemplate: this._isTemplate,
                tags: this._tags.join(" "),
                stringTags: this._stringTags,
                tagsChanged: this._tagsChanged,
                firstTick: this._firstTick
            }
        }
        _LoadFromJson(e) {
            if (!e) return;
            this._LoadTracksFromJson(e.tracksJson), this._name = e.name, this._playheadTime.Set(e.playheadTime), this._playbackRate = e.playbackRate, this._pingPongState = e.pingPongState, this._currentRepeatCount = e.currentRepeatCount, this._isPlaying = !!e.isPlaying, this._isScheduled = !!e.isScheduled, this._initialStateSet = !!e.initialStateSet, this._finishedTriggers = !!e.hasOwnProperty("finishedTriggers") && !!e.finishedTriggers, this._complete = !!e.complete, this._released = !!e.released, this._markedForRemoval = !!e.markedForRemoval, this._completedTick = e.completedTick, this._implicitPause = !!e.implicitPause, this._isTemplate = !!e.isTemplate, this._tags = e.tags.split(" "), this._stringTags = e.stringTags, this._tagsChanged = !!e.tagsChanged, this._firstTick = !!e.firstTick
        }
        _SaveTracksToJson() {
            return this._tracks.map(e => e._SaveToJson())
        }
        _LoadTracksFromJson(e) {
            e.forEach((e, t) => {
                const n = this._tracks[t];
                n._LoadFromJson(e)
            }), this._tracks.filter(e => e.CanInstanceBeValid())
        }
        static _HasTag(e) {
            const t = this.GetTags();
            return e === "" ? t.length === 1 && t[0] === "" : t.includes(e)
        }
        static _GetTagArray(t) {
            if (e.IsArray(t)) return t.slice(0);
            if (e.IsString(t)) return t.split(" ")
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.TrackState = class Track extends e.DefendedBase {
        constructor(t, n) {
            super(), this._timeline = t, this._trackDataItem = n, this._trackData = n.GetTrackData(), this._instanceUid = NaN, this._objectClassIndex = NaN, this._instance = null, this._worldInfo = null, this._isNested = n.GetStartOffset() > 0, this._initialStateOfNestedSet = !1, this._endStateOfNestedSet = !1, this._lastKeyframeDataItem = null, this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray(), this._propertyTracks = [];
            for (const t of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems()) this._propertyTracks.push(e.PropertyTrackState.Create(this, t))
        }
        static Create(t, n) {
            return e.New(e.TrackState, t, n)
        }
        Release() {
            this._keyframeDataItems = null;
            for (const e of this._propertyTracks) e.Release();
            e.clearArray(this._propertyTracks), this._propertyTracks = null, this._timeline = null, this._instance = null, this._worldInfo = null, this._trackDataItem = null, this._lastKeyframeDataItem = null
        }
        CleanCaches() {
            for (const e of this._propertyTracks) e.CleanCaches();
            this._instance = null, this._worldInfo = null
        }
        GetTimeline() {
            return this._timeline
        }
        GetRuntime() {
            return this._timeline.GetRuntime()
        }
        GetKeyframeDataItems() {
            return this._keyframeDataItems ? this._keyframeDataItems : (this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray(), this._keyframeDataItems)
        }
        GetPropertyTracks() {
            return this._propertyTracks
        }
        GetPropertyTrack(e) {
            for (const t of this._propertyTracks)
                if (t.GetPropertyName() === e) return t
        }
        MaybeGetInstance() {
            this._instance || this.GetInstance()
        }
        IsInstanceValid() {
            return !!this._instance && !this._instance.IsDestroyed()
        }
        CanInstanceBeValid() {
            const t = this.GetInstanceUID(),
                e = this.GetRuntime().GetInstanceByUID(t);
            return !!e && !e.IsDestroyed()
        }
        GetObjectClass() {
            const e = this.GetObjectClassIndex();
            if (e === -1) return;
            return this.GetRuntime().GetObjectClassByIndex(e)
        }
        ClearInstance() {
            this._instance = null, this._instanceUid = -1, this._worldInfo = null, this._objectClassIndex = -1
        }
        HasInstance() {
            return !!this._instance
        }
        GetInstance() {
            if (this._instance && this.IsInstanceValid()) return this._instance;
            const e = this.GetInstanceUID();
            return this._instance = this.GetRuntime().GetInstanceByUID(e), this._instance
        }
        SetInstance(e) {
            if (this._instance === e) return;
            this.CleanCaches(), this._instance = e, this._objectClassIndex = e.GetObjectClass().GetIndex(), this._instanceUid = e.GetUID(), this._worldInfo = e.GetWorldInfo();
            for (const t of this.propertyTrackItems()) {
                const s = t.propertyTrack,
                    n = t.sourceAdapter,
                    o = s.GetSourceAdapterId();
                switch (o) {
                    case "instance-variable": {
                        const r = n.GetEditorIndex(),
                            s = e.GetObjectClass(),
                            o = s.GetInstanceVariableIndexByName(t.name),
                            i = s.GetInstanceVariableName(o),
                            a = s.GetInstanceVariableType(o);
                        i === t.name && a === t.type && n.UpdateInstanceVariableIndex(o);
                        break
                    }
                    case "behavior": {
                        const s = t.behaviorType,
                            a = this.GetObjectClass(),
                            o = e.GetObjectClass(),
                            i = n.GetBehaviorType(o);
                        if (s && i) {
                            const e = s.GetName(),
                                t = a.GetBehaviorIndexByName(e),
                                r = o.GetBehaviorIndexByName(e),
                                c = n.GetEditorIndex();
                            n.UpdateBehaviorTypeSid(i.GetSID())
                        }
                        break
                    }
                }
            }
        }* propertyTrackItems() {
            for (const n of this._propertyTracks) {
                const s = n.GetSourceAdapter(),
                    t = this.GetObjectClass(),
                    e = {
                        propertyTrack: n,
                        sourceAdapter: s
                    };
                switch (n.GetSourceAdapterId()) {
                    case "world-instance": {
                        e.property = n.GetPropertyName();
                        break
                    }
                    case "instance-variable": {
                        const n = s.GetEditorIndex();
                        e.name = t.GetInstanceVariableName(n), e.type = t.GetInstanceVariableType(n);
                        break
                    }
                    case "effect": {
                        const n = t.GetEffectList(),
                            o = s.GetEffectType(n);
                        e.effectType = o;
                        break
                    }
                    case "behavior": {
                        const n = s.GetBehaviorType(t);
                        e.behaviorType = n;
                        break
                    }
                    case "plugin": {
                        e.plugin = t.GetPlugin();
                        break
                    }
                }
                yield e
            }
        }
        GetWorldInfo() {
            if (this._worldInfo && this.IsInstanceValid()) return this._worldInfo;
            const e = this.GetInstance();
            return e && (this._worldInfo = e.GetWorldInfo()), this._worldInfo
        }
        GetTrackDataItem() {
            return this._trackDataItem
        }
        GetInstanceUID() {
            return this._instanceUid ? this._instanceUid : this._trackDataItem.GetInstanceUID()
        }
        SetInstanceUID(e) {
            this._trackDataItem.SetInstanceUID(e)
        }
        GetInterpolationMode() {
            return this._trackDataItem.GetInterpolationMode()
        }
        SetInterpolationMode(e) {
            this._trackDataItem.SetInterpolationMode(e)
        }
        GetResultMode() {
            return this._trackDataItem.GetResultMode()
        }
        GetId() {
            return this._trackDataItem.GetId()
        }
        GetStartOffset() {
            return this._trackDataItem.GetStartOffset()
        }
        GetLocalTotalTime() {
            return this._trackDataItem.GetLocalTotalTime()
        }
        SetResultMode(e) {
            this._trackDataItem.SetResultMode(e)
        }
        SetEase(e) {
            for (const t of this.GetKeyframeDataItems()) t.SetEase(e);
            for (const t of this.GetPropertyTracks()) t.SetEase(e)
        }
        GetEnable() {
            return this._trackDataItem.GetEnable()
        }
        SetEnable(e) {
            this._trackDataItem.SetEnable(e)
        }
        GetObjectClassIndex() {
            return isNaN(this._objectClassIndex) ? this._trackDataItem.GetObjectClassIndex() : this._objectClassIndex
        }
        SetObjectClassIndex(e) {
            this._trackDataItem.SetObjectClassIndex(e)
        }
        SetOriginalWidth(e) {
            this._trackDataItem.SetOriginalWidth(e)
        }
        GetOriginalWidth() {
            return this._trackDataItem.GetOriginalWidth()
        }
        SetOriginalHeight(e) {
            this._trackDataItem.SetOriginalHeight(e)
        }
        GetOriginalHeight() {
            return this._trackDataItem.GetOriginalHeight()
        }
        SetInitialState() {
            if (this.MaybeGetInstance(), !this.IsInstanceValid()) return;
            for (const e of this._propertyTracks) e.SetInitialState();
            const t = this.GetTimeline(),
                n = t.IsForwardPlayBack(),
                e = n ? 0 : this.GetLocalTotalTime();
            this._lastKeyframeDataItem = this.GetLastKeyFrameBeforeTime(e), this._initialStateOfNestedSet = !1, this._endStateOfNestedSet = !1, this.Interpolate(e)
        }
        SetResumeState() {
            if (this.MaybeGetInstance(), !this.IsInstanceValid()) return;
            const t = this._timeline.IsForwardPlayBack(),
                e = this._timeline.GetTime() - this.GetStartOffset();
            this._lastKeyframeDataItem = this.GetLastKeyFrameBeforeTime(e);
            for (const e of this._propertyTracks) e.SetResumeState()
        }
        SetEndState() {
            if (this.GetTimeline().IsComplete()) return;
            if (this.MaybeGetInstance(), !this.IsInstanceValid()) return;
            if (!this._isNested) {
                const e = this._timeline.GetTime(),
                    t = this.GetStartOffset() + this.GetLocalTotalTime();
                e >= t ? this.Interpolate(this.GetLocalTotalTime(), !0, !1, !0) : e <= 0 && this.Interpolate(0, !0, !1, !0)
            }
        }
        BeforeInterpolate() {
            for (const e of this._propertyTracks) e.BeforeInterpolate()
        }
        Interpolate(t, n = !1, s = !1, o = !1, i = !1, a = !1) {
            if (this.MaybeGetInstance(), !this.IsInstanceValid()) return !1;
            if (a && this.GetObjectClass().IsGlobal()) return !1;
            if (t = t - this.GetStartOffset(), t < 0) return !1;
            this.MaybeSetInitialStateOfNestedTrack(t, n), this.MaybeTriggerKeyframeReachedConditions(t, n, i);
            let r = !1,
                c = !1;
            for (const i of this._propertyTracks) {
                const n = i.Interpolate(t, s, !1, o);
                !r && (n & e.TimelineState.WORLD_INSTANCE_BOX_CHANGE) !== 0 && (r = !0), !c && (n & e.TimelineState.LAYOUT_RENDER_CHANGE) !== 0 && (c = !0)
            }
            if (this.MaybeSetEndStateOfNestedTrack(t, n), r) {
                const e = this.GetWorldInfo();
                e && e.SetBboxChanged()
            }
            return c
        }
        AfterInterpolate() {
            for (const e of this._propertyTracks) e.AfterInterpolate()
        }
        MaybeSetInitialStateOfNestedTrack(e, t) {
            if (!t) return;
            if (!this._isNested) return;
            if (this._initialStateOfNestedSet) return;
            const n = this.GetTimeline();
            if (n.IsForwardPlayBack()) {
                if (e < 0) return;
                for (const e of this._propertyTracks) e.Interpolate(0, !1, !1, !0)
            } else {
                if (e > this.GetLocalTotalTime()) return;
                for (const e of this._propertyTracks) e.Interpolate(this.GetLocalTotalTime(), !1, !1, !0)
            }
            for (const e of this._propertyTracks) e.SetInitialState();
            this._initialStateOfNestedSet = !0
        }
        MaybeSetEndStateOfNestedTrack(e, t) {
            if (!t) return;
            if (!this._isNested) return;
            if (this._endStateOfNestedSet) return;
            const n = this.GetTimeline();
            if (n.IsForwardPlayBack()) {
                if (e >= this.GetLocalTotalTime()) {
                    for (const e of this._propertyTracks) e.Interpolate(this.GetLocalTotalTime(), !1, !1, !0);
                    this._endStateOfNestedSet = !0
                }
            } else if (e <= 0) {
                for (const e of this._propertyTracks) e.Interpolate(0, !1, !1, !0);
                this._endStateOfNestedSet = !0
            }
        }
        MaybeTriggerKeyframeReachedConditions(e, t, n) {
            if (n) return;
            if (!t) return;
            let s = this.GetLastKeyFrameBeforeTime(e);
            return s !== this._lastKeyframeDataItem && this.OnKeyframeReached(s), this._lastKeyframeDataItem = s, s
        }
        GetLastKeyFrameBeforeTime(e) {
            const n = this.GetTimeline();
            let t = this._trackData.GetKeyFrameDataItemAtTime(e, this._trackDataItem);
            return t ? t : n.IsForwardPlayBack() ? this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(e, this._trackDataItem) : this._trackData.GetFirstKeyFrameDataItemHigherOrEqualThan(e, this._trackDataItem)
        }
        OnKeyframeReached(t) {
            if (!e.Plugins.Timeline || this.GetTimeline().constructor !== e.TimelineState) return;
            const n = this.GetTimeline();
            e.Plugins.Timeline.Cnds.SetTriggerTimeline(n), e.Plugins.Timeline.Cnds.SetTriggerKeyframe(t);
            const s = n.GetTimelineManager();
            s.Trigger(e.Plugins.Timeline.Cnds.OnAnyKeyframeReached), s.Trigger(e.Plugins.Timeline.Cnds.OnKeyframeReached), e.Plugins.Timeline.Cnds.SetTriggerTimeline(null), e.Plugins.Timeline.Cnds.SetTriggerKeyframe(null)
        }
        AddKeyframe() {
            const e = this._trackDataItem.GetKeyframeData(),
                t = e.AddEmptyKeyframeDataItem();
            return t
        }
        AddPropertyTrack() {
            const n = this._trackDataItem.GetPropertyTrackData(),
                s = n.AddEmptyPropertyTrackDataItem(),
                t = e.PropertyTrackState.Create(this, s);
            return this._propertyTracks.push(t), t
        }
        DeleteKeyframes(e) {
            const t = this._trackDataItem.GetKeyframeData();
            t.DeleteKeyframeDataItems(e)
        }
        DeletePropertyKeyframes(e) {
            for (const t of this._propertyTracks) t.DeletePropertyKeyframes(e)
        }
        SaveState() {
            for (const e of this._propertyTracks) e.SaveState()
        }
        CompareInitialStateWithCurrent() {
            if (this.MaybeGetInstance(), !this.IsInstanceValid()) return;
            for (const e of this._propertyTracks) e.CompareInitialStateWithCurrent()
        }
        CompareSaveStateWithCurrent() {
            if (this.MaybeGetInstance(), !this.IsInstanceValid()) return;
            let e = !1;
            for (const t of this._propertyTracks) {
                const n = t.CompareSaveStateWithCurrent();
                !e && n && (e = !0)
            }
            if (e) {
                const e = this.AddKeyframe();
                e.SetTime(this.GetTimeline().GetTime()), e.SetEase("noease"), e.SetEnable(!0), e.SetTags("")
            }
        }
        _SaveToJson() {
            const e = this.GetInstance(),
                t = e ? e.GetUID() : this.GetInstanceUID();
            return {
                propertyTracksJson: this._SavePropertyTracksToJson(),
                lastKeyframeDataItemJson: this._SaveLastKeyframeDataItemToJson(),
                initialStateOfNestedSet: this._initialStateOfNestedSet,
                endStateOfNestedSet: this._endStateOfNestedSet,
                instanceUid: t
            }
        }
        _LoadFromJson(e) {
            if (!e) return;
            this._LoadPropertyTracksFromJson(e.propertyTracksJson), this._LoadLastKeyframeDataItemFromJson(e.lastKeyframeDataItemJson), this._LoadInstanceFromJson(e.instanceUid), this._initialStateOfNestedSet = !1, e.hasOwnProperty.initialStateOfNestedSet && (this._initialStateOfNestedSet = e.initialStateOfNestedSet), this._endStateOfNestedSet = !1, e.hasOwnProperty.endStateOfNestedSet && (this._endStateOfNestedSet = e.endStateOfNestedSet)
        }
        _SaveLastKeyframeDataItemToJson() {
            const e = this._trackDataItem.GetKeyframeData();
            return e.GetKeyframeDataItemIndex(this._lastKeyframeDataItem)
        }
        _SavePropertyTracksToJson() {
            return this._propertyTracks.map(e => e._SaveToJson())
        }
        _LoadPropertyTracksFromJson(e) {
            e.forEach((e, t) => {
                const n = this._propertyTracks[t];
                n._LoadFromJson(e)
            })
        }
        _LoadInstanceFromJson(t) {
            if (!e.IsFiniteNumber(t)) return;
            const n = this.GetRuntime().GetInstanceByUID(t);
            if (!n) return;
            const s = this.GetTimeline();
            s.ClearTrackInstances(), s.SetTrackInstance(this._trackDataItem.GetId(), n)
        }
        _LoadLastKeyframeDataItemFromJson(e) {
            const t = this._trackDataItem.GetKeyframeData();
            this._lastKeyframeDataItem = t.GetKeyframeDataItemFromIndex(e)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.PropertyTrackState = class PropertyTrack extends e.DefendedBase {
        constructor(e, t) {
            super(), this._track = e, this._propertyTrackDataItem = t, this._propertyTrackData = t.GetPropertyTrackData(), this._sourceAdapter = this.GetSourceAdapter(), this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()
        }
        static Create(t, n) {
            return e.New(e.PropertyTrackState, t, n)
        }
        Release() {
            this._track = null, this._sourceAdapter && (this._sourceAdapter.Release(), this._sourceAdapter = null), this._propertyKeyframeDataItems = null, this._propertyTrackDataItem = null, this._propertyTrackData = null
        }
        GetTrack() {
            return this._track
        }
        GetPropertyTrackDataItem() {
            return this._propertyTrackDataItem
        }
        GetPropertyTrackData() {
            return this._propertyTrackData
        }
        GetTimeline() {
            return this._track.GetTimeline()
        }
        GetRuntime() {
            return this._track.GetRuntime()
        }
        GetInstance() {
            return this._track.GetInstance()
        }
        GetSourceAdapter() {
            if (this._sourceAdapter) return this._sourceAdapter;
            const n = this._propertyTrackDataItem.GetSourceAdapterId();
            let t;
            switch (n) {
                case "behavior":
                    t = new e.PropertyTrackState.BehaviorSourceAdapter(this);
                    break;
                case "effect":
                    t = new e.PropertyTrackState.EffectSourceAdapter(this);
                    break;
                case "instance-variable":
                    t = new e.PropertyTrackState.InstanceVariableSourceAdapter(this);
                    break;
                case "plugin":
                    t = new e.PropertyTrackState.PluginSourceAdapter(this);
                    break;
                case "world-instance":
                    t = new e.PropertyTrackState.WorldInstanceSourceAdapter(this);
                    break;
                case "value":
                    t = new e.PropertyTrackState.ValueSourceAdapter(this);
                    break
            }
            return this._sourceAdapter = t, this._sourceAdapter
        }
        GetSourceAdapterId() {
            return this._propertyTrackDataItem.GetSourceAdapterId()
        }
        SetSourceAdapterId(e) {
            this._propertyTrackDataItem.SetSourceAdapterId(e)
        }
        GetSourceAdapterArgs() {
            return this._propertyTrackDataItem.GetSourceAdapterArguments()
        }
        SetSourceAdapterArgs(e) {
            this._propertyTrackDataItem.SetSourceAdapterArguments(e)
        }
        GetSourceAdapterValue() {
            return this.GetSourceAdapter().GetValue()
        }
        GetPropertyName() {
            return this._propertyTrackDataItem.GetProperty()
        }
        SetPropertyName(e) {
            this._propertyTrackDataItem.SetProperty(e)
        }
        GetPropertyType() {
            return this._propertyTrackDataItem.GetType()
        }
        SetPropertyType(e) {
            this._propertyTrackDataItem.SetType(e)
        }
        GetPropertyKeyframeType() {
            return this.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem).GetType()
        }
        GetMin() {
            return this._propertyTrackDataItem.GetMin()
        }
        SetMin(e) {
            this._propertyTrackDataItem.SetMin(e)
        }
        GetMax() {
            return this._propertyTrackDataItem.GetMax()
        }
        SetMax(e) {
            this._propertyTrackDataItem.SetMax(e)
        }
        GetEnable() {
            return this._propertyTrackDataItem.GetEnable()
        }
        SetEnable(e) {
            this._propertyTrackDataItem.SetEnable(e)
        }
        GetInterpolationMode() {
            return this._propertyTrackDataItem.GetInterpolationMode()
        }
        SetInterpolationMode(e) {
            this._propertyTrackDataItem.SetInterpolationMode(e)
        }
        GetResultMode() {
            return this._propertyTrackDataItem.GetResultMode()
        }
        SetResultMode(e) {
            this._propertyTrackDataItem.SetResultMode(e)
        }
        SetEase(e) {
            for (const t of this.GetPropertyKeyframeDataItems()) t.SetEase(e)
        }
        GetPropertyKeyframeDataItems() {
            return this._propertyKeyframeDataItems ? this._propertyKeyframeDataItems : (this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray(), this._propertyKeyframeDataItems)
        }* GetPropertyKeyframeValues() {
            for (const e of this.GetPropertyKeyframeDataItems()) yield e.GetValueWithResultMode()
        }
        CleanCaches() {
            this.GetSourceAdapter().CleanCaches()
        }
        GetCurrentState() {
            return this.GetSourceAdapter().GetCurrentState()
        }
        SetInitialState() {
            this.GetSourceAdapter().SetInitialState()
        }
        SetResumeState() {
            this.GetSourceAdapter().SetResumeState()
        }
        BeforeInterpolate() {
            this.GetSourceAdapter().BeforeInterpolate()
        }
        Interpolate(e, t = !1, n = !1, s = !1) {
            const o = this._propertyTrackDataItem;
            let i = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(e, o),
                a;
            return i ? a = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherThan(e, o) : (i = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, o), a = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, o)), this.GetSourceAdapter().Interpolate(e, i, a, t, n, s)
        }
        AfterInterpolate() {
            this.GetSourceAdapter().AfterInterpolate()
        }
        static GetStartPropertyKeyframeForTime(e, t) {
            const s = t.GetPropertyTrackDataItem(),
                o = t._propertyTrackData;
            let n = o.GetPropertyKeyFrameDataItemAtTime(e, s);
            return n || (n = o.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, s)), n
        }
        static GetEndPropertyKeyframeForTime(e, t) {
            const n = t.GetPropertyTrackDataItem(),
                s = t._propertyTrackData;
            let o = s.GetPropertyKeyFrameDataItemAtTime(e, n);
            return o ? s.GetFirstPropertyKeyFrameDataItemHigherThan(e, n) : s.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, n)
        }
        AddPropertyKeyframe() {
            const e = this._propertyTrackDataItem.GetPropertyKeyframeData(),
                t = e.AddEmptyPropertyKeyframeDataItem();
            return t
        }
        DeletePropertyKeyframes(e) {
            const t = this._propertyTrackDataItem.GetPropertyKeyframeData();
            t.DeletePropertyKeyframeDataItems(e)
        }
        SaveState() {
            this.GetSourceAdapter().SaveState()
        }
        CompareInitialStateWithCurrent() {
            const e = this.GetSourceAdapter().CompareInitialStateWithCurrent();
            if (e) {
                const e = this._propertyTrackData.GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem),
                    t = this.GetSourceAdapter().GetCurrentState();
                e.SetAbsoluteValue(t)
            }
        }
        CompareSaveStateWithCurrent() {
            const e = this.GetSourceAdapter().CompareSaveStateWithCurrent();
            return e && this.AddPropertyKeyframeAtCurrentTime(), this.GetSourceAdapter().ClearSaveState(), e
        }
        AddPropertyKeyframeAtCurrentTime() {
            const n = this.GetTimeline().GetTime(),
                s = this.GetSourceAdapter(),
                o = e.PropertyTrackState.GetStartPropertyKeyframeForTime(n, this),
                t = this.AddPropertyKeyframe();
            t.SetType(o.GetType()), t.SetTime(n), t.SetEase(o.GetEase()), t.SetEnable(!0), t.SetValue(s.GetValueAtTime()), t.SetAbsoluteValue(s.GetCurrentState())
        }
        _SaveToJson() {
            return {
                sourceAdapterJson: this.GetSourceAdapter()._SaveToJson()
            }
        }
        _LoadFromJson(e) {
            if (!e) return;
            this.GetSourceAdapter()._LoadFromJson(e.sourceAdapterJson)
        }
    }
}
"use strict";
{
    const t = self.C3,
        e = t.PropertyTrackState;
    e.PropertySourceAdapter = class PropertySourceAdapter {
        constructor(e) {
            this._propertyTrack = e, this._propertyAdapter = null
        }
        Release() {
            this._propertyAdapter && (this._propertyAdapter.Release(), this._propertyAdapter = null), this._propertyTrack = null
        }
        GetPropertyTrack() {
            return this._propertyTrack
        }
        CleanCaches() {
            this._propertyAdapter && this._propertyAdapter.CleanCaches()
        }
        GetPropertyAdapter() {
            return this._propertyAdapter ? this._propertyAdapter : (this._propertyAdapter = this._CreatePropertyAdapter(), this._propertyAdapter)
        }
        GetEditorIndex() {}
        GetIndex() {
            return this.GetEditorIndex()
        }
        GetTarget() {}
        SetInitialState() {
            this.GetPropertyAdapter().SetInitialState()
        }
        SetResumeState() {
            this.GetPropertyAdapter().SetResumeState()
        }
        BeforeInterpolate() {
            this.GetPropertyAdapter().BeforeChangeProperty()
        }
        Interpolate(t, n, s, o, i, a) {
            const c = e.PropertySourceAdapter.GetInterpolateFunc(this._propertyTrack),
                r = c(t, n, s, this._propertyTrack);
            return i ? r : this.GetPropertyAdapter().ChangeProperty(t, r, n, s, o, a)
        }
        AfterInterpolate() {
            this.GetPropertyAdapter().AfterChangeProperty()
        }
        SaveState() {
            this.GetPropertyAdapter().SetSaveState()
        }
        ClearSaveState() {
            this.GetPropertyAdapter().ClearSaveState()
        }
        GetCurrentState() {
            return this.GetPropertyAdapter().GetCurrentState()
        }
        CompareInitialStateWithCurrent() {
            return this.GetPropertyAdapter().CompareInitialStateWithCurrent()
        }
        CompareSaveStateWithCurrent() {
            return this.GetPropertyAdapter().CompareSaveStateWithCurrent()
        }
        GetValueAtTime() {
            return e.PropertySourceAdapter.GetValueAtTime(this._propertyTrack)
        }
        _CreatePropertyAdapter() {
            const t = this._propertyTrack.GetPropertyType(),
                n = this._propertyTrack.GetPropertyKeyframeType();
            switch (n) {
                case "combo":
                case "boolean":
                case "text":
                case "string":
                    return new e.PropertyInterpolationAdapter.NoInterpolationAdapter(this);
                case "numeric":
                case "number":
                case "angle":
                    return t === "combo" ? new e.PropertyInterpolationAdapter.NoInterpolationAdapter(this) : new e.PropertyInterpolationAdapter.NumericInterpolationAdapter(this);
                case "color":
                case "offsetColor":
                    return new e.PropertyInterpolationAdapter.ColorInterpolationAdapter(this)
            }
        }
        _SaveToJson() {
            return {
                propertyAdapterJson: this.GetPropertyAdapter()._SaveToJson()
            }
        }
        _LoadFromJson(e) {
            if (!e) return;
            this.GetPropertyAdapter()._LoadFromJson(e.propertyAdapterJson)
        }
        static GetValueAtTime(t) {
            const s = t.GetTrack(),
                n = s.GetTimeline().GetTime(),
                o = e.GetStartPropertyKeyframeForTime(n, t),
                i = e.GetEndPropertyKeyframeForTime(n, t),
                a = e.PropertySourceAdapter.GetInterpolateFunc(t);
            return a(n, o, i, t)
        }
        static GetValue(e, t, n) {
            let s = e.GetResultMode();
            switch (e.GetPropertyType() === "combo" && (s = "absolute"), s) {
                case "relative":
                    return t + n;
                case "absolute":
                    return n
            }
        }
        static GetInterpolateFunc(t) {
            const n = t.GetPropertyKeyframeType();
            switch (n) {
                case "numeric":
                    return e.NumericTypeAdapter.Interpolate;
                case "angle":
                    return e.AngleTypeAdapter.Interpolate;
                case "boolean":
                    return e.BooleanTypeAdapter.Interpolate;
                case "color":
                    return e.ColorTypeAdapter.Interpolate;
                case "text":
                    return e.TextTypeAdapter.Interpolate
            }
        }
        static GetWillChangeFunc(t) {
            const n = t.GetPropertyKeyframeType();
            switch (n) {
                case "numeric":
                    return e.NumericTypeAdapter.WillChange;
                case "angle":
                    return e.AngleTypeAdapter.WillChange;
                case "boolean":
                    return e.BooleanTypeAdapter.WillChange;
                case "color":
                    return e.ColorTypeAdapter.WillChange;
                case "text":
                    return e.TextTypeAdapter.WillChange
            }
        }
    }
}
"use strict";
{
    const e = self.C3;
    class t extends e.PropertyTrackState.PropertySourceAdapter {
        constructor(e) {
            super(e)
        }
    }
    e.PropertyTrackState.WorldInstanceSourceAdapter = t
}
"use strict";
{
    const e = self.C3,
        t = 0;
    class n extends e.PropertyTrackState.PropertySourceAdapter {
        constructor(e) {
            super(e), this._updatedIndex = NaN
        }
        GetEditorIndex() {
            return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[t]
        }
        GetIndex() {
            return this._updatedIndex ? this._updatedIndex : super.GetIndex()
        }
        GetTarget() {
            return this._propertyTrack.GetTrack().GetInstance()
        }
        UpdateInstanceVariableIndex(e) {
            const n = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[t];
            if (n === e) return;
            this._updatedIndex = e
        }
        Interpolate(e, t, n, s, o, i) {
            if (!this.GetPropertyAdapter().CanChange(t.GetValue())) return;
            return super.Interpolate(e, t, n, s, o, i)
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                index: this._updatedIndex
            })
        }
        _LoadFromJson(e) {
            if (!e) return;
            super._LoadFromJson(e), this._updatedIndex = e.index
        }
    }
    e.PropertyTrackState.InstanceVariableSourceAdapter = n
}
"use strict";
{
    const e = self.C3,
        t = 0,
        n = 1,
        s = 2;
    class o extends e.PropertyTrackState.PropertySourceAdapter {
        constructor(e) {
            super(e), this._sid = NaN
        }
        GetEditorIndex() {
            const e = this._propertyTrack.GetPropertyTrackDataItem();
            return e.GetSourceAdapterArguments()[n]
        }
        GetTarget() {
            const n = this._propertyTrack.GetPropertyTrackDataItem(),
                s = this._propertyTrack.GetTrack(),
                o = this._sid ? this._sid : n.GetSourceAdapterArguments()[t],
                e = s.GetInstance(),
                i = e.GetBehaviorIndexBySID(o),
                a = e.GetBehaviorInstances()[i];
            return a.GetSdkInstance()
        }
        GetBehaviorType(e) {
            const t = this._propertyTrack.GetPropertyTrackDataItem(),
                n = t.GetSourceAdapterArguments()[s];
            return e.GetBehaviorTypeByName(n)
        }
        UpdateBehaviorTypeSid(e) {
            const n = this._propertyTrack.GetPropertyTrackDataItem();
            if (n.GetSourceAdapterArguments()[t] === e) return;
            this._sid = e
        }
        Interpolate(e, t, n, s, o, i) {
            const a = this._propertyTrack.GetTrack(),
                r = a.GetInstance();
            if (!this.GetBehaviorType(r.GetObjectClass())) return;
            return super.Interpolate(e, t, n, s, o, i)
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                sid: this._sid
            })
        }
        _LoadFromJson(e) {
            if (!e) return;
            super._LoadFromJson(e), this._sid = e.sid
        }
    }
    e.PropertyTrackState.BehaviorSourceAdapter = o
}
"use strict";
{
    const e = self.C3,
        t = 0,
        n = 1;
    class s extends e.PropertyTrackState.PropertySourceAdapter {
        constructor(e) {
            super(e)
        }
        GetEditorIndex() {
            return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[n]
        }
        GetTarget() {
            const n = this._propertyTrack,
                s = n.GetTrack(),
                o = s.GetWorldInfo(),
                e = o.GetInstanceEffectList(),
                i = e.GetEffectList(),
                a = this.GetEffectType(i),
                t = a.GetIndex();
            return e.IsEffectIndexActive(t) ? e.GetEffectParametersForIndex(t) : null
        }
        GetEffectType(e) {
            const n = this._propertyTrack,
                s = n.GetPropertyTrackDataItem().GetSourceAdapterArguments()[t];
            return e.GetEffectTypeByName(s)
        }
        Interpolate(e, t, n, s, o, i) {
            if (!this._IsEffectActive()) return;
            return super.Interpolate(e, t, n, s, o, i)
        }
        _IsEffectActive() {
            const n = this._propertyTrack,
                s = n.GetTrack(),
                o = s.GetWorldInfo(),
                e = o.GetInstanceEffectList(),
                i = e.GetEffectList(),
                t = this.GetEffectType(i);
            if (!t) return;
            const a = t.GetIndex();
            return e.IsEffectIndexActive(a)
        }
    }
    e.PropertyTrackState.EffectSourceAdapter = s
}
"use strict";
{
    const e = self.C3,
        t = 0;
    class n extends e.PropertyTrackState.PropertySourceAdapter {
        constructor(e) {
            super(e)
        }
        GetEditorIndex() {
            return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[t]
        }
        GetTarget() {
            return this._propertyTrack.GetTrack().GetInstance().GetSdkInstance()
        }
        Interpolate(e, t, n, s, o, i) {
            const a = this._propertyTrack.GetTrack(),
                r = a.GetObjectClass().GetPlugin(),
                c = a.GetInstance().GetObjectClass().GetPlugin();
            if (r !== c) return;
            return super.Interpolate(e, t, n, s, o, i)
        }
    }
    e.PropertyTrackState.PluginSourceAdapter = n
}
"use strict";
{
    const e = self.C3;
    class t extends e.PropertyTrackState.PropertySourceAdapter {
        constructor(e) {
            super(e), this._value = 0, this._init = !1
        }
        SetInitialState() {
            const t = this._propertyTrack.GetPropertyTrackData();
            let e = this._propertyTrack.GetPropertyTrackDataItem();
            e = t.GetFirstPropertyKeyframeDataItem(e), this._value = e.GetValueWithResultMode()
        }
        SetResumeState() {}
        GetValue() {
            return this._init || this._propertyTrack.Interpolate(0), this._value
        }
        Interpolate(t, n, s) {
            const r = e.PropertyTrackState.NumericTypeAdapter.Interpolate;
            this._value = r(t, n, s, this._propertyTrack), this._init = !0
        }
        SaveState() {}
        ClearSaveState() {}
        GetCurrentState() {
            return this._value
        }
        CompareInitialStateWithCurrent() {
            return !1
        }
        CompareSaveStateWithCurrent() {
            return !1
        }
        _SaveToJson() {
            return {
                value: this._value,
                init: this._init
            }
        }
        _LoadFromJson(e) {
            if (!e) return;
            this._value = e.value, this._init = !e.hasOwnProperty("init") || e.init
        }
    }
    e.PropertyTrackState.ValueSourceAdapter = t
}
"use strict";
{
    const e = self.C3;
    e.PropertyTrackState.PropertyInterpolationAdapter = class PropertyInterpolationAdapter {
        constructor(e) {
            this._sourceAdapter = e, this._propertyTrack = e.GetPropertyTrack(), this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo(), this._property = this._propertyTrack.GetPropertyName(), this._firstAbsoluteUpdate = !1, this._saveState = null, this._target = null
        }
        Release() {
            this._sourceAdapter = null, this._propertyTrack = null, this._worldInfo = null, this._saveState = null, this._target = null
        }
        CleanCaches() {
            this._worldInfo = null, this._saveState = null, this._target = null
        }
        GetPropertyTrack() {
            return this._propertyTrack
        }
        GetWorldInfo() {
            return this._worldInfo ? this._worldInfo : (this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo(), this._worldInfo)
        }
        SetFirstAbsoluteUpdate(e) {
            this._firstAbsoluteUpdate = !!e
        }
        GetFirstAbsoluteUpdate() {
            return this._firstAbsoluteUpdate
        }
        SetInitialState() {}
        SetResumeState() {}
        SetSaveState() {
            this._saveState = this.GetCurrentState()
        }
        ClearSaveState() {
            this._saveState = null
        }
        GetCurrentState() {}
        CompareInitialStateWithCurrent() {}
        CompareSaveStateWithCurrent() {}
        CanChange(e) {
            const t = typeof this._Getter(),
                n = typeof e;
            return t === n
        }
        BeforeChangeProperty() {}
        ChangeProperty() {}
        AfterChangeProperty() {}
        _FirstKeyframeGetter() {
            const e = this._PickTimelinePlaybackMode(() => {
                const e = this._propertyTrack.GetPropertyTrackDataItem(),
                    t = this._propertyTrack.GetPropertyTrackData();
                return t.GetFirstPropertyKeyframeDataItem(e)
            }, () => {
                const e = this._propertyTrack.GetPropertyTrackDataItem(),
                    t = this._propertyTrack.GetPropertyTrackData();
                return t.GetLastPropertyKeyframeDataItem(e)
            });
            return e.GetAbsoluteValue()
        }
        _CurrentKeyframeGetter() {
            const t = this._propertyTrack.GetTimeline(),
                e = t.GetTime() - this._propertyTrack.GetTrack().GetStartOffset(),
                n = this._PickTimelinePlaybackMode(() => {
                    const t = this._propertyTrack.GetPropertyTrackDataItem(),
                        n = this._propertyTrack.GetPropertyTrackData();
                    return n.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, t)
                }, () => {
                    const t = this._propertyTrack.GetPropertyTrackDataItem(),
                        n = this._propertyTrack.GetPropertyTrackData(),
                        s = n.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, t);
                    return s || n.GetLastPropertyKeyframeDataItem(t)
                });
            return n.GetAbsoluteValue()
        }
        _PickTimelinePlaybackMode(e, t) {
            const n = this._propertyTrack.GetTimeline();
            return n.IsForwardPlayBack() ? e() : t()
        }
        _PickResultMode(e, t) {
            const n = this._propertyTrack.GetResultMode();
            return n === "relative" ? e() : t()
        }
        _PickFirstAbsoluteUpdate(e, t) {
            return this.GetFirstAbsoluteUpdate() ? (this.SetFirstAbsoluteUpdate(!1), e()) : t()
        }
        _GetAbsoluteInitialValue() {}
        _GetIndex() {
            return this._sourceAdapter.GetIndex()
        }
        _GetTarget() {
            return this._target ? this._target : (this._target = this._sourceAdapter.GetTarget(), this._target)
        }
        _PickSource(e, t, n, s, o) {
            const i = this._propertyTrack.GetSourceAdapterId();
            switch (i) {
                case "behavior":
                    return e();
                case "effect":
                    return t();
                case "instance-variable":
                    return n();
                case "plugin":
                    return s();
                case "world-instance":
                    return o()
            }
        }
        _SaveToJson() {
            return {
                firstAbsoluteUpdate: this._firstAbsoluteUpdate,
                saveState: this._saveState
            }
        }
        _LoadFromJson(e) {
            if (!e) return;
            this._firstAbsoluteUpdate = e.firstAbsoluteUpdate, this._saveState = e.saveState
        }
        _GetPropertyKeyframeStubs(e, t = !1) {
            const n = [];
            for (const s of e) {
                const o = s.GetTrack().GetStartOffset();
                for (const e of s.GetPropertyKeyframeDataItems()) t && e.GetTime() === 0 ? n.push({
                    time: o + e.GetTime(),
                    value: e.GetAbsoluteValue()
                }) : t || n.push({
                    time: o + e.GetTime(),
                    value: e.GetAbsoluteValue()
                })
            }
            return n.sort((e, t) => e.time - t.time)
        }
        _GetLastPropertyKeyframeStub(e, t, n) {
            return this._GetPropertyKeyframeStubLowerThanPlayhead(t, n)
        }
        _GetPropertyKeyframeStubLowerThanPlayhead(e, t) {
            for (let n = t.length - 1; n >= 0; n--) {
                const s = t[n].time;
                if (s <= e) return t[n]
            }
            return null
        }
    }
}
"use strict";
{
    const e = self.C3,
        n = new Map,
        t = [0, 0, 0];
    class s extends e.PropertyTrackState.PropertyInterpolationAdapter {
        constructor(e) {
            super(e)
        }
        SetInitialState() {}
        SetResumeState() {}
        GetCurrentState() {
            const n = this._propertyTrack.GetSourceAdapterId(),
                e = this._GetTarget(),
                t = this._GetIndex();
            switch (n) {
                case "behavior":
                    return this._ToColorArray(e.GetPropertyValueByIndex(t));
                case "effect":
                    return this._ToColorArray(e[t]);
                case "plugin":
                    return this._ToColorArray(e.GetPropertyValueByIndex(t));
                case "world-instance":
                    return this._ToColorArray(this._Getter())
            }
        }
        CompareInitialStateWithCurrent() {
            const e = this._FirstKeyframeGetter();
            return !this._CompareColors(e, this._Getter())
        }
        CompareSaveStateWithCurrent() {
            return !e.IsNullOrUndefined(this._saveState) && !this._CompareColors(this._saveState, this._Getter())
        }
        _CompareColors(e, t) {
            return e.equalsIgnoringAlpha(t)
        }
        _FirstKeyframeGetter() {
            const e = super._FirstKeyframeGetter();
            return this._GetColorFromArray(e)
        }
        _CurrentKeyframeGetter() {
            const e = super._CurrentKeyframeGetter();
            return this._GetColorFromArray(e)
        }
        _GetAbsoluteInitialValue() {}
        _ToColorArray(t) {
            return e.IsInstanceOf(t, e.Color) ? t.toArray().slice(0, 3) : t.slice(0, 3)
        }
        _GetColorFromArray(t) {
            return e.IsInstanceOf(t, e.Color) ? t : new e.Color(t[0], t[1], t[2], 1)
        }
        CanChange() {
            return !0
        }
        BeforeChangeProperty() {
            const t = this._propertyTrack.GetInstance();
            n.has(t) || n.set(t, new Map);
            const s = n.get(t),
                o = this._propertyTrack.GetSourceAdapterId();
            s.has(o) || s.set(o, new Map);
            const i = s.get(o);
            i.has(this._property) || i.set(this._property, {
                used: !1,
                color: new e.Color(0, 0, 0, 1)
            })
        }
        _GetTmpColor(e, t, s) {
            const o = n.get(e).get(t).get(s);
            return o.used = !0, o.color
        }
        ChangeProperty(t, n) {
            const a = this._propertyTrack.GetTimeline(),
                d = this._propertyTrack.GetTrack(),
                r = this._propertyTrack.GetInstance(),
                u = this._propertyTrack.GetSourceAdapter(),
                c = this._propertyTrack.GetSourceAdapterId(),
                h = this._property,
                l = a.GetSimilarPropertyTracks(r, u, h);
            if (l.length > 1) {
                {
                    const s = this._GetPropertyKeyframeStubs(l, !0),
                        t = this._GetLastPropertyKeyframeStub(a, a.GetTime(), s);
                    if (t) {
                        const o = d.GetStartOffset(),
                            s = t.time - o;
                        if (s === 0) this._GetTmpColor(r, c, this._property).addRgb(n[0], n[1], n[2]);
                        else {
                            if (s < 0) return;
                            const o = n[0],
                                i = n[1],
                                a = n[2],
                                t = this._propertyTrack.Interpolate(s, !1, !0),
                                l = e.Color.DiffChannel(o, t[0]),
                                d = e.Color.DiffChannel(i, t[1]),
                                u = e.Color.DiffChannel(a, t[2]);
                            this._GetTmpColor(r, c, this._property).addRgb(l, d, u)
                        }
                    }
                }
            } else this._Setter(n[0], n[1], n[2]);
            return e.TimelineState.LAYOUT_RENDER_CHANGE
        }
        AfterChangeProperty() {
            const t = this._propertyTrack.GetInstance();
            if (!n.has(t)) return;
            const e = n.get(t),
                s = this._propertyTrack.GetSourceAdapterId();
            if (!e.has(s)) return;
            const o = e.get(s);
            if (!o.has(this._property)) return;
            const a = o.get(this._property),
                r = a.used,
                i = a.color;
            r && this._Setter(i.getR(), i.getG(), i.getB()), o.size === 0 && e.delete(s), e.size === 0 && n.delete(t)
        }
        _Getter() {
            const n = this._propertyTrack.GetSourceAdapterId(),
                e = this._GetTarget(),
                t = this._GetIndex();
            switch (n) {
                case "behavior":
                    return this._GetColorFromArray(e.GetPropertyValueByIndex(t));
                case "effect":
                    return e[t].clone();
                case "plugin":
                    return this._GetColorFromArray(e.GetPropertyValueByIndex(t));
                case "world-instance":
                    return this.GetWorldInfo().GetUnpremultipliedColor().clone()
            }
        }
        _Setter(e, n, s) {
            const a = this._propertyTrack.GetSourceAdapterId(),
                o = this._GetTarget(),
                i = this._GetIndex();
            switch (a) {
                case "behavior":
                    t[0] = e, t[1] = n, t[2] = s, o.SetPropertyValueByIndex(i, t);
                    break;
                case "effect":
                    o[i].setRgb(e, n, s);
                    break;
                case "plugin":
                    t[0] = e, t[1] = n, t[2] = s, o.SetPropertyValueByIndex(i, t);
                    break;
                case "world-instance":
                    this.GetWorldInfo().SetUnpremultipliedColorRGB(e, n, s);
                    break
            }
        }
        _SaveToJson() {}
        _LoadFromJson() {}
    }
    e.PropertyTrackState.PropertyInterpolationAdapter.ColorInterpolationAdapter = s
}
"use strict";
{
    const e = self.C3;
    class t extends e.PropertyTrackState.PropertyInterpolationAdapter {
        constructor(e) {
            super(e)
        }
        SetInitialState() {}
        SetResumeState() {}
        GetCurrentState() {
            return this._Getter()
        }
        CompareInitialStateWithCurrent() {
            const e = this._FirstKeyframeGetter();
            return e !== this.GetCurrentState()
        }
        CompareSaveStateWithCurrent() {
            return !e.IsNullOrUndefined(this._saveState) && this._saveState !== this.GetCurrentState()
        }
        ChangeProperty(t, n) {
            const u = e.PropertyTrackState.PropertySourceAdapter.GetWillChangeFunc(this._propertyTrack),
                a = this._propertyTrack,
                r = a.GetTrack(),
                c = a.GetSourceAdapterId(),
                l = a.GetTimeline(),
                h = r.GetInstance(),
                m = a.GetSourceAdapter(),
                f = this._property,
                d = l.GetSimilarPropertyTracks(h, m, f);
            if (d.length > 1) {
                const s = this._GetPropertyKeyframeStubs(d),
                    o = t + r.GetStartOffset(),
                    e = this._GetLastPropertyKeyframeStub(l, o, s);
                e && (n = e.value)
            }
            const p = u(this._GetIndex(), this._GetTarget(), n, c);
            if (!p) return;
            switch (this._Setter(n), c) {
                case "behavior":
                    return;
                case "effect":
                    return;
                case "instance-variable":
                    return;
                case "plugin":
                    return e.TimelineState.LAYOUT_RENDER_CHANGE
            }
        }
        _Getter() {
            const n = this._propertyTrack.GetSourceAdapterId(),
                e = this._GetTarget(),
                t = this._GetIndex();
            switch (n) {
                case "behavior":
                    return e.GetPropertyValueByIndex(t);
                case "effect":
                    return e[t];
                case "instance-variable":
                    return e.GetInstanceVariableValue(t);
                case "plugin":
                    return e.GetPropertyValueByIndex(t)
            }
        }
        _Setter(e) {
            const s = this._propertyTrack.GetSourceAdapterId(),
                t = this._GetTarget(),
                n = this._GetIndex();
            switch (s) {
                case "behavior":
                    t.SetPropertyValueByIndex(n, e);
                    break;
                case "effect":
                    t[n] = e;
                    break;
                case "instance-variable":
                    t.SetInstanceVariableValue(n, e);
                    break;
                case "plugin":
                    t.SetPropertyValueByIndex(n, e);
                    break
            }
        }
    }
    e.PropertyTrackState.PropertyInterpolationAdapter.NoInterpolationAdapter = t
}
"use strict";
{
    const t = self.C3,
        o = t.PropertyTrackState.PropertyInterpolationAdapter,
        n = new Map,
        e = (e, t, s, o, i) => n.set(e, {
            setter: t,
            absolute_setter: s,
            getter: o,
            round: i
        });
    e("offsetX", (e, t) => e.OffsetX(t), (e, t) => e.SetX(t), e => e.GetX(), !0), e("offsetY", (e, t) => e.OffsetY(t), (e, t) => e.SetY(t), e => e.GetY(), !0), e("offsetWidth", (e, t) => e.OffsetWidth(t), (e, t) => e.SetWidth(t), e => e.GetWidth(), !0), e("offsetHeight", (e, t) => e.OffsetHeight(t), (e, t) => e.SetHeight(t), e => e.GetHeight(), !0), e("offsetAngle", (e, t) => e.OffsetAngle(t), (e, t) => e.SetAngle(t), e => e.GetAngle(), !1), e("offsetOpacity", (e, t) => e.OffsetOpacity(t), (e, t) => e.SetOpacity(t), e => e.GetOpacity(), !1), e("offsetOriginX", (e, t) => e.OffsetOriginX(t), (e, t) => e.SetOriginX(t), e => e.GetOriginX(), !1), e("offsetOriginY", (e, t) => e.OffsetOriginY(t), (e, t) => e.SetOriginY(t), e => e.GetOriginY(), !1), e("offsetZElevation", (e, t) => e.OffsetZElevation(t), (e, t) => e.SetZElevation(t), e => e.GetZElevation(), !0), e("offsetScaleX", (e, t, n) => {
        e.OffsetWidth(n.GetOriginalWidth() * t)
    }, (e, t, n) => {
        e.SetWidth(n.GetOriginalWidth() * t)
    }, (e, t) => e.GetWidth() / t.GetOriginalWidth(), !1), e("offsetScaleY", (e, t, n) => {
        e.OffsetHeight(n.GetOriginalHeight() * t)
    }, (e, t, n) => {
        e.SetHeight(n.GetOriginalHeight() * t)
    }, (e, t) => e.GetHeight() / t.GetOriginalHeight(), !1);
    class s extends t.PropertyTrackState.PropertyInterpolationAdapter {
        constructor(e) {
            super(e), this._lastValue = 0, this._instance_getter = null, this._instance_setter = null, this._instance_absolute_setter = null, this._round = !1, t.IsInstanceOf(this._propertyTrack.GetTimeline(), t.Tween) ? this._typeAdapter = new t.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween(this) : this._typeAdapter = new t.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline(this);
            const s = this._propertyTrack.GetPropertyName();
            if (this._propertyTrack.GetSourceAdapterId() === "world-instance") {
                const e = n.get(s);
                this._instance_getter = e.getter, this._instance_setter = e.setter, this._instance_absolute_setter = e.absolute_setter, this._round = e.round
            }
        }
        Release() {
            this._typeAdapter = null, this._instance_getter = null, this._instance_setter = null, this._instance_absolute_setter = null, super.Release()
        }
        GetLastValue() {
            return this._lastValue
        }
        SetLastValue(e) {
            this._lastValue = e
        }
        SetInitialState() {
            const e = this._typeAdapter.SetInitialState();
            typeof e == "number" && (this._lastValue = e)
        }
        SetResumeState() {
            const e = this._typeAdapter.SetResumeState();
            typeof e == "number" && (this._lastValue = e)
        }
        GetCurrentState() {
            return this._Getter()
        }
        CompareInitialStateWithCurrent() {
            const e = this._FirstKeyframeGetter();
            return e !== this.GetCurrentState()
        }
        CompareSaveStateWithCurrent() {
            return !t.IsNullOrUndefined(this._saveState) && this._saveState !== this.GetCurrentState()
        }
        BeforeChangeProperty() {
            this._typeAdapter.BeforeChangeProperty()
        }
        ChangeProperty(e, t, n, s, o, i) {
            return this._typeAdapter.ChangeProperty(e, t, n, s, o, i)
        }
        AfterChangeProperty() {
            this._typeAdapter.AfterChangeProperty()
        }
        _Getter() {
            const e = this._GetTarget(),
                t = this._GetIndex(),
                n = this._propertyTrack.GetTrack(),
                s = this.GetWorldInfo();
            return this._PickSource(() => e.GetPropertyValueByIndex(t), () => e[t], () => e.GetInstanceVariableValue(t), () => e.GetPropertyValueByIndex(t), () => this._instance_getter(s, n))
        }
        _Setter(e) {
            const s = this._GetTarget(),
                o = this._GetIndex(),
                i = this._propertyTrack.GetTrack(),
                a = this.GetWorldInfo();
            this._PickSource(() => s.OffsetPropertyValueByIndex(o, e), () => s[o] += e, () => s.SetInstanceVariableOffset(o, e), () => s.OffsetPropertyValueByIndex(o, e), () => this._instance_setter(a, e, i))
        }
        _SetterAbsolute(e) {
            const s = this._GetTarget(),
                o = this._GetIndex(),
                i = this._propertyTrack.GetTrack(),
                a = this.GetWorldInfo();
            this._PickSource(() => s.SetPropertyValueByIndex(o, e), () => s[o] = e, () => s.SetInstanceVariableValue(o, e), () => s.SetPropertyValueByIndex(o, e), () => this._instance_absolute_setter(a, e, i))
        }
        _MaybeEnsureValue(e, t, n, s, o, i) {
            this._typeAdapter._MaybeEnsureValue(e, t, n, s, o, i)
        }
        _AddDelta(e, n, s) {
            const r = e.toString(),
                c = r.split(".")[1] || "",
                a = c.length,
                o = this._Getter();
            let i;
            a === 0 ? i = this._round ? Math.round(o) : o : i = t.toFixed(o, a), this._Setter(i - o, n, s)
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                v: this._lastValue
            })
        }
        _LoadFromJson(e) {
            if (!e) return;
            super._LoadFromJson(e), this._lastValue = e.v
        }
    }
    t.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapter = s
}
"use strict";
{
    const t = self.C3,
        e = new Map;
    class n {
        constructor(e) {
            this._numericInterpolationAdapter = e
        }
        Release() {
            this._numericInterpolationAdapter = null
        }
        SetInitialState() {
            const e = this._numericInterpolationAdapter,
                n = this._numericInterpolationAdapter.GetPropertyTrack();
            return e._PickResultMode(() => e._PickTimelinePlaybackMode(() => 0, () => t.PropertyTrackState.PropertySourceAdapter.GetValueAtTime(n)), () => {})
        }
        SetResumeState() {}
        BeforeChangeProperty() {
            const s = this._numericInterpolationAdapter,
                t = this._numericInterpolationAdapter.GetPropertyTrack(),
                n = t.GetPropertyName();
            s._PickResultMode(() => {}, () => {
                const s = t.GetInstance();
                e.has(s) || e.set(s, new Map);
                const o = e.get(s),
                    i = t.GetSourceAdapterId();
                o.has(i) || o.set(i, new Map);
                const a = o.get(i);
                a.has(n) || a.set(n, {
                    used: !1,
                    value: 0
                })
            })
        }
        _GetTmpAbsoluteValueObject(t, n, s) {
            const o = e.get(t).get(n).get(s);
            return o.used = !0, o
        }
        ChangeProperty(e, n, s, o, i, a) {
            const r = this._numericInterpolationAdapter,
                c = this._numericInterpolationAdapter.GetPropertyTrack(),
                l = c.GetPropertyName();
            return r._PickResultMode(() => {
                const t = r.GetLastValue();
                r._Setter(n - t, s, o), a && this._MaybeEnsureValue(e, s, o, i, t, n), r.SetLastValue(n)
            }, () => {
                const e = c.GetTimeline(),
                    i = c.GetTrack(),
                    t = c.GetInstance(),
                    a = c.GetSourceAdapter(),
                    s = c.GetSourceAdapterId(),
                    o = e.GetSimilarPropertyTracks(t, a, l);
                if (o.length > 1) {
                    {
                        const d = r._GetPropertyKeyframeStubs(o, !0),
                            a = r._GetLastPropertyKeyframeStub(e, e.GetTime(), d);
                        if (a) {
                            const o = i.GetStartOffset(),
                                e = a.time - o;
                            if (e === 0) {
                                const e = this._GetTmpAbsoluteValueObject(t, s, l);
                                e.value += n
                            } else {
                                if (e < 0) return;
                                const o = c.Interpolate(e, !1, !0),
                                    i = this._GetTmpAbsoluteValueObject(t, s, l);
                                i.value += n - o
                            }
                        }
                    }
                } else r._SetterAbsolute(n)
            }), r._PickSource(() => {}, () => t.TimelineState.LAYOUT_RENDER_CHANGE, () => {}, () => t.TimelineState.LAYOUT_RENDER_CHANGE, () => t.TimelineState.LAYOUT_RENDER_CHANGE)
        }
        AfterChangeProperty() {
            const s = this._numericInterpolationAdapter,
                t = this._numericInterpolationAdapter.GetPropertyTrack(),
                n = t.GetPropertyName();
            s._PickResultMode(() => {}, () => {
                const a = t.GetInstance();
                if (!e.has(a)) return;
                const o = e.get(a),
                    r = t.GetSourceAdapterId();
                if (!o.has(r)) return;
                const i = o.get(r);
                if (!i.has(n)) return;
                const c = i.get(n),
                    l = c.used,
                    d = c.value;
                l && s._SetterAbsolute(d), i.delete(n), i.size === 0 && o.delete(r), o.size === 0 && e.delete(a)
            })
        }
        _MaybeEnsureValue(e, t, n, s, o, i) {
            const a = this._numericInterpolationAdapter;
            if (s) return;
            t && e === t.GetTime() ? a._AddDelta(t.GetValueWithResultMode(), t, n) : n && e === n.GetTime() ? a._AddDelta(n.GetValueWithResultMode(), t, n) : i - o === 0 && a._AddDelta(t.GetValueWithResultMode(), t, n)
        }
    }
    t.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline = n
}
"use strict";
{
    const e = self.C3,
        n = new Map;
    class t {
        constructor(e) {
            this._numericInterpolationAdapter = e
        }
        Release() {
            this._numericInterpolationAdapter = null
        }
        SetInitialState() {
            const e = this._numericInterpolationAdapter;
            return e.SetFirstAbsoluteUpdate(!0), this._GetAbsoluteInitialValue(e._FirstKeyframeGetter())
        }
        SetResumeState() {
            const e = this._numericInterpolationAdapter;
            if (e._FirstKeyframeGetter() === e._CurrentKeyframeGetter()) return;
            return e.SetFirstAbsoluteUpdate(!0), this._GetAbsoluteInitialValue(e._CurrentKeyframeGetter())
        }
        BeforeChangeProperty() {}
        ChangeProperty(t, n, s, o, i, a) {
            const r = this._numericInterpolationAdapter,
                c = r.GetLastValue();
            return r._PickResultMode(() => {
                r._Setter(n - c, s, o), a && this._MaybeEnsureValue(t, s, o, i, c, n)
            }, () => {
                r._PickFirstAbsoluteUpdate(() => {
                    r._Setter(c, s, o)
                }, () => {
                    r._Setter(n - c, s, o), a && this._MaybeEnsureValue(t, s, o, i, c, n)
                })
            }), r.SetLastValue(n), r._PickSource(() => {}, () => e.TimelineState.LAYOUT_RENDER_CHANGE, () => {}, () => e.TimelineState.LAYOUT_RENDER_CHANGE, () => e.TimelineState.LAYOUT_RENDER_CHANGE)
        }
        AfterChangeProperty() {}
        _GetAbsoluteInitialValue(e) {
            const t = this._numericInterpolationAdapter;
            return e - t.GetCurrentState()
        }
        _MaybeEnsureValue(e, t, n, s, o, i) {
            const a = this._numericInterpolationAdapter;
            s ? t && e === t.GetTime() ? a._AddDelta(t.GetValueWithResultMode(), t, n) : n && e === n.GetTime() ? a._AddDelta(n.GetValueWithResultMode(), t, n) : n || a._AddDelta(t.GetValueWithResultMode(), t, n) : t && e === t.GetTime() ? a._AddDelta(t.GetValueWithResultMode(), t, n) : n && e === n.GetTime() ? a._AddDelta(n.GetValueWithResultMode(), t, n) : i - o === 0 && a._AddDelta(t.GetValueWithResultMode(), t, n)
        }
    }
    e.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween = t
}
"use strict";
{
    const t = self.C3,
        e = self.Ease;
    t.PropertyTrackState.NumericTypeAdapter = class NumericTypeAdapter {
        constructor() {}
        static WillChange(e, t, n, s) {
            let o;
            switch (s) {
                case "behavior":
                    o = t.GetPropertyValueByIndex(e);
                    break;
                case "effect":
                    o = t[e];
                    break;
                case "instance-variable":
                    o = t.GetInstanceVariableValue(e);
                    break;
                case "plugin":
                    o = t.GetPropertyValueByIndex(e);
                    break
            }
            return o !== n
        }
        static Interpolate(n, s, o, i) {
            if (!o) {
                let e = i.GetPropertyTrackDataItem();
                const t = i.GetPropertyTrackData();
                return e = t.GetLastPropertyKeyframeDataItem(e), e.GetValueWithResultMode()
            }
            let a = i.GetInterpolationMode();
            if (a === "default" && (a = "continuous"), i.GetPropertyType() === "combo" && (a = "discrete"), a === "discrete") return s.GetValueWithResultMode();
            if (a === "continuous" || a === "step") {
                if (a === "step") {
                    const e = i.GetTimeline().GetStep();
                    if (e !== 0) {
                        const t = 1 / e;
                        n = Math.floor(n * t) / t
                    }
                }
                const l = s.GetTime(),
                    d = o.GetTime(),
                    r = s.GetValueWithResultMode(),
                    u = o.GetValueWithResultMode();
                if (r === u) return r;
                const f = t.normalize(n, l, d),
                    p = s.GetEase();
                let c;
                const h = s.GetAddOn("cubic-bezier"),
                    m = o.GetAddOn("cubic-bezier");
                if (h && h.GetStartEnable() && m && m.GetEndEnable()) {
                    const t = d - l;
                    c = e.GetRuntimeEase(p)(t * f, 0, 1, t), c = e.GetRuntimeEase("cubicbezier")(c, r, r + h.GetStartAnchor(), u + m.GetEndAnchor(), u)
                } else c = e.GetRuntimeEase(p)((d - l) * f, r, u - r, d - l);
                return i.GetPropertyType() === "integer" ? Math.floor(c) : c
            }
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.PropertyTrackState.AngleTypeAdapter = class AngleTypeAdapter {
        constructor() {}
        static WillChange(e, t, n, s) {
            let o;
            switch (s) {
                case "behavior":
                    o = t.GetPropertyValueByIndex(e);
                    break;
                case "effect":
                    o = t[e];
                    break;
                case "instance-variable":
                    o = t.GetInstanceVariableValue(e);
                    break;
                case "plugin":
                    o = t.GetPropertyValueByIndex(e);
                    break
            }
            return o !== n
        }
        static Interpolate(t, n, s, o) {
            if (!s) {
                let e = o.GetPropertyTrackDataItem();
                const t = o.GetPropertyTrackData();
                return e = t.GetLastPropertyKeyframeDataItem(e), e.GetValueWithResultMode()
            }
            let i = o.GetInterpolationMode();
            if (i === "default" && (i = "continuous"), o.GetPropertyType() === "combo" && (i = "discrete"), i === "discrete") return n.GetValueWithResultMode();
            if (i === "continuous" || i === "step") {
                if (i === "step") {
                    const e = o.GetTimeline().GetStep();
                    if (e !== 0) {
                        const n = 1 / e;
                        t = Math.floor(t * n) / n
                    }
                }
                const l = n.GetTime(),
                    d = s.GetTime(),
                    a = n.GetValueWithResultMode(),
                    r = s.GetValueWithResultMode(),
                    c = n.GetAddOn("angle");
                if (c) {
                    const s = c.GetRevolutions();
                    if (a === r && s === 0) return a;
                    const i = e.normalize(t, l, d),
                        u = self.Ease.GetRuntimeEase(n.GetEase()),
                        o = u(i, 0, 1, 1);
                    switch (c.GetDirection()) {
                        case "closest":
                            return e.angleLerp(a, r, o, s);
                        case "clockwise":
                            return e.angleLerpClockwise(a, r, o, s);
                        case "anti-clockwise":
                            return e.angleLerpAntiClockwise(a, r, o, s)
                    }
                } else {
                    if (a === r) return a;
                    const s = e.normalize(t, l, d),
                        o = self.Ease.GetRuntimeEase(n.GetEase());
                    return e.angleLerp(a, r, o(s, 0, 1, 1))
                }
            }
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.PropertyTrackState.BooleanTypeAdapter = class BooleanTypeAdapter {
        constructor() {}
        static WillChange(e, t, n, s) {
            let o;
            switch (s) {
                case "behavior":
                    o = t.GetPropertyValueByIndex(e);
                    break;
                case "effect":
                    o = t[e];
                    break;
                case "instance-variable":
                    o = t.GetInstanceVariableValue(e);
                    break;
                case "plugin":
                    o = t.GetPropertyValueByIndex(e);
                    break
            }
            return !!o !== !!n
        }
        static Interpolate(e, t, n, s) {
            if (!n) {
                let e = s.GetPropertyTrackDataItem();
                const t = s.GetPropertyTrackData();
                return e = t.GetLastPropertyKeyframeDataItem(e), e.GetValueWithResultMode() ? 1 : 0
            }
            return t.GetValueWithResultMode() ? 1 : 0
        }
    }
}
"use strict";
{
    const s = self.C3,
        e = [0, 0, 0],
        t = [0, 0, 0],
        n = [0, 0, 0];
    s.PropertyTrackState.ColorTypeAdapter = class ColorTypeAdapter {
        constructor() {}
        static WillChange(s, o, i, a) {
            let r;
            switch (a) {
                case "behavior":
                    r = o.GetPropertyValueByIndex(s);
                    break;
                case "effect":
                    r = o[s];
                    break;
                case "instance-variable":
                    r = o.GetInstanceVariableValue(s);
                    break;
                case "plugin":
                    r = o.GetPropertyValueByIndex(s);
                    break
            }
            return Array.isArray(i) ? (e[0] = i[0], e[1] = i[1], e[2] = i[2]) : (n.parseCommaSeparatedRgb(i), e[0] = Math.floor(n.getR() * 255), e[1] = Math.floor(n.getG() * 255), e[2] = Math.floor(n.getB() * 255)), Array.isArray(r) ? (t[0] = r[0], t[1] = r[1], t[2] = r[2]) : (n.parseCommaSeparatedRgb(r), t[0] = Math.floor(n.getR() * 255), t[1] = Math.floor(n.getG() * 255), t[2] = Math.floor(n.getB() * 255)), e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2]
        }
        static Interpolate(t, n, o, i) {
            if (!o) {
                let t = i.GetPropertyTrackDataItem();
                const s = i.GetPropertyTrackData();
                t = s.GetLastPropertyKeyframeDataItem(t);
                const n = t.GetValueWithResultMode();
                return e[0] = n[0], e[1] = n[1], e[2] = n[2], e
            }
            let a = i.GetInterpolationMode();
            if (a === "default" && (a = "continuous"), a === "discrete") {
                const t = n.GetValueWithResultMode();
                return e[0] = t[0], e[1] = t[1], e[2] = t[2], e
            }
            if (a === "continuous" || a === "step") {
                if (a === "step") {
                    const e = i.GetTimeline().GetStep();
                    if (e !== 0) {
                        const n = 1 / e;
                        t = Math.floor(t * n) / n
                    }
                }
                const p = n.GetTime(),
                    j = o.GetTime(),
                    h = n.GetValueWithResultMode(),
                    u = o.GetValueWithResultMode(),
                    _ = s.normalize(t, p, j),
                    y = n.GetEase(),
                    r = h[0],
                    d = h[1],
                    l = h[2],
                    g = u[0],
                    v = u[1],
                    b = u[2],
                    m = self.Ease.GetRuntimeEase(y),
                    c = j - p,
                    f = c * _;
                return r === g ? e[0] = r : e[0] = m(f, r, g - r, c), d === v ? e[1] = d : e[1] = m(f, d, v - d, c), l === b ? e[2] = l : e[2] = m(f, l, b - l, c), e
            }
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.PropertyTrackState.TextTypeAdapter = class TextTypeAdapter {
        constructor() {}
        static WillChange(e, t, n, s) {
            let o;
            switch (s) {
                case "behavior":
                    o = t.GetPropertyValueByIndex(e);
                    break;
                case "effect":
                    o = t[e];
                    break;
                case "instance-variable":
                    o = t.GetInstanceVariableValue(e);
                    break;
                case "plugin":
                    o = t.GetPropertyValueByIndex(e);
                    break
            }
            return o !== n
        }
        static Interpolate(e, t, n, s) {
            if (!n) {
                let e = s.GetPropertyTrackDataItem();
                const t = s.GetPropertyTrackData();
                return e = t.GetLastPropertyKeyframeDataItem(e), e.GetValueWithResultMode()
            }
            return t.GetValueWithResultMode()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.TimelineDataManager = class TimelineDataManager {
        constructor() {
            this._timelineDataItems = new Map
        }
        Release() {
            for (const e of this._timelineDataItems.values()) e.Release();
            this._timelineDataItems.clear(), this._timelineDataItems = null
        }
        Add(t) {
            const n = new e.TimelineDataItem(t),
                s = n.GetName();
            this._timelineDataItems.set(s, n)
        }
        Get(e) {
            return this._timelineDataItems.get(e)
        }
        GetNameId() {
            return 0
        }
        static _CreateDataItems(t, n, s, o) {
            if (!n) return;
            for (const i of n) e.TimelineDataManager._CreateDataItem("create", i, t, s, o)
        }
        static _LoadDataItemsFromJson(t, n, s, o) {
            t.length ? n.forEach((e, n) => {
                t[n]._LoadFromJson(e)
            }) : n.forEach(n => {
                e.TimelineDataManager._CreateDataItem("load", n, t, s, o)
            })
        }
        static _CreateDataItem(e, t, n, s, o) {
            let i;
            if (typeof s == "function") switch (e) {
                case "load":
                    i = new s(null, o);
                    break;
                case "create":
                    i = new s(t, o);
                    break
            } else if (typeof s == "object") {
                const a = s.prop,
                    r = t[a],
                    n = s.map.get(r);
                switch (e) {
                    case "load":
                        i = new n(null, o);
                        break;
                    case "create":
                        i = new n(t, o);
                        break
                }
            } switch (e) {
                case "load":
                    i._LoadFromJson(t), n.push(i);
                    break;
                case "create":
                    if (typeof i.GetEnable == "function" && !i.GetEnable()) return i.Release();
                    n.push(i);
                    break
            }
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = 0,
        n = 1,
        s = 2,
        o = 3,
        i = 4,
        a = 5,
        r = 6,
        c = 7,
        l = 8;
    e.TimelineDataItem = class TimelineDataItem {
        constructor(d) {
            if (this._name = "", this._totalTime = NaN, this._step = 0, this._interpolationMode = "default", this._resultMode = "default", this._loop = !1, this._pingPong = !1, this._repeatCount = 1, this._trackData = null, !d) return;
            this._name = d[t], this._totalTime = d[n], this._step = d[s], this._interpolationMode = d[o], this._resultMode = d[i], this._loop = !!d[r], this._pingPong = !!d[c], this._repeatCount = d[l], this._trackData = new e.TrackData(d[a], this)
        }
        Release() {
            this._trackData.Release(), this._trackData = null
        }
        GetTrackData() {
            return this._trackData || (this._trackData = new e.TrackData(null, this)), this._trackData
        }
        GetName() {
            return this._name
        }
        SetName(e) {
            this._name = e
        }
        GetTotalTime() {
            return this._totalTime
        }
        SetTotalTime(e) {
            this._totalTime = e
        }
        GetStep() {
            return this._step
        }
        SetStep(e) {
            this._step = e
        }
        GetInterpolationMode() {
            return this._interpolationMode
        }
        SetInterpolationMode(e) {
            this._interpolationMode = e
        }
        GetResultMode() {
            return this._resultMode
        }
        SetResultMode(e) {
            this._resultMode = e
        }
        GetLoop() {
            return this._loop
        }
        SetLoop(e) {
            this._loop = e
        }
        GetPingPong() {
            return this._pingPong
        }
        SetPingPong(e) {
            this._pingPong = e
        }
        GetRepeatCount() {
            return this._repeatCount
        }
        _SaveToJson() {
            return {
                trackDataJson: this._trackData._SaveToJson(),
                name: this._name,
                totalTime: this._totalTime,
                step: this._step,
                interpolationMode: this._interpolationMode,
                resultMode: this._resultMode,
                loop: this._loop,
                pingPong: this._pingPong,
                repeatCount: this._repeatCount
            }
        }
        _LoadFromJson(e) {
            if (!e) return;
            this.GetTrackData()._LoadFromJson(e.trackDataJson), this._name = e.name, this._totalTime = e.totalTime, this._step = e.step, this._interpolationMode = e.interpolationMode, this._resultMode = e.resultMode, this._loop = e.loop, this._pingPong = e.pingPong, this._repeatCount = e.repeatCount
        }
    }
}
"use strict";
{
    const e = self.C3,
        n = 0,
        g = 1,
        p = 2,
        d = 1,
        f = 2,
        m = 3,
        h = 4,
        u = 5,
        l = 6,
        t = 7,
        c = 0,
        r = 1,
        a = 8,
        i = 0,
        o = 1;
    class s {
        constructor(s, o) {
            if (this._trackData = o, this._instanceData = null, this._additionalInstanceData = null, this._instanceUid = NaN, this._objectClassIndex = NaN, this._interpolationMode = "default", this._resultMode = "default", this._enabled = !1, this._keyframeData = null, this._propertyTrackData = null, this._id = "", this._nestedData = null, this._startOffset = 0, this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime(), !s) return;
            this._instanceData = s[n], this._instanceUid = s[n][p], this._objectClassIndex = s[n][g], this._interpolationMode = s[d], this._resultMode = s[f], this._enabled = !!s[m], s[l] && (this._id = s[l]), s[t] && (this._nestedData = s[t], this._startOffset = s[t][c], this._localTotalTime = s[t][r]), s[a] && (this._additionalInstanceData = s[a]), this._keyframeData = new e.KeyframeData(s[h], this), this._propertyTrackData = new e.PropertyTrackData(s[u], this)
        }
        Release() {
            this._instanceData = null, this._trackData = null, this._keyframeData && (this._keyframeData.Release(), this._keyframeData = null), this._propertyTrackData && (this._propertyTrackData.Release(), this._propertyTrackData = null), this._nestedData = null
        }
        GetTrackData() {
            return this._trackData
        }
        GetKeyframeData() {
            return this._keyframeData || (this._keyframeData = new e.KeyframeData(null, this)), this._keyframeData
        }
        GetPropertyTrackData() {
            return this._propertyTrackData || (this._propertyTrackData = new e.PropertyTrackData(null, this)), this._propertyTrackData
        }
        GetInstanceData() {
            return this._instanceData
        }
        GetObjectClassIndex() {
            return this._objectClassIndex
        }
        SetObjectClassIndex(e) {
            this._objectClassIndex = e
        }
        GetInstanceUID() {
            return this._instanceUid
        }
        SetInstanceUID(e) {
            this._instanceUid = e
        }
        GetInterpolationMode() {
            return this._interpolationMode
        }
        SetInterpolationMode(e) {
            this._interpolationMode = e
        }
        GetResultMode() {
            return this._resultMode
        }
        SetResultMode(e) {
            this._resultMode = e
        }
        GetEnable() {
            return this._enabled
        }
        SetEnable(e) {
            this._enabled = !!e
        }
        GetId() {
            return this._id
        }
        GetStartOffset() {
            return this._startOffset
        }
        GetLocalTotalTime() {
            return this._localTotalTime
        }
        GetOriginalWidth() {
            return this._additionalInstanceData[i]
        }
        SetOriginalWidth(e) {
            this._additionalInstanceData || (this._additionalInstanceData = []), this._additionalInstanceData[i] = e
        }
        GetOriginalHeight() {
            return this._additionalInstanceData || (this._additionalInstanceData = []), this._additionalInstanceData[o]
        }
        SetOriginalHeight(e) {
            this._additionalInstanceData || (this._additionalInstanceData = []), this._additionalInstanceData[o] = e
        }
        _SaveToJson() {
            return {
                keyframeDataJson: this._keyframeData._SaveToJson(),
                propertyTrackDataJson: this._propertyTrackData._SaveToJson(),
                instanceData: this._instanceData,
                additionalInstanceData: this._additionalInstanceData,
                instanceUid: this._instanceUid,
                objectClassIndex: this._objectClassIndex,
                interpolationMode: this._interpolationMode,
                resultMode: this._resultMode,
                enabled: this._enabled,
                id: this._id,
                nestedData: this._nestedData
            }
        }
        _LoadFromJson(e) {
            if (!e) return;
            this._instanceData = e.instanceData, this._instanceUid = e.instanceUid, this._objectClassIndex = e.objectClassIndex, this._interpolationMode = e.interpolationMode, this._resultMode = e.resultMode, this._enabled = e.enabled, this._id = e.id, this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime(), e.nestedData && (this._nestedData = e.nestedData, this._startOffset = this._nestedData[c], this._localTotalTime = this._nestedData[r]), e.additionalInstanceData && (this._additionalInstanceData = e.additionalInstanceData), this.GetKeyframeData()._LoadFromJson(e.keyframeDataJson), this.GetPropertyTrackData()._LoadFromJson(e.propertyTrackDataJson)
        }
    }
    e.TrackData = class TrackData {
        constructor(t, n) {
            this._timelineDataItem = n, this._trackDataItems = [], this._keyframeTimeMap = new Map, e.TimelineDataManager._CreateDataItems(this._trackDataItems, t, s, this)
        }
        Release() {
            this._timelineDataItem = null;
            for (const e of this._trackDataItems) e.Release();
            e.clearArray(this._trackDataItems), this._trackDataItems = null, this._keyframeTimeMap.clear(), this._keyframeTimeMap = null
        }
        GetTimelineDataItem() {
            return this._timelineDataItem
        }
        AddEmptyTrackDataItem() {
            const e = new s(null, this);
            return this._trackDataItems.push(e), e
        }
        GetFirstKeyframeDataItem(e) {
            return e.GetKeyframeData().GetKeyframeDataItemArray()[0]
        }
        GetLastKeyframeDataItem(e) {
            const t = e.GetKeyframeData().GetKeyframeDataItemArray();
            return t[t.length - 1]
        }
        GetKeyFrameDataItemAtTime(e, t) {
            const n = this._keyframeTimeMap.get(t);
            if (!!n && n.has(e)) return n.get(e);
            for (const s of t.GetKeyframeData().keyframeDataItems())
                if (s.GetTime() === e) return n || this._keyframeTimeMap.set(t, new Map), this._keyframeTimeMap.get(t).set(e, s), s
        }
        GetFirstKeyFrameDataItemHigherThan(e, t) {
            for (const n of t.GetKeyframeData().keyframeDataItems())
                if (n.GetTime() > e) return n
        }
        GetFirstKeyFrameDataItemHigherOrEqualThan(e, t) {
            for (const n of t.GetKeyframeData().keyframeDataItems())
                if (n.GetTime() >= e) return n
        }
        GetFirstKeyFrameDataItemLowerOrEqualThan(e, t) {
            for (const n of t.GetKeyframeData().keyframeDataItemsReverse())
                if (n.GetTime() <= e) return n
        }* trackDataItems() {
            for (const e of this._trackDataItems) yield e
        }
        _SaveToJson() {
            return {
                trackDataItemsJson: this._trackDataItems.map(e => e._SaveToJson())
            }
        }
        _LoadFromJson(t) {
            if (!t) return;
            e.TimelineDataManager._LoadDataItemsFromJson(this._trackDataItems, t.trackDataItemsJson, s, this)
        }
    }
}
"use strict";
{
    const e = self.C3,
        n = 0,
        s = 0,
        o = 1,
        i = 2,
        a = 3,
        r = 4,
        c = 5,
        l = 6,
        d = 7,
        u = 8;
    class t {
        constructor(t, h) {
            if (this._propertyTrackData = h, this._sourceAdapterId = "", this._sourceAdapterArguments = null, this._property = null, this._type = null, this._min = NaN, this._max = NaN, this._interpolationMode = "default", this._resultMode = "default", this._enabled = !1, this._propertyKeyframeData = null, !t) return;
            this._sourceAdapterId = t[n][s], this._sourceAdapterArguments = t[n].slice(1), this._property = t[o], this._type = t[i], this._min = t[a], this._max = t[r], this._interpolationMode = t[c], this._resultMode = t[l], this._enabled = !!t[d], this._propertyKeyframeData = new e.PropertyKeyframeData(t[u], this)
        }
        Release() {
            this._propertyKeyframeData.Release(), this._propertyKeyframeData = null, this._propertyTrackData = null, this._sourceAdapterArguments = null
        }
        GetPropertyTrackData() {
            return this._propertyTrackData
        }
        GetPropertyKeyframeData() {
            return this._propertyKeyframeData || (this._propertyKeyframeData = new e.PropertyKeyframeData(null, this)), this._propertyKeyframeData
        }
        GetSourceAdapterId() {
            return this._sourceAdapterId
        }
        SetSourceAdapterId(e) {
            this._sourceAdapterId = e
        }
        GetSourceAdapterArguments() {
            return this._sourceAdapterArguments
        }
        SetSourceAdapterArguments(e) {
            this._sourceAdapterArguments = e
        }
        GetProperty() {
            return this._property
        }
        SetProperty(e) {
            this._property = e
        }
        GetType() {
            return this._type
        }
        SetType(e) {
            this._type = e
        }
        GetMin() {
            return this._min
        }
        SetMin(e) {
            this._min = e
        }
        GetMax() {
            return this._max
        }
        SetMax(e) {
            this._max = e
        }
        GetInterpolationMode() {
            return this._interpolationMode
        }
        SetInterpolationMode(e) {
            this._interpolationMode = e
        }
        GetResultMode() {
            return this._resultMode
        }
        SetResultMode(e) {
            this._resultMode = e
        }
        GetEnable() {
            return this._enabled
        }
        SetEnable(e) {
            this._enabled = !!e
        }
        _SaveToJson() {
            return {
                propertyKeyframeDataJson: this._propertyKeyframeData._SaveToJson(),
                sourceAdapterId: this._sourceAdapterId,
                sourceAdapterArguments: this._sourceAdapterArguments,
                property: this._property,
                type: this._type,
                min: this._min,
                max: this._max,
                interpolationMode: this._interpolationMode,
                resultMode: this._resultMode,
                enabled: this._enabled
            }
        }
        _LoadFromJson(e) {
            if (!e) return;
            this._sourceAdapterId = e.sourceAdapterId, this._sourceAdapterArguments = e.sourceAdapterArguments, this._property = e.property, this._type = e.type, this._min = e.min, this._max = e.max, this._interpolationMode = e.interpolationMode, this._resultMode = e.resultMode, this._enabled = e.enabled, this.GetPropertyKeyframeData()._LoadFromJson(e.propertyKeyframeDataJson)
        }
    }
    e.PropertyTrackData = class PropertyTrackData {
        constructor(n, s) {
            this._trackDataItem = s, this._propertyTrackDataItems = [], this._propertyKeyframeTimeMap = new Map, e.TimelineDataManager._CreateDataItems(this._propertyTrackDataItems, n, t, this)
        }
        Release() {
            this._trackDataItem = null;
            for (const e of this._propertyTrackDataItems) e.Release();
            e.clearArray(this._propertyTrackDataItems), this._propertyTrackDataItems = null, this._propertyKeyframeTimeMap.clear(), this._propertyKeyframeTimeMap = null
        }
        GetTrackDataItem() {
            return this._trackDataItem
        }
        AddEmptyPropertyTrackDataItem() {
            const e = new t(null, this);
            return this._propertyTrackDataItems.push(e), e
        }
        GetFirstPropertyKeyframeDataItem(e) {
            const t = e.GetPropertyKeyframeData();
            return t.GetPropertyKeyframeDataItemArray()[0]
        }
        GetLastPropertyKeyframeDataItem(e) {
            const n = e.GetPropertyKeyframeData(),
                t = n.GetPropertyKeyframeDataItemArray();
            return t[t.length - 1]
        }
        GetPropertyKeyFrameDataItemAtTime(e, t) {
            const n = this._propertyKeyframeTimeMap.get(t);
            if (!!n && n.has(e)) return n.get(e);
            const s = t.GetPropertyKeyframeData();
            for (const o of s.propertyKeyframeDataItems())
                if (o.GetTime() === e) return n || this._propertyKeyframeTimeMap.set(t, new Map), this._propertyKeyframeTimeMap.get(t).set(e, o), o
        }
        GetFirstPropertyKeyFrameDataItemHigherThan(e, t) {
            const n = t.GetPropertyKeyframeData();
            for (const t of n.propertyKeyframeDataItems())
                if (t.GetTime() > e) return t
        }
        GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, t) {
            const n = t.GetPropertyKeyframeData();
            for (const t of n.propertyKeyframeDataItems())
                if (t.GetTime() >= e) return t
        }
        GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, t) {
            const n = t.GetPropertyKeyframeData();
            for (const t of n.propertyKeyframeDataItemsReverse())
                if (t.GetTime() <= e) return t
        }* propertyTrackDataItems() {
            for (const e of this._propertyTrackDataItems) yield e
        }
        _SaveToJson() {
            return {
                propertyTrackDataItemsJson: this._propertyTrackDataItems.map(e => e._SaveToJson())
            }
        }
        _LoadFromJson(n) {
            if (!n) return;
            e.TimelineDataManager._LoadDataItemsFromJson(this._propertyTrackDataItems, n.propertyTrackDataItemsJson, t, this)
        }
    }
}
"use strict";
{
    const e = self.C3,
        n = 0,
        s = 1,
        o = 2,
        i = 3;
    class t {
        constructor(e, t) {
            if (this._keyframeData = t, this._time = -1, this._ease = "noease", this._enable = !1, this._tags = null, this._lowerTags = null, !e) return;
            this._time = e[n], this._ease = e[s], this._enable = !!e[o];
            const a = e[i];
            this._tags = a ? a.split(" ") : [], this._lowerTags = new Set(this._tags.map(e => e.toLowerCase()))
        }
        Release() {
            this._keyframeData = null, e.clearArray(this._tags), this._tags = null, this._lowerTags.clear(), this._lowerTags = null
        }
        GetKeyframeData() {
            return this._keyframeData
        }
        GetTime() {
            return this._time
        }
        SetTime(e) {
            this._time = e
        }
        GetEase() {
            return this._ease
        }
        SetEase(e) {
            this._ease = e
        }
        GetEnable() {
            return this._enable
        }
        SetEnable(e) {
            this._enable = !!e
        }
        GetTags() {
            return this._tags
        }
        SetTags(e) {
            this._tags = e ? e.split(" ") : [], this._lowerTags = new Set(this._tags.map(e => e.toLowerCase()))
        }
        GetLowerTags() {
            return this._lowerTags
        }
        HasTag(e) {
            return this._lowerTags.has(e.toLowerCase())
        }
        _SaveToJson() {
            return {
                time: this._time,
                ease: this._ease,
                enable: this._enable,
                tags: this._tags
            }
        }
        _LoadFromJson(e) {
            if (!e) return;
            this._time = e.time, this._ease = e.ease, this._enable = e.enable, this._tags = e.tags, this._lowerTags = new Set(this._tags.map(e => e.toLowerCase()))
        }
    }
    e.KeyframeData = class KeyframeData {
        constructor(n, s) {
            this._trackDataItem = s, this._keyframeDataItems = [], e.TimelineDataManager._CreateDataItems(this._keyframeDataItems, n, t, this)
        }
        Release() {
            this._trackDataItem = null;
            for (const e of this._keyframeDataItems) e.Release();
            e.clearArray(this._keyframeDataItems), this._keyframeDataItems = null
        }
        GetTrackDataItem() {
            return this._trackDataItem
        }
        GetKeyframeDataItemCount() {
            return this._keyframeDataItems.length
        }
        GetKeyframeDataItemArray() {
            return this._keyframeDataItems
        }
        AddEmptyKeyframeDataItem() {
            const e = new t(null, this);
            return this._keyframeDataItems.push(e), e
        }
        DeleteKeyframeDataItems(e) {
            for (const t of this._keyframeDataItems) {
                if (!e(t)) continue;
                const n = this._keyframeDataItems.indexOf(t);
                if (n === -1) continue;
                t.Release(), this._keyframeDataItems.splice(n, 1)
            }
            this.SortKeyframeDataItems()
        }
        SortKeyframeDataItems() {
            this._keyframeDataItems.sort((e, t) => e.GetTime() - t.GetTime())
        }
        GetKeyframeDataItemIndex(e) {
            return this._keyframeDataItems.indexOf(e)
        }
        GetKeyframeDataItemFromIndex(e) {
            return this._keyframeDataItems[e]
        }* keyframeDataItems() {
            for (const e of this._keyframeDataItems) yield e
        }* keyframeDataItemsReverse() {
            for (let e = this._keyframeDataItems.length - 1; e >= 0; e--) yield this._keyframeDataItems[e]
        }
        _SaveToJson() {
            return {
                keyframeDataItemsJson: this._keyframeDataItems.map(e => e._SaveToJson())
            }
        }
        _LoadFromJson(n) {
            if (!n) return;
            e.TimelineDataManager._LoadDataItemsFromJson(this._keyframeDataItems, n.keyframeDataItemsJson, t, this)
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = 0,
        o = 0,
        i = 1,
        a = 2,
        r = 1,
        c = 2,
        l = 3,
        s = 4;
    class n {
        constructor(n, d) {
            if (this._propertyKeyframeData = d, this._value = null, this._aValue = null, this._type = "", this._time = NaN, this._ease = "noease", this._enable = !1, this._addonData = null, !n) return;
            this._value = n[t][o], this._aValue = n[t][i], this._type = n[t][a], this._time = n[r], this._ease = n[c], this._enable = !!n[l], this._addonData = null, !n[s] || (this._addonData = new e.AddonData(n[s], this))
        }
        Release() {
            this._propertyKeyframeData = null, this._addonData && (this._addonData.Release(), this._addonData = null)
        }
        GetAddonData() {
            return this._addonData
        }
        GetValue() {
            return this._value
        }
        SetValue(t) {
            this._type === "color" && e.IsFiniteNumber(t) ? (this._value[0] = e.GetRValue(t), this._value[1] = e.GetGValue(t), this._value[2] = e.GetBValue(t)) : this._value = t
        }
        GetAbsoluteValue() {
            return this._aValue
        }
        SetAbsoluteValue(t) {
            this._type === "color" && e.IsFiniteNumber(t) ? (this._aValue[0] = e.GetRValue(t), this._aValue[1] = e.GetGValue(t), this._aValue[2] = e.GetBValue(t)) : this._aValue = t
        }
        GetValueWithResultMode() {
            const e = this._propertyKeyframeData.GetPropertyTrackDataItem().GetResultMode();
            if (e === "relative") return this.GetValue();
            if (e === "absolute") return this.GetAbsoluteValue()
        }
        GetType() {
            return this._type
        }
        SetType(e) {
            this._type = e
        }
        GetTime() {
            return this._time
        }
        SetTime(e) {
            this._time = e
        }
        GetEase() {
            return this._ease
        }
        SetEase(e) {
            this._ease = e
        }
        GetEnable() {
            return this._enable
        }
        SetEnable(e) {
            this._enable = !!e
        }
        GetAddOn(e) {
            if (!this.GetAddonData()) return;
            for (const t of this.GetAddonData().addonDataItems())
                if (t.GetId() === e) return t
        }
        _SaveToJson() {
            const e = this._addonData;
            return {
                addonDataJson: e && e._SaveToJson(),
                value: this._value,
                aValue: this._aValue,
                type: this._type,
                time: this._time,
                ease: this._ease,
                enable: this._enable
            }
        }
        _LoadFromJson(e) {
            if (!e) return;
            e.addonDataJson && this._addonData._SetFromJson(e.addonDataJson), this._value = e.value, this._aValue = e.aValue, this._type = e.type, this._time = e.time, this._ease = e.ease, this._enable = e.enable
        }
    }
    e.PropertyKeyframeData = class PropertyKeyframeData {
        constructor(t, s) {
            this._propertyTrackDataItem = s, this._propertyKeyframeDataItems = [], e.TimelineDataManager._CreateDataItems(this._propertyKeyframeDataItems, t, n, this)
        }
        Release() {
            this._propertyTrackDataItem = null;
            for (const e of this._propertyKeyframeDataItems) e.Release();
            e.clearArray(this._propertyKeyframeDataItems), this._propertyKeyframeDataItems = null
        }
        AddEmptyPropertyKeyframeDataItem() {
            const e = new n(null, this);
            return this._propertyKeyframeDataItems.push(e), e
        }
        DeletePropertyKeyframeDataItems(e) {
            for (const t of this._propertyKeyframeDataItems) {
                if (!e(t)) continue;
                const n = this._propertyKeyframeDataItems.indexOf(t);
                if (n === -1) continue;
                t.Release(), this._propertyKeyframeDataItems.splice(n, 1)
            }
            this.SortPropertyKeyFrameDataItems()
        }
        SortPropertyKeyFrameDataItems() {
            this._propertyKeyframeDataItems.sort((e, t) => e.GetTime() - t.GetTime())
        }
        GetPropertyTrackDataItem() {
            return this._propertyTrackDataItem
        }
        GetPropertyKeyframeDataItemCount() {
            return this._propertyKeyframeDataItems.length
        }
        GetPropertyKeyframeDataItemArray() {
            return this._propertyKeyframeDataItems
        }* propertyKeyframeDataItems() {
            for (const e of this._propertyKeyframeDataItems) yield e
        }* propertyKeyframeDataItemsReverse() {
            for (let e = this._propertyKeyframeDataItems.length - 1; e >= 0; e--) yield this._propertyKeyframeDataItems[e]
        }
        _SaveToJson() {
            return {
                propertyKeyframeDataItemsJson: this._propertyKeyframeDataItems.map(e => e._SaveToJson())
            }
        }
        _LoadFromJson(t) {
            if (!t) return;
            e.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItems, t.propertyKeyframeDataItemsJson, n, this)
        }
    }
}
"use strict";
{
    const e = self.C3,
        o = 0,
        i = 1;
    class t {
        constructor(e, t) {
            this._addonData = t, this._id = e[o], this._data = e[i]
        }
        Release() {
            this._addonData = null, this._data = null
        }
        GetAddonData() {
            return this._addonData
        }
        GetId() {
            return this._id
        }
        _SaveToJson() {
            return {
                id: this._id,
                data: this._data
            }
        }
        _LoadFromJson(e) {
            if (!e) return;
            this._id = e.id, this._data = e.data
        }
    }
    const a = 0,
        r = 1,
        c = 2,
        l = 3;
    class n extends t {
        constructor(e, t) {
            super(e, t), this._startAnchor = this._data[a], this._startEnable = !!this._data[r], this._endAnchor = this._data[c], this._endEnable = !!this._data[l]
        }
        Release() {
            super.Release()
        }
        GetStartAnchor() {
            return this._startAnchor
        }
        GetStartEnable() {
            return this._startEnable
        }
        GetEndAnchor() {
            return this._endAnchor
        }
        GetEndEnable() {
            return this._endEnable
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                startAnchor: this._startAnchor,
                startEnable: !!this._startEnable,
                endAnchor: this._endAnchor,
                endEnable: !!this._endEnable
            })
        }
        _LoadFromJson(e) {
            if (!e) return;
            super._LoadFromJson(e), this._startAnchor = e.startAnchor, this._startEnable = !!e.startEnable, this._endAnchor = e.endAnchor, this._endEnable = !!e.endEnable
        }
    }
    const d = 0,
        u = 1;
    class s extends t {
        constructor(e, t) {
            super(e, t), this._direction = this._data[d], this._revolutions = this._data[u]
        }
        Release() {
            super.Release()
        }
        GetDirection() {
            return this._direction
        }
        GetRevolutions() {
            return this._revolutions
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                direction: this._direction,
                revolutions: this._revolutions
            })
        }
        _LoadFromJson(e) {
            if (!e) return;
            super._LoadFromJson(e), this._direction = e.direction, this._revolutions = e.revolutions
        }
    }
    e.AddonData = class AddonData {
        constructor(t, o) {
            this._propertyKeyframeDataItem = o, this._addonDataItems = [], e.TimelineDataManager._CreateDataItems(this._addonDataItems, t, {
                prop: 0,
                map: new Map([
                    ["cubic-bezier", n],
                    ["angle", s]
                ])
            }, this)
        }
        Release() {
            this._propertyKeyframeDataItem = null;
            for (const e of this._addonDataItems) e.Release();
            e.clearArray(this._addonDataItems), this._addonDataItems = null
        }
        GetPropertyKeyframeDataItem() {
            return this._propertyKeyframeDataItem
        }* addonDataItems() {
            for (const e of this._addonDataItems) yield e
        }
        _SaveToJson() {
            return {
                addonDataItemsJson: this._addonDataItems.map(e => e._SaveToJson())
            }
        }
        _LoadFromJson(t) {
            if (!t) return;
            e.TimelineDataManager._LoadDataItemsFromJson(this._addonDataItems, t.addonDataItemsJson, {
                prop: "id",
                map: new Map([
                    ["cubic-bezier", n],
                    ["angle", s]
                ])
            }, this)
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = "start-value",
        n = "current-state";
    let s = 0;
    e.Tween = class Tween extends e.TimelineState {
        constructor(e, n) {
            super(`tween-${s++}`, e, n), this._id = "", this._destroyInstanceOnComplete = !1, this._initialValueMode = t, this._on_completed_callbacks = null, this._on_started_callbacks = null
        }
        GetInstance() {
            const e = this.GetTracks();
            if (!e || !e.length) return;
            const t = e[0];
            if (!t) return;
            const n = t.GetInstance();
            return t.IsInstanceValid() ? n : null
        }
        AddStartedCallback(e) {
            this._on_started_callbacks || (this._on_started_callbacks = []), this._on_started_callbacks.push(e)
        }
        AddCompletedCallback(e) {
            this._on_completed_callbacks || (this._on_completed_callbacks = []), this._on_completed_callbacks.push(e)
        }
        RemoveStartedCallback(e) {
            if (!this._on_started_callbacks) return;
            const t = this._on_started_callbacks.indexOf(e);
            t !== -1 && this._on_started_callbacks.splice(t, 1)
        }
        RemoveCompletedCallback(e) {
            if (!this._on_completed_callbacks) return;
            const t = this._on_completed_callbacks.indexOf(e);
            t !== -1 && this._on_completed_callbacks.splice(t, 1)
        }
        SetStartValue(e, t) {
            for (const n of this._tracks)
                for (const s of n._propertyTracks) {
                    if (s.GetPropertyName() !== t) continue;
                    const i = s.GetPropertyTrackData(),
                        a = s.GetPropertyTrackDataItem(),
                        o = i.GetFirstPropertyKeyframeDataItem(a);
                    o.SetValue(e), o.SetAbsoluteValue(e)
                }
        }
        _GetPropertyTrackState(e) {
            for (const t of this._tracks)
                for (const n of t._propertyTracks)
                    if (n.GetPropertyName() === e) return n
        }
        BeforeSetEndValues(e) {
            for (const t of e) {
                const n = this._GetPropertyTrackState(t);
                this.SetStartValue(n.GetCurrentState(), t)
            }
            this.IsForwardPlayBack() ? (this.SetTotalTime(this.GetTotalTime() - this.GetTime()), this._SetTime(0)) : (this.SetTotalTime(this.GetTime()), this._SetTime(this.GetTotalTime())), this.SetInitialStateFromSetTime()
        }
        SetEndValue(e, t) {
            const s = this._GetPropertyTrackState(t),
                o = s.GetPropertyTrackData(),
                i = s.GetPropertyTrackDataItem(),
                n = o.GetLastPropertyKeyframeDataItem(i);
            n.SetTime(this.GetTotalTime()), n.SetValue(e), n.SetAbsoluteValue(e)
        }
        SetId(e) {
            this._id = e
        }
        GetId() {
            return this._id
        }
        SetInitialValueMode(e) {
            this._initialValueMode = e
        }
        GetInitialValueMode() {
            return this._initialValueMode
        }
        SetDestroyInstanceOnComplete(e) {
            this._destroyInstanceOnComplete = e
        }
        GetDestroyInstanceOnComplete() {
            return this._destroyInstanceOnComplete
        }
        OnStarted() {
            if (this._on_started_callbacks)
                for (const e of this._on_started_callbacks) e(this);
            if (this.IsComplete()) return;
            for (const e of this._tracks) e.CompareSaveStateWithCurrent()
        }
        OnCompleted() {
            this._completedTick = this._runtime.GetTickCount()
        }
        FinishTriggers() {
            if (this._finishedTriggers) return;
            if (this._finishedTriggers = !0, this._on_completed_callbacks)
                for (const e of this._on_completed_callbacks) e(this)
        }
        SetTime(e) {
            this._DeleteIntermediateKeyframes(), super.SetTime(e)
        }
        SetInitialState(e) {
            if (!this.InitialStateSet() && this.GetInitialValueMode() === n)
                for (const e of this._tracks) e.CompareInitialStateWithCurrent();
            super.SetInitialState(e)
        }
        Stop(e = !1) {
            if (super.Stop(e), this.IsComplete()) return;
            for (const e of this._tracks) e.SaveState()
        }
        Reset(e = !0, t = !1) {
            this._DeleteIntermediateKeyframes(), super.Reset(e, t)
        }
        _DeleteIntermediateKeyframes() {
            for (const e of this._tracks) {
                const t = e => {
                    const t = e.GetTime(),
                        n = this.GetTotalTime();
                    return t !== 0 && t !== n
                };
                e.DeleteKeyframes(t), e.DeletePropertyKeyframes(t)
            }
        }
        _OnBeforeChangeLayout() {
            if (this.IsReleased()) return !0;
            const e = this.GetInstance();
            return !(e && e.GetObjectClass().IsGlobal()) && (this._timelineManager.CompleteTimeline(this), this.ResetBeforeChangeLayout(), !0)
        }
        MaybeTriggerKeyframeReachedConditions() {}
        Tick() {
            const n = this.GetInstance(),
                s = this.GetRuntime().GetDt(n);
            super.Tick(s, 1)
        }
        _SaveToJson() {
            const e = super._SaveToJson(),
                t = this.GetTimelineDataItem();
            return Object.assign(e, {
                tweenDataItemJson: t._SaveToJson(),
                id: this._id,
                destroyInstanceOnComplete: this._destroyInstanceOnComplete,
                initialValueMode: this._initialValueMode
            })
        }
        _LoadFromJson(e) {
            if (!e) return;
            const t = this.GetTimelineDataItem();
            t._LoadFromJson(e.tweenDataItemJson), super._LoadFromJson(e), this._id = e.id, this._destroyInstanceOnComplete = e.destroyInstanceOnComplete, this._initialValueMode = e.initialValueMode
        }
        static IsPlaying(e) {
            return e.IsPlaying()
        }
        static IsPaused(e) {
            return e.IsPaused()
        }
        static Build(t) {
            const r = t.runtime.GetTimelineManager(),
                a = new e.TimelineDataItem;
            if (t.json) {
                a._LoadFromJson(t.json.tweenDataItemJson);
                const n = new e.Tween(a, r);
                return n._LoadFromJson(t.json), n
            }
            const n = new e.Tween(a, r);
            e.IsArray(t.propertyTracksConfig) || (t.propertyTracksConfig = [t.propertyTracksConfig]), n.SetId(t.id), n.SetTags(t.tags), n.SetInitialValueMode(t.initialValueMode), n.SetDestroyInstanceOnComplete(t.releaseOnComplete), n.SetLoop(t.loop), n.SetPingPong(t.pingPong), n.SetTotalTime(t.time), n.SetStep(0), n.SetInterpolationMode("default"), n.SetResultMode(t.propertyTracksConfig[0].resultMode);
            const s = n.AddTrack();
            s.SetInstanceUID(t.instance.GetUID()), s.SetInterpolationMode("default"), s.SetResultMode(t.propertyTracksConfig[0].resultMode), s.SetEnable(!0), s.SetObjectClassIndex(t.instance.GetObjectClass().GetIndex()), s.SetOriginalWidth(t.instance.GetWorldInfo().GetWidth()), s.SetOriginalHeight(t.instance.GetWorldInfo().GetHeight());
            const o = s.AddKeyframe();
            o.SetTime(0), o.SetEase("noease"), o.SetEnable(!0), o.SetTags("");
            const i = s.AddKeyframe();
            i.SetTime(t.time), i.SetEase("noease"), i.SetEnable(!0), i.SetTags("");
            for (const e of t.propertyTracksConfig) {
                const n = s.AddPropertyTrack();
                n.SetSourceAdapterId(e.sourceId), n.SetSourceAdapterArgs(e.sourceArgs), n.SetPropertyName(e.property), n.SetPropertyType(e.type), n.SetMin(NaN), n.SetMax(NaN), n.SetInterpolationMode("default"), n.SetResultMode(e.resultMode), n.SetEnable(!0);
                const o = n.AddPropertyKeyframe();
                o.SetType(e.valueType), o.SetTime(0), o.SetEase(e.ease), o.SetEnable(!0), o.SetValue(e.startValue), o.SetAbsoluteValue(e.startValue);
                const i = n.AddPropertyKeyframe();
                i.SetType(e.valueType), i.SetTime(t.time), i.SetEase(e.ease), i.SetEnable(!0), i.SetValue(e.endValue), i.SetAbsoluteValue(e.endValue)
            }
            return n
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = self.Ease,
        n = 0,
        s = 1;
    e.Transition = class Transition extends e.DefendedBase {
        constructor(o) {
            super(), this._name = o[n], this._transitionKeyframes = [];
            for (const t of o[s]) {
                const n = e.TransitionKeyframe.Create(this, t);
                this._transitionKeyframes.push(n)
            }
            this._precalculatedSamples = new Map, this._transitionKeyframeCache = new Map, this._PreCalcSamples(), t.AddCustomEase(this._name, (e, t, n, s) => this.Interpolate(e, t, n, s))
        }
        static Create(t) {
            return e.New(e.Transition, t)
        }
        Release() {
            for (const e of this._transitionKeyframes) e.Release();
            e.clearArray(this._transitionKeyframes), this._transitionKeyframes = null, this._precalculatedSamples.clear(), this._precalculatedSamples = null, this._transitionKeyframeCache.clear(), this._transitionKeyframeCache = null
        }
        GetTransitionKeyFrameAt(e) {
            const t = this._transitionKeyframeCache.get(e);
            if (t) return t;
            for (const t of this._transitionKeyframes)
                if (t.GetValueX() === e) return this._transitionKeyframeCache.set(e, t), t
        }
        GetFirstTransitionKeyFrameHigherThan(e) {
            for (const t of this._transitionKeyframes)
                if (t.GetValueX() > e) return t
        }
        GetFirstTransitionKeyFrameHigherOrEqualThan(e) {
            for (const t of this._transitionKeyframes)
                if (t.GetValueX() >= e) return t
        }
        GetFirstTransitionKeyFrameLowerOrEqualThan(e) {
            for (let t = this._transitionKeyframes.length - 1; t >= 0; t--) {
                const n = this._transitionKeyframes[t];
                if (n.GetValueX() <= e) return n
            }
        }
        Interpolate(n, s, o, i) {
            const c = n / i;
            let a = this.GetTransitionKeyFrameAt(c),
                r = null;
            a ? r = this.GetFirstTransitionKeyFrameHigherThan(c) : (a = this.GetFirstTransitionKeyFrameLowerOrEqualThan(c), r = this.GetFirstTransitionKeyFrameHigherOrEqualThan(c));
            const j = r.GetValueX() - a.GetValueX(),
                h = e.mapToRange(c, a.GetValueX(), r.GetValueX(), 0, j),
                u = a.GetValueX(),
                d = a.GetValueY(),
                m = a.GetValueX() + a.GetStartAnchorX(),
                f = a.GetValueY() + a.GetStartAnchorY(),
                p = r.GetValueX() + r.GetEndAnchorX(),
                g = r.GetValueY() + r.GetEndAnchorY(),
                v = r.GetValueX(),
                b = r.GetValueY();
            let l = t.GetRuntimeEase("spline")(h, u, d, m, f, p, g, v, b, this._precalculatedSamples.get(a));
            return l += a.GetValueY(), (1 - l) * s + l * (s + o)
        }
        _PreCalcSamples() {
            this._precalculatedSamples.clear();
            for (let e = 0; e < this._transitionKeyframes.length - 1; e++) {
                const o = this._transitionKeyframes[e];
                if (!o.GetStartEnable()) continue;
                const n = o,
                    s = this._transitionKeyframes[e + 1],
                    i = n.GetValueX(),
                    a = n.GetValueX() + n.GetStartAnchorX(),
                    r = s.GetValueX() + s.GetEndAnchorX(),
                    c = s.GetValueX();
                this._precalculatedSamples.set(n, t.GetBezierSamples(i, a, r, c))
            }
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = 0,
        n = 1,
        s = 2,
        o = 3,
        i = 4,
        a = 5,
        r = 6,
        c = 7;
    e.TransitionKeyframe = class TransitionKeyframe extends e.DefendedBase {
        constructor(e, l) {
            super(), this._transition = e, this._valueX = l[t], this._valueY = l[n], this._startAnchorX = l[s], this._startAnchorY = l[o], this._endAnchorX = l[i], this._endAnchorY = l[a], this._startEnable = l[r], this._endEnable = l[c]
        }
        Release() {
            this._transition = null
        }
        static Create(t, n) {
            return e.New(e.TransitionKeyframe, t, n)
        }
        GetValueX() {
            return this._valueX
        }
        GetValueY() {
            return this._valueY
        }
        GetStartAnchorX() {
            return this._startAnchorX
        }
        GetStartAnchorY() {
            return this._startAnchorY
        }
        GetEndAnchorX() {
            return this._endAnchorX
        }
        GetEndAnchorY() {
            return this._endAnchorY
        }
        GetStartEnable() {
            return this._startEnable
        }
        GetEndEnable() {
            return this._endEnable
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.TransitionManager = class TransitionManager extends e.DefendedBase {
        constructor(e) {
            super(), this._runtime = e, this._transitions = []
        }
        Release() {
            for (const e of this._transitions) e.Release();
            e.clearArray(this._transitions), this._transitions = null
        }
        Create(t) {
            this._transitions.push(e.Transition.Create(t))
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.SolStack = class SolStack extends e.DefendedBase {
        constructor(t) {
            super(), this._objectClass = t, this._stack = [], this._stack.push(e.New(e.Sol, this)), this._index = 0, this._current = this._stack[0]
        }
        Release() {
            for (const e of this._stack) e.Release();
            e.clearArray(this._stack), this._current = null, this._objectClass = null
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetCurrentSol() {
            return this._current
        }
        Clear() {
            this.GetCurrentSol().Clear()
        }
        PushClean() {
            const t = this._stack,
                n = ++this._index;
            if (n === t.length) {
                const n = e.New(e.Sol, this);
                t.push(n), this._current = n
            } else {
                const e = t[n];
                e.Reset(), this._current = e
            }
        }
        PushCopy() {
            const t = this._stack,
                n = ++this._index;
            n === t.length && t.push(e.New(e.Sol, this));
            const s = t[n];
            s.Copy(t[n - 1]), this._current = s
        }
        Pop() {
            this._current = this._stack[--this._index]
        }
        RemoveInstances(e) {
            const t = this._stack;
            for (let n = 0, s = t.length; n < s; ++n) t[n].RemoveInstances(e)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Sol = class Sol extends e.DefendedBase {
        constructor(e) {
            super(), this._stack = e, this._objectClass = this._stack.GetObjectClass(), this._eventStack = this._objectClass.GetRuntime().GetEventStack(), this._selectAll = !0, this._instances = [], this._elseInstances = []
        }
        Release() {
            this.ClearArrays(), this._stack = null, this._objectClass = null, this._eventStack = null
        }
        ClearArrays() {
            e.clearArray(this._instances), e.clearArray(this._elseInstances)
        }
        GetObjectClass() {
            return this._objectClass
        }
        IsSelectAll() {
            return this._selectAll
        }
        HasAnyInstances() {
            return this._selectAll ? !!this._objectClass.GetInstanceCount() : !!this._instances.length
        }
        GetInstances() {
            return this._selectAll ? this._objectClass.GetInstances() : this._instances
        }
        HasAnyElseInstances() {
            return !!this._elseInstances.length
        }
        GetElseInstances() {
            return this._elseInstances
        }
        GetExpressionInstances() {
            const e = this.GetInstances();
            return e.length ? e : this._elseInstances
        }
        Reset() {
            this._selectAll = !0, e.clearArray(this._elseInstances)
        }
        Clear() {
            this._selectAll = !0
        }
        Copy(t) {
            t.IsSelectAll() ? this.Reset() : (this._selectAll = !1, e.shallowAssignArray(this._instances, t._instances), e.clearArray(this._elseInstances))
        }
        _PushInstance(e) {
            this._instances.push(e)
        }
        _PushElseInstance(e) {
            this._elseInstances.push(e)
        }
        _SetSelectAll(e) {
            this._selectAll = !!e
        }
        _GetOwnInstances() {
            return this._instances
        }
        _GetOwnElseInstances() {
            return this._elseInstances
        }
        SetSinglePicked(t) {
            this._selectAll = !1, e.clearArray(this._instances), this._instances.push(t)
        }
        SetArrayPicked(t) {
            this._selectAll = !1, e.shallowAssignArray(this._instances, t)
        }
        SetSetPicked(t) {
            this._selectAll = !1, e.clearArray(this._instances);
            for (const e of t) this._instances.push(e)
        }
        AddElseInstances(e, t) {
            for (const n of t) e.has(n) || this._elseInstances.push(n)
        }
        TransferElseInstancesToOwn(t) {
            for (const e of t) this._instances.push(e);
            e.arrayRemoveAllInSet(this._elseInstances, t)
        }
        PickOne(t) {
            if (!t) return;
            if (this._eventStack.GetCurrentStackFrame().GetCurrentEvent().IsOrBlock()) {
                this.IsSelectAll() && (e.clearArray(this._instances), e.shallowAssignArray(this._elseInstances, t.GetObjectClass().GetInstances()), this._selectAll = !1);
                const n = this._elseInstances.indexOf(t);
                n !== -1 && (this._instances.push(this._elseInstances[n]), this._elseInstances.splice(n, 1))
            } else this.SetSinglePicked(t)
        }
        RemoveInstances(t) {
            e.arrayRemoveAllInSet(this._instances, t), e.arrayRemoveAllInSet(this._elseInstances, t)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.EventStack = class EventStack extends e.DefendedBase {
        constructor(t) {
            super(), this._eventSheetManager = t, this._runtime = this._eventSheetManager.GetRuntime(), this._stack = [], this._stack.push(e.New(e.EventStackFrame, this, null)), this._index = 0, this._expFuncStack = []
        }
        Release() {
            for (const e of this._stack) e.Release();
            e.clearArray(this._stack), e.clearArray(this._expFuncStack), this._eventSheetManager = null, this._runtime = null
        }
        GetEventSheetManager() {
            return this._eventSheetManager
        }
        GetRuntime() {
            return this._runtime
        }
        GetCurrentStackFrame() {
            return this._stack[this._index]
        }
        Push(t) {
            const n = this._stack,
                s = ++this._index;
            if (s === n.length) {
                const s = e.New(e.EventStackFrame, this, t);
                return n.push(s), s
            }
            const o = n[s];
            return o.Reset(t), o
        }
        Pop() {
            --this._index
        }
        PushExpFunc(e) {
            this._expFuncStack.push(e)
        }
        PopExpFunc() {
            this._expFuncStack.pop()
        }
        GetCurrentExpFuncStackFrame() {
            const e = this._expFuncStack;
            return e.length === 0 ? null : e[e.length - 1]
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.EventStackFrame = class EventStackFrame extends e.DefendedBase {
        constructor(e, t) {
            super(), this._stack = e, this._runtime = this._stack.GetRuntime(), this._currentEvent = t, this._cndIndex = 0, this._actIndex = 0, this._lastEventTrue = !1, this._elseBranchRan = !1, this._expressionObjectClass = null, this._functionReturnType = 0, this._functionReturnValue = 0
        }
        Release() {
            this.Reset(null), this._stack = null, this._runtime = null
        }
        Reset(e) {
            this._currentEvent = e, this._cndIndex = 0, this._actIndex = 0, this._lastEventTrue = !1, this._elseBranchRan = !1
        }
        _Restore(e, t) {
            this._currentEvent = e, this._cndIndex = 0, this._actIndex = t
        }
        ResetQuick() {
            this._cndIndex = 0, this._actIndex = 0
        }
        GetCurrentEvent() {
            return this._currentEvent
        }
        SetCurrentEvent(e) {
            this._currentEvent = e
        }
        GetConditionIndex() {
            return this._cndIndex
        }
        SetConditionIndex(e) {
            this._cndIndex = e
        }
        GetActionIndex() {
            return this._actIndex
        }
        SetActionIndex(e) {
            this._actIndex = e
        }
        SetLastEventTrue(e) {
            this._lastEventTrue = !!e
        }
        GetLastEventTrue() {
            return this._lastEventTrue
        }
        SetElseBranchRan(e) {
            this._elseBranchRan = !!e
        }
        GetElseBranchRan() {
            return this._elseBranchRan
        }
        SetExpressionObjectClass(e) {
            this._expressionObjectClass = e
        }
        GetExpressionObjectClass() {
            return this._expressionObjectClass
        }
        InitCallFunctionExpression(e, t) {
            this._functionReturnType = e, this._functionReturnValue = t
        }
        GetFunctionReturnType() {
            return this._functionReturnType
        }
        SetFunctionReturnValue(e) {
            this._functionReturnValue = e
        }
        GetFunctionReturnValue() {
            return this._functionReturnValue
        }
        IsSolModifierAfterCnds() {
            const e = this._currentEvent;
            return !!e.IsSolWriterAfterCnds() || this._cndIndex < e.GetConditionCount() - 1 && !!e.GetSolModifiers().length
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.LocalVarStack = class LocalVarStack extends e.DefendedBase {
        constructor(e) {
            super(), this._eventSheetManager = e, this._runtime = this._eventSheetManager.GetRuntime(), this._stack = [], this._index = -1, this._current = null, this._initialValues = []
        }
        Release() {
            e.clearArray(this._stack), this._eventSheetManager = null, this._runtime = null
        }
        _SetInitialValues(e) {
            this._initialValues = e;
            const t = this._initialValues.slice(0);
            this._stack.push(t), this._index = 0, this._current = t
        }
        GetEventSheetManager() {
            return this._eventSheetManager
        }
        GetRuntime() {
            return this._runtime
        }
        GetCurrent() {
            return this._current
        }
        Push() {
            const n = ++this._index,
                t = this._stack;
            n === t.length ? t.push(this._initialValues.slice(0)) : e.shallowAssignArray(t[n], this._initialValues), this._current = t[n]
        }
        Pop() {
            this._current = this._stack[--this._index]
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.LoopStack = class LoopStack extends e.DefendedBase {
        constructor(e) {
            super(), this._eventSheetManager = e, this._runtime = this._eventSheetManager.GetRuntime(), this._stack = [], this._index = -1
        }
        Release() {
            e.clearArray(this._stack), this._eventSheetManager = null, this._runtime = null
        }
        GetEventSheetManager() {
            return this._eventSheetManager
        }
        GetRuntime() {
            return this._runtime
        }
        IsInLoop() {
            return this._index >= 0
        }
        GetCurrent() {
            return this._stack[this._index]
        }
        Push() {
            if (++this._index, this._index === this._stack.length) {
                const t = e.New(e.Loop, this);
                return this._stack.push(t), t
            }
            const t = this._stack[this._index];
            return t.Reset(), t
        }
        Pop() {
            --this._index
        }
        FindByName(e) {
            const t = this._stack;
            for (let n = this._index; n >= 0; --n) {
                const s = t[n];
                if (s.GetName() === e) return s
            }
            return null
        }
        _GetStack() {
            return this._stack.slice(0, this._index + 1)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Loop = class Loop extends e.DefendedBase {
        constructor(e) {
            super(), this._loopStack = e, this._name = "", this._index = 0, this._isStopped = !1, this._end = NaN
        }
        Reset() {
            this._name = "", this._index = 0, this._isStopped = !1, this._end = NaN
        }
        SetName(e) {
            this._name = e
        }
        GetName() {
            return this._name
        }
        SetIndex(e) {
            this._index = e
        }
        GetIndex() {
            return this._index
        }
        Stop() {
            this._isStopped = !0
        }
        IsStopped() {
            return this._isStopped
        }
        SetEnd(e) {
            this._end = e
        }
        GetEnd() {
            return this._end
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.ArrayStack = class ArrayStack extends e.DefendedBase {
        constructor() {
            super(), this._stack = [], this._index = -1
        }
        Release() {
            e.clearArray(this._stack)
        }
        GetCurrent() {
            return this._stack[this._index]
        }
        Push() {
            if (++this._index, this._index === this._stack.length) {
                const e = [];
                return this._stack.push(e), e
            }
            return this._stack[this._index]
        }
        Pop() {
            --this._index
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = self.assert;

    function SortSolArray(e, t) {
        return e.GetIndex() - t.GetIndex()
    }

    function IsSolArrayIdentical(e, t) {
        for (let n = 0, s = e.length; n < s; ++n)
            if (e[n] !== t[n]) return !1;
        return !0
    }
    e.EventSheetManager = class EventSheetManager extends e.DefendedBase {
        constructor(t) {
            super(), this._runtime = t, this._allSheets = [], this._sheetsByName = new Map, this._allGroups = [], this._groupsByName = new Map, this._blocksBySid = new Map, this._cndsBySid = new Map, this._actsBySid = new Map, this._allUniqueSolModifiers = new Map, this._eventVarsBySid = new Map, this._nextLocalVarIndex = 0, this._allGlobalVars = [], this._allLocalVars = [], this._localVarInitialValues = [], this._functionBlocksByName = new Map, this._eventStack = e.New(e.EventStack, this), this._localVarStack = e.New(e.LocalVarStack, this), this._loopStack = e.New(e.LoopStack, this), this._triggersToPostInit = [], this._queuedTriggers = [], this._queuedDebugTriggers = [], this._runningEventsDepth = 0, this._executingTriggerDepth = 0, this._blockFlushingDepth = 0, this._scheduledWaits = [], this._asyncActionPromises = [], self.c3_callFunction = (e, t) => this._InvokeFunctionFromJS(e, t)
        }
        Release() {
            this.ClearAllScheduledWaits(), this._eventStack.Release(), this._eventStack = null, this._localVarStack.Release(), this._localVarStack = null, e.clearArray(this._queuedTriggers), e.clearArray(this._queuedDebugTriggers), this._runtime = null, e.clearArray(this._allSheets), this._sheetsByName.clear()
        }
        Create(t) {
            const n = e.New(e.EventSheet, this, t);
            this._allSheets.push(n), this._sheetsByName.set(n.GetName().toLowerCase(), n)
        }
        _AddTriggerToPostInit(e) {
            this._triggersToPostInit.push(e)
        }
        _PostInit() {
            for (const e of this._functionBlocksByName.values()) e._PostInit(!1);
            for (const e of this._allSheets) e._PostInit();
            for (const e of this._allSheets) e._UpdateDeepIncludes();
            for (const e of this._triggersToPostInit) e._PostInit(!1);
            e.clearArray(this._triggersToPostInit), this._localVarStack._SetInitialValues(this._localVarInitialValues)
        }
        GetRuntime() {
            return this._runtime
        }
        GetEventSheetByName(e) {
            return this._sheetsByName.get(e.toLowerCase()) || null
        }
        _RegisterGroup(e) {
            this._allGroups.push(e), this._groupsByName.set(e.GetGroupName(), e)
        }
        _RegisterEventBlock(e) {
            this._blocksBySid.set(e.GetSID(), e)
        }
        _RegisterCondition(e) {
            this._cndsBySid.set(e.GetSID(), e)
        }
        _RegisterAction(e) {
            this._actsBySid.set(e.GetSID(), e)
        }
        _RegisterFunctionBlock(e) {
            this._functionBlocksByName.set(e.GetFunctionName().toLowerCase(), e)
        }
        _RegisterEventVariable(e) {
            this._eventVarsBySid.set(e.GetSID(), e), e.IsGlobal() ? this._allGlobalVars.push(e) : this._allLocalVars.push(e)
        }
        _DeduplicateSolModifierList(e) {
            e.length >= 2 && e.sort(SortSolArray);
            let t = this._allUniqueSolModifiers.get(e.length);
            t || (t = [], this._allUniqueSolModifiers.set(e.length, t));
            for (let n = 0, o = t.length; n < o; ++n) {
                const s = t[n];
                if (IsSolArrayIdentical(e, s)) return s
            }
            return t.push(e), e
        }
        _GetNextLocalVarIndex(e) {
            return this._localVarInitialValues.push(e.GetInitialValue()), this._nextLocalVarIndex++
        }
        GetEventStack() {
            return this._eventStack
        }
        GetCurrentEventStackFrame() {
            return this.GetEventStack().GetCurrentStackFrame()
        }
        GetCurrentEvent() {
            return this.GetCurrentEventStackFrame().GetCurrentEvent()
        }
        GetCurrentCondition() {
            const e = this.GetCurrentEventStackFrame(),
                t = e.GetCurrentEvent();
            return t.GetConditionAt(e.GetConditionIndex())
        }
        GetCurrentAction() {
            const e = this.GetCurrentEventStackFrame(),
                t = e.GetCurrentEvent();
            return t.GetActionAt(e.GetActionIndex())
        }
        GetLocalVarStack() {
            return this._localVarStack
        }
        GetLoopStack() {
            return this._loopStack
        }
        GetAllLocalVariablesInScope(t) {
            const n = [];
            for (t = t.GetScopeParent(); t;) e.appendArray(n, t._GetAllLocalVariablesInScope()), t = t.GetScopeParent();
            return n
        }
        _GetLocalVariablesScriptInterface(e) {
            const t = {};
            for (const n of this.GetAllLocalVariablesInScope(e)) t[n.GetJsPropName()] = n._GetScriptInterfaceDescriptor();
            return Object.create(Object.prototype, t)
        }
        GetEventVariableBySID(e) {
            return this._eventVarsBySid.get(e) || null
        }
        GetEventBlockBySID(e) {
            return this._blocksBySid.get(e) || null
        }
        GetConditionBySID(e) {
            return this._cndsBySid.get(e) || null
        }
        GetActionBySID(e) {
            return this._actsBySid.get(e) || null
        }
        GetFunctionBlockByName(e) {
            return this._functionBlocksByName.get(e.toLowerCase()) || null
        }
        GetAllGlobalVariables() {
            return this._allGlobalVars
        }
        GetAllLocalVariables() {
            return this._allLocalVars
        }
        ResetAllGlobalsToInitialValue() {
            for (const e of this._allGlobalVars) e.ResetToInitialValue()
        }
        GetEventGroupByName(e) {
            return this._groupsByName.get(e.toLowerCase()) || null
        }
        GetEventGroupBySID(e) {
            const t = this._blocksBySid.get(e);
            return t && t.IsGroup() ? t : null
        }
        GetAllGroups() {
            return this._allGroups
        }
        ResetAllGroupsInitialActivation() {
            for (const e of this._allGroups) e.ResetInitialActivation()
        }
        _ResetAllHasRunFlags() {
            for (const e of this._allSheets) e._ResetHasRunFlag()
        }
        RunEvents(e) {
            this._ResetAllHasRunFlags(), this._runningEventsDepth++;
            for (const t of e.runningLayouts()) {
                const n = t.GetEventSheet();
                if (!n) continue;
                this._runtime.PushCurrentLayout(t), n.Run(), this._runtime.PopCurrentLayout()
            }
            this._runningEventsDepth--
        }
        async DebugRunEvents(e) {
            this._ResetAllHasRunFlags(), this._runningEventsDepth++;
            for (const t of this._DebugRunEventsGen(e)) await this._runtime.DebugBreak(t);
            this._runningEventsDepth--
        }* _DebugRunEventsGen(e) {
            for (const t of e.runningLayouts()) {
                const n = t.GetEventSheet();
                if (!n) continue;
                this._runtime.PushCurrentLayout(t), yield* n.DebugRun(), this._runtime.PopCurrentLayout()
            }
        }
        _Trigger(e, t, n, s) {
            let o = !1;
            if (!e.GetMainRunningLayout()) return this.QueueTrigger(t, n, s);
            this._executingTriggerDepth++;
            for (const a of e.runningLayouts()) {
                const i = a.GetEventSheet();
                if (!i) continue;
                this._runtime.PushCurrentLayout(a);
                for (const e of i.deepIncludes()) {
                    const a = e._Trigger(t, n, s);
                    o = o || a
                }
                const r = i._Trigger(t, n, s);
                o = o || r, this._runtime.PopCurrentLayout()
            }
            return this._executingTriggerDepth--, o
        }* _DebugTrigger(e, t, n, s) {
            let o = !1;
            if (!e.GetMainRunningLayout()) return this.QueueTrigger(t, n, s);
            this._executingTriggerDepth++;
            for (const a of e.runningLayouts()) {
                const i = a.GetEventSheet();
                if (!i) continue;
                this._runtime.PushCurrentLayout(a);
                for (const e of i.deepIncludes()) {
                    const a = yield* e._DebugTrigger(t, n, s);
                    o = o || a
                }
                const r = yield* i._DebugTrigger(t, n, s);
                o = o || r, this._runtime.PopCurrentLayout()
            }
            return this._executingTriggerDepth--, o
        }
        QueueTrigger(e, t, n) {
            return this._queuedTriggers.push([e, t, n]), !1
        }
        QueueDebugTrigger(e, t, n) {
            let s = null;
            const o = new Promise(e => s = e);
            return this._queuedDebugTriggers.push([e, t, n, s]), o
        }* _RunQueuedDebugTriggersGen() {
            if (this._runtime.HitBreakpoint()) throw new Error("should not be in breakpoint");
            const e = this._runtime.GetLayoutManager();
            for (; this._queuedDebugTriggers.length;) {
                const [t, n, s, o] = this._queuedDebugTriggers.shift(), i = yield* this._DebugTrigger(e, t, n, s);
                o(i)
            }
        }
        async RunQueuedDebugTriggersAsync() {
            for (const e of this._RunQueuedDebugTriggersGen()) await this._runtime.DebugBreak(e)
        }
        _FastTrigger(e, t, n, s) {
            let o = !1;
            const a = e.GetMainRunningLayout(),
                i = a.GetEventSheet();
            if (!i) return;
            this._executingTriggerDepth++, this._runtime.PushCurrentLayout(a);
            const r = i.deepIncludes();
            for (let e = 0, i = r.length; e < i; ++e) {
                const a = r[e]._FastTrigger(t, n, s);
                o = o || a
            }
            const c = i._FastTrigger(t, n, s);
            return o = o || c, this._runtime.PopCurrentLayout(), this._executingTriggerDepth--, o
        }* _DebugFastTrigger(e, t, n, s) {
            let o = !1;
            const a = e.GetMainRunningLayout(),
                i = a.GetEventSheet();
            if (!i) return;
            this._executingTriggerDepth++, this._runtime.PushCurrentLayout(a);
            const r = i.deepIncludes();
            for (let e = 0, i = r.length; e < i; ++e) {
                const a = yield* r[e]._DebugFastTrigger(t, n, s);
                o = o || a
            }
            const c = yield* i._DebugFastTrigger(t, n, s);
            return o = o || c, this._runtime.PopCurrentLayout(), this._executingTriggerDepth--, o
        }
        GetTriggerDepth() {
            return this._executingTriggerDepth
        }
        IsInTrigger() {
            return this.GetTriggerDepth() > 0
        }
        _IncTriggerDepth() {
            return ++this._executingTriggerDepth
        }
        _DecTriggerDepth() {
            --this._executingTriggerDepth
        }
        IsRunningEvents() {
            return this._runningEventsDepth > 0
        }
        IsInEventEngine() {
            return this.IsRunningEvents() || this.IsInTrigger()
        }
        _RunQueuedTriggers(t) {
            for (const [e, n, s] of this._queuedTriggers) this._Trigger(t, e, n, s);
            e.clearArray(this._queuedTriggers)
        }
        BlockFlushingInstances(e) {
            e ? this._blockFlushingDepth++ : this._blockFlushingDepth--
        }
        IsFlushingBlocked() {
            return this._blockFlushingDepth > 0
        }
        ClearSol(e) {
            for (let t = 0, n = e.length; t < n; ++t) e[t].GetSolStack().Clear()
        }
        PushCleanSol(e) {
            for (let t = 0, n = e.length; t < n; ++t) e[t].GetSolStack().PushClean()
        }
        PushCopySol(e) {
            for (let t = 0, n = e.length; t < n; ++t) e[t].GetSolStack().PushCopy()
        }
        PopSol(e) {
            for (let t = 0, n = e.length; t < n; ++t) e[t].GetSolStack().Pop()
        }
        AddScheduledWait() {
            const t = e.New(e.ScheduledWait, this);
            return this._scheduledWaits.push(t), t
        }
        scheduledWaits() {
            return this._scheduledWaits
        }
        RunScheduledWaits() {
            if (!this._scheduledWaits.length) return;
            const t = this.GetCurrentEventStackFrame();
            let e = !1;
            this._runningEventsDepth++;
            for (let n = 0, o = this._scheduledWaits.length; n < o; ++n) {
                const s = this._scheduledWaits[n];
                s._ShouldRun() && s._Run(t), s.ShouldRelease() && (e = !0)
            }
            e && this._FilterScheduledWaitsToRelease(), this._runningEventsDepth--
        }
        async DebugRunScheduledWaits() {
            if (!this._scheduledWaits.length) return;
            const t = this.GetCurrentEventStackFrame();
            let e = !1;
            this._runningEventsDepth++;
            for (let n = 0, o = this._scheduledWaits.length; n < o; ++n) {
                const s = this._scheduledWaits[n];
                s._ShouldRun() && await s._DebugRun(t), s.ShouldRelease() && (e = !0)
            }
            e && this._FilterScheduledWaitsToRelease(), this._runningEventsDepth--
        }
        _FilterScheduledWaitsToRelease() {
            const t = e.arrayFilterOut(this._scheduledWaits, e => e.ShouldRelease());
            for (const e of t) e.Release()
        }
        ClearAllScheduledWaits() {
            for (const e of this._scheduledWaits) e.Release();
            e.clearArray(this._scheduledWaits)
        }
        RemoveInstancesFromScheduledWaits(e) {
            for (const t of this._scheduledWaits) t.RemoveInstances(e)
        }
        AddAsyncActionPromise(e) {
            this._asyncActionPromises.push(e)
        }
        ClearAsyncActionPromises() {
            e.clearArray(this._asyncActionPromises)
        }
        GetPromiseForAllAsyncActions() {
            const e = Promise.all(this._asyncActionPromises);
            return this._asyncActionPromises = [], e
        }
        _SaveToJson() {
            return {
                groups: this._SaveGroupsToJson(),
                cnds: this._SaveCndsToJson(),
                acts: this._SaveActsToJson(),
                vars: this._SaveVarsToJson(),
                waits: this._SaveScheduledWaitsToJson()
            }
        }
        _LoadFromJson(e) {
            this._LoadGroupsFromJson(e.groups), this._LoadCndsFromJson(e.cnds), this._LoadActsFromJson(e.acts), this._LoadVarsFromJson(e.vars), this._LoadScheduledWaitsFromJson(e.waits)
        }
        _SaveGroupsToJson() {
            const e = {};
            for (const t of this.GetAllGroups()) e[t.GetSID().toString()] = t.IsGroupActive();
            return e
        }
        _LoadGroupsFromJson(e) {
            for (const [n, s] of Object.entries(e)) {
                const o = parseInt(n, 10),
                    t = this.GetEventGroupBySID(o);
                t && t.SetGroupActive(s)
            }
        }
        _SaveCndsToJson() {
            const e = {};
            for (const [n, s] of this._cndsBySid) {
                const t = s._SaveToJson();
                t && (e[n.toString()] = t)
            }
            return e
        }
        _LoadCndsFromJson(e) {
            const t = new Map;
            for (const [n, s] of Object.entries(e)) t.set(parseInt(n, 10), s);
            for (const [e, n] of this._cndsBySid) n._LoadFromJson(t.get(e) || null)
        }
        _SaveActsToJson() {
            const e = {};
            for (const [n, s] of this._actsBySid) {
                const t = s._SaveToJson();
                t && (e[n.toString()] = t)
            }
            return e
        }
        _LoadActsFromJson(e) {
            const t = new Map;
            for (const [n, s] of Object.entries(e)) t.set(parseInt(n, 10), s);
            for (const [e, n] of this._actsBySid) n._LoadFromJson(t.get(e) || null)
        }
        _SaveVarsToJson() {
            const e = {};
            for (const [n, t] of this._eventVarsBySid) !t.IsConstant() && (t.IsGlobal() || t.IsStatic()) && (e[n.toString()] = t.GetValue());
            return e
        }
        _LoadVarsFromJson(e) {
            for (const [n, s] of Object.entries(e)) {
                const o = parseInt(n, 10),
                    t = this.GetEventVariableBySID(o);
                t && t.SetValue(s)
            }
        }
        _SaveScheduledWaitsToJson() {
            return this._scheduledWaits.filter(e => !e.IsPromise()).map(e => e._SaveToJson())
        }
        _LoadScheduledWaitsFromJson(t) {
            this.ClearAllScheduledWaits();
            for (const s of t) {
                const n = e.ScheduledWait._CreateFromJson(this, s);
                n && this._scheduledWaits.push(n)
            }
        }
        _GetPerfRecords() {
            return [...this._runtime.GetLayoutManager().runningLayouts()].map(e => e.GetEventSheet()).filter(e => e).map(e => e._GetPerfRecord())
        }
        FindFirstFunctionBlockParent(t) {
            for (; t;) {
                const n = t.GetScopeParent();
                if (n instanceof e.FunctionBlock) return n;
                t = t.GetParent()
            }
            return null
        }
        _InvokeFunctionFromJS(e, t) {
            Array.isArray(t) || (t = []);
            const n = this.GetFunctionBlockByName(e.toLowerCase());
            if (!n) return null;
            if (!n.IsEnabled()) return n.GetDefaultReturnValue();
            const s = n.GetFunctionParameters();
            if (t.length < s.length) {
                t = t.slice(0);
                do t.push(s[t.length].GetInitialValue()); while (t.length < s.length)
            }
            const o = n.GetEventBlock();
            return o.RunAsExpressionFunctionCall(o.GetSolModifiersIncludingParents(), n.GetReturnType(), n.GetDefaultReturnValue(), ...t)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.EventSheet = class EventSheet extends e.DefendedBase {
        constructor(e, t) {
            super(), this._eventSheetManager = e, this._runtime = e.GetRuntime(), this._name = t[0], this._events = [], this._triggers = new Map, this._fastTriggers = new Map, this._eventsByDisplayNumber = new Map, this._hasRun = !1, this._shallowIncludes = [], this._deepIncludes = [], this._alreadyIncludedSheets = new Set;
            for (const e of t[1]) this._CreateEvent(e, null, this._events);
            this._perfRecord = this._runtime.IsDebug() ? {
                type: "sheet",
                name: this._name,
                totalTimeCounter: 0,
                children: []
            } : null
        }
        Release() {
            this._eventSheetManager = null, this._runtime = null
        }
        _CreateEvent(e, t, n) {
            switch (e[0]) {
                case 0:
                case 3:
                    this._CreateEventBlock(e, t, n);
                    break;
                case 1:
                    this._CreateEventVariable(e, t, n);
                    break;
                case 2:
                    this._CreateInclude(e, t, n);
                    break;
                case 4:
                    this._CreateFunctionBlock(e, t);
                    break;
                case 5:
                    this._CreateScriptBlock(e, t, n);
                    break;
                default:
                    throw new Error("invalid event type")
            }
        }
        _CreateEventBlock(t, n, s) {
            const o = e.EventBlock.Create(this, n, t);
            if (o.IsOrBlock()) {
                s.push(o);
                const e = o.GetConditions();
                for (let t = 0, n = e.length; t < n; ++t) e[t].IsTrigger() && this._InitTrigger(o, t)
            } else o.IsTrigger() ? this._InitTrigger(o, 0) : s.push(o)
        }
        _CreateFunctionBlock(t, n) {
            const s = e.FunctionBlock.Create(this, n, t);
            this._eventSheetManager._RegisterFunctionBlock(s)
        }
        _CreateEventVariable(t, n, s) {
            const o = e.EventVariable.Create(this, n, t);
            s.push(o)
        }
        _CreateInclude(t, n, s) {
            const o = e.EventInclude.Create(this, n, t);
            s.push(o)
        }
        _CreateScriptBlock(t, n, s) {
            const o = e.EventScript.Create(this, n, t);
            s.push(o)
        }
        _InitTrigger(e, t) {
            e.IsOrBlock() || this._eventSheetManager._AddTriggerToPostInit(e);
            const n = e.GetConditionAt(t),
                s = n._GetFunc(),
                o = n.GetObjectClass();
            if (n.IsFastTrigger()) {
                let i = this._fastTriggers.get(o);
                i || (i = new Map, this._fastTriggers.set(o, i));
                const c = n.GetFastTriggerValue().toLowerCase();
                let a = i.get(s);
                a || (a = new Map, i.set(s, a));
                let r = a.get(c);
                r || (r = [], a.set(c, r)), r.push([e, t])
            } else {
                let a = this._triggers.get(o);
                a || (a = {
                    methodMap: new Map,
                    behaviors: new Map
                }, this._triggers.set(o, a));
                const c = n.GetBehaviorType();
                let i;
                c ? (i = a.behaviors.get(c), i || (i = new Map, a.behaviors.set(c, i))) : i = a.methodMap;
                let r = i.get(s);
                r || (r = [], i.set(s, r)), r.push([e, t])
            }
        }
        _PostInit() {
            const t = this._events;
            for (let n = 0, s = t.length; n < s; ++n) {
                const o = n < s - 1 && t[n + 1] instanceof e.EventBlock && t[n + 1].IsElseBlock();
                t[n]._PostInit(o)
            }
        }
        _AddShallowInclude(e) {
            this._shallowIncludes.push(e)
        }
        _UpdateDeepIncludes() {
            e.clearArray(this._deepIncludes), this._AddDeepIncludes(this), this._alreadyIncludedSheets.clear()
        }
        _AddDeepIncludes(e) {
            const n = e._deepIncludes,
                t = e._alreadyIncludedSheets;
            for (const o of this._shallowIncludes) {
                const s = o.GetIncludeSheet();
                if (!o.IsActive() || e === s || t.has(s)) continue;
                t.add(s), s._AddDeepIncludes(e), n.push(s)
            }
        }
        deepIncludes() {
            return this._deepIncludes
        }
        GetEventSheetManager() {
            return this._eventSheetManager
        }
        GetRuntime() {
            return this._runtime
        }
        GetName() {
            return this._name
        }
        _RegisterEventByDisplayNumber(e, t) {
            this._eventsByDisplayNumber.set(t, e)
        }
        _GetEventByDisplayNumber(e) {
            return this._eventsByDisplayNumber.get(e) || null
        }
        _ResetHasRunFlag() {
            this._hasRun = !1
        }
        Run() {
            if (this._hasRun) return;
            const t = this._runtime,
                n = t.IsCPUProfiling(),
                o = n ? performance.now() : 0;
            this._hasRun = !0;
            const e = this.GetEventSheetManager(),
                s = e.GetCurrentEventStackFrame();
            for (const n of this._events) n.Run(s), e.ClearSol(n.GetSolModifiers()), e.ClearAsyncActionPromises(), t.FlushPendingInstances();
            s.Reset(null), n && (this._perfRecord.totalTimeCounter += performance.now() - o)
        }* DebugRun() {
            if (this._hasRun) return;
            this._hasRun = !0;
            const n = this._runtime,
                e = this.GetEventSheetManager(),
                t = e.GetCurrentEventStackFrame();
            for (const s of this._events) yield* s.DebugRun(t), e.ClearSol(s.GetSolModifiers()), e.ClearAsyncActionPromises(), n.FlushPendingInstances();
            t.Reset(null)
        }
        _Trigger(e, t, n) {
            if (t) {
                const i = t.GetObjectClass();
                let s = !1,
                    o = this._TriggerForClass(e, t, i, n);
                s = s || o;
                for (const a of i.GetFamilies()) o = this._TriggerForClass(e, t, a, n), s = s || o
            } else return this._TriggerForClass(e, t, null, null)
        }
        _TriggerForClass(e, t, n, s) {
            const o = this._triggers.get(n);
            if (!o) return !1;
            const a = s ? o.behaviors.get(s) : o.methodMap;
            if (!a) return !1;
            const r = a.get(e);
            if (!r) return !1;
            let i = !1;
            for (const [e, n] of r) {
                const s = this._ExecuteTrigger(t, e, n);
                i = i || s
            }
            return i
        }* _DebugTrigger(e, t, n) {
            if (t) {
                const i = t.GetObjectClass();
                let s = !1,
                    o = yield* this._DebugTriggerForClass(e, t, i, n);
                s = s || o;
                for (const a of i.GetFamilies()) o = yield* this._DebugTriggerForClass(e, t, a, n), s = s || o
            } else return yield* this._DebugTriggerForClass(e, t, null, null)
        }* _DebugTriggerForClass(e, t, n, s) {
            const o = this._triggers.get(n);
            if (!o) return !1;
            const a = s ? o.behaviors.get(s) : o.methodMap;
            if (!a) return !1;
            const r = a.get(e);
            if (!r) return !1;
            let i = !1;
            for (const [e, s] of r) {
                let n;
                e.DebugCanRunFast() ? n = this._ExecuteTrigger(t, e, s) : n = yield* this._DebugExecuteTrigger(t, e, s), i = i || n
            }
            return i
        }
        _FastTrigger(e, t, n) {
            const r = t.GetObjectClass(),
                i = this._fastTriggers.get(r);
            if (!i) return !1;
            const a = i.get(e);
            if (!a) return !1;
            const s = a.get(n);
            if (!s) return !1;
            let o = !1;
            for (let e = 0, n = s.length; e < n; ++e) {
                const t = s[e],
                    i = this._ExecuteTrigger(null, t[0], t[1]);
                o = o || i
            }
            return o
        }* _DebugFastTrigger(e, t, n) {
            const r = t.GetObjectClass(),
                i = this._fastTriggers.get(r);
            if (!i) return !1;
            const a = i.get(e);
            if (!a) return !1;
            const s = a.get(n);
            if (!s) return !1;
            let o = !1;
            for (let e = 0, r = s.length; e < r; ++e) {
                const i = s[e],
                    t = i[0],
                    a = i[1];
                let n;
                t.DebugCanRunFast() ? n = this._ExecuteTrigger(null, t, a) : n = yield* this._DebugExecuteTrigger(null, t, a), o = o || n
            }
            return o
        }
        _ExecuteTrigger(e, t, n) {
            const a = this._runtime,
                s = this._eventSheetManager,
                o = s.GetCurrentEvent(),
                r = s.GetEventStack(),
                c = s.GetTriggerDepth();
            let l = !1;
            o && s.PushCleanSol(o.GetSolModifiersIncludingParents()), s.PushCleanSol(t.GetSolModifiersIncludingParents());
            const d = c > 1;
            d && s.GetLocalVarStack().Push();
            const i = r.Push(t);
            if (e) {
                const s = t.GetConditions()[n].GetObjectClass(),
                    o = s.GetCurrentSol();
                o.SetSinglePicked(e), e.IsInContainer() && e.SetSiblingsSinglePicked()
            }
            let u = !0;
            if (t.GetParent()) {
                const e = t.GetTriggerParents();
                for (let t = 0, n = e.length; t < n; ++t)
                    if (!e[t].RunPreTrigger(i)) {
                        u = !1;
                        break
                    }
            }
            return u && (a.IncrementExecCount(), t.IsOrBlock() ? t.RunOrBlockTrigger(i, n) : t.Run(i), l = i.GetLastEventTrue()), r.Pop(), d && s.GetLocalVarStack().Pop(), s.PopSol(t.GetSolModifiersIncludingParents()), o && s.PopSol(o.GetSolModifiersIncludingParents()), !o && c === 1 && !s.IsFlushingBlocked() && a.FlushPendingInstances(), l
        }* _DebugExecuteTrigger(e, t, n) {
            const a = this._runtime,
                s = this._eventSheetManager,
                o = s.GetCurrentEvent(),
                r = s.GetEventStack(),
                c = s.GetTriggerDepth();
            let l = !1;
            o && s.PushCleanSol(o.GetSolModifiersIncludingParents()), s.PushCleanSol(t.GetSolModifiersIncludingParents());
            const d = c > 1;
            d && s.GetLocalVarStack().Push();
            const i = r.Push(t);
            if (e) {
                const s = t.GetConditions()[n].GetObjectClass(),
                    o = s.GetCurrentSol();
                o.SetSinglePicked(e), e.IsInContainer() && e.SetSiblingsSinglePicked()
            }
            let u = !0;
            if (t.GetParent()) {
                const e = t.GetTriggerParents();
                for (let t = 0, n = e.length; t < n; ++t)
                    if (!(yield* e[t].DebugRunPreTrigger(i))) {
                        u = !1;
                        break
                    }
            }
            return u && (a.IncrementExecCount(), t.IsOrBlock() ? yield* t.DebugRunOrBlockTrigger(i, n): yield* t.DebugRun(i), l = i.GetLastEventTrue()), r.Pop(), d && s.GetLocalVarStack().Pop(), s.PopSol(t.GetSolModifiersIncludingParents()), o && s.PopSol(o.GetSolModifiersIncludingParents()), !o && c === 1 && !s.IsFlushingBlocked() && a.FlushPendingInstances(), l
        }
        _GetPerfRecord() {
            return this._perfRecord
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = [];

    function NoActions() {
        return !0
    }

    function* DebugNoActions() {
        return !0
    }
    e.EventBlock = class EventBlock extends e.DefendedBase {
        constructor(n, s, o) {
            super(), this._eventSheet = n, this._runtime = n.GetRuntime(), this._parent = s, this._scopeParent = null, this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._solModifiers = [], this._solModifiersIncludingParents = [], this._hasGotSolModifiersIncludingParents = !1, this._isSolWriterAfterCnds = !1, this._isTopLevelGroup = !1, this._hasElseBlock = !1, this._isOrBlock = !!o[2], this._isElseBlock = !1, this._triggerParents = null, this._conditions = [], this._actions = [], this._subEvents = [], this._RunActions = NoActions, this._DebugRunActions = DebugNoActions, this._isGroup = !1, this._isInitiallyActive = !1, this._groupName = "", this._isGroupActive = !1, this._containedIncludes = null, this._perfRecord = null, this._sid = o[4], this._displayNumber = o[5], this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber), this._debugData = this._runtime.IsDebug() ? {
                isBreakpoint: o[3][0],
                isBreakable: o[3][1],
                canRunAllConditionsFast: !1,
                canRunAllActionsFast: !1,
                canRunAllSubEventsFast: !1,
                canRunSelfFast: !1
            } : null, this.GetEventSheetManager()._RegisterEventBlock(this), o[0] === 3 && this._InitGroup(o[1]);
            let i = 0;
            for (const n of o[6]) {
                const t = e.Condition.Create(this, n, i++);
                this._conditions.push(t), this._AddSolModifier(t.GetObjectClass())
            }
            i = 0;
            for (const t of o[7]) {
                const n = e.Action.Create(this, t, i++);
                this._actions.push(n)
            }
            if (o.length === 9) {
                const e = o[8];
                for (const t of e) this._eventSheet._CreateEvent(t, this, this._subEvents)
            }
            this._conditions.length && (this._isElseBlock = this._conditions[0].GetObjectClass() === null && this._conditions[0]._GetFunc() === e.Plugins.System.Cnds.Else), this._conditions.length === 0 && (this._conditions = t), this._actions.length === 0 && (this._actions = t), this._subEvents.length === 0 && (this._subEvents = t)
        }
        static Create(t, n, s) {
            return e.New(e.EventBlock, t, n, s)
        }
        _InitGroup(e) {
            this._isGroup = !0, this._isInitiallyActive = !!e[0], this._isGroupActive = this._isInitiallyActive, this._groupName = e[1].toLowerCase(), this._containedIncludes = [], this.GetEventSheetManager()._RegisterGroup(this), this._runtime.IsDebug() && (this._perfRecord = {
                type: "group",
                name: e[1],
                totalTimeCounter: 0,
                children: []
            })
        }
        _AddContainedInclude(e) {
            this._containedIncludes.push(e)
        }
        _AddContainerSolModifierToList(e, t) {
            for (const n of e.GetContainer().objectTypes()) t.includes(n) || t.push(n)
        }
        _AddSolModifierToList(e, t) {
            if (!e) return;
            if (t.includes(e) || t.push(e), e.IsFamily())
                for (const n of e.GetFamilyMembers()) n.IsInContainer() && this._AddContainerSolModifierToList(n, t);
            else e.IsInContainer() && this._AddContainerSolModifierToList(e, t)
        }
        _AddSolModifier(e) {
            this._AddSolModifierToList(e, this._solModifiers)
        }
        _AddParentSolModifier(e) {
            this._AddSolModifierToList(e, this._solModifiersIncludingParents)
        }
        SetAllSolModifiers() {
            this._solModifiers = this._runtime.GetAllObjectClasses()
        }
        _PostInit(t) {
            this._hasElseBlock = !!t, this._IdentifyTopLevelGroup(), this._IdentifyTriggerParents();
            for (const e of this._conditions) e._PostInit();
            if (this._actions.length > 0) {
                let e = !1;
                for (const t of this._actions) t._PostInit(), t.HasReturnType() && (e = !0);
                e ? (this._RunActions = this._RunActions_ReturnValue, this._DebugRunActions = this._DebugRunActions_ReturnValue) : (this._RunActions = this._RunActions_Fast, this._DebugRunActions = this._DebugRunActions_Fast)
            }
            const n = this._subEvents;
            for (let t = 0, s = n.length; t < s; ++t) {
                const o = t < s - 1 && n[t + 1] instanceof e.EventBlock && n[t + 1].IsElseBlock();
                n[t]._PostInit(o)
            }
            this._debugData && this._UpdateCanRunFast(), this._perfRecord && this._GetPerfRecordParent()._GetPerfRecord().children.push(this._perfRecord)
        }
        _GetPerfRecord() {
            return this._perfRecord
        }
        _GetPerfRecordParent() {
            let e = this.GetParent();
            for (; e;) {
                if (e.IsGroup()) return e;
                e = e.GetParent()
            }
            return this._eventSheet
        }
        _UpdateCanRunFast() {
            const e = this._debugData;
            e.canRunAllConditionsFast = this._conditions.every(e => e.DebugCanRunFast()), e.canRunAllActionsFast = this._actions.every(e => e.DebugCanRunFast()), e.canRunAllSubEventsFast = this._subEvents.every(e => e.DebugCanRunFast()), e.canRunSelfFast = e.canRunAllConditionsFast && e.canRunAllActionsFast && e.canRunAllSubEventsFast
        }
        _UpdateCanRunFastRecursive() {
            let e = this;
            do e._UpdateCanRunFast(), e = e.GetParent(); while (e)
        }
        _IdentifyTopLevelGroup() {
            if (!this.IsGroup()) return;
            let e = this.GetParent();
            for (this._isTopLevelGroup = !0; e;) {
                if (!e.IsGroup()) {
                    this._isTopLevelGroup = !1;
                    break
                }
                e = e.GetParent()
            }
        }
        _IdentifySolModifiersIncludingParents() {
            const t = this._runtime.GetAllObjectClasses();
            if (this._solModifiers === t) this._solModifiersIncludingParents = t;
            else {
                this._solModifiersIncludingParents = e.cloneArray(this._solModifiers);
                let t = this.GetParent();
                for (; t;) {
                    for (const e of t._solModifiers) this._AddParentSolModifier(e);
                    t = t.GetParent()
                }
                const n = this.GetEventSheetManager();
                this._solModifiers = n._DeduplicateSolModifierList(this._solModifiers), this._solModifiersIncludingParents = n._DeduplicateSolModifierList(this._solModifiersIncludingParents)
            }
        }
        _IdentifyTriggerParents() {
            if (!this.HasAnyTriggeredCondition()) return;
            this._triggerParents = [];
            let e = this.GetParent();
            for (; e;) this._triggerParents.push(e), e = e.GetParent();
            this._triggerParents.reverse()
        }
        SetSolWriterAfterCnds() {
            this._isSolWriterAfterCnds = !0, this._parent && this._parent.SetSolWriterAfterCnds()
        }
        IsSolWriterAfterCnds() {
            return this._isSolWriterAfterCnds
        }
        GetSolModifiers() {
            return this._solModifiers
        }
        GetSolModifiersIncludingParents() {
            return this._hasGotSolModifiersIncludingParents || (this._hasGotSolModifiersIncludingParents = !0, this._IdentifySolModifiersIncludingParents()), this._solModifiersIncludingParents
        }
        HasSolModifier(e) {
            return this._solModifiers.includes(e)
        }
        GetTriggerParents() {
            return this._triggerParents
        }
        GetEventSheet() {
            return this._eventSheet
        }
        GetEventSheetManager() {
            return this._eventSheet.GetEventSheetManager()
        }
        GetRuntime() {
            return this._runtime
        }
        GetParent() {
            return this._parent
        }
        _SetScopeParent(e) {
            this._scopeParent = e
        }
        GetScopeParent() {
            return this._scopeParent || this._parent
        }
        GetDisplayNumber() {
            return this._displayNumber
        }
        IsDebugBreakable() {
            return this._debugData && this._debugData.isBreakable
        }
        IsDebugBreakpoint() {
            return this.IsDebugBreakable() && this._debugData.isBreakpoint
        }
        _SetDebugBreakpoint(e) {
            this._debugData.isBreakpoint = !!e, this._UpdateCanRunFastRecursive()
        }
        IsGroup() {
            return this._isGroup
        }
        IsTopLevelGroup() {
            return this._isTopLevelGroup
        }
        IsElseBlock() {
            return this._isElseBlock
        }
        HasElseBlock() {
            return this._hasElseBlock
        }
        GetGroupName() {
            return this._groupName
        }
        IsGroupActive() {
            return this._isGroupActive
        }
        ResetInitialActivation() {
            this.SetGroupActive(this._isInitiallyActive)
        }
        SetGroupActive(e) {
            if (e = !!e, !this._isGroup) throw new Error("not a group");
            if (this._isGroupActive === e) return;
            this._isGroupActive = e;
            for (const e of this._containedIncludes) e.UpdateActive();
            if (this._containedIncludes.length) {
                const t = this._runtime.GetCurrentLayout(),
                    e = t.GetEventSheet();
                e && e._UpdateDeepIncludes()
            }
        }
        GetSID() {
            return this._sid
        }
        IsOrBlock() {
            return this._isOrBlock
        }
        IsTrigger() {
            return this._conditions.length && this._conditions[0].IsTrigger()
        }
        IsForFunctionBlock() {
            return this._scopeParent && this._scopeParent instanceof e.FunctionBlock
        }
        HasAnyTriggeredCondition() {
            return this.IsForFunctionBlock() || this._conditions.some(e => e.IsTrigger())
        }
        GetConditions() {
            return this._conditions
        }
        GetConditionCount() {
            return this._conditions.length
        }
        GetConditionAt(e) {
            if (e = Math.floor(e), e < 0 || e >= this._conditions.length) throw new RangeError("invalid condition index");
            return this._conditions[e]
        }
        GetConditionByDebugIndex(e) {
            return this.GetConditionAt(e)
        }
        IsFirstConditionOfType(e) {
            let t = e.GetIndex();
            if (t === 0) return !0;
            for (--t; t >= 0; --t)
                if (this._conditions[t].GetObjectClass() === e.GetObjectClass()) return !1;
            return !0
        }
        GetActions() {
            return this._actions
        }
        GetActionCount() {
            return this._actions.length
        }
        GetActionAt(e) {
            if (e = Math.floor(e), e < 0 || e >= this._actions.length) throw new RangeError("invalid action index");
            return this._actions[e]
        }
        GetActionByDebugIndex(e) {
            e = Math.floor(e);
            const t = this._actions.find(t => t.GetDebugIndex() === e);
            if (!t) throw new RangeError("invalid action debug index");
            return t
        }
        _HasActionIndex(e) {
            return e = Math.floor(e), e >= 0 && e < this._actions.length
        }
        GetSubEvents() {
            return this._subEvents
        }
        _GetAllLocalVariablesInScope() {
            return this._subEvents.filter(t => t instanceof e.EventVariable)
        }
        RunPreTrigger(e) {
            e.SetCurrentEvent(this);
            let t = !1;
            const n = this._conditions;
            for (let s = 0, i = n.length; s < i; ++s) {
                const o = n[s];
                if (e.SetConditionIndex(s), o.IsLooping()) throw new Error("trigger cannot be used as sub-event to a loop");
                if (o.Run()) t = !0;
                else if (!this._isOrBlock) return !1
            }
            return !this._isOrBlock || t
        }
        RunOrBlockTrigger(e, t) {
            e.SetCurrentEvent(this), this._conditions[t].Run() && (this._RunActions(e, 0) && this._RunSubEvents(e), e.SetLastEventTrue(!0))
        }* DebugRunPreTrigger(e) {
            e.SetCurrentEvent(this);
            let t = !1;
            const n = this._conditions;
            for (let s = 0, a = n.length; s < a; ++s) {
                const o = n[s];
                if (e.SetConditionIndex(s), o.IsLooping()) throw new Error("trigger cannot be used as sub-event to a loop");
                let i;
                if (o.DebugCanRunFast() ? i = o.Run() : i = yield* o.DebugRun(), i) t = !0;
                else if (!this._isOrBlock) return !1
            }
            return !this._isOrBlock || t
        }* DebugRunOrBlockTrigger(e, t) {
            e.SetCurrentEvent(this);
            const n = this._conditions[t];
            let s;
            if (n.DebugCanRunFast() ? s = n.Run() : s = yield* n.DebugRun(), s) {
                let t;
                this.DebugCanRunActionsFast() ? t = this._RunActions(e, 0) : t = yield* this._DebugRunActions(e, 0), t && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), e.SetLastEventTrue(!0)
            }
        }
        Run(e) {
            e.SetCurrentEvent(this), this._isElseBlock || e.SetElseBranchRan(!1), this._isOrBlock ? this._RunOrBlock(e) : this._RunAndBlock(e)
        }* DebugRun(e) {
            (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), e.SetCurrentEvent(this), this._isElseBlock || e.SetElseBranchRan(!1), this._isOrBlock ? yield* this._DebugRunOrBlock(e): yield* this._DebugRunAndBlock(e)
        }
        _RunOrBlock(e) {
            const n = this._conditions;
            let t = n.length === 0;
            for (let s = 0, i = n.length; s < i; ++s) {
                const o = n[s];
                if (o.IsTrigger()) continue;
                e.SetConditionIndex(s);
                const a = o.Run();
                t = t || a
            }
            e.SetLastEventTrue(t), t && (this._RunActions(e, 0) && this._RunSubEvents(e), this._hasElseBlock && e.SetElseBranchRan(!0))
        }* _DebugRunOrBlock(e) {
            const n = this._conditions;
            let t = n.length === 0;
            for (let s = 0, a = n.length; s < a; ++s) {
                const o = n[s];
                if (o.IsTrigger()) continue;
                e.SetConditionIndex(s);
                let i;
                o.DebugCanRunFast() ? i = o.Run() : i = yield* o.DebugRun(), t = t || i
            }
            if (e.SetLastEventTrue(t), t) {
                let t;
                this.DebugCanRunActionsFast() ? t = this._RunActions(e, 0) : t = yield* this._DebugRunActions(e, 0), t && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), this._hasElseBlock && e.SetElseBranchRan(!0)
            }
        }
        _RunAndBlock(e) {
            const t = this._conditions;
            for (let n = 0, s = t.length; n < s; ++n) {
                const o = t[n];
                e.SetConditionIndex(n);
                const i = o.Run();
                if (!i) {
                    e.SetLastEventTrue(!1);
                    return
                }
            }
            e.SetLastEventTrue(!0), this._RunActions(e, 0) && this._RunSubEvents(e), e.GetLastEventTrue() && this._hasElseBlock && e.SetElseBranchRan(!0)
        }* _DebugRunAndBlock(e) {
            const n = this._conditions;
            for (let t = 0, i = n.length; t < i; ++t) {
                const s = n[t];
                e.SetConditionIndex(t);
                let o;
                if (s.DebugCanRunFast() ? o = s.Run() : o = yield* s.DebugRun(), !o) {
                    e.SetLastEventTrue(!1);
                    return
                }
            }
            e.SetLastEventTrue(!0);
            let t;
            this.DebugCanRunActionsFast() ? t = this._RunActions(e, 0) : t = yield* this._DebugRunActions(e, 0), t && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), e.GetLastEventTrue() && this._hasElseBlock && e.SetElseBranchRan(!0)
        }
        _RunActions_Fast(e, t) {
            const n = this._actions;
            for (let s = t, o = n.length; s < o; ++s) {
                const i = n[s];
                e.SetActionIndex(s), i.Run()
            }
            return !0
        }* _DebugRunActions_Fast(e, t) {
            const n = this._actions;
            for (let s = t, i = n.length; s < i; ++s) {
                const o = n[s];
                e.SetActionIndex(s), o.DebugCanRunFast() ? o.Run() : yield* o.DebugRun()
            }
            return !0
        }
        _RunActions_ReturnValue(e, t) {
            const s = this.GetEventSheetManager(),
                n = this._actions;
            for (let o = t, r = n.length; o < r; ++o) {
                const i = n[o];
                e.SetActionIndex(o);
                const a = i.Run();
                if (i.CanBailOut() && a === !0) return !1;
                i.IsAsync() && a instanceof Promise && s.AddAsyncActionPromise(a)
            }
            return !0
        }* _DebugRunActions_ReturnValue(e, t) {
            const s = this.GetEventSheetManager(),
                n = this._actions;
            for (let a = t, r = n.length; a < r; ++a) {
                const o = n[a];
                e.SetActionIndex(a);
                let i;
                if (o.DebugCanRunFast() ? i = o.Run() : i = yield* o.DebugRun(), o.CanBailOut() && i === !0) return !1;
                o.IsAsync() && i instanceof Promise && s.AddAsyncActionPromise(i)
            }
            return !0
        }
        _ResumeActionsAndSubEvents(e) {
            this._RunActions(e, e.GetActionIndex()) && this._RunSubEvents()
        }* _DebugResumeActionsAndSubEvents(e) {
            (yield* this._DebugRunActions(e, e.GetActionIndex())) && (yield* this._DebugRunSubEvents())
        }
        _RunSubEvents() {
            if (!this._subEvents.length) return;
            const e = this.IsGroup() && this._runtime.IsCPUProfiling(),
                s = e ? performance.now() : 0,
                t = this._eventStack,
                n = t.Push(this);
            this._isSolWriterAfterCnds ? this._RunSubEvents_SolWriterAfterCnds(n) : this._RunSubEvents_Fast(n), t.Pop(), e && (this._perfRecord.totalTimeCounter += performance.now() - s)
        }
        _RunSubEvents_SolWriterAfterCnds(e) {
            const s = this._isGroup,
                o = this._isTopLevelGroup,
                t = this.GetEventSheetManager(),
                n = this._subEvents;
            for (let i = 0, r = n.length, d = r - 1; i < r; ++i) {
                const c = n[i],
                    a = c.GetSolModifiers(),
                    l = !o || !s && i < d;
                l && t.PushCopySol(a), c.Run(e), l ? t.PopSol(a) : t.ClearSol(a)
            }
        }
        _RunSubEvents_Fast(e) {
            const t = this._subEvents;
            for (let n = 0, s = t.length; n < s; ++n) t[n].Run(e)
        }* _DebugRunSubEvents() {
            if (!this._subEvents.length) return;
            const e = this._eventStack,
                t = e.Push(this);
            this._isSolWriterAfterCnds ? yield* this._DebugRunSubEvents_SolWriterAfterCnds(t): yield* this._DebugRunSubEvents_Fast(t), e.Pop()
        }* _DebugRunSubEvents_SolWriterAfterCnds(e) {
            const s = this._isGroup,
                o = this._isTopLevelGroup,
                t = this.GetEventSheetManager(),
                n = this._subEvents;
            for (let i = 0, r = n.length, d = r - 1; i < r; ++i) {
                const c = n[i],
                    a = c.GetSolModifiers(),
                    l = !o || !s && i < d;
                l && t.PushCopySol(a), yield* c.DebugRun(e), l ? t.PopSol(a) : t.ClearSol(a)
            }
        }* _DebugRunSubEvents_Fast(e) {
            const t = this._subEvents;
            for (let n = 0, s = t.length; n < s; ++n) yield* t[n].DebugRun(e)
        }
        Retrigger(e, t) {
            this._runtime.IncrementExecCount(), t.ResetQuick();
            const n = this._conditions;
            if (!this.IsOrBlock())
                for (let s = e.GetConditionIndex() + 1, o = n.length; s < o; ++s) {
                    const i = n[s];
                    t.SetConditionIndex(s);
                    const a = i.Run();
                    if (!a) return !1
                }
            return this._RunActions(t, 0) && this._RunSubEvents(t), !0
        }* DebugRetrigger(e, t) {
            this._runtime.IncrementExecCount(), t.ResetQuick();
            const s = this._conditions;
            if (!this.IsOrBlock())
                for (let n = e.GetConditionIndex() + 1, a = s.length; n < a; ++n) {
                    const o = s[n];
                    t.SetConditionIndex(n);
                    let i;
                    if (o.DebugCanRunFast() ? i = o.Run() : i = yield* o.DebugRun(), !i) return !1
                }
            let n;
            return this.DebugCanRunActionsFast() ? n = this._RunActions(t, 0) : n = yield* this._DebugRunActions(t, 0), n && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), !0
        }
        DebugCanRunFast() {
            return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext() && this._debugData.canRunSelfFast
        }
        DebugCanRunActionsFast() {
            return !this._runtime.DebugBreakNext() && this._debugData.canRunAllActionsFast
        }
        DebugCanRunSubEventsFast() {
            return !this._runtime.DebugBreakNext() && this._debugData.canRunAllSubEventsFast
        }
        _CheckParentsOKToRun(e) {
            if (this.GetParent()) {
                const t = this.GetTriggerParents();
                for (let n = 0, s = t.length; n < s; ++n)
                    if (!t[n].RunPreTrigger(e)) return !1
            }
            return !0
        }* _DebugCheckParentsOKToRun(e) {
            if (this.GetParent()) {
                const t = this.GetTriggerParents();
                for (let n = 0, s = t.length; n < s; ++n)
                    if (!(yield* t[n].DebugRunPreTrigger(e))) return !1
            }
            return !0
        }
        _EvaluateFunctionCallParameters(e, t, n) {
            if (t.length > 0)
                if (n) {
                    const n = t.map(e => e.Get(0));
                    e.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(n)
                } else this._scopeParent.EvaluateFunctionParameters(t);
            else n && e.GetLocalVarStack().Push()
        }
        RunAsFunctionCall(e, t) {
            let o, i;
            const a = e.length > 0,
                r = this._runtime,
                c = this._eventStack,
                n = r.GetEventSheetManager(),
                d = n._IncTriggerDepth(),
                l = d > 1;
            this._EvaluateFunctionCallParameters(n, t, l), a && n.PushCleanSol(e);
            const s = c.Push(this);
            if (this._CheckParentsOKToRun(s)) {
                r.IncrementExecCount(), s.SetCurrentEvent(this);
                const e = this._scopeParent.IsAsync();
                e && ([i, o] = this._scopeParent.StartAsyncFunctionCall()), this._RunAndBlock(s), e && this._scopeParent.MaybeFinishAsyncFunctionCall(i)
            }
            return c.Pop(), l && n.GetLocalVarStack().Pop(), a && n.PopSol(e), n._DecTriggerDepth(), o
        }* DebugRunAsFunctionCall(e, t) {
            let o, i;
            (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this);
            const a = e.length > 0,
                r = this._runtime,
                c = this._eventStack,
                n = r.GetEventSheetManager(),
                d = n._IncTriggerDepth(),
                l = d > 1;
            this._EvaluateFunctionCallParameters(n, t, l), a && n.PushCleanSol(e);
            const s = c.Push(this);
            if (yield* this._DebugCheckParentsOKToRun(s)) {
                r.IncrementExecCount(), s.SetCurrentEvent(this);
                const e = this._scopeParent.IsAsync();
                e && ([i, o] = this._scopeParent.StartAsyncFunctionCall()), yield* this._DebugRunAndBlock(s), e && this._scopeParent.MaybeFinishAsyncFunctionCall(i)
            }
            return c.Pop(), l && n.GetLocalVarStack().Pop(), a && n.PopSol(e), n._DecTriggerDepth(), o
        }
        RunAsMappedFunctionCall(e) {
            const n = this.GetSolModifiersIncludingParents(),
                o = n.length > 0,
                i = this._runtime,
                a = this._eventStack,
                t = i.GetEventSheetManager(),
                c = t._IncTriggerDepth(),
                r = c > 1;
            r && t.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(e), o && t.PushCleanSol(n);
            const s = a.Push(this);
            this._CheckParentsOKToRun(s) && (i.IncrementExecCount(), s.SetCurrentEvent(this), this._RunAndBlock(s)), a.Pop(), r && t.GetLocalVarStack().Pop(), o && t.PopSol(n), t._DecTriggerDepth()
        }* DebugRunAsMappedFunctionCall(e) {
            (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this);
            const n = this.GetSolModifiersIncludingParents(),
                o = n.length > 0,
                i = this._runtime,
                a = this._eventStack,
                t = i.GetEventSheetManager(),
                c = t._IncTriggerDepth(),
                r = c > 1;
            r && t.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(e), o && t.PushCleanSol(n);
            const s = a.Push(this);
            (yield* this._DebugCheckParentsOKToRun(s)) && (i.IncrementExecCount(), s.SetCurrentEvent(this), yield* this._DebugRunAndBlock(s)), a.Pop(), r && t.GetLocalVarStack().Pop(), o && t.PopSol(n), t._DecTriggerDepth()
        }
        RunAsExpressionFunctionCall(o, h, d, ...i) {
            let c, r;
            const a = o.length > 0,
                n = this._runtime,
                s = this._eventStack,
                t = n.GetEventSheetManager(),
                u = t._IncTriggerDepth(),
                l = u > 1;
            l && t.GetLocalVarStack().Push(), i.length > 0 && this._scopeParent.SetFunctionParameters(i), a && t.PushCleanSol(o);
            const e = s.Push(this);
            if (e.InitCallFunctionExpression(h, d), s.PushExpFunc(e), n.SetDebuggingEnabled(!1), this._CheckParentsOKToRun(e)) {
                n.IncrementExecCount(), e.SetCurrentEvent(this);
                const t = this._scopeParent.IsAsync();
                t && ([r, c] = this._scopeParent.StartAsyncFunctionCall()), this._RunAndBlock(e), t && this._scopeParent.MaybeFinishAsyncFunctionCall(r)
            }
            return n.SetDebuggingEnabled(!0), s.Pop(), s.PopExpFunc(), l && t.GetLocalVarStack().Pop(), a && t.PopSol(o), t._DecTriggerDepth(), c || e.GetFunctionReturnValue()
        }
    }
}
"use strict";
{
    const e = self.C3,
        n = [];
    let t = !1;
    e.EventScript = class EventScript extends e.DefendedBase {
        constructor(e, t, n) {
            super();
            const s = e.GetRuntime(),
                o = e.GetEventSheetManager();
            this._eventSheet = e, this._eventSheetManager = o, this._runtime = e.GetRuntime(), this._parent = t;
            const i = s.GetObjectReference(n[1]);
            this._func = i, this._displayNumber = n[2], this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber), this._debugData = s.IsDebug() ? {
                isBreakpoint: n[3][0],
                isBreakable: n[3][1]
            } : null
        }
        static Create(t, n, s) {
            return e.New(e.EventScript, t, n, s)
        }
        _PostInit() {
            const e = this._func,
                t = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this);
            this._func = e.bind(null, this._runtime.GetIRuntime(), t)
        }
        GetParent() {
            return this._parent
        }
        GetScopeParent() {
            return this._parent
        }
        GetEventSheet() {
            return this._eventSheet
        }
        GetDisplayNumber() {
            return this._displayNumber
        }
        IsDebugBreakable() {
            return this._debugData && this._debugData.isBreakable
        }
        IsDebugBreakpoint() {
            return this.IsDebugBreakable() && this._debugData.isBreakpoint
        }
        _SetDebugBreakpoint(e) {
            this._debugData.isBreakpoint = !!e
        }
        IsElseBlock() {
            return !1
        }
        GetSolModifiers() {
            return n
        }
        GetSolModifiersIncludingParents() {
            return this._parent ? this._parent.GetSolModifiersIncludingParents() : n
        }
        Run(e) {
            e.SetCurrentEvent(this), this._eventSheetManager.AddAsyncActionPromise(this._RunUserScript())
        }
        async _RunUserScript() {
            try {
                await this._func()
            } catch (e) {
                console.error(`Unhandled exception running script %c${this.GetEventSheet().GetName()}, event ${this.GetDisplayNumber()}:`, "font-size: 1.2em; font-weight: bold;", e), self.C3Debugger && self.C3Debugger._SetLastErrorScript(this), t || (console.info(`%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()`, "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), t = !0)
            }
        }* DebugRun(e) {
            e.SetCurrentEvent(this), (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this.Run(e)
        }
        DebugCanRunFast() {
            return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext()
        }
        static HadUserScriptException() {
            return t
        }
        static SetHadUserScriptException() {
            t = !0
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = self.assert;
    e.FunctionBlock = class FunctionBlock extends e.DefendedBase {
        constructor(t, n, s) {
            super(), this._eventSheet = t, this._runtime = t.GetRuntime(), this._parent = n;
            const o = s[1];
            this._functionName = o[0], this._returnType = o[1], this._functionParameters = o[2].map(n => e.EventVariable.Create(t, this, n)), this._isEnabled = o[3], this._isAsync = o[4], this._nextAsyncId = 0, this._currentAsyncId = -1, this._asyncMap = new Map, this._eventBlock = e.EventBlock.Create(t, n, s), this._eventBlock._SetScopeParent(this)
        }
        static Create(t, n, s) {
            return e.New(e.FunctionBlock, t, n, s)
        }
        _PostInit() {
            for (const e of this._functionParameters) e._PostInit();
            this._eventBlock._PostInit(!1)
        }
        _GetAllLocalVariablesInScope() {
            return this._functionParameters
        }
        GetFunctionParameters() {
            return this._functionParameters
        }
        GetFunctionParameterCount() {
            return this._functionParameters.length
        }
        EvaluateFunctionParameters(e) {
            const t = this._functionParameters;
            for (let n = 0, s = t.length; n < s; ++n) t[n].SetValue(e[n].Get(0))
        }
        SetFunctionParameters(e) {
            const t = this._functionParameters;
            for (let n = 0, s = t.length; n < s; ++n) t[n].SetValue(e[n])
        }
        CaptureFunctionParameters() {
            return this._functionParameters.map(e => e.GetValue())
        }
        GetParent() {
            return this._parent
        }
        GetScopeParent() {
            return this._parent
        }
        GetFunctionName() {
            return this._functionName
        }
        GetReturnType() {
            return this._returnType
        }
        IsEnabled() {
            return this._isEnabled
        }
        GetDefaultReturnValue() {
            switch (this._returnType) {
                case 0:
                    return null;
                case 2:
                    return "";
                default:
                    return 0
            }
        }
        GetEventBlock() {
            return this._eventBlock
        }
        IsAsync() {
            return this._isAsync
        }
        StartAsyncFunctionCall() {
            const e = this._nextAsyncId++;
            this._currentAsyncId = e;
            let t;
            const n = new Promise(e => t = e);
            return this._asyncMap.set(e, {
                resolve: t,
                pauseCount: 0
            }), [e, n]
        }
        MaybeFinishAsyncFunctionCall(e) {
            const t = this._asyncMap.get(e);
            t.pauseCount === 0 && (t.resolve(), this._asyncMap.delete(e)), this._currentAsyncId = -1
        }
        PauseCurrentAsyncFunction() {
            const e = this._asyncMap.get(this._currentAsyncId);
            return e.pauseCount++, this._currentAsyncId
        }
        ResumeAsyncFunction(e) {
            this._currentAsyncId = e;
            const t = this._asyncMap.get(e);
            t.pauseCount--
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = [];
    e.EventVariable = class EventVariable extends e.DefendedBase {
        constructor(t, n, s) {
            super();
            const o = t.GetEventSheetManager();
            this._eventSheet = t, this._eventSheetManager = o, this._runtime = t.GetRuntime(), this._parent = n, this._localVarStack = o.GetLocalVarStack(), this._name = s[1], this._type = s[2], this._initialValue = s[3], this._isStatic = !!s[4], this._isConstant = !!s[5], this._isFunctionParameter = n instanceof e.FunctionBlock, this._sid = s[6], this._jsPropName = this._runtime.GetJsPropName(s[8]), this._scriptSetter = e => this.SetValue(e), this._scriptGetter = () => this.GetValue(), this._hasSingleValue = !this._parent || this._isStatic || this._isConstant, this._value = this._initialValue, this._localIndex = -1, this.IsBoolean() && (this._value = this._value ? 1 : 0), this.IsLocal() && !this.IsStatic() && !this.IsConstant() && (this._localIndex = o._GetNextLocalVarIndex(this)), o._RegisterEventVariable(this)
        }
        static Create(t, n, s) {
            return e.New(e.EventVariable, t, n, s)
        }
        _PostInit() {}
        GetName() {
            return this._name
        }
        GetJsPropName() {
            return this._jsPropName
        }
        GetParent() {
            return this._parent
        }
        IsGlobal() {
            return !this.GetParent()
        }
        IsLocal() {
            return !this.IsGlobal()
        }
        IsFunctionParameter() {
            return this._isFunctionParameter
        }
        IsStatic() {
            return this._isStatic
        }
        IsConstant() {
            return this._isConstant
        }
        IsNumber() {
            return this._type === 0
        }
        IsString() {
            return this._type === 1
        }
        IsBoolean() {
            return this._type === 2
        }
        IsElseBlock() {
            return !1
        }
        GetSID() {
            return this._sid
        }
        GetInitialValue() {
            return this._initialValue
        }
        GetSolModifiers() {
            return t
        }
        Run() {
            this.IsLocal() && !this.IsStatic() && !this.IsConstant() && this.SetValue(this.GetInitialValue())
        }
        DebugCanRunFast() {
            return !0
        }* DebugRun(e) {
            this.Run(e)
        }
        SetValue(e) {
            this.IsNumber() ? typeof e != "number" && (e = parseFloat(e)) : this.IsString() ? typeof e != "string" && (e = e.toString()) : this.IsBoolean() && (e = e ? 1 : 0), this._hasSingleValue ? this._value = e : this._localVarStack.GetCurrent()[this._localIndex] = e
        }
        GetValue() {
            return this._hasSingleValue ? this._value : this._localVarStack.GetCurrent()[this._localIndex]
        }
        GetTypedValue() {
            let e = this.GetValue();
            return this.IsBoolean() && (e = !!e), e
        }
        ResetToInitialValue() {
            this._value = this._initialValue
        }
        _GetScriptInterfaceDescriptor() {
            return {
                configurable: !1,
                enumerable: !0,
                get: this._scriptGetter,
                set: this._scriptSetter
            }
        }
    }
}
"use strict";
{
    const e = self.C3,
        n = self.assert,
        t = [];
    e.EventInclude = class EventInclude extends e.DefendedBase {
        constructor(e, t, n) {
            super();
            const s = e.GetEventSheetManager();
            this._eventSheet = e, this._eventSheetManager = s, this._runtime = e.GetRuntime(), this._parent = t, this._includeSheet = null, this._includeSheetName = n[1], this._isActive = !0
        }
        static Create(t, n, s) {
            return e.New(e.EventInclude, t, n, s)
        }
        _PostInit() {
            this._includeSheet = this._eventSheetManager.GetEventSheetByName(this._includeSheetName), this._eventSheet._AddShallowInclude(this);
            let t = this.GetParent();
            for (; t;) t instanceof e.EventBlock && t.IsGroup() && t._AddContainedInclude(this), t = t.GetParent();
            this.UpdateActive(), this._runtime.IsDebug() && this._eventSheet._GetPerfRecord().children.push(this._includeSheet._GetPerfRecord())
        }
        GetParent() {
            return this._parent
        }
        GetSolModifiers() {
            return t
        }
        GetIncludeSheet() {
            return this._includeSheet
        }
        Run() {
            const t = !!this.GetParent(),
                n = this._runtime.GetAllObjectClasses();
            t && this._eventSheetManager.PushCleanSol(n), this._includeSheet.Run(), t && this._eventSheetManager.PopSol(n)
        }* DebugRun() {
            const t = !!this.GetParent(),
                n = this._runtime.GetAllObjectClasses();
            t && this._eventSheetManager.PushCleanSol(n), yield* this._includeSheet.DebugRun(), t && this._eventSheetManager.PopSol(n)
        }
        DebugCanRunFast() {
            return !1
        }
        IsActive() {
            return this._isActive
        }
        UpdateActive() {
            let t = this.GetParent();
            for (; t;) {
                if (t instanceof e.EventBlock && t.IsGroup() && !t.IsGroupActive()) {
                    this._isActive = !1;
                    return
                }
                t = t.GetParent()
            }
            this._isActive = !0
        }
    }
}
"use strict";
{
    const e = self.C3,
        r = self.assert;
    e.ExpNode = class ExpNode extends e.DefendedBase {
        constructor(e) {
            super(), this._owner = e, this._runtime = e.GetRuntime()
        }
        _PostInit() {}
        static CreateNode(r, c) {
            const l = c[0],
                d = [i, s, o, a, t, n];
            return e.New(d[l], r, c)
        }
    };
    class t extends e.ExpNode {
        constructor(t, n) {
            super(t), this._systemPlugin = this._runtime.GetSystemPlugin(), this._func = this._runtime.GetObjectReference(n[1]), (this._func === e.Plugins.System.Exps.random || this._func === e.Plugins.System.Exps.choose) && this._owner.SetVariesPerInstance()
        }
        GetBoundMethod() {
            return this._systemPlugin._GetBoundACEMethod(this._func, this._systemPlugin)
        }
    }
    class n extends e.ExpNode {
        constructor(e, t) {
            super(e), this._functionBlock = null, this._functionName = t[1], this._owner.SetVariesPerInstance()
        }
        _PostInit() {
            const e = this._runtime.GetEventSheetManager();
            this._functionBlock = e.GetFunctionBlockByName(this._functionName), this._functionName = null;
            const t = this._owner.GetEventBlock(),
                n = this._functionBlock.GetEventBlock();
            this._combinedSolModifiers = [...new Set([...t.GetSolModifiersIncludingParents(), ...n.GetSolModifiersIncludingParents()])], this._combinedSolModifiers = e._DeduplicateSolModifierList(this._combinedSolModifiers)
        }
        GetBoundMethod() {
            const t = this._functionBlock;
            if (t.IsEnabled()) {
                const n = t.GetEventBlock();
                return e.EventBlock.prototype.RunAsExpressionFunctionCall.bind(n, this._combinedSolModifiers, t.GetReturnType(), t.GetDefaultReturnValue())
            }
            const n = t.GetDefaultReturnValue();
            return () => n
        }
    }

    function WrapIndex(e, t) {
        return e >= t ? e % t : e < 0 ? (e <= -t && (e %= t), e < 0 && (e += t), e) : e
    }
    class s extends e.ExpNode {
        constructor(e, t) {
            super(e), this._objectClass = this._runtime.GetObjectClassByIndex(t[1]), this._func = this._runtime.GetObjectReference(t[2]), this._returnsString = !!t[3], this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._owner._MaybeVaryFor(this._objectClass)
        }
        GetBoundMethod() {
            return this._objectClass.GetPlugin()._GetBoundACEMethod(this._func, this._objectClass.GetSingleGlobalInstance().GetSdkInstance())
        }
        ExpObject(...s) {
            const e = this._objectClass,
                t = e.GetCurrentSol().GetExpressionInstances(),
                n = t.length;
            if (n === 0) return this._returnsString ? "" : 0;
            const o = WrapIndex(this._owner.GetSolIndex(), n);
            return this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(e), this._func.apply(t[o].GetSdkInstance(), s)
        }
        ExpObject_InstExpr(s, ...o) {
            const e = this._objectClass,
                t = e.GetInstances(),
                n = t.length;
            if (n === 0) return this._returnsString ? "" : 0;
            const i = WrapIndex(s, n);
            return this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(e), this._func.apply(t[i].GetSdkInstance(), o)
        }
    }
    class o extends e.ExpNode {
        constructor(e, t) {
            super(e), this._objectClass = this._runtime.GetObjectClassByIndex(t[1]), this._varIndex = t[3], this._returnsString = !!t[2], this._owner._MaybeVaryFor(this._objectClass)
        }
        ExpInstVar() {
            const e = this._objectClass.GetCurrentSol().GetExpressionInstances(),
                t = e.length;
            if (t === 0) return this._returnsString ? "" : 0;
            const n = WrapIndex(this._owner.GetSolIndex(), t);
            return e[n]._GetInstanceVariableValueUnchecked(this._varIndex)
        }
        ExpInstVar_Family() {
            const e = this._objectClass,
                t = e.GetCurrentSol().GetExpressionInstances(),
                n = t.length;
            if (n === 0) return this._returnsString ? "" : 0;
            const o = WrapIndex(this._owner.GetSolIndex(), n),
                s = t[o],
                i = s.GetObjectClass().GetFamilyInstanceVariableOffset(e.GetFamilyIndex());
            return s._GetInstanceVariableValueUnchecked(this._varIndex + i)
        }
        ExpInstVar_InstExpr(e) {
            const t = this._objectClass,
                n = t.GetInstances(),
                s = n.length;
            if (s === 0) return this._returnsString ? "" : 0;
            const a = WrapIndex(e, s),
                o = n[a];
            let i = 0;
            return t.IsFamily() && (i = o.GetObjectClass().GetFamilyInstanceVariableOffset(t.GetFamilyIndex())), o._GetInstanceVariableValueUnchecked(this._varIndex + i)
        }
    }
    class i extends e.ExpNode {
        constructor(e, t) {
            super(e), this._objectClass = this._runtime.GetObjectClassByIndex(t[1]), this._behaviorType = this._objectClass.GetBehaviorTypeByName(t[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(t[2]), this._func = this._runtime.GetObjectReference(t[3]), this._returnsString = !!t[4], this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._owner._MaybeVaryFor(this._objectClass)
        }
        ExpBehavior(...i) {
            const e = this._objectClass,
                t = e.GetCurrentSol().GetExpressionInstances(),
                n = t.length;
            if (n === 0) return this._returnsString ? "" : 0;
            const a = WrapIndex(this._owner.GetSolIndex(), n);
            this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(e);
            const s = t[a];
            let o = 0;
            return e.IsFamily() && (o = s.GetObjectClass().GetFamilyBehaviorOffset(e.GetFamilyIndex())), this._func.apply(s.GetBehaviorInstances()[this._behaviorIndex + o].GetSdkInstance(), i)
        }
        ExpBehavior_InstExpr(i, ...a) {
            const e = this._objectClass,
                t = e.GetInstances(),
                n = t.length;
            if (n === 0) return this._returnsString ? "" : 0;
            const r = WrapIndex(i, n);
            this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(e);
            const s = t[r];
            let o = 0;
            return e.IsFamily() && (o = s.GetObjectClass().GetFamilyBehaviorOffset(e.GetFamilyIndex())), this._func.apply(s.GetBehaviorInstances()[this._behaviorIndex + o].GetSdkInstance(), a)
        }
    }
    class a extends e.ExpNode {
        constructor(e, t) {
            super(e), this._eventVar = null, this._eventVarSid = t[1]
        }
        _PostInit() {
            this._eventVar = this._runtime.GetEventSheetManager().GetEventVariableBySID(this._eventVarSid)
        }
        GetVar() {
            return this._eventVar
        }
    }
}
"use strict";
{
    const e = self.C3,
        p = self.assert;
    e.Parameter = class Parameter extends e.DefendedBase {
        constructor(e, t, n) {
            super(), this._owner = e, this._index = n, this._type = t, this.Get = null, this._variesPerInstance = !1, this._isConstant = !1
        }
        static Create(p, g, v) {
            const b = g[0],
                j = [t, o, s, n, r, c, i, t, n, n, d, u, s, m, o, l, a, h, f];
            return e.New(j[b], p, b, v, g)
        }
        _PostInit() {}
        SetVariesPerInstance() {
            this._variesPerInstance = !0
        }
        _MaybeVaryFor(e) {
            if (this._variesPerInstance) return;
            if (!e) return;
            e.GetPlugin().IsSingleGlobal() || (this._variesPerInstance = !0)
        }
        VariesPerInstance() {
            return this._variesPerInstance
        }
        GetIndex() {
            return this._index
        }
        GetRuntime() {
            return this._owner.GetRuntime()
        }
        GetEventBlock() {
            return this._owner.GetEventBlock()
        }
        IsConstant() {
            return this._isConstant
        }
    };

    function GetExpressionFunc(e) {
        const t = self.C3_ExpressionFuncs[e];
        if (!t) throw new Error("invalid expression number");
        return t
    }
    class t extends e.Parameter {
        constructor(t, n, s, o) {
            super(t, n, s), this._solIndex = 0;
            const i = o[1];
            this._expressionNumber = i[0], this._numberedNodes = [], this._expressionFunc = null;
            for (let t = 1, n = i.length; t < n; ++t) this._numberedNodes.push(e.ExpNode.CreateNode(this, i[t]));
            this._numberedNodes.length ? this.Get = this.GetExpression : (this.Get = GetExpressionFunc(this._expressionNumber), this._isConstant = !0)
        }
        _GetNode(e) {
            if (e < 0 || e >= this._numberedNodes.length) throw new RangeError("invalid numbered node");
            return this._numberedNodes[e]
        }
        _PostInit() {
            for (const e of this._numberedNodes) e._PostInit();
            const e = GetExpressionFunc(this._expressionNumber);
            this._numberedNodes.length ? this._expressionFunc = e(this) : this._expressionFunc = e
        }
        GetSolIndex() {
            return this._solIndex
        }
        GetExpression(e) {
            return this._solIndex = e, this._expressionFunc()
        }
    }
    class o extends t {
        constructor(t, n, s, o) {
            super(t, n, s, o), this.Get = this.GetStringExpression, n === 14 && (this.GetEventBlock().SetAllSolModifiers(), this._owner instanceof e.Action && this.GetEventBlock().SetSolWriterAfterCnds())
        }
        GetStringExpression(e) {
            this._solIndex = e;
            const t = this._expressionFunc();
            return typeof t == "string" ? t : ""
        }
        _GetFastTriggerValue() {
            return GetExpressionFunc(this._expressionNumber)()
        }
    }
    class c extends t {
        constructor(e, t, n, s) {
            super(e, t, n, s), this.Get = this.GetLayer, this._isConstant = !1
        }
        GetLayer(e) {
            this._solIndex = e;
            const t = this._expressionFunc(),
                n = this.GetRuntime().GetCurrentLayout();
            return n.GetLayer(t)
        }
    }
    class n extends e.Parameter {
        constructor(e, t, n, s) {
            super(e, t, n), this._combo = s[1], this.Get = this.GetCombo, this._isConstant = !0
        }
        GetCombo() {
            return this._combo
        }
    }
    class a extends e.Parameter {
        constructor(e, t, n, s) {
            super(e, t, n), this._bool = s[1], this.Get = this.GetBoolean, this._isConstant = !0
        }
        GetBoolean() {
            return this._bool
        }
    }
    class r extends e.Parameter {
        constructor(t, n, s, o) {
            super(t, n, s), this._objectClass = this.GetRuntime().GetObjectClassByIndex(o[1]), this.Get = this.GetObjectClass;
            const i = this.GetEventBlock();
            i._AddSolModifier(this._objectClass), this._owner instanceof e.Action ? i.SetSolWriterAfterCnds() : i.GetParent() && i.GetParent().SetSolWriterAfterCnds(), this._isConstant = !0
        }
        GetObjectClass() {
            return this._objectClass
        }
    }
    class i extends e.Parameter {
        constructor(e, t, n, s) {
            super(e, t, n), this._layout = this.GetRuntime().GetLayoutManager().GetLayoutByName(s[1]), this.Get = this.GetLayout, this._isConstant = !0
        }
        GetLayout() {
            return this._layout
        }
    }
    class l extends e.Parameter {
        constructor(e, t, n, s) {
            super(e, t, n), this._timeline = this.GetRuntime().GetTimelineManager().GetTimelineByName(s[1]), this.Get = this.GetTimeline, this._isConstant = !0
        }
        GetTimeline() {
            return this._timeline
        }
    }
    class s extends e.Parameter {
        constructor(e, t, n, s) {
            super(e, t, n), this._fileInfo = s[1], this.Get = this.GetFile, this._isConstant = !0
        }
        GetFile() {
            return this._fileInfo
        }
    }
    class d extends e.Parameter {
        constructor(e, t, n, s) {
            super(e, t, n), this._instVarIndex = s[1];
            const o = this._owner.GetObjectClass();
            o && o.IsFamily() ? (this.Get = this.GetFamilyInstanceVariable, this.SetVariesPerInstance()) : (this.Get = this.GetInstanceVariable, this._isConstant = !0)
        }
        GetInstanceVariable() {
            return this._instVarIndex
        }
        GetFamilyInstanceVariable(e) {
            e = e || 0;
            const t = this._owner.GetObjectClass(),
                s = t.GetCurrentSol(),
                o = s.GetInstances();
            let n = null;
            if (o.length) n = o[e % o.length].GetObjectClass();
            else if (s.HasAnyElseInstances()) {
                const t = s.GetElseInstances();
                n = t[e % t.length].GetObjectClass()
            } else if (t.GetInstanceCount() > 0) {
                const s = t.GetInstances();
                n = s[e % s.length].GetObjectClass()
            } else return 0;
            return this._instVarIndex + n.GetFamilyInstanceVariableOffset(t.GetFamilyIndex())
        }
    }
    class u extends e.Parameter {
        constructor(e, t, n, s) {
            super(e, t, n), this._eventVarSid = s[1], this._eventVar = null, this.Get = this.GetEventVariable, this._isConstant = !0
        }
        _PostInit() {
            this._eventVar = this.GetRuntime().GetEventSheetManager().GetEventVariableBySID(this._eventVarSid)
        }
        GetEventVariable() {
            return this._eventVar
        }
    }
    class h extends e.Parameter {
        constructor(e, t, n, s) {
            super(e, t, n), this._functionBlockName = s[1], this._functionBlock = null, this.Get = this.GetFunction, this._isConstant = !0
        }
        _PostInit() {
            this._functionBlock = this.GetRuntime().GetEventSheetManager().GetFunctionBlockByName(this._functionBlockName), this._functionBlockName = null
        }
        GetFunction() {
            return this._functionBlock
        }
    }
    class m extends e.Parameter {
        constructor(t, n, s, o) {
            super(t, n, s), this._subParams = [], this._variadicRet = [], this._isConstant = !0;
            for (let t = 1, s = o.length; t < s; ++t) {
                const n = e.Parameter.Create(this._owner, o[t], 0);
                this._subParams.push(n), this._variadicRet.push(0), n.IsConstant() || (this._isConstant = !1)
            }
            this.Get = this.GetVariadic
        }
        _PostInit() {
            for (const e of this._subParams) e._PostInit()
        }
        GetVariadic() {
            const e = this._subParams,
                t = this._variadicRet;
            for (let n = 0, s = e.length; n < s; ++n) t[n] = e[n].Get(0);
            return t
        }
    }
    class f extends e.Parameter {
        constructor(e, t, n, s) {
            super(e, t, n), this._easeIndex = s[1], this.Get = this.GetEase, this._isConstant = !0
        }
        GetEase() {
            return this._easeIndex
        }
    }
}
"use strict";
{
    const e = self.C3,
        s = self.assert;

    function EvalParams(e, t) {
        for (let n = 0, s = e.length; n < s; ++n) t[n] = e[n].Get(0)
    }
    const t = [],
        n = function() {};
    e.Condition = class Condition extends e.DefendedBase {
        constructor(s, o, i) {
            if (super(), this._eventBlock = s, this._runtime = s.GetRuntime(), this._index = i, this._func = this._runtime.GetObjectReference(o[1]), this._isTrigger = o[3] > 0, this._isFastTrigger = o[3] === 2, this._isLooping = !!o[4], this._isInverted = !!o[5], this._isStatic = !!o[6], this._sid = o[7], this._isInOrBlock = this._eventBlock.IsOrBlock(), this._objectClass = null, this._behaviorType = null, this._behaviorIndex = -1, this._systemPlugin = null, this.Run = n, this.DebugRun = n, this._parameters = [], this._results = [], this._anyParamVariesPerInstance = !1, this._savedData = null, this._unsavedData = null, this._debugData = this._runtime.IsDebug() ? {
                    isBreakpoint: o[8][0],
                    canDebug: o[8][1]
                } : null, o[0] === -1 ? this._systemPlugin = this._runtime.GetSystemPlugin() : (this._objectClass = this._runtime.GetObjectClassByIndex(o[0]), o[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(o[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(o[2])), this._eventBlock.GetParent() && this._eventBlock.GetParent().SetSolWriterAfterCnds()), o.length === 10) {
                let t = o[9];
                for (let n of t) this._parameters.push(e.Parameter.Create(this, n, this._parameters.length)), this._results.push(0)
            }
            this._parameters.length === 0 && (this._parameters = t, this._results = t), this._eventBlock.GetEventSheetManager()._RegisterCondition(this)
        }
        static Create(t, n, s) {
            return e.New(e.Condition, t, n, s)
        }
        _PostInit() {
            for (const e of this._parameters) e._PostInit(), e.VariesPerInstance() && (this._anyParamVariesPerInstance = !0);
            this._isFastTrigger ? (this.Run = this._RunFastTrigger, this.DebugRun = this._DebugRunFastTrigger) : this._systemPlugin ? (this._SetSystemRunMethod(), this.DebugRun = this._DebugRunSystem) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(), this.DebugRun = this._DebugRunSingleGlobal) : this._isStatic ? (this.Run = this._RunStatic, this.DebugRun = this._DebugRunStatic) : (this.Run = this._RunObject, this.DebugRun = this._DebugRunObject)
        }
        _SetSystemRunMethod() {
            const e = this._systemPlugin,
                t = this._systemPlugin;
            this._SetRunMethodForBoundFunc(e, t, this._RunSystem)
        }
        _SetSingleGlobalRunMethod() {
            const e = this._objectClass.GetPlugin(),
                t = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
            this._SetRunMethodForBoundFunc(e, t, this._RunSingleGlobal)
        }
        _SetRunMethodForBoundFunc(t, n, s) {
            const a = this._func,
                i = this._isInverted,
                o = this._parameters;
            if (o.length === 0) {
                const s = t._GetBoundACEMethod(a, n);
                i ? this.Run = function() {
                    return e.xor(s(), i)
                } : this.Run = s
            } else if (o.length === 1) {
                const s = o[0];
                if (!i && s.IsConstant()) this.Run = t._GetBoundACEMethod_1param(a, n, s.Get(0));
                else {
                    const o = t._GetBoundACEMethod(a, n);
                    this.Run = function() {
                        return e.xor(o(s.Get(0)), i)
                    }
                }
            } else if (o.length === 2) {
                const s = o[0],
                    r = o[1];
                if (!i && s.IsConstant() && r.IsConstant()) this.Run = t._GetBoundACEMethod_2params(a, n, s.Get(0), r.Get(0));
                else {
                    const o = t._GetBoundACEMethod(a, n);
                    this.Run = function() {
                        return e.xor(o(s.Get(0), r.Get(0)), i)
                    }
                }
            } else if (o.length === 3) {
                const s = o[0],
                    r = o[1],
                    c = o[2];
                if (!i && s.IsConstant() && r.IsConstant() && c.IsConstant()) this.Run = t._GetBoundACEMethod_3params(a, n, s.Get(0), r.Get(0), c.Get(0));
                else {
                    const o = t._GetBoundACEMethod(a, n);
                    this.Run = function() {
                        return e.xor(o(s.Get(0), r.Get(0), c.Get(0)), i)
                    }
                }
            } else this.Run = s
        }
        GetSID() {
            return this._sid
        }
        _GetFunc() {
            return this._func
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetBehaviorType() {
            return this._behaviorType
        }
        GetEventBlock() {
            return this._eventBlock
        }
        GetRuntime() {
            return this._runtime
        }
        GetIndex() {
            return this._index
        }
        GetDebugIndex() {
            return this.GetIndex()
        }
        IsTrigger() {
            return this._isTrigger
        }
        IsFastTrigger() {
            return this._isFastTrigger
        }
        IsInverted() {
            return this._isInverted
        }
        IsLooping() {
            return this._isLooping
        }
        IsBreakpoint() {
            return this._debugData.isBreakpoint
        }
        _SetBreakpoint(e) {
            this._debugData.isBreakpoint = !!e, this._eventBlock._UpdateCanRunFastRecursive()
        }
        _DebugReturnsGenerator() {
            return this._debugData.canDebug
        }
        DebugCanRunFast() {
            return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator()
        }
        GetSavedDataMap() {
            return this._savedData || (this._savedData = new Map), this._savedData
        }
        GetUnsavedDataMap() {
            return this._unsavedData || (this._unsavedData = new Map), this._unsavedData
        }
        _RunSystem() {
            const t = this._results;
            return EvalParams(this._parameters, t), e.xor(this._func.apply(this._systemPlugin, t), this._isInverted)
        }* _DebugRunSystem() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
                const n = this._results;
                EvalParams(this._parameters, n);
                let t = this._func.apply(this._systemPlugin, n);
                return e.IsIterator(t) && (t = yield* t), e.xor(t, this._isInverted)
            }
            return this.Run()
        }
        _RunSingleGlobal() {
            const t = this._results;
            EvalParams(this._parameters, t);
            const n = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
            return e.xor(this._func.apply(n, t), this._isInverted)
        }* _DebugRunSingleGlobal() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
                const n = this._results;
                EvalParams(this._parameters, n);
                const s = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
                let t = this._func.apply(s, n);
                return e.IsIterator(t) && (t = yield* t), e.xor(t, this._isInverted)
            }
            return this.Run()
        }
        _RunFastTrigger() {
            return !0
        }* _DebugRunFastTrigger() {
            return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), !0
        }
        _RunStatic() {
            const e = this._results;
            EvalParams(this._parameters, e);
            const t = this._func.apply(this._behaviorType || this._objectClass, e);
            return this._objectClass.ApplySolToContainer(), t
        }* _DebugRunStatic() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
                const n = this._results;
                EvalParams(this._parameters, n);
                let t = this._func.apply(this._behaviorType || this._objectClass, n);
                return e.IsIterator(t) && (t = yield* t), this._objectClass.ApplySolToContainer(), t
            }
            return this.Run()
        }
        _RunObject() {
            const t = this._parameters,
                n = this._results,
                e = this._objectClass.GetCurrentSol();
            for (let e = 0, o = t.length; e < o; ++e) {
                const s = t[e];
                s.VariesPerInstance() || (n[e] = s.Get(0))
            }
            return e.IsSelectAll() ? this._RunObject_FirstFilter(e) : this._RunObject_NextFilter(e)
        }* _DebugRunObject() {
            return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._RunObject()
        }
        _EvaluateVaryingParameters(e) {
            const t = this._parameters,
                n = this._results;
            for (let s = 0, i = t.length; s < i; ++s) {
                const o = t[s];
                o.VariesPerInstance() && (n[s] = o.Get(e))
            }
        }
        _RunObject_FirstFilter(t) {
            const n = this._objectClass,
                r = n.IsFamily(),
                c = n.GetFamilyIndex(),
                s = this._behaviorIndex,
                l = s >= 0,
                o = n.GetInstances(),
                d = this._anyParamVariesPerInstance,
                i = this._results,
                a = this._func,
                u = this._isInverted,
                h = this._isInOrBlock && !this._isTrigger;
            t.ClearArrays();
            for (let m = 0, p = o.length; m < p; ++m) {
                const n = o[m];
                d && this._EvaluateVaryingParameters(m);
                let f;
                if (l) {
                    const e = r ? n.GetObjectClass().GetFamilyBehaviorOffset(c) : 0;
                    f = a.apply(n.GetBehaviorInstances()[s + e].GetSdkInstance(), i)
                } else f = a.apply(n.GetSdkInstance(), i);
                e.xor(f, u) ? t._PushInstance(n) : h && t._PushElseInstance(n)
            }
            return n.FinishCondition(!0), t._SetSelectAll(!1), n.ApplySolToContainer(), t.HasAnyInstances()
        }
        _RunObject_NextFilter(t) {
            const s = this._objectClass,
                b = s.IsFamily(),
                v = s.GetFamilyIndex(),
                i = s.IsInContainer(),
                m = this._behaviorIndex,
                g = m >= 0,
                p = this._anyParamVariesPerInstance,
                u = this._results,
                d = this._func,
                f = this._isInverted,
                c = this._isInOrBlock && !this._isTrigger,
                l = t._GetOwnInstances(),
                h = t._GetOwnElseInstances(),
                r = c && !this._eventBlock.IsFirstConditionOfType(this),
                a = r ? h : l;
            let n = 0,
                o = !1;
            for (let s = 0, y = a.length; s < y; ++s) {
                const t = a[s];
                p && this._EvaluateVaryingParameters(s);
                let j;
                if (g) {
                    const e = b ? t.GetObjectClass().GetFamilyBehaviorOffset(v) : 0;
                    j = d.apply(t.GetBehaviorInstances()[m + e].GetSdkInstance(), u)
                } else j = d.apply(t.GetSdkInstance(), u);
                e.xor(j, f) ? (o = !0, r ? (l.push(t), i && t._PushSiblingsToSolInstances()) : (a[n] = t, i && t._SetSiblingsToSolInstancesIndex(n), ++n)) : r ? (a[n] = t, i && t._SetSiblingsToSolElseInstancesIndex(n), ++n) : c && (h.push(t), i && t._PushSiblingsToSolElseInstances())
            }
            e.truncateArray(a, n), i && s._TruncateContainerSols(r, n);
            const j = o;
            return r && !o && (o = this._OrBlockCheckInstances(l)), s.FinishCondition(j || c), c ? o : t.HasAnyInstances()
        }
        _OrBlockCheckInstances(t) {
            const n = this._objectClass,
                a = n.IsFamily(),
                r = n.GetFamilyIndex(),
                c = this._anyParamVariesPerInstance,
                s = this._behaviorIndex,
                l = s >= 0,
                o = this._results,
                i = this._func,
                d = this._isInverted;
            for (let n = 0, m = t.length; n < m; ++n) {
                const u = t[n];
                c && this._EvaluateVaryingParameters(n);
                let h;
                if (l) {
                    const e = a ? u.GetObjectClass().GetFamilyBehaviorOffset(r) : 0;
                    h = i.apply(u.GetBehaviorInstances()[s + e].GetSdkInstance(), o)
                } else h = i.apply(u.GetSdkInstance(), o);
                if (e.xor(h, d)) return !0
            }
            return !1
        }
        ReevaluateParameter(e, t) {
            return this._parameters[e].Get(t)
        }
        GetFastTriggerValue() {
            const e = this._parameters;
            if (!e.length) throw new Error("no parameters");
            return e[0]._GetFastTriggerValue()
        }
        _SaveToJson() {
            if (!this._savedData || !this._savedData.size) return null;
            const e = {};
            for (const [t, n] of this._savedData.entries()) {
                let s = n;
                t === "collmemory" && (s = [...n.entries()].map(e => [e[0].GetUID(), e[1].GetUID(), e[2]])), e[t] = s
            }
            return {
                ex: e
            }
        }
        _LoadFromJson(t) {
            if (this._savedData && (this._savedData.clear(), this._savedData = null), !t) return;
            const n = this._runtime,
                s = t.ex;
            if (s) {
                const t = this.GetSavedDataMap();
                t.clear();
                for (const [o, i] of Object.entries(s)) {
                    let a = i;
                    o === "collmemory" && (a = e.New(e.PairMap, i.map(e => [n.GetInstanceByUID(e[0]), n.GetInstanceByUID(e[1]), e[2]]).filter(e => e[0] && e[1]))), t.set(o, a)
                }
            }
        }
    }
}
"use strict";
{
    const e = self.C3,
        o = self.assert;

    function EvalParams(e, t) {
        for (let n = 0, s = e.length; n < s; ++n) t[n] = e[n].Get(0)
    }
    const n = [],
        t = function() {},
        s = function*() {};
    e.Action = class Action extends e.DefendedBase {
        constructor(s, o, i) {
            super(), this._eventBlock = s;
            const a = s.GetRuntime();
            this._runtime = a, this._index = i, this._sid = o.length >= 4 ? o[3] : -1, this._actionReturnType = o.length >= 5 ? o[4] : 0, this._func = null, this._objectClass = null, this._behaviorType = null, this._behaviorIndex = -1, this._systemPlugin = null, this._callFunctionName = "", this._callEventBlock = null, this._combinedSolModifiers = null, this.Run = t, this.DebugRun = t, this._parameters = [], this._results = [], this._anyParamVariesPerInstance = !1, this._savedData = null, this._unsavedData = null;
            const r = o[0] === -3,
                c = r ? o[2] : o[5];
            if (this._debugData = a.IsDebug() || r ? {
                    isBreakpoint: c[0],
                    canDebug: c[1],
                    index: c[2]
                } : null, o[0] === -1) this._systemPlugin = a.GetSystemPlugin(), this._func = a.GetObjectReference(o[1]);
            else if (o[0] === -2) this._callFunctionName = o[1];
            else if (r) {
                const e = a.GetObjectReference(o[1]);
                this._func = e, this.Run = this.RunUserScript, this.DebugRun = this.DebugRunUserScript, this._actionReturnType = 1
            } else this._func = a.GetObjectReference(o[1]), this._objectClass = a.GetObjectClassByIndex(o[0]), o[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(o[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(o[2]));
            if (o.length === 7) {
                const t = o[6];
                for (const n of t) this._parameters.push(e.Parameter.Create(this, n, this._parameters.length)), this._results.push(0)
            }
            this._parameters.length === 0 && (this._parameters = n, this._results = n), this._eventBlock.GetEventSheetManager()._RegisterAction(this)
        }
        static Create(t, n, s) {
            return e.New(e.Action, t, n, s)
        }
        _PostInit() {
            for (const e of this._parameters) e._PostInit(), e.VariesPerInstance() && (this._anyParamVariesPerInstance = !0);
            if (this._systemPlugin) this._SetSystemRunMethod(), this.DebugRun = this._DebugRunSystem;
            else if (this._callFunctionName) this._SetCallFunctionRunMethod(), this._callFunctionName = "";
            else if (this.Run === this.RunUserScript) {
                const e = this._func,
                    t = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this._eventBlock);
                this._func = e.bind(null, this._runtime.GetIRuntime(), t)
            } else this._behaviorType ? this.IsAsync() ? (this.Run = this._RunBehavior_Async, this.DebugRun = this._DebugRunBehavior_Async) : (this.Run = this._RunBehavior, this.DebugRun = this._DebugRunBehavior) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(), this.DebugRun = this._DebugRunSingleGlobal) : this.IsAsync() ? (this.Run = this._RunObject_Async, this.DebugRun = this._DebugRunObject_Async) : this._parameters.length ? this._parameters.every(e => e.VariesPerInstance()) ? (this.Run = this._RunObject_AllParamsVary, this.DebugRun = this._DebugRunObject_AllParamsVary) : this._anyParamVariesPerInstance ? (this.Run = this._RunObject_SomeParamsVary, this.DebugRun = this._DebugRunObject_SomeParamsVary) : this._parameters.every(e => e.IsConstant()) ? (EvalParams(this._parameters, this._results), this.Run = this._RunObject_ParamsConst, this.DebugRun = this._DebugRunObject_ParamsConst) : (this.Run = this._RunObject_ParamsDontVary, this.DebugRun = this._DebugRunObject_ParamsDontVary) : (this.Run = this._RunObject_ParamsConst, this.DebugRun = this._DebugRunObject_ParamsConst)
        }
        _SetSystemRunMethod() {
            const e = this._systemPlugin,
                t = this._systemPlugin;
            this._SetRunMethodForBoundFunc(e, t, this._RunSystem)
        }
        _SetSingleGlobalRunMethod() {
            const e = this._objectClass.GetPlugin(),
                t = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
            this._SetRunMethodForBoundFunc(e, t, this._RunSingleGlobal)
        }
        _SetCallFunctionRunMethod() {
            const n = this._eventBlock.GetEventSheetManager(),
                o = n.GetFunctionBlockByName(this._callFunctionName);
            o.IsEnabled() ? (this._callEventBlock = o.GetEventBlock(), this._combinedSolModifiers = [...new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents()])], this._combinedSolModifiers = n._DeduplicateSolModifierList(this._combinedSolModifiers), this.Run = e.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, this._combinedSolModifiers, this._parameters), this.DebugRun = this._DebugRunCallFunction) : (this.Run = t, this.DebugRun = s)
        }
        _SetRunMethodForBoundFunc(e, t, n) {
            const o = this._func,
                s = this._parameters;
            if (s.length === 0) this.Run = e._GetBoundACEMethod(o, t);
            else if (s.length === 1) {
                const n = s[0];
                if (n.IsConstant()) this.Run = e._GetBoundACEMethod_1param(o, t, n.Get(0));
                else {
                    const s = e._GetBoundACEMethod(o, t);
                    this.Run = function() {
                        return s(n.Get(0))
                    }
                }
            } else if (s.length === 2) {
                const n = s[0],
                    i = s[1];
                if (n.IsConstant() && i.IsConstant()) this.Run = e._GetBoundACEMethod_2params(o, t, n.Get(0), i.Get(0));
                else {
                    const s = e._GetBoundACEMethod(o, t);
                    this.Run = function() {
                        return s(n.Get(0), i.Get(0))
                    }
                }
            } else if (s.length === 3) {
                const n = s[0],
                    i = s[1],
                    a = s[2];
                if (n.IsConstant() && i.IsConstant() && a.IsConstant()) this.Run = e._GetBoundACEMethod_3params(o, t, n.Get(0), i.Get(0), a.Get(0));
                else {
                    const s = e._GetBoundACEMethod(o, t);
                    this.Run = function() {
                        return s(n.Get(0), i.Get(0), a.Get(0))
                    }
                }
            } else this.Run = n
        }
        GetSID() {
            return this._sid
        }
        IsAsync() {
            return this._actionReturnType === 1
        }
        CanBailOut() {
            return this._actionReturnType === 2
        }
        HasReturnType() {
            return this._actionReturnType !== 0
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetEventBlock() {
            return this._eventBlock
        }
        GetRuntime() {
            return this._runtime
        }
        GetIndex() {
            return this._index
        }
        GetDebugIndex() {
            return this._debugData.index
        }
        GetCombinedSolModifiers() {
            return this._combinedSolModifiers
        }
        IsBreakpoint() {
            return this._debugData.isBreakpoint
        }
        _SetBreakpoint(e) {
            this._debugData.isBreakpoint = !!e, this._eventBlock._UpdateCanRunFastRecursive()
        }
        _DebugReturnsGenerator() {
            return this._debugData.canDebug
        }
        DebugCanRunFast() {
            return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator()
        }
        GetSavedDataMap() {
            return this._savedData || (this._savedData = new Map), this._savedData
        }
        GetUnsavedDataMap() {
            return this._unsavedData || (this._unsavedData = new Map), this._unsavedData
        }
        _RunSystem() {
            const e = this._results;
            return EvalParams(this._parameters, e), this._func.apply(this._systemPlugin, e)
        }* _DebugRunSystem() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
                const e = this._results;
                EvalParams(this._parameters, e);
                const t = yield* this._func.apply(this._systemPlugin, e);
                return t
            }
            return this.Run()
        }* _DebugRunCallFunction() {
            (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this);
            const e = yield* this._callEventBlock.DebugRunAsFunctionCall(this._combinedSolModifiers, this._parameters);
            return e
        }
        _RunSingleGlobal() {
            const e = this._results;
            return EvalParams(this._parameters, e), this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), e)
        }* _DebugRunSingleGlobal() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
                const e = this._results;
                EvalParams(this._parameters, e);
                const t = yield* this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), e);
                return t
            }
            return this.Run()
        }
        _RunObject_ParamsConst() {
            const t = this._results,
                e = this._objectClass.GetCurrentSol().GetInstances();
            for (let n = 0, s = e.length; n < s; ++n) this._func.apply(e[n].GetSdkInstance(), t)
        }* _DebugRunObject_ParamsConst() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
                const t = this._results,
                    e = this._objectClass.GetCurrentSol().GetInstances();
                for (let n = 0, s = e.length; n < s; ++n) yield* this._func.apply(e[n].GetSdkInstance(), t)
            } else this._RunObject_ParamsConst()
        }
        _RunObject_ParamsDontVary() {
            const e = this._results;
            EvalParams(this._parameters, e);
            const t = this._objectClass.GetCurrentSol().GetInstances();
            for (let n = 0, s = t.length; n < s; ++n) this._func.apply(t[n].GetSdkInstance(), e)
        }* _DebugRunObject_ParamsDontVary() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
                const e = this._results;
                EvalParams(this._parameters, e);
                const t = this._objectClass.GetCurrentSol().GetInstances();
                for (let n = 0, s = t.length; n < s; ++n) yield* this._func.apply(t[n].GetSdkInstance(), e)
            } else this._RunObject_ParamsDontVary()
        }
        _RunObject_AllParamsVary() {
            const e = this._parameters,
                t = this._results,
                s = this._func,
                n = this._objectClass.GetCurrentSol().GetInstances();
            for (let o = 0, i = n.length; o < i; ++o) {
                const a = n[o];
                for (let n = 0, s = e.length; n < s; ++n) t[n] = e[n].Get(o);
                s.apply(a.GetSdkInstance(), t)
            }
        }* _DebugRunObject_AllParamsVary() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
                const e = this._parameters,
                    t = this._results,
                    s = this._func,
                    n = this._objectClass.GetCurrentSol().GetInstances();
                for (let o = 0, i = n.length; o < i; ++o) {
                    const a = n[o];
                    for (let n = 0, s = e.length; n < s; ++n) t[n] = e[n].Get(o);
                    yield* s.apply(a.GetSdkInstance(), t)
                }
            } else this._RunObject_AllParamsVary()
        }
        _RunObject_SomeParamsVary() {
            const e = this._parameters,
                t = this._results,
                s = this._func,
                n = this._objectClass.GetCurrentSol().GetInstances();
            for (let n = 0, o = e.length; n < o; ++n) {
                const s = e[n];
                s.VariesPerInstance() || (t[n] = s.Get(0))
            }
            for (let o = 0, i = n.length; o < i; ++o) {
                const a = n[o];
                for (let n = 0, i = e.length; n < i; ++n) {
                    const s = e[n];
                    s.VariesPerInstance() && (t[n] = s.Get(o))
                }
                s.apply(a.GetSdkInstance(), t)
            }
        }* _DebugRunObject_SomeParamsVary() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
                const e = this._parameters,
                    t = this._results,
                    s = this._func,
                    n = this._objectClass.GetCurrentSol().GetInstances();
                for (let n = 0, o = e.length; n < o; ++n) {
                    const s = e[n];
                    s.VariesPerInstance() || (t[n] = s.Get(0))
                }
                for (let o = 0, i = n.length; o < i; ++o) {
                    const a = n[o];
                    for (let n = 0, i = e.length; n < i; ++n) {
                        const s = e[n];
                        s.VariesPerInstance() && (t[n] = s.Get(o))
                    }
                    yield* s.apply(a.GetSdkInstance(), t)
                }
            } else this._RunObject_SomeParamsVary()
        }
        _RunBehavior() {
            const t = this._objectClass,
                o = t.IsFamily(),
                i = t.GetFamilyIndex(),
                e = this._parameters,
                a = this._anyParamVariesPerInstance,
                n = this._results,
                r = this._func,
                c = this._behaviorIndex,
                s = t.GetCurrentSol().GetInstances();
            for (let t = 0, o = e.length; t < o; ++t) {
                const s = e[t];
                s.VariesPerInstance() || (n[t] = s.Get(0))
            }
            for (let t = 0, d = s.length; t < d; ++t) {
                const l = s[t];
                if (a)
                    for (let s = 0, i = e.length; s < i; ++s) {
                        const o = e[s];
                        o.VariesPerInstance() && (n[s] = o.Get(t))
                    }
                const u = o ? l.GetObjectClass().GetFamilyBehaviorOffset(i) : 0;
                r.apply(l.GetBehaviorInstances()[c + u].GetSdkInstance(), n)
            }
        }* _DebugRunBehavior() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
                const t = this._objectClass,
                    o = t.IsFamily(),
                    i = t.GetFamilyIndex(),
                    e = this._parameters,
                    a = this._anyParamVariesPerInstance,
                    n = this._results,
                    r = this._func,
                    c = this._behaviorIndex,
                    s = t.GetCurrentSol().GetInstances();
                for (let t = 0, o = e.length; t < o; ++t) {
                    const s = e[t];
                    s.VariesPerInstance() || (n[t] = s.Get(0))
                }
                for (let t = 0, d = s.length; t < d; ++t) {
                    const l = s[t];
                    if (a)
                        for (let s = 0, i = e.length; s < i; ++s) {
                            const o = e[s];
                            o.VariesPerInstance() && (n[s] = o.Get(t))
                        }
                    const u = o ? l.GetObjectClass().GetFamilyBehaviorOffset(i) : 0;
                    yield* r.apply(l.GetBehaviorInstances()[c + u].GetSdkInstance(), n)
                }
            } else this._RunBehavior()
        }
        _RunObject_Async() {
            const e = this._parameters,
                t = this._results,
                o = this._func,
                n = this._objectClass.GetCurrentSol().GetInstances(),
                s = [];
            for (let i = 0, a = n.length; i < a; ++i) {
                const r = n[i];
                for (let n = 0, s = e.length; n < s; ++n) t[n] = e[n].Get(i);
                s.push(o.apply(r.GetSdkInstance(), t))
            }
            return Promise.all(s)
        }* _DebugRunObject_Async() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
                const e = this._parameters,
                    t = this._results,
                    o = this._func,
                    n = this._objectClass.GetCurrentSol().GetInstances(),
                    s = [];
                for (let i = 0, a = n.length; i < a; ++i) {
                    const r = n[i];
                    for (let n = 0, s = e.length; n < s; ++n) t[n] = e[n].Get(i);
                    s.push(yield* o.apply(r.GetSdkInstance(), t))
                }
                return Promise.all(s)
            }
            return this._RunObject_Async()
        }
        _RunBehavior_Async() {
            const e = this._objectClass,
                i = e.IsFamily(),
                a = e.GetFamilyIndex(),
                t = this._parameters,
                n = this._results,
                r = this._func,
                c = this._behaviorIndex,
                s = e.GetCurrentSol().GetInstances(),
                o = [];
            for (let e = 0, d = s.length; e < d; ++e) {
                const l = s[e];
                for (let s = 0, o = t.length; s < o; ++s) n[s] = t[s].Get(e);
                const u = i ? l.GetObjectClass().GetFamilyBehaviorOffset(a) : 0;
                o.push(r.apply(l.GetBehaviorInstances()[c + u].GetSdkInstance(), n))
            }
            return Promise.all(o)
        }* _DebugRunBehavior_Async() {
            if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
                const e = this._objectClass,
                    i = e.IsFamily(),
                    a = e.GetFamilyIndex(),
                    t = this._parameters,
                    n = this._results,
                    r = this._func,
                    c = this._behaviorIndex,
                    s = e.GetCurrentSol().GetInstances(),
                    o = [];
                for (let e = 0, d = s.length; e < d; ++e) {
                    const l = s[e];
                    for (let s = 0, o = t.length; s < o; ++s) n[s] = t[s].Get(e);
                    const u = i ? l.GetObjectClass().GetFamilyBehaviorOffset(a) : 0;
                    o.push(yield* r.apply(l.GetBehaviorInstances()[c + u].GetSdkInstance(), n))
                }
                return Promise.all(o)
            }
            return this._RunBehavior_Async()
        }
        async RunUserScript() {
            try {
                await this._func()
            } catch (t) {
                console.error(`Unhandled exception running script %c${this._eventBlock.GetEventSheet().GetName()}, event ${this._eventBlock.GetDisplayNumber()}, action ${this.GetDebugIndex()+1}:`, "font-size: 1.2em; font-weight: bold;", t), self.C3Debugger && self.C3Debugger._SetLastErrorScript(this), e.EventScript.HadUserScriptException() || (console.info(`%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()`, "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), e.EventScript.SetHadUserScriptException())
            }
        }* DebugRunUserScript() {
            return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this.RunUserScript()
        }
        _SaveToJson() {
            return !this._savedData || !this._savedData.size ? null : {
                ex: e.ToSuperJSON(this._savedData)
            }
        }
        _LoadFromJson(t) {
            if (this._savedData && (this._savedData.clear(), this._savedData = null), !t) return;
            const n = t.ex;
            n && (this._savedData = e.FromSuperJSON(n))
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = new e.Color;

    function CompareX(t, n) {
        return e.compare(this.GetWorldInfo().GetX(), t, n)
    }

    function CompareY(t, n) {
        return e.compare(this.GetWorldInfo().GetY(), t, n)
    }

    function IsOnScreen() {
        const e = this.GetWorldInfo();
        return e.IsInViewport(e.GetLayer().GetViewport())
    }

    function IsOutsideLayout() {
        const t = this.GetWorldInfo(),
            n = t.GetLayout(),
            e = t.GetBoundingBox();
        return e.getRight() < 0 || e.getBottom() < 0 || e.getLeft() > n.GetWidth() || e.getTop() > n.GetHeight()
    }

    function PickDistance(t, n, s) {
        const c = this.GetCurrentSol(),
            a = c.GetInstances();
        if (!a.length) return !1;
        let o = a[0],
            i = o.GetWorldInfo(),
            l = o,
            r = e.distanceSquared(i.GetX(), i.GetY(), n, s);
        for (let c = 1, u = a.length; c < u; ++c) {
            o = a[c], i = o.GetWorldInfo();
            const d = e.distanceSquared(i.GetX(), i.GetY(), n, s);
            (t === 0 && d < r || t === 1 && d > r) && (r = d, l = o)
        }
        return c.PickOne(l), !0
    }

    function SetX(e) {
        const t = this.GetWorldInfo();
        if (t.GetX() === e) return;
        t.SetX(e), t.SetBboxChanged()
    }

    function SetY(e) {
        const t = this.GetWorldInfo();
        if (t.GetY() === e) return;
        t.SetY(e), t.SetBboxChanged()
    }

    function SetPos(e, t) {
        const n = this.GetWorldInfo();
        if (n.EqualsXY(e, t)) return;
        n.SetXY(e, t), n.SetBboxChanged()
    }

    function SetPosToObject(e, t) {
        if (!e) return;
        const s = e.GetPairedInstance(this._inst);
        if (!s) return;
        const [o, i] = s.GetImagePoint(t), n = this.GetWorldInfo();
        if (n.GetX() === o && n.GetY() === i) return;
        n.SetXY(o, i), n.SetBboxChanged()
    }

    function MoveForward(e) {
        if (e === 0) return;
        const t = this.GetWorldInfo();
        t.OffsetXY(t.GetCosAngle() * e, t.GetSinAngle() * e), t.SetBboxChanged()
    }

    function MoveAtAngle(t, n) {
        if (n === 0) return;
        const s = this.GetWorldInfo();
        t = e.toRadians(t), s.OffsetXY(Math.cos(t) * n, Math.sin(t) * n), s.SetBboxChanged()
    }

    function GetX() {
        return this.GetWorldInfo().GetX()
    }

    function GetY() {
        return this.GetWorldInfo().GetY()
    }

    function GetDt() {
        return this._runtime.GetDt(this._inst)
    }

    function CompareWidth(t, n) {
        return e.compare(this.GetWorldInfo().GetWidth(), t, n)
    }

    function CompareHeight(t, n) {
        return e.compare(this.GetWorldInfo().GetHeight(), t, n)
    }

    function SetWidth(e) {
        const t = this.GetWorldInfo();
        if (t.GetWidth() === e) return;
        t.SetWidth(e), t.SetBboxChanged()
    }

    function SetHeight(e) {
        const t = this.GetWorldInfo();
        if (t.GetHeight() === e) return;
        t.SetHeight(e), t.SetBboxChanged()
    }

    function SetSize(e, t) {
        const n = this.GetWorldInfo();
        if (n.GetWidth() === e && n.GetHeight() === t) return;
        n.SetSize(e, t), n.SetBboxChanged()
    }

    function GetWidth() {
        return this.GetWorldInfo().GetWidth()
    }

    function GetHeight() {
        return this.GetWorldInfo().GetHeight()
    }

    function GetBboxLeft() {
        return this.GetWorldInfo().GetBoundingBox().getLeft()
    }

    function GetBboxTop() {
        return this.GetWorldInfo().GetBoundingBox().getTop()
    }

    function GetBboxRight() {
        return this.GetWorldInfo().GetBoundingBox().getRight()
    }

    function GetBboxBottom() {
        return this.GetWorldInfo().GetBoundingBox().getBottom()
    }

    function IsAngleWithin(t, n) {
        return e.angleDiff(this.GetWorldInfo().GetAngle(), e.toRadians(n)) <= e.toRadians(t)
    }

    function IsAngleClockwiseFrom(t) {
        return e.angleClockwise(this.GetWorldInfo().GetAngle(), e.toRadians(t))
    }

    function IsBetweenAngles(t, n) {
        const o = e.toRadians(t),
            i = e.toRadians(n),
            s = this.GetWorldInfo().GetAngle(),
            a = !e.angleClockwise(i, o);
        return a ? !!e.angleClockwise(s, o) || !e.angleClockwise(s, i) : e.angleClockwise(s, o) && !e.angleClockwise(s, i)
    }

    function SetAngle(t) {
        const n = this.GetWorldInfo(),
            s = e.clampAngle(e.toRadians(t));
        if (isNaN(s) || n.GetAngle() === s) return;
        n.SetAngle(s), n.SetBboxChanged()
    }

    function RotateClockwise(t) {
        if (isNaN(t) || t === 0) return;
        const n = this.GetWorldInfo();
        n.SetAngle(n.GetAngle() + e.toRadians(t)), n.SetBboxChanged()
    }

    function RotateCounterclockwise(t) {
        if (isNaN(t) || t === 0) return;
        const n = this.GetWorldInfo();
        n.SetAngle(n.GetAngle() - e.toRadians(t)), n.SetBboxChanged()
    }

    function RotateTowardAngle(t, n) {
        const s = this.GetWorldInfo(),
            i = s.GetAngle(),
            o = e.angleRotate(i, e.toRadians(n), e.toRadians(t));
        if (isNaN(o) || i === o) return;
        s.SetAngle(o), s.SetBboxChanged()
    }

    function RotateTowardPosition(t, n, s) {
        const o = this.GetWorldInfo(),
            a = o.GetAngle(),
            r = n - o.GetX(),
            c = s - o.GetY(),
            l = Math.atan2(c, r),
            i = e.angleRotate(a, l, e.toRadians(t));
        if (isNaN(i) || a === i) return;
        o.SetAngle(i), o.SetBboxChanged()
    }

    function SetTowardPosition(e, t) {
        const n = this.GetWorldInfo(),
            o = n.GetAngle(),
            i = e - n.GetX(),
            a = t - n.GetY(),
            s = Math.atan2(a, i);
        if (isNaN(s) || o === s) return;
        n.SetAngle(s), n.SetBboxChanged()
    }

    function GetAngle() {
        return e.toDegrees(this.GetWorldInfo().GetAngle())
    }

    function CompareOpacity(t, n) {
        return e.compare(e.round6dp(this.GetWorldInfo().GetOpacity() * 100), t, n)
    }

    function IsVisible() {
        return this.GetWorldInfo().IsVisible()
    }

    function SetVisible(e) {
        const t = this.GetWorldInfo();
        if (e === 2 ? e = !t.IsVisible() : e = e !== 0, t.IsVisible() === e) return;
        t.SetVisible(e), this._runtime.UpdateRender()
    }

    function SetOpacity(t) {
        const n = e.clamp(t / 100, 0, 1),
            s = this.GetWorldInfo();
        if (s.GetOpacity() === n) return;
        s.SetOpacity(n), this._runtime.UpdateRender()
    }

    function SetDefaultColor(e) {
        t.setFromRgbValue(e);
        const n = this.GetWorldInfo();
        if (n.GetUnpremultipliedColor().equalsIgnoringAlpha(t)) return;
        n.SetUnpremultipliedColor(t), this._runtime.UpdateRender()
    }

    function GetColor() {
        const t = this.GetWorldInfo().GetUnpremultipliedColor();
        return e.PackRGBAEx(t.getR(), t.getG(), t.getB(), t.getA())
    }

    function GetOpacity() {
        return e.round6dp(this.GetWorldInfo().GetOpacity() * 100)
    }

    function IsOnLayer(e) {
        return !!e && this.GetWorldInfo().GetLayer() === e
    }

    function PickTopBottom(e) {
        const s = this.GetCurrentSol(),
            t = s.GetInstances();
        if (!t.length) return !1;
        let o = t[0],
            n = o;
        for (let i = 1, l = t.length; i < l; ++i) {
            const a = t[i],
                r = a.GetWorldInfo(),
                c = n.GetWorldInfo(),
                s = r.GetLayer().GetIndex(),
                o = c.GetLayer().GetIndex();
            e === 0 ? (s > o || s === o && r.GetZIndex() > c.GetZIndex()) && (n = a) : (s < o || s === o && r.GetZIndex() < c.GetZIndex()) && (n = a)
        }
        return s.PickOne(n), !0
    }

    function CompareZElevation(t, n, s) {
        const o = this.GetWorldInfo(),
            i = t === 0 ? o.GetZElevation() : o.GetTotalZElevation();
        return e.compare(i, n, s)
    }

    function MoveToTop() {
        this.GetWorldInfo().ZOrderMoveToTop()
    }

    function MoveToBottom() {
        this.GetWorldInfo().ZOrderMoveToBottom()
    }

    function MoveToLayer(e) {
        if (!e) return;
        this.GetWorldInfo().ZOrderMoveToLayer(e)
    }

    function ZMoveToObject(e, t) {
        const s = e === 0;
        if (!t) return;
        const n = t.GetFirstPicked(this.GetInstance());
        if (!n) return;
        this.GetWorldInfo().ZOrderMoveAdjacentToInstance(n, s)
    }

    function SetZElevation(e) {
        const t = this.GetWorldInfo();
        if (t.GetZElevation() === e) return;
        t.SetZElevation(e), this._runtime.UpdateRender()
    }

    function LayerNumber() {
        return this.GetWorldInfo().GetLayer().GetIndex()
    }

    function LayerName() {
        return this.GetWorldInfo().GetLayer().GetName()
    }

    function ZIndex() {
        return this.GetWorldInfo().GetZIndex()
    }

    function ZElevation() {
        return this.GetWorldInfo().GetZElevation()
    }

    function TotalZElevation() {
        return this.GetWorldInfo().GetTotalZElevation()
    }

    function SetEffectEnabled(e, t) {
        const s = this.GetObjectClass().GetEffectList().GetEffectTypeByName(t);
        if (!s) return;
        const o = s.GetIndex(),
            i = e === 1,
            n = this.GetWorldInfo().GetInstanceEffectList();
        if (n.IsEffectIndexActive(o) === i) return;
        n.SetEffectIndexActive(o, i), n.UpdateActiveEffects(), this._runtime.UpdateRender()
    }

    function SetEffectParam(e, n, s) {
        const i = this.GetObjectClass().GetEffectList().GetEffectTypeByName(e);
        if (!i) return;
        const a = i.GetIndex(),
            r = this.GetWorldInfo().GetInstanceEffectList(),
            o = r.GetEffectParametersForIndex(a);
        if (n = Math.floor(n), n < 0 || n >= o.length) return;
        const c = i.GetShaderProgram().GetParameterType(n);
        if (c === "color") {
            t.setFromRgbValue(s);
            const e = o[n];
            if (t.equalsIgnoringAlpha(e)) return;
            e.copyRgb(t)
        } else {
            if (c === "percent" && (s /= 100), o[n] === s) return;
            o[n] = s
        }
        r.IsEffectIndexActive(a) && this._runtime.UpdateRender()
    }

    function HasParent() {
        return this.GetWorldInfo().HasParent()
    }

    function HasChildren() {
        return this.GetWorldInfo().HasChildren()
    }

    function PickParent(e, t) {
        const r = this.GetCurrentSol(),
            s = r.GetInstances();
        if (s.length === 0) return !1;
        const o = e.GetCurrentSol(),
            i = o.GetInstances();
        if (i.length === 0) return !1;
        const a = new Set(i),
            n = new Set;
        for (let o = 0, r = s.length; o < r; ++o) {
            const i = s[o];
            if (t === 1)
                for (const t of i.parents()) t.BelongsToObjectClass(e) && a.has(t) && n.add(t);
            else {
                let s;
                if (t === 0) {
                    if (s = i.GetParent(), s === null) continue
                } else s = i.GetTopParent();
                s.BelongsToObjectClass(e) && a.has(s) && n.add(s)
            }
        }
        return n.size !== 0 && (o.SetSetPicked(n), e.ApplySolToContainer(), !0)
    }

    function PickChildren(e, t) {
        const r = this.GetCurrentSol(),
            s = r.GetInstances();
        if (s.length === 0) return !1;
        const o = e.GetCurrentSol(),
            i = o.GetInstances();
        if (i.length === 0) return !1;
        const a = new Set(i),
            n = new Set;
        for (let i = 0, r = s.length; i < r; ++i) {
            const o = s[i];
            t === 2 && !o.HasChildren() && o.BelongsToObjectClass(e) && a.has(o) && n.add(o);
            for (const s of t === 0 ? o.children() : o.allChildren()) {
                if (t === 2 && s.HasChildren()) continue;
                s.BelongsToObjectClass(e) && a.has(s) && n.add(s)
            }
        }
        return n.size !== 0 && (o.SetSetPicked(n), e.ApplySolToContainer(), !0)
    }

    function PickNthChild(e, t) {
        const a = this.GetCurrentSol(),
            n = a.GetInstances();
        if (n.length === 0) return !1;
        const o = e.GetCurrentSol(),
            i = o.GetInstances();
        if (i.length === 0) return !1;
        const r = new Set(i),
            s = [];
        for (let i = 0, a = n.length; i < a; ++i) {
            const c = n[i],
                o = c.GetChildAt(t);
            o !== null && o.BelongsToObjectClass(e) && r.has(o) && s.push(o)
        }
        return s.length !== 0 && (o.SetArrayPicked(s), e.ApplySolToContainer(), !0)
    }

    function CompareChildCount(t, n) {
        return e.compare(this._inst.GetChildCount(), t, n)
    }

    function AddChild(e, t, n, s, o, i, a, r) {
        const c = this._inst,
            l = this._runtime.GetCurrentAction().GetObjectClass();
        for (const d of e.allCorrespondingInstances(c, l)) {
            if (!d.GetPlugin().SupportsSceneGraph()) return;
            c.AddChild(d, {
                transformX: t,
                transformY: n,
                transformWidth: s,
                transformHeight: o,
                transformAngle: i,
                transformZElevation: a,
                destroyWithParent: r
            })
        }
    }

    function RemoveChild(e) {
        const t = this._inst,
            n = this._runtime.GetCurrentAction().GetObjectClass();
        for (const s of e.allCorrespondingInstances(t, n)) t.RemoveChild(s)
    }

    function RemoveFromParent() {
        if (!this._inst.HasParent()) return;
        const e = this._inst.GetParent();
        e.RemoveChild(this._inst)
    }

    function ChildCount() {
        return this._inst.GetChildCount()
    }

    function SetMeshSize(e, t) {
        e = Math.floor(e), t = Math.floor(t);
        const n = this.GetWorldInfo();
        e < 2 || t < 2 || !isFinite(e) || !isFinite(t) ? (n.ReleaseMesh(), n.SetBboxChanged()) : n.CreateMesh(e, t)
    }

    function SetMeshPoint(e, t, n, s, o, i, a) {
        const r = this.GetWorldInfo(),
            c = r.SetMeshPoint(e, t, {
                mode: n === 0 ? "absolute" : "relative",
                x: s,
                y: o,
                u: i,
                v: a
            });
        c && r.SetBboxChanged()
    }

    function MeshColumns() {
        const e = this.GetWorldInfo();
        return e.HasMesh() ? e.GetSourceMesh().GetHSize() : 0
    }

    function MeshRows() {
        const e = this.GetWorldInfo();
        return e.HasMesh() ? e.GetSourceMesh().GetVSize() : 0
    }

    function SetElementVisible(e) {
        const t = this.GetWorldInfo();
        if (e === 2 ? e = !t.IsVisible() : e = e !== 0, t.IsVisible() === e) return;
        t.SetVisible(e)
    }

    function SetElementCSSStyle(e, t) {
        this.SetElementCSSStyle(e, t)
    }

    function SetElementAttribute(e, t) {
        this.SetElementAttribute(e, "" + t)
    }

    function RemoveElementAttribute(e) {
        this.RemoveElementAttribute(e)
    }

    function SetElementFocus() {
        this.FocusElement()
    }

    function SetElementBlur() {
        this.BlurElement()
    }

    function IsElementFocused() {
        return this.IsElementFocused()
    }

    function SetElementEnabled(e) {
        this._SetEnabled(e !== 0)
    }

    function IsElementEnabled() {
        return this._IsEnabled()
    }

    function CompareInstanceVar(t, n, s) {
        return e.compare(this.GetInstance().GetInstanceVariableValue(t), n, s)
    }

    function IsBoolInstanceVarSet(e) {
        return !!this.GetInstance().GetInstanceVariableValue(e)
    }

    function PickInstVarHiLow(e, t) {
        const i = this.GetCurrentSol(),
            s = i.GetInstances();
        if (!s.length) return !1;
        let n = s[0],
            a = n,
            o = n.GetInstanceVariableValue(t);
        for (let i = 1, c = s.length; i < c; ++i) {
            n = s[i];
            const r = n.GetInstanceVariableValue(t);
            (e === 0 && r < o || e === 1 && r > o) && (o = r, a = n)
        }
        return i.PickOne(a), !0
    }

    function PickByUID(e) {
        return this._runtime.GetCurrentCondition().IsInverted() ? PickByUID_Inverted(this, e) : PickByUID_Normal(this, e)
    }

    function PickByUID_Normal(e, t) {
        const n = e.GetRuntime().GetInstanceByUID(t);
        if (!n) return !1;
        const s = e.GetCurrentSol();
        if (!s.IsSelectAll() && !s._GetOwnInstances().includes(n)) return !1;
        if (e.IsFamily()) {
            if (n.GetObjectClass().BelongsToFamily(e)) return s.PickOne(n), e.ApplySolToContainer(), !0
        } else if (n.GetObjectClass() === e) return s.PickOne(n), e.ApplySolToContainer(), !0;
        return !1
    }

    function PickByUID_Inverted(t, n) {
        const s = t.GetCurrentSol();
        if (s.IsSelectAll()) {
            s._SetSelectAll(!1), s.ClearArrays();
            const e = t.GetInstances();
            for (let t = 0, i = e.length; t < i; ++t) {
                const o = e[t];
                o.GetUID() === n ? s._PushElseInstance(o) : s._PushInstance(o)
            }
            return t.ApplySolToContainer(), !!s._GetOwnInstances().length
        }
        const o = s._GetOwnInstances();
        let i = 0;
        for (let e = 0, a = o.length; e < a; ++e) {
            const t = o[e];
            o[i] = t, t.GetUID() === n ? s._PushElseInstance(t) : ++i
        }
        return e.truncateArray(o, i), t.ApplySolToContainer(), !!o.length
    }

    function Destroy() {
        this._runtime.DestroyInstance(this._inst)
    }

    function OnCreated() {
        return !0
    }

    function OnDestroyed() {
        return !0
    }

    function SetInstanceVar(e, t) {
        this.GetInstance().SetInstanceVariableValue(e, t)
    }

    function AddInstanceVar(e, t) {
        const s = this.GetInstance(),
            n = s.GetInstanceVariableValue(e);
        typeof n == "number" && typeof t != "number" ? t = parseFloat(t) : typeof n == "string" && typeof t != "string" && (t = t.toString()), s.SetInstanceVariableValue(e, n + t)
    }

    function SubInstanceVar(e, t) {
        const n = this.GetInstance(),
            s = n.GetInstanceVariableValue(e);
        if (typeof s != "number") return;
        typeof t != "number" && (t = parseFloat(t)), n.SetInstanceVariableValue(e, s - t)
    }

    function SetBoolInstanceVar(e, t) {
        this.GetInstance().SetInstanceVariableValue(e, t ? 1 : 0)
    }

    function ToggleBoolInstanceVar(e) {
        const t = this.GetInstance();
        t.SetInstanceVariableValue(e, t.GetInstanceVariableValue(e) === 0 ? 1 : 0)
    }

    function LoadFromJsonString(e) {
        let t;
        try {
            t = JSON.parse(e)
        } catch (e) {
            console.error("Failed to load from JSON string: ", e);
            return
        }
        this.GetInstance().LoadFromJson(t, "state")
    }

    function AsJSON() {
        return JSON.stringify(this.GetInstance().SaveToJson("state"))
    }

    function ObjectTypeName() {
        return this.GetInstance().GetObjectClass().GetName()
    }

    function Count() {
        const e = this._runtime.GetCurrentEventStackFrame().GetExpressionObjectClass();
        let t = e.GetInstanceCount();
        const n = this._runtime._GetInstancesPendingCreate();
        for (const s of n) e.IsFamily() ? s.GetObjectClass().BelongsToFamily(e) && ++t : s.GetObjectClass() === e && ++t;
        return t
    }

    function PickedCount() {
        return this._runtime.GetCurrentEventStackFrame().GetExpressionObjectClass().GetCurrentSol().GetInstances().length
    }

    function GetIID() {
        return this._inst.GetIID()
    }

    function GetUID() {
        return this._inst.GetUID()
    }
    e.AddCommonACEs = function(t, n) {
        const l = t[1],
            v = t[3],
            g = t[4],
            p = t[5],
            r = t[6],
            c = t[7],
            a = t[8],
            d = t[10],
            u = t[11],
            h = t[12],
            m = t[13],
            f = t[14],
            o = n.Cnds,
            s = n.Acts,
            i = n.Exps;
        v && (o.CompareX = CompareX, o.CompareY = CompareY, o.IsOnScreen = IsOnScreen, o.IsOutsideLayout = IsOutsideLayout, o.PickDistance = PickDistance, s.SetX = SetX, s.SetY = SetY, s.SetPos = SetPos, s.SetPosToObject = SetPosToObject, s.MoveForward = MoveForward, s.MoveAtAngle = MoveAtAngle, i.X = GetX, i.Y = GetY, i.dt = GetDt), g && (o.CompareWidth = CompareWidth, o.CompareHeight = CompareHeight, s.SetWidth = SetWidth, s.SetHeight = SetHeight, s.SetSize = SetSize, i.Width = GetWidth, i.Height = GetHeight, i.BBoxLeft = GetBboxLeft, i.BBoxTop = GetBboxTop, i.BBoxRight = GetBboxRight, i.BBoxBottom = GetBboxBottom), p && (o.AngleWithin = IsAngleWithin, o.IsClockwiseFrom = IsAngleClockwiseFrom, o.IsBetweenAngles = IsBetweenAngles, s.SetAngle = SetAngle, s.RotateClockwise = RotateClockwise, s.RotateCounterclockwise = RotateCounterclockwise, s.RotateTowardAngle = RotateTowardAngle, s.RotateTowardPosition = RotateTowardPosition, s.SetTowardPosition = SetTowardPosition, i.Angle = GetAngle), r && (o.IsVisible = IsVisible, o.CompareOpacity = CompareOpacity, s.SetVisible = SetVisible, s.SetOpacity = SetOpacity, s.SetDefaultColor = SetDefaultColor, i.Opacity = GetOpacity, i.ColorValue = GetColor), c && (o.IsOnLayer = IsOnLayer, o.PickTopBottom = PickTopBottom, o.CompareZElevation = CompareZElevation, s.MoveToTop = MoveToTop, s.MoveToBottom = MoveToBottom, s.MoveToLayer = MoveToLayer, s.ZMoveToObject = ZMoveToObject, s.SetZElevation = SetZElevation, i.LayerNumber = LayerNumber, i.LayerName = LayerName, i.ZIndex = ZIndex, i.ZElevation = ZElevation, i.TotalZElevation = TotalZElevation), a && (s.SetEffectEnabled = SetEffectEnabled, s.SetEffectParam = SetEffectParam), m && (o.HasParent = HasParent, o.HasChildren = HasChildren, o.PickParent = PickParent, o.PickChildren = PickChildren, o.PickNthChild = PickNthChild, o.CompareChildCount = CompareChildCount, s.AddChild = AddChild, s.RemoveChild = RemoveChild, s.RemoveFromParent = RemoveFromParent, i.ChildCount = ChildCount), f && (s.SetMeshSize = SetMeshSize, s.SetMeshPoint = SetMeshPoint, i.MeshColumns = MeshColumns, i.MeshRows = MeshRows), d && (o.IsVisible = IsVisible, s.SetVisible = SetElementVisible, s.SetCSSStyle = SetElementCSSStyle, s.SetElemAttribute = SetElementAttribute, s.RemoveElemAttribute = RemoveElementAttribute), u && (o.IsFocused = IsElementFocused, s.SetFocus = SetElementFocus, s.SetBlur = SetElementBlur), h && (o.IsEnabled = IsElementEnabled, s.SetEnabled = SetElementEnabled), l || (o.CompareInstanceVar = CompareInstanceVar, o.IsBoolInstanceVarSet = IsBoolInstanceVarSet, o.PickInstVarHiLow = PickInstVarHiLow, o.PickByUID = PickByUID, s.SetInstanceVar = SetInstanceVar, s.AddInstanceVar = AddInstanceVar, s.SubInstanceVar = SubInstanceVar, s.SetBoolInstanceVar = SetBoolInstanceVar, s.ToggleBoolInstanceVar = ToggleBoolInstanceVar, o.OnCreated = OnCreated, o.OnDestroyed = OnDestroyed, s.Destroy = Destroy, s.LoadFromJsonString || (s.LoadFromJsonString = LoadFromJsonString), i.AsJSON || (i.AsJSON = AsJSON), i.Count = Count, i.PickedCount = PickedCount, i.IID = GetIID, i.UID = GetUID, i.ObjectTypeName = ObjectTypeName)
    }
}
"use strict";
{
    const e = self.C3;
    e.ScheduledWait = class ScheduledWait extends e.DefendedBase {
        constructor(e) {
            super(), this._eventSheetManager = e, this._type = "", this._time = -1, this._signalTag = "", this._isSignalled = !1, this._event = null, this._actIndex = 0, this._solModifiers = [], this._sols = new Map, this._callingFunctionBlock = null, this._asyncId = -1, this._functionParameters = null, this._shouldRelease = !1
        }
        Release() {
            this._type = "", this._time = -1, this._signalTag = "", this._event = null, this._callingFunctionBlock = null, this._functionParameters = null, this._asyncId = -1, e.clearArray(this._solModifiers);
            for (const e of this._sols.values()) e.Release();
            this._sols.clear()
        }
        _Init() {
            const n = this._eventSheetManager,
                o = n.GetRuntime().GetAllObjectClasses(),
                s = n.GetCurrentEventStackFrame();
            this._event = s.GetCurrentEvent(), this._actIndex = s.GetActionIndex() + 1;
            const t = n.FindFirstFunctionBlockParent(this._event);
            t && (this._callingFunctionBlock = t, this._functionParameters = t.CaptureFunctionParameters(), t.IsAsync() && (this._asyncId = t.PauseCurrentAsyncFunction()));
            for (const t of o) {
                const n = t.GetCurrentSol();
                if (n.IsSelectAll() && !this._event.HasSolModifier(t)) continue;
                this._solModifiers.push(t), this._sols.set(t, e.New(e.SolState, n))
            }
        }
        InitTimer(e) {
            this._type = "timer", this._Init(), this._time = this._eventSheetManager.GetRuntime().GetGameTime() + e
        }
        InitSignal(e) {
            this._type = "signal", this._Init(), this._signalTag = e.toLowerCase()
        }
        InitPromise(e) {
            this._type = "promise", this._Init(), e.then(() => this.SetSignalled()).catch(e => {
                console.warn("[C3 runtime] Promise rejected in 'Wait for previous actions to complete': ", e), this.SetSignalled()
            })
        }
        IsTimer() {
            return this._type === "timer"
        }
        IsSignal() {
            return this._type === "signal"
        }
        IsPromise() {
            return this._type === "promise"
        }
        GetSignalTag() {
            return this._signalTag
        }
        IsSignalled() {
            return this._isSignalled
        }
        SetSignalled() {
            this._isSignalled = !0
        }
        _ShouldRun() {
            return this.IsTimer() ? this._time <= this._eventSheetManager.GetRuntime().GetGameTime() : this.IsSignalled()
        }
        _RestoreState(e) {
            e._Restore(this._event, this._actIndex);
            for (const [e, t] of this._sols.entries()) {
                const n = e.GetCurrentSol();
                t._Restore(n)
            }
            const t = this._callingFunctionBlock;
            t && (t.SetFunctionParameters(this._functionParameters), t.IsAsync() && t.ResumeAsyncFunction(this._asyncId))
        }
        _Run(e) {
            this._RestoreState(e), this._event._ResumeActionsAndSubEvents(e), this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId), this._eventSheetManager.ClearSol(this._solModifiers), this._shouldRelease = !0
        }
        async _DebugRun(e) {
            this._RestoreState(e);
            for (const t of this._event._DebugResumeActionsAndSubEvents(e)) await this._eventSheetManager.GetRuntime().DebugBreak(t);
            this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId), this._eventSheetManager.ClearSol(this._solModifiers), this._shouldRelease = !0
        }
        ShouldRelease() {
            return this._shouldRelease
        }
        RemoveInstances(e) {
            for (const t of this._sols.values()) t.RemoveInstances(e)
        }
        _SaveToJson() {
            const e = {},
                t = {
                    t: this._time,
                    st: this._signalTag,
                    s: this._isSignalled,
                    ev: this._event.GetSID(),
                    sm: this._solModifiers.map(e => e.GetSID()),
                    sols: e
                };
            this._event._HasActionIndex(this._actIndex) && (t.act = this._event.GetActionAt(this._actIndex).GetSID());
            for (const [t, n] of this._sols) e[t.GetSID().toString()] = n._SaveToJson();
            return t
        }
        static _CreateFromJson(t, n) {
            const o = t.GetRuntime(),
                i = t.GetEventBlockBySID(n.ev);
            if (!i) return null;
            let a = 0;
            if (n.hasOwnProperty("act")) {
                const e = t.GetActionBySID(n.act);
                if (!e) return null;
                a = e.GetIndex()
            }
            const s = e.New(e.ScheduledWait, t);
            s._time = n.t, s._type = s._time === -1 ? "signal" : "timer", s._signalTag = n.st, s._isSignalled = n.s, s._event = i, s._actIndex = a;
            for (const t of n.sm) {
                const e = o.GetObjectClassBySID(t);
                e && s._solModifiers.push(e)
            }
            for (const [r, c] of Object.entries(n.sols)) {
                const l = parseInt(r, 10),
                    i = o.GetObjectClassBySID(l);
                if (!i) continue;
                const a = e.New(e.SolState, null);
                a._LoadFromJson(t, c), s._sols.set(i, a)
            }
            return s
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.SolState = class SolState extends e.DefendedBase {
        constructor(t) {
            super(), this._objectClass = null, this._isSelectAll = !0, this._instances = [], t && (this._objectClass = t.GetObjectClass(), this._isSelectAll = t.IsSelectAll(), e.shallowAssignArray(this._instances, t._GetOwnInstances()))
        }
        Release() {
            this._objectClass = null, e.clearArray(this._instances)
        }
        _Restore(t) {
            t._SetSelectAll(this._isSelectAll), e.shallowAssignArray(t._GetOwnInstances(), this._instances)
        }
        RemoveInstances(t) {
            e.arrayRemoveAllInSet(this._instances, t)
        }
        _SaveToJson() {
            return {
                sa: this._isSelectAll,
                insts: this._instances.map(e => e.GetUID())
            }
        }
        _LoadFromJson(t, n) {
            const s = t.GetRuntime();
            this._isSelectAll = !!n.sa, e.clearArray(this._instances);
            for (const t of n.insts) {
                const e = s.GetInstanceByUID(t);
                e && this._instances.push(e)
            }
        }
    }
}
"use strict";
{
    const e = self.C3;

    function GetNextParamMap(e, t) {
        let n = e.get(t);
        return n || (n = new Map, e.set(t, n)), n
    }
    e.SDKPluginBase = class SDKPluginBase extends e.DefendedBase {
        constructor(e) {
            super(), this._runtime = e.runtime, this._isSingleGlobal = !!e.isSingleGlobal, this._isWorldType = !!e.isWorld, this._isRotatable = !!e.isRotatable, this._mustPredraw = !!e.mustPredraw, this._hasEffects = !!e.hasEffects, this._supportsSceneGraph = !!e.supportsSceneGraph, this._supportsMesh = !!e.supportsMesh, this._singleGlobalObjectClass = null, this._boundACEMethodCache = new Map, this._boundACEMethodCache_1param = new Map, this._boundACEMethodCache_2params = new Map, this._boundACEMethodCache_3params = new Map
        }
        Release() {
            this._runtime = null
        }
        GetRuntime() {
            return this._runtime
        }
        OnCreate() {}
        IsSingleGlobal() {
            return this._isSingleGlobal
        }
        IsWorldType() {
            return this._isWorldType
        }
        IsRotatable() {
            return this._isRotatable
        }
        MustPreDraw() {
            return this._mustPredraw
        }
        HasEffects() {
            return this._hasEffects
        }
        SupportsSceneGraph() {
            return this._supportsSceneGraph
        }
        SupportsMesh() {
            return this._supportsMesh
        }
        _GetBoundACEMethod(e, t) {
            if (!t) throw new Error("missing 'this' binding");
            let n = this._boundACEMethodCache.get(e);
            return n || (n = e.bind(t), this._boundACEMethodCache.set(e, n), n)
        }
        _GetBoundACEMethod_1param(e, t, n) {
            if (!t) throw new Error("missing 'this' binding");
            const o = GetNextParamMap(this._boundACEMethodCache_1param, e);
            let s = o.get(n);
            return s || (s = e.bind(t, n), o.set(n, s), s)
        }
        _GetBoundACEMethod_2params(e, t, n, s) {
            if (!t) throw new Error("missing 'this' binding");
            const a = GetNextParamMap(this._boundACEMethodCache_2params, e),
                i = GetNextParamMap(a, n);
            let o = i.get(s);
            return o || (o = e.bind(t, n, s), i.set(s, o), o)
        }
        _GetBoundACEMethod_3params(e, t, n, s, o) {
            if (!t) throw new Error("missing 'this' binding");
            const r = GetNextParamMap(this._boundACEMethodCache_3params, e),
                c = GetNextParamMap(r, n),
                a = GetNextParamMap(c, s);
            let i = a.get(o);
            return i || (i = e.bind(t, n, s, o), a.set(o, i), i)
        }
        _SetSingleGlobalObjectClass(e) {
            if (!this.IsSingleGlobal()) throw new Error("must be single-global plugin");
            this._singleGlobalObjectClass = e
        }
        GetSingleGlobalObjectClass() {
            if (!this.IsSingleGlobal()) throw new Error("must be single-global plugin");
            return this._singleGlobalObjectClass
        }
        GetSingleGlobalInstance() {
            if (!this.IsSingleGlobal()) throw new Error("must be single-global plugin");
            return this._singleGlobalObjectClass.GetSingleGlobalInstance()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.SDKDOMPluginBase = class SDKDOMPluginBase extends e.SDKPluginBase {
        constructor(e, t) {
            super(e), this._domComponentId = t, this._nextElementId = 0, this._instMap = new Map, this.AddElementMessageHandler("elem-focused", e => e._OnElemFocused()), this.AddElementMessageHandler("elem-blurred", e => {
                e && e._OnElemBlurred()
            })
        }
        Release() {
            super.Release()
        }
        _AddElement(e) {
            const t = this._nextElementId++;
            return this._instMap.set(t, e), t
        }
        _RemoveElement(e) {
            this._instMap.delete(e)
        }
        AddElementMessageHandler(e, t) {
            this._runtime.AddDOMComponentMessageHandler(this._domComponentId, e, e => {
                const n = this._instMap.get(e.elementId);
                t(n, e)
            })
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.SDKTypeBase = class SDKTypeBase extends e.DefendedBase {
        constructor(e) {
            super(), this._objectClass = e, this._runtime = e.GetRuntime(), this._plugin = e.GetPlugin()
        }
        Release() {
            this._objectClass = null, this._runtime = null, this._plugin = null
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetRuntime() {
            return this._runtime
        }
        GetPlugin() {
            return this._plugin
        }
        GetImageInfo() {
            return this._objectClass.GetImageInfo()
        }
        FinishCondition() {}
        LoadTextures() {}
        ReleaseTextures() {}
        OnDynamicTextureLoadComplete() {}
        PreloadTexturesWithInstances() {}
        LoadTilemapData() {}
        GetScriptInterfaceClass() {
            return null
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.SDKInstanceBase = class SDKInstanceBase extends e.DefendedBase {
        constructor(e, t) {
            super(), this._inst = e, this._domComponentId = t, this._runtime = e.GetRuntime(), this._objectClass = this._inst.GetObjectClass(), this._sdkType = this._objectClass.GetSdkType(), this._tickFunc = null, this._tick2Func = null, this._isTicking = !1, this._isTicking2 = !1, this._disposables = null, this._wasReleased = !1
        }
        Release() {
            this._wasReleased = !0, this._StopTicking(), this._StopTicking2(), this._tickFunc = null, this._tick2Func = null, this._disposables && (this._disposables.Release(), this._disposables = null), this._inst = null, this._runtime = null, this._objectClass = null, this._sdkType = null
        }
        WasReleased() {
            return this._wasReleased
        }
        GetInstance() {
            return this._inst
        }
        GetRuntime() {
            return this._runtime
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetPlugin() {
            return this._sdkType.GetPlugin()
        }
        GetSdkType() {
            return this._sdkType
        }
        GetScriptInterface() {
            return this._inst.GetInterfaceClass()
        }
        Trigger(e) {
            return this._runtime.Trigger(e, this._inst, null)
        }
        DebugTrigger(e) {
            return this._runtime.DebugTrigger(e, this._inst, null)
        }
        TriggerAsync(e) {
            return this._runtime.TriggerAsync(e, this._inst, null)
        }
        FastTrigger(e, t) {
            return this._runtime.FastTrigger(e, this._inst, t)
        }
        DebugFastTrigger(e, t) {
            return this._runtime.DebugFastTrigger(e, this._inst, t)
        }
        ScheduleTriggers(e) {
            return this._runtime.ScheduleTriggers(e)
        }
        AddDOMMessageHandler(e, t) {
            this._runtime.AddDOMComponentMessageHandler(this._domComponentId, e, t)
        }
        AddDOMMessageHandlers(e) {
            for (const [t, n] of e) this.AddDOMMessageHandler(t, n)
        }
        PostToDOM(e, t) {
            this._runtime.PostComponentMessageToDOM(this._domComponentId, e, t)
        }
        PostToDOMAsync(e, t) {
            return this._runtime.PostComponentMessageToDOMAsync(this._domComponentId, e, t)
        }
        _PostToDOMMaybeSync(e, t) {
            if (this._runtime.IsInWorker()) this.PostToDOM(e, t);
            else return window.c3_runtimeInterface._OnMessageFromRuntime({
                type: "event",
                component: this._domComponentId,
                handler: e,
                data: t,
                responseId: null
            })
        }
        GetCurrentImageInfo() {
            return null
        }
        GetCurrentSurfaceSize() {
            const e = this.GetCurrentImageInfo();
            if (e) {
                const t = e.GetTexture();
                if (t) return [t.GetWidth(), t.GetHeight()]
            }
            return [100, 100]
        }
        GetCurrentTexRect() {
            const e = this.GetCurrentImageInfo();
            return e ? e.GetTexRect() : null
        }
        GetImagePoint() {
            const t = this._inst.GetWorldInfo();
            return [t.GetX(), t.GetY()]
        }
        Tick() {}
        Tick2() {}
        _StartTicking() {
            if (this._isTicking) return;
            this._tickFunc || (this._tickFunc = () => this.Tick()), this._runtime.Dispatcher().addEventListener("tick", this._tickFunc), this._isTicking = !0
        }
        _StopTicking() {
            if (!this._isTicking) return;
            this._runtime.Dispatcher().removeEventListener("tick", this._tickFunc), this._isTicking = !1
        }
        IsTicking() {
            return this._isTicking
        }
        _StartTicking2() {
            if (this._isTicking2) return;
            this._tick2Func || (this._tick2Func = () => this.Tick2()), this._runtime.Dispatcher().addEventListener("tick2", this._tick2Func), this._isTicking2 = !0
        }
        _StopTicking2() {
            if (!this._isTicking2) return;
            this._runtime.Dispatcher().removeEventListener("tick2", this._tick2Func), this._isTicking2 = !1
        }
        IsTicking2() {
            return this._isTicking2
        }
        GetDebuggerProperties() {
            return []
        }
        SaveToJson() {
            return null
        }
        LoadFromJson() {}
        LoadTilemapData() {}
        TestPointOverlapTile() {}
        GetPropertyValueByIndex() {}
        SetPropertyValueByIndex() {}
        OffsetPropertyValueByIndex(e, t) {
            if (t === 0) return;
            const n = this.GetPropertyValueByIndex(e);
            if (typeof n != "number") throw new Error("expected number");
            this.SetPropertyValueByIndex(e, n + t)
        }
        SetPropertyColorOffsetValueByIndex() {}
        CallAction(e, ...t) {
            e.call(this, ...t)
        }
        CallExpression(e, ...t) {
            return e.call(this, ...t)
        }
        GetScriptInterfaceClass() {
            return null
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.SDKWorldInstanceBase = class SDKWorldInstanceBase extends e.SDKInstanceBase {
        constructor(e, t) {
            super(e, t), this._worldInfo = e.GetWorldInfo(), this._webglcontextlost_handler = null, this._webglcontextrestored_handler = null
        }
        Release() {
            if (this._webglcontextlost_handler) {
                const e = this._runtime.Dispatcher();
                e.removeEventListener("webglcontextlost", this._webglcontextlost_handler), e.removeEventListener("webglcontextrestored", this._webglcontextrestored_handler), this._webglcontextlost_handler = null, this._webglcontextrestored_handler = null
            }
            this._worldInfo = null, super.Release()
        }
        HandleWebGLContextLoss() {
            if (this._webglcontextlost_handler) return;
            this._webglcontextlost_handler = () => this.OnWebGLContextLost(), this._webglcontextrestored_handler = () => this.OnWebGLContextRestored();
            const e = this._runtime.Dispatcher();
            e.addEventListener("webglcontextlost", this._webglcontextlost_handler), e.addEventListener("webglcontextrestored", this._webglcontextrestored_handler)
        }
        OnWebGLContextLost() {}
        OnWebGLContextRestored() {}
        GetWorldInfo() {
            return this._worldInfo
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = e.New(e.Rect);
    e.SDKDOMInstanceBase = class SDKDOMInstanceBase extends e.SDKWorldInstanceBase {
        constructor(t, n) {
            super(t, n), this._elementId = this.GetPlugin()._AddElement(this), this._isElementShowing = !0, this._elemHasFocus = !1, this._autoFontSize = !1, this._lastRect = e.New(e.Rect, 0, 0, -1, -1);
            const s = this._runtime.GetCanvasManager();
            this._lastWindowWidth = s.GetLastWidth(), this._lastWindowHeight = s.GetLastHeight(), this._isPendingUpdateState = !1, this._StartTicking()
        }
        Release() {
            this.GetPlugin()._RemoveElement(this._elementId), this.PostToDOMElement("destroy"), this._elementId = -1, super.Release()
        }
        _GetElementInDOMMode() {
            if (this._runtime.IsInWorker()) throw new Error("not valid in worker mode");
            return this._PostToDOMElementMaybeSync("get-element")
        }
        PostToDOMElement(e, t) {
            t || (t = {}), t.elementId = this._elementId, this.PostToDOM(e, t)
        }
        _PostToDOMElementMaybeSync(e, t) {
            return t || (t = {}), t.elementId = this._elementId, this._PostToDOMMaybeSync(e, t)
        }
        PostToDOMElementAsync(e, t) {
            return t || (t = {}), t.elementId = this._elementId, this.PostToDOMAsync(e, t)
        }
        CreateElement(e) {
            e || (e = {});
            const t = this.GetWorldInfo().IsVisible();
            e.elementId = this._elementId, e.isVisible = t, Object.assign(e, this.GetElementState()), this._isElementShowing = !!e.isVisible, this._PostToDOMMaybeSync("create", e), this._UpdatePosition(!0)
        }
        SetElementVisible(e) {
            if (e = !!e, this._isElementShowing === e) return;
            this._isElementShowing = e, this.PostToDOMElement("set-visible", {
                isVisible: e
            })
        }
        Tick() {
            this._UpdatePosition(!1)
        }
        _ShouldPreserveElement() {
            const t = this._runtime.GetCanvasManager().GetFullscreenMode();
            return e.Platform.OS === "Android" && (t === "scale-inner" || t === "scale-outer" || t === "crop")
        }
        _UpdatePosition(e) {
            const n = this.GetWorldInfo(),
                i = n.GetLayer(),
                h = n.GetX(),
                u = n.GetY();
            let [a, r] = i.LayerToCanvasCss(h, u), [c, o] = i.LayerToCanvasCss(h + n.GetWidth(), u + n.GetHeight());
            const s = this._runtime.GetCanvasManager(),
                l = s.GetCssWidth(),
                d = s.GetCssHeight();
            if (!n.IsVisible() || !i.IsVisible()) {
                this.SetElementVisible(!1);
                return
            }
            if (!this._ShouldPreserveElement()) {
                if (c <= 0 || o <= 0 || a >= l || r >= d) {
                    this.SetElementVisible(!1);
                    return
                }
                a < 1 && (a = 1), r < 1 && (r = 1), c >= l && (c = l - 1), o >= d && (o = d - 1)
            }
            t.set(a, r, c, o);
            const m = s.GetLastWidth(),
                f = s.GetLastHeight();
            if (!e && t.equals(this._lastRect) && this._lastWindowWidth === m && this._lastWindowHeight === f) {
                this.SetElementVisible(!0);
                return
            }
            this._lastRect.copy(t), this._lastWindowWidth = m, this._lastWindowHeight = f, this.SetElementVisible(!0);
            let p = null;
            this._autoFontSize && (p = i.GetDisplayScale() - .2), this.PostToDOMElement("update-position", {
                left: Math.round(this._lastRect.getLeft()) + s.GetCanvasClientX(),
                top: Math.round(this._lastRect.getTop()) + s.GetCanvasClientY(),
                width: Math.round(this._lastRect.width()),
                height: Math.round(this._lastRect.height()),
                fontSize: p
            })
        }
        FocusElement() {
            this._PostToDOMElementMaybeSync("focus", {
                focus: !0
            })
        }
        BlurElement() {
            this._PostToDOMElementMaybeSync("focus", {
                focus: !1
            })
        }
        _OnElemFocused() {
            this._elemHasFocus = !0
        }
        _OnElemBlurred() {
            this._elemHasFocus = !1
        }
        IsElementFocused() {
            return this._elemHasFocus
        }
        SetElementCSSStyle(t, n) {
            this.PostToDOMElement("set-css-style", {
                prop: e.CSSToCamelCase(t),
                val: n
            })
        }
        SetElementAttribute(e, t) {
            this.PostToDOMElement("set-attribute", {
                name: e,
                val: t
            })
        }
        RemoveElementAttribute(e) {
            this.PostToDOMElement("remove-attribute", {
                name: e
            })
        }
        UpdateElementState() {
            if (this._isPendingUpdateState) return;
            this._isPendingUpdateState = !0, Promise.resolve().then(() => {
                this._isPendingUpdateState = !1, this.PostToDOMElement("update-state", this.GetElementState())
            })
        }
        GetElementState() {}
        GetElementId() {
            return this._elementId
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = self.IBehavior;
    e.SDKBehaviorBase = class SDKBehaviorBase extends e.DefendedBase {
        constructor(n) {
            super(), this._runtime = n.runtime, this._myObjectClasses = e.New(e.ArraySet), this._myInstances = e.New(e.ArraySet), this._iBehavior = null;
            const s = n.scriptInterfaceClass;
            if (s) {
                if (this._iBehavior = new s(this), !(this._iBehavior instanceof t)) throw new TypeError("script interface class must derive from IBehavior")
            } else this._iBehavior = new t(this)
        }
        Release() {
            this._myInstances.Release(), this._myObjectClasses.Release(), this._runtime = null
        }
        GetRuntime() {
            return this._runtime
        }
        OnCreate() {}
        _AddObjectClass(e) {
            this._myObjectClasses.Add(e)
        }
        GetObjectClasses() {
            return this._myObjectClasses.GetArray()
        }
        _AddInstance(e) {
            this._myInstances.Add(e)
        }
        _RemoveInstance(e) {
            this._myInstances.Delete(e)
        }
        GetInstances() {
            return this._myInstances.GetArray()
        }
        GetIBehavior() {
            return this._iBehavior
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.SDKBehaviorTypeBase = class SDKBehaviorTypeBase extends e.DefendedBase {
        constructor(e) {
            super(), this._runtime = e.GetRuntime(), this._behaviorType = e, this._objectClass = e.GetObjectClass(), this._behavior = e.GetBehavior(), this._behavior._AddObjectClass(this._objectClass)
        }
        Release() {
            this._runtime = null, this._behaviorType = null, this._objectClass = null, this._behavior = null
        }
        GetBehaviorType() {
            return this._behaviorType
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetRuntime() {
            return this._runtime
        }
        GetBehavior() {
            return this._behavior
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.SDKBehaviorInstanceBase = class SDKBehaviorInstanceBase extends e.DefendedBase {
        constructor(e, t) {
            super(), this._behInst = e, this._domComponentId = t, this._inst = e.GetObjectInstance(), this._runtime = e.GetRuntime(), this._behaviorType = e.GetBehaviorType(), this._sdkType = this._behaviorType.GetSdkType(), this._isTicking = !1, this._isTicking2 = !1, this._isPostTicking = !1, this._disposables = null
        }
        Release() {
            this._StopTicking(), this._StopTicking2(), this._StopPostTicking(), this._disposables && (this._disposables.Release(), this._disposables = null), this._behInst = null, this._inst = null, this._runtime = null, this._behaviorType = null, this._sdkType = null
        }
        GetBehavior() {
            return this._behaviorType.GetBehavior()
        }
        GetBehaviorInstance() {
            return this._behInst
        }
        GetObjectInstance() {
            return this._inst
        }
        GetObjectClass() {
            return this._inst.GetObjectClass()
        }
        GetWorldInfo() {
            return this._inst.GetWorldInfo()
        }
        GetRuntime() {
            return this._runtime
        }
        GetBehaviorType() {
            return this._behaviorType
        }
        GetSdkType() {
            return this._sdkType
        }
        GetScriptInterface() {
            return this._behInst.GetScriptInterface()
        }
        Trigger(e) {
            return this._runtime.Trigger(e, this._inst, this._behaviorType)
        }
        DebugTrigger(e) {
            return this._runtime.DebugTrigger(e, this._inst, this._behaviorType)
        }
        TriggerAsync(e) {
            return this._runtime.TriggerAsync(e, this._inst, this._behaviorType)
        }
        PostCreate() {}
        Tick() {}
        Tick2() {}
        PostTick() {}
        _StartTicking() {
            if (this._isTicking) return;
            this._runtime._AddBehInstToTick(this), this._isTicking = !0
        }
        _StopTicking() {
            if (!this._isTicking) return;
            this._runtime._RemoveBehInstToTick(this), this._isTicking = !1
        }
        IsTicking() {
            return this._isTicking
        }
        _StartTicking2() {
            if (this._isTicking2) return;
            this._runtime._AddBehInstToTick2(this), this._isTicking2 = !0
        }
        _StopTicking2() {
            if (!this._isTicking2) return;
            this._runtime._RemoveBehInstToTick2(this), this._isTicking2 = !1
        }
        IsTicking2() {
            return this._isTicking2
        }
        _StartPostTicking() {
            if (this._isPostTicking) return;
            this._runtime._AddBehInstToPostTick(this), this._isPostTicking = !0
        }
        _StopPostTicking() {
            if (!this._isPostTicking) return;
            this._runtime._RemoveBehInstToPostTick(this), this._isPostTicking = !1
        }
        IsPostTicking() {
            return this._isPostTicking
        }
        GetDebuggerProperties() {
            return []
        }
        AddDOMMessageHandler(e, t) {
            this._runtime.AddDOMComponentMessageHandler(this._domComponentId, e, t)
        }
        OnSpriteFrameChanged() {}
        SaveToJson() {
            return null
        }
        LoadFromJson() {}
        GetPropertyValueByIndex() {}
        SetPropertyValueByIndex() {}
        OffsetPropertyValueByIndex(e, t) {
            if (t === 0) return;
            const n = this.GetPropertyValueByIndex(e);
            if (typeof n != "number") throw new Error("expected number");
            this.SetPropertyValueByIndex(e, n + t)
        }
        SetPropertyColorOffsetValueByIndex() {}
        CallAction(e, ...t) {
            e.call(this, ...t)
        }
        CallExpression(e, ...t) {
            return e.call(this, ...t)
        }
        GetScriptInterfaceClass() {
            return null
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins = {}, e.Behaviors = {}, e.PluginManager = class PluginManager extends e.DefendedBase {
        constructor(e) {
            super(), this._runtime = e, this._allPlugins = [], this._pluginsByCtor = new Map, this._systemPlugin = null, this._allBehaviors = [], this._behaviorsByCtor = new Map, this._solidBehavior = null, this._jumpthruBehavior = null
        }
        CreatePlugin(t) {
            const n = this._runtime.GetObjectReference(t[0]);
            if (!n) throw new Error("missing plugin");
            e.AddCommonACEs(t, n);
            const s = e.New(n, {
                runtime: this._runtime,
                isSingleGlobal: t[1],
                isWorld: t[2],
                isRotatable: t[5],
                hasEffects: t[8],
                mustPredraw: t[9],
                supportsSceneGraph: t[13],
                supportsMesh: t[14]
            });
            s.OnCreate(), this._allPlugins.push(s), this._pluginsByCtor.set(n, s)
        }
        CreateSystemPlugin() {
            this._systemPlugin = e.New(e.Plugins.System, {
                runtime: this._runtime,
                isSingleGlobal: !0
            }), this._systemPlugin.OnCreate()
        }
        CreateBehavior(t) {
            const s = this._runtime.GetObjectReference(t[1]);
            if (!s) throw new Error("missing behavior");
            const n = e.New(s, {
                runtime: this._runtime
            });
            n.OnCreate(), this._allBehaviors.push(n), this._behaviorsByCtor.set(s, n), !this._solidBehavior && e.Behaviors.solid && n instanceof e.Behaviors.solid ? this._solidBehavior = n : !this._jumpthruBehavior && e.Behaviors.jumpthru && n instanceof e.Behaviors.jumpthru && (this._jumpthruBehavior = n)
        }
        GetPluginByConstructorFunction(e) {
            return this._pluginsByCtor.get(e) || null
        }
        HasBehaviorByConstructorFunction(e) {
            return this._behaviorsByCtor.has(e)
        }
        GetBehaviorByConstructorFunction(e) {
            return this._behaviorsByCtor.get(e) || null
        }
        GetSystemPlugin() {
            return this._systemPlugin
        }
        GetSolidBehavior() {
            return this._solidBehavior
        }
        GetJumpthruBehavior() {
            return this._jumpthruBehavior
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = new Set;
    e.ImageInfo = class ImageInfo extends e.DefendedBase {
        constructor() {
            super(), this._url = "", this._size = 0, this._pixelFormat = 0, this._offsetX = 0, this._offsetY = 0, this._width = 0, this._height = 0, this._hasMetaData = !1, this._imageAsset = null, this._textureState = "", this._rcTex = e.New(e.Rect), t.add(this)
        }
        Release() {
            this.ReleaseTexture(), this._imageAsset = null, t.delete(this)
        }
        static OnWebGLContextLost() {
            for (const e of t) e._textureState = "", e._rcTex.set(0, 0, 0, 0)
        }
        LoadData(e) {
            this._url = e[0], this._size = e[1], this._pixelFormat = e[2], this._offsetX = e[3], this._offsetY = e[4], this._width = e[5], this._height = e[6], this._hasMetaData = !0
        }
        LoadAnimationFrameData(e) {
            this._url = e[0], this._size = e[1], this._offsetX = e[2], this._offsetY = e[3], this._width = e[4], this._height = e[5], this._pixelFormat = e[11], this._hasMetaData = !0
        }
        LoadDynamicAsset(t, n) {
            if (this._imageAsset) throw new Error("already loaded asset");
            this._url = n;
            const s = {};
            return e.IsAbsoluteURL(n) && (s.loadPolicy = "remote"), this.LoadAsset(t, s), this._imageAsset.Load()
        }
        ReplaceWith(e) {
            if (e === this) throw new Error("cannot replace with self");
            this.ReleaseTexture(), this._url = e._url, this._size = e._size, this._pixelFormat = e._pixelFormat, this._offsetX = e._offsetX, this._offsetY = e._offsetY, this._width = e._width, this._height = e._height, this._hasMetaData = e._hasMetaData, this._imageAsset = e._imageAsset, this._textureState = e._textureState, this._rcTex = e._rcTex
        }
        GetURL() {
            return this._url
        }
        GetSize() {
            return this._size
        }
        GetPixelFormat() {
            return this._pixelFormat
        }
        GetOffsetX() {
            return this._offsetX
        }
        GetOffsetY() {
            return this._offsetY
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        GetSheetWidth() {
            return this._imageAsset.GetWidth()
        }
        GetSheetHeight() {
            return this._imageAsset.GetHeight()
        }
        LoadAsset(e, t) {
            if (this._imageAsset) throw new Error("already got asset");
            t = Object.assign({}, t, {
                url: this.GetURL(),
                size: this.GetSize()
            }), this._imageAsset = e.LoadImage(t)
        }
        IsLoaded() {
            return this._imageAsset && this._imageAsset.IsLoaded()
        }
        async LoadStaticTexture(e, t) {
            if (!this._imageAsset) throw new Error("no asset");
            if (this._textureState) throw new Error("already loaded texture");
            this._textureState = "loading";
            const n = await this._imageAsset.LoadStaticTexture(e, t);
            return n ? (this._textureState = "loaded", this._hasMetaData || (this._width = n.GetWidth(), this._height = n.GetHeight(), this._hasMetaData = !0), this._rcTex.set(this._offsetX, this._offsetY, this._offsetX + this._width, this._offsetY + this._height), this._rcTex.divide(n.GetWidth(), n.GetHeight()), n) : (this._textureState = "", null)
        }
        ReleaseTexture() {
            if (!this._textureState) return;
            this._imageAsset && this._imageAsset.ReleaseTexture(), this._textureState = "", this._rcTex.set(0, 0, 0, 0)
        }
        GetTexture() {
            return this._imageAsset ? this._imageAsset.GetTexture() : null
        }
        GetTexRect() {
            return this._rcTex
        }
        async ExtractImageToCanvas() {
            const n = await this._imageAsset.LoadToDrawable(),
                t = e.CreateCanvas(this._width, this._height),
                s = t.getContext("2d");
            return s.drawImage(n, this._offsetX, this._offsetY, this._width, this._height, 0, 0, this._width, this._height), t
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.AnimationInfo = class AnimationInfo extends e.DefendedBase {
        constructor(t) {
            super(), this._name = t[0], this._speed = t[1], this._isLooping = !!t[2], this._repeatCount = t[3], this._repeatTo = t[4], this._isPingPong = !!t[5], this._sid = t[6], this._frames = t[7].map(t => e.New(e.AnimationFrameInfo, t))
        }
        Release() {
            for (const e of this._frames) e.Release();
            e.clearArray(this._frames)
        }
        LoadAllAssets(e) {
            for (const t of this._frames) t.GetImageInfo().LoadAsset(e)
        }
        LoadAllTextures(e, t) {
            return Promise.all(this._frames.map(n => n.GetImageInfo().LoadStaticTexture(e, t)))
        }
        ReleaseAllTextures() {
            for (const e of this._frames) e.GetImageInfo().ReleaseTexture()
        }
        GetName() {
            return this._name
        }
        GetSID() {
            return this._sid
        }
        GetFrameCount() {
            return this._frames.length
        }
        GetFrames() {
            return this._frames
        }
        GetFrameAt(e) {
            if (e = Math.floor(e), e < 0 || e >= this._frames.length) throw new RangeError("invalid frame");
            return this._frames[e]
        }
        GetSpeed() {
            return this._speed
        }
        IsLooping() {
            return this._isLooping
        }
        GetRepeatCount() {
            return this._repeatCount
        }
        GetRepeatTo() {
            return this._repeatTo
        }
        IsPingPong() {
            return this._isPingPong
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.AnimationFrameInfo = class AnimationFrameInfo extends e.DefendedBase {
        constructor(t) {
            super(), this._imageInfo = e.New(e.ImageInfo), this._imageInfo.LoadAnimationFrameData(t), this._duration = t[6], this._origin = e.New(e.Vector2, t[7], t[8]), this._imagePoints = t[9].map(t => e.New(e.ImagePoint, this, t)), this._imagePointsByName = new Map;
            for (const e of this._imagePoints) this._imagePointsByName.set(e.GetName().toLowerCase(), e);
            this._collisionPoly = null;
            const n = t[10];
            n.length >= 6 && (this._collisionPoly = e.New(e.CollisionPoly, n))
        }
        Release() {
            this._collisionPoly && (this._collisionPoly.Release(), this._collisionPoly = null), this._imageInfo.Release(), this._imageInfo = null
        }
        GetImageInfo() {
            return this._imageInfo
        }
        GetDuration() {
            return this._duration
        }
        GetOriginX() {
            return this._origin.getX()
        }
        GetOriginY() {
            return this._origin.getY()
        }
        GetCollisionPoly() {
            return this._collisionPoly
        }
        GetImagePointByName(e) {
            return this._imagePointsByName.get(e.toLowerCase()) || null
        }
        GetImagePointByIndex(e) {
            return e = Math.floor(e), e < 0 || e >= this._imagePoints.length ? null : this._imagePoints[e]
        }
        GetImagePointCount() {
            return this._imagePoints.length
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.ImagePoint = class ImagePoint extends e.DefendedBase {
        constructor(t, n) {
            super(), this._afi = t, this._name = n[0], this._pos = e.New(e.Vector2, n[1], n[2])
        }
        Release() {}
        GetName() {
            return this._name
        }
        GetX() {
            return this._pos.getX()
        }
        GetY() {
            return this._pos.getY()
        }
        GetVec2() {
            return this._pos
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = self.C3Debugger,
        n = self.IObjectClass,
        s = self.assert;
    e.ObjectClass = class ObjectClass extends e.DefendedBase {
        constructor(t, s, o) {
            super();
            const i = t.GetObjectReference(o[1]);
            if (this._runtime = t, this._plugin = t.GetPluginManager().GetPluginByConstructorFunction(i), this._sdkType = null, this._instSdkCtor = i.Instance, this._index = s, this._sid = o[11], this._name = o[0], this._jsPropName = this._runtime.GetJsPropName(o[14]), this._isGlobal = !!o[9], this._isFamily = !!o[2], this._isOnLoaderLayout = !!o[10], this._instVars = o[3].map(e => ({
                    sid: e[0],
                    type: e[1],
                    name: e[2],
                    jsPropName: t.GetJsPropName(e[3])
                })), this._behaviorsCount = o[4], this._effectsCount = o[5], this._isWorldType = this._plugin.IsWorldType(), this._effectList = null, this._collisionGrid = e.New(e.SparseGrid, t.GetOriginalViewportWidth(), t.GetOriginalViewportHeight()), this._anyCollisionCellChanged = !0, this._anyInstanceParallaxed = !1, this._familyMembers = null, this._familyMembersSet = null, this._familyIndex = -1, this._families = null, this._familiesSet = null, this._familyInstVarMap = null, this._familyBehaviorMap = null, this._familyEffectMap = null, this._isInContainer = !1, this._container = null, this._behaviorTypes = o[8].map(t => e.BehaviorType.Create(this, t)), this._behaviorTypesIncludingInherited = [], this._behaviorsByName = new Map, this._behaviorNameToIndex = new Map, this._usedBehaviorCtors = new Set, this._solStack = e.New(e.SolStack, this), this._defaultInstanceData = null, this._defaultLayerIndex = 0, this._isContained = !1, this._container = null, this._imageInfo = null, this._animations = null, this._animationsByName = null, this._animationsBySid = null, this._textureRefCount = 0, this._savedData = new Map, this._unsavedData = new Map, this._instances = [], this._iidsStale = !0, this._plugin.HasEffects() && (this._effectList = e.New(e.EffectList, this, o[12])), o[6] && (this._imageInfo = e.New(e.ImageInfo), this._imageInfo.LoadData(o[6])), o[7]) {
                this._animations = o[7].map(t => e.New(e.AnimationInfo, t)), this._animationsByName = new Map, this._animationsBySid = new Map;
                for (const e of this._animations) this._animationsByName.set(e.GetName().toLowerCase(), e), this._animationsBySid.set(e.GetSID(), e)
            }
            this._isFamily ? (this._familyMembers = [], this._familyMembersSet = new Set, this._familyIndex = this._runtime._GetNextFamilyIndex()) : (this._families = [], this._familiesSet = new Set, this._familyInstVarMap = [], this._familyBehaviorMap = [], this._familyEffectMap = []), this._sdkType = e.New(i.Type, this, o[15]), this._iObjectClass = null, this._instanceUserScriptClass = null, this._userScriptDispatcher = e.New(e.Event.Dispatcher);
            const a = this._sdkType.GetScriptInterfaceClass();
            if (a) {
                if (this._iObjectClass = new a(this), !(this._iObjectClass instanceof n)) throw new TypeError("script interface class must derive from IObjectClass")
            } else this._iObjectClass = new n(this);
            if (o[13]) {
                const e = o[13];
                if (e) {
                    const t = e[0],
                        n = e[1];
                    this._sdkType.LoadTilemapData(t, n)
                }
            }(!this._runtime.UsesLoaderLayout() || this._isFamily || this._isOnLoaderLayout || !this._isWorldType) && this.OnCreate(), this._plugin.IsSingleGlobal() && (this._plugin._SetSingleGlobalObjectClass(this), this._CreateSingleGlobalInstance(o))
        }
        static Create(t, n, s) {
            return e.New(e.ObjectClass, t, n, s)
        }
        Release() {
            if (this._imageInfo && (this._imageInfo.Release(), this._imageInfo = null), this._animations) {
                for (const e of this._animations) e.Release();
                e.clearArray(this._animations), this._animationsByName.clear(), this._animationsBySid.clear()
            }
            this._solStack.Release(), this._solStack = null, this._savedData.clear(), this._unsavedData.clear(), this._container = null, this._runtime = null
        }
        _LoadFamily(e) {
            for (let n = 1, s = e.length; n < s; ++n) {
                const t = this._runtime.GetObjectClassByIndex(e[n]);
                this._familyMembers.push(t), this._familyMembersSet.add(t), t._families.push(this), t._familiesSet.add(this)
            }
        }
        _SetContainer(e) {
            this._isInContainer = !0, this._container = e
        }
        IsInContainer() {
            return this._isInContainer
        }
        GetContainer() {
            return this._container
        }
        _OnAfterCreate() {
            let t = 0;
            if (!this._isFamily)
                for (const e of this._families)
                    for (const n of e.GetBehaviorTypes()) {
                        const s = n.GetName().toLowerCase();
                        this._behaviorsByName.set(s, n), this._behaviorNameToIndex.set(s, t), this._behaviorTypesIncludingInherited.push(n), ++t
                    }
            for (const e of this.GetBehaviorTypes()) {
                const n = e.GetName().toLowerCase();
                this._behaviorsByName.set(n, e), this._behaviorNameToIndex.set(n, t), this._behaviorTypesIncludingInherited.push(e), ++t
            }
            for (const e of this._behaviorTypesIncludingInherited) this._usedBehaviorCtors.add(e.GetBehavior().constructor);
            if (!this._isFamily && this._families.length) {
                const t = this._runtime.GetFamilyCount();
                e.extendArray(this._familyInstVarMap, t, 0), e.extendArray(this._familyBehaviorMap, t, 0), e.extendArray(this._familyEffectMap, t, 0);
                const n = [];
                let s = 0,
                    o = 0,
                    i = 0;
                for (const e of this._families) {
                    const t = e.GetFamilyIndex();
                    this._familyInstVarMap[t] = s, s += e.GetInstanceVariablesCount(), this._familyBehaviorMap[t] = o, o += e.GetBehaviorTypesCount(), this._familyEffectMap[t] = i, i += e.GetEffectTypesCount();
                    const a = e.GetEffectList();
                    if (a && this._effectList)
                        for (const e of a.GetAllEffectTypes()) n.push(e.Clone(this._effectList))
                }
                this._effectList && this._effectList.PrependEffectTypes(n)
            }
        }
        _CreateSingleGlobalInstance(t) {
            const s = this._runtime._GetNewUID(),
                n = e.New(e.Instance, {
                    runtime: this._runtime,
                    objectType: this,
                    uid: s
                });
            n._CreateSdkInstance(t[16], []), this._runtime._MapInstanceByUID(s, n), this._instances.push(n)
        }
        GetSdkType() {
            return this._sdkType
        }
        IsOnLoaderLayout() {
            return this._isOnLoaderLayout
        }
        OnCreate() {
            this._isFamily || this._sdkType.OnCreate()
        }
        HasLoadedTextures() {
            return this._textureRefCount > 0
        }
        LoadTextures(e) {
            return this._isFamily ? Promise.resolve() : (this._textureRefCount++, this._textureRefCount === 1 ? this._sdkType.LoadTextures(e) || Promise.resolve() : Promise.resolve())
        }
        ReleaseTextures() {
            if (this._isFamily) return;
            if (this._textureRefCount--, this._textureRefCount < 0) throw new Error("released textures too many times");
            this._textureRefCount === 0 && this._sdkType.ReleaseTextures()
        }
        OnDynamicTextureLoadComplete() {
            if (this._isFamily) throw new Error("not applicable to family");
            this._sdkType.OnDynamicTextureLoadComplete()
        }
        PreloadTexturesWithInstances(e) {
            return this._isFamily ? Promise.resolve() : this._sdkType.PreloadTexturesWithInstances(e)
        }
        GetRuntime() {
            return this._runtime
        }
        GetPlugin() {
            return this._plugin
        }
        GetInstanceSdkCtor() {
            return this._instSdkCtor
        }
        GetName() {
            return this._name
        }
        GetJsPropName() {
            return this._jsPropName
        }
        GetIndex() {
            return this._index
        }
        GetSID() {
            return this._sid
        }
        IsFamily() {
            return this._isFamily
        }
        IsGlobal() {
            return this._isGlobal
        }
        IsWorldType() {
            return this._isWorldType
        }
        GetFamilyIndex() {
            return this._familyIndex
        }
        GetBehaviorTypes() {
            return this._behaviorTypes
        }
        GetBehaviorTypesCount() {
            return this._behaviorsCount
        }
        UsesBehaviorByCtor(e) {
            return e && this._usedBehaviorCtors.has(e)
        }
        GetInstanceVariablesCount() {
            return this._instVars.length
        }
        GetInstanceVariableSIDs() {
            return this._instVars.map(e => e.sid)
        }
        GetInstanceVariableIndexBySID(e) {
            return this._instVars.findIndex(t => t.sid === e)
        }
        GetInstanceVariableIndexByName(e) {
            return this._instVars.findIndex(t => t.name === e)
        }
        _GetAllInstanceVariableNames() {
            return this._instVars.map(e => e.name)
        }
        _GetAllInstanceVariableJsPropNames() {
            return this._instVars.map(e => e.jsPropName)
        }
        GetInstanceVariableType(e) {
            if (e = Math.floor(e), e < 0 || e >= this._instVars.length) throw new RangeError("invalid instance variable index");
            return this._instVars[e].type
        }
        GetInstanceVariableName(e) {
            if (e = Math.floor(e), e < 0 || e >= this._instVars.length) throw new RangeError("invalid instance variable index");
            return this._instVars[e].name
        }
        GetEffectTypesCount() {
            return this._effectsCount
        }
        GetBehaviorTypesIncludingInherited() {
            return this._behaviorTypesIncludingInherited
        }
        GetBehaviorTypeByName(e) {
            return this._behaviorsByName.get(e.toLowerCase()) || null
        }
        GetBehaviorIndexByName(e) {
            const t = this._behaviorNameToIndex.get(e.toLowerCase());
            return typeof t == "undefined" ? -1 : t
        }
        GetEffectList() {
            return this._effectList
        }
        HasEffects() {
            return this._plugin.HasEffects()
        }
        UsesEffects() {
            return this._effectList && this._effectList.HasAnyEffectType()
        }
        GetSolStack() {
            return this._solStack
        }
        GetCurrentSol() {
            return this._solStack.GetCurrentSol()
        }
        GetImageInfo() {
            return this._imageInfo
        }
        SetDefaultInstanceData(e) {
            this._defaultInstanceData = e
        }
        GetDefaultInstanceData() {
            return this._defaultInstanceData
        }
        _SetDefaultLayerIndex(e) {
            this._defaultLayerIndex = e
        }
        GetDefaultLayerIndex() {
            return this._defaultLayerIndex
        }
        GetAnimations() {
            return this._animations
        }
        GetAnimationCount() {
            return this._animations.length
        }
        GetFamilies() {
            return this._families
        }
        BelongsToFamily(e) {
            return this._familiesSet.has(e)
        }
        GetFamilyMembers() {
            return this._familyMembers
        }
        FamilyHasMember(e) {
            return this._familyMembersSet.has(e)
        }
        GetFamilyBehaviorOffset(e) {
            return this._familyBehaviorMap[e]
        }
        GetFamilyInstanceVariableOffset(e) {
            return this._familyInstVarMap[e]
        }
        GetAnimationByName(e) {
            if (!this._animations) throw new Error("no animations");
            return this._animationsByName.get(e.toLowerCase()) || null
        }
        GetAnimationBySID(e) {
            if (!this._animations) throw new Error("no animations");
            return this._animationsBySid.get(e) || null
        }
        GetFirstAnimationFrame() {
            if (!this._animations) throw new Error("no animations");
            return this._animations[0].GetFrameAt(0)
        }
        GetDefaultInstanceSize() {
            if (this._animations) {
                const e = this.GetFirstAnimationFrame().GetImageInfo();
                return [e.GetWidth(), e.GetHeight()]
            }
            return this._imageInfo ? [this._imageInfo.GetWidth(), this._imageInfo.GetHeight()] : [100, 100]
        }
        GetSingleGlobalInstance() {
            if (!this._plugin.IsSingleGlobal()) throw new Error("not a single-global plugin");
            return this._instances[0]
        }
        GetInstances() {
            return this._instances
        }* instances() {
            yield* this._instances
        }* instancesIncludingPendingCreate() {
            yield* this._instances;
            for (const e of this._runtime._GetInstancesPendingCreate()) e.GetObjectClass() === this && (yield e)
        }
        GetInstanceCount() {
            return this._instances.length
        }
        _AddInstance(e) {
            this._instances.push(e)
        }
        _SetIIDsStale() {
            this._iidsStale = !0
        }
        _UpdateIIDs() {
            if (!this._iidsStale || this._isFamily) return;
            const t = this._instances;
            let e = 0;
            for (let n = t.length; e < n; ++e) t[e]._SetIID(e);
            const n = this._runtime._GetInstancesPendingCreate();
            for (const t of n) t.GetObjectClass() === this && t._SetIID(e++);
            this._iidsStale = !1
        }
        GetInstanceByIID(e) {
            const t = this._instances;
            if (e < t.length) return t[e];
            e -= t.length;
            const n = this._runtime._GetInstancesPendingCreate();
            for (const t of n)
                if (t.GetObjectClass() === this) {
                    if (e === 0) return t;
                    --e
                } return null
        }
        GetFirstPicked(e) {
            if (e && e.IsInContainer() && e.GetObjectClass() !== this)
                for (const t of e.siblings())
                    if (t.GetObjectClass() === this) return t;
            const t = this.GetCurrentSol().GetInstances();
            return t.length ? t[0] : null
        }
        GetPairedInstance(e) {
            const t = this.GetCurrentSol().GetInstances();
            return t.length ? t[e.GetIID() % t.length] : null
        }* allCorrespondingInstances(e, t) {
            const r = this.GetCurrentSol().GetInstances(),
                c = r.length,
                u = t.GetCurrentSol(),
                l = t.GetCurrentSol().GetInstances(),
                d = l.length;
            let s = e.GetIID();
            (t.IsFamily() || !u.IsSelectAll()) && (s = l.indexOf(e));
            const n = Math.ceil(c / d),
                o = c % d;
            let i = 0,
                a = 0;
            o === 0 || s < o ? (i = s * n, a = n) : (i = o * n + (s - o) * (n - 1), a = n - 1);
            for (let e = i, t = i + a; e < t; ++e) yield r[e]
        }
        FinishCondition(e) {
            this._sdkType.FinishCondition(e)
        }
        ApplySolToContainer() {
            if (!this._isInContainer || this._isFamily) return;
            this._UpdateIIDs();
            const t = this.GetCurrentSol(),
                o = t._GetOwnInstances(),
                s = t.IsSelectAll(),
                n = this._runtime.GetCurrentEventStackFrame(),
                i = n && n.GetCurrentEvent() && n.GetCurrentEvent().IsOrBlock();
            for (const n of this._container.objectTypes()) {
                if (n === this) continue;
                n._UpdateIIDs();
                const a = n.GetCurrentSol();
                if (a._SetSelectAll(s), !s) {
                    const s = a._GetOwnInstances();
                    e.clearArray(s);
                    for (const e of o) s.push(n.GetInstanceByIID(e.GetIID()));
                    if (i) {
                        const o = t._GetOwnElseInstances(),
                            s = a._GetOwnElseInstances();
                        e.clearArray(s);
                        for (const e of o) s.push(n.GetInstanceByIID(e.GetIID()))
                    }
                }
            }
        }
        _TruncateContainerSols(t, n) {
            for (const o of this.GetContainer().objectTypes()) {
                const s = o.GetCurrentSol();
                t ? e.truncateArray(s._GetOwnElseInstances(), n) : e.truncateArray(s._GetOwnInstances(), n)
            }
        }
        _GetCollisionCellGrid() {
            return this._collisionGrid
        }
        _SetAnyCollisionCellChanged(e) {
            this._anyCollisionCellChanged = !!e
        }
        _SetAnyInstanceParallaxed(e) {
            this._anyInstanceParallaxed = !!e
        }
        IsAnyInstanceParallaxed() {
            return this._anyInstanceParallaxed
        }
        _UpdateAllCollisionCells() {
            if (!this._anyCollisionCellChanged || !this._isWorldType) return;
            for (const e of this._instances) e.GetWorldInfo()._UpdateCollisionCell();
            for (const e of this._runtime._GetInstancesPendingCreate()) e.GetObjectClass() === this && e.GetWorldInfo()._UpdateCollisionCell();
            this._anyCollisionCellChanged = !1
        }
        GetSavedDataMap() {
            return this._savedData || (this._savedData = new Map), this._savedData
        }
        GetUnsavedDataMap() {
            return this._unsavedData || (this._unsavedData = new Map), this._unsavedData
        }
        HasSolidBehavior() {
            return this.UsesBehaviorByCtor(e.Behaviors.solid)
        }
        HasNoSaveBehavior() {
            return this.UsesBehaviorByCtor(e.Behaviors.NoSave)
        }
        HasPersistBehavior() {
            return this.UsesBehaviorByCtor(e.Behaviors.Persist)
        }
        _SaveToJson() {
            const t = {
                instances: this._instances.map(e => e.SaveToJson())
            };
            return this._savedData && this._savedData.size && (t.ex = e.ToSuperJSON(this._savedData)), t
        }
        _LoadFromJson(t) {
            this._savedData && (this._savedData.clear(), this._savedData = null);
            const o = t.ex;
            o && (this._savedData = e.FromSuperJSON(o));
            const n = this._instances,
                s = t.instances;
            for (let e = 0, t = Math.min(n.length, s.length); e < t; ++e) n[e].LoadFromJson(s[e]);
            for (let e = s.length, t = n.length; e < t; ++e) this._runtime.DestroyInstance(n[e]);
            for (let e = n.length, i = s.length; e < i; ++e) {
                const o = s[e];
                let t = null;
                if (this.IsWorldType() && (t = this._runtime.GetMainRunningLayout().GetLayerBySID(o.w.l), !t)) continue;
                const a = this._runtime.CreateInstanceFromData(this._defaultInstanceData || this, t, !1, 0, 0, !0);
                a.LoadFromJson(o)
            }
            this._SetIIDsStale()
        }
        GetIObjectClass() {
            return this._iObjectClass
        }
        UserScriptDispatcher() {
            return this._userScriptDispatcher
        }
        _GetUserScriptInstanceClass() {
            return this._instanceUserScriptClass
        }
        _SetUserScriptInstanceClass(e) {
            this._instanceUserScriptClass = e
        }
        DispatchUserScriptEvent(e) {
            const n = this._runtime,
                s = n.IsDebug() && !n.GetEventSheetManager().IsInEventEngine();
            s && t.StartMeasuringScriptTime(), this._userScriptDispatcher.dispatchEvent(e), s && t.AddScriptTime()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Container = class Container extends e.DefendedBase {
        constructor(e, t) {
            super(), this._runtime = e, this._objectTypes = t;
            for (const e of this._objectTypes) e._SetContainer(this)
        }
        Release() {
            this._runtime = null
        }
        GetRuntime() {
            return this._runtime
        }
        GetObjectTypes() {
            return this._objectTypes
        }
        objectTypes() {
            return this._objectTypes
        }
        HasAnyWorldType() {
            return this._objectTypes.some(e => e.IsWorldType())
        }
    }
}
"use strict";
{
    const e = self.C3,
        a = self.C3Debugger,
        s = self.IInstance,
        r = [];
    let u = 0;
    const t = new WeakMap,
        n = new WeakMap,
        c = 1 << 0,
        l = 1 << 1,
        d = 1 << 2,
        o = 1 << 3,
        i = 1 << 4;
    e.Instance = class Instance extends e.DefendedBase {
        constructor(t) {
            super(), this._runtime = t.runtime, this._objectType = t.objectType, this._worldInfo = null, this._sdkInst = null, this._iScriptInterface = null, this._iid = 0, this._uid = t.uid, this._puid = u++, this._flags = 0, this._instVarValues = r, this._behaviorInstances = r;
            const n = this._objectType.GetBehaviorTypesIncludingInherited();
            n.length > 0 && (this._behaviorInstances = n.map((t, n) => e.New(e.BehaviorInstance, {
                runtime: this._runtime,
                behaviorType: t,
                instance: this,
                index: n
            }))), this._siblings = this._objectType.IsInContainer() ? [] : null, this._timeScale = -1, this._dispatcher = null;
            const s = this.GetPlugin();
            if (s.MustPreDraw() && (this._flags |= d), s.IsWorldType())
                if (this._worldInfo = e.New(e.WorldInfo, this, t.layer), t.worldData) this._worldInfo.Init(t.worldData);
                else {
                    this._worldInfo.InitNoData();
                    const [e, t] = this._objectType.GetDefaultInstanceSize();
                    this._worldInfo.SetSize(e, t), this.GetObjectClass().UsesEffects() && this._worldInfo.GetInstanceEffectList().LoadDefaultEffectParameters()
                } t.instVarData ? this._LoadInstanceVariableData(t.instVarData) : this._LoadDefaultInstanceVariables()
        }
        Release() {
            if (this._iScriptInterface && (this._iScriptInterface._Release(), this._iScriptInterface = null), this._behaviorInstances.length > 0) {
                for (const e of this._behaviorInstances) e.Release();
                e.clearArray(this._behaviorInstances)
            }
            this._sdkInst.Release(), this._sdkInst = null;
            const s = t.get(this);
            s && (s.clear(), t.delete(this));
            const o = n.get(this);
            o && (o.clear(), n.delete(this)), this._siblings && e.clearArray(this._siblings), this._dispatcher && (this._dispatcher.Release(), this._dispatcher = null), this._runtime = null, this._objectType = null, this._instVarValues.length > 0 && e.clearArray(this._instVarValues), this._worldInfo && (this._worldInfo.Release(), this._worldInfo = null)
        }
        _LoadInstanceVariableData(t) {
            t.length > 0 && (this._instVarValues = [], e.shallowAssignArray(this._instVarValues, t))
        }
        _LoadDefaultInstanceVariables() {
            const e = this._objectType.GetInstanceVariablesCount();
            if (e === 0) return;
            this._instVarValues = [];
            const t = [0, 0, ""];
            for (let n = 0; n < e; ++n) this._instVarValues.push(t[this._objectType.GetInstanceVariableType(n)])
        }
        _CreateSdkInstance(t, n) {
            if (this._sdkInst) throw new Error("already got sdk instance");
            for (let e = 0, t = this._behaviorInstances.length; e < t; ++e) {
                const s = this._behaviorInstances[e];
                s._CreateSdkInstance(n ? n[e] : null)
            }
            if (this._sdkInst = e.New(this._objectType.GetInstanceSdkCtor(), this, t), !(this._sdkInst instanceof e.SDKInstanceBase)) throw new Error("sdk type must derive from SDKInstanceBase");
            for (let e = 0, t = this._behaviorInstances.length; e < t; ++e) this._behaviorInstances[e].PostCreate();
            this._objectType._GetUserScriptInstanceClass() && this._InitUserScriptInterface()
        }
        GetSdkInstance() {
            return this._sdkInst
        }
        GetWorldInfo() {
            return this._worldInfo
        }
        GetRuntime() {
            return this._runtime
        }
        GetTimeScale() {
            return this._timeScale
        }
        GetActiveTimeScale() {
            const e = this._timeScale;
            return e === -1 ? this.GetRuntime().GetTimeScale() : e
        }
        SetTimeScale(e) {
            e = +e, (e < 0 || !isFinite(e)) && (e = 0), this._timeScale = e
        }
        RestoreTimeScale() {
            this._timeScale = -1
        }
        Dispatcher() {
            return this._dispatcher || (this._dispatcher = e.New(e.Event.Dispatcher)), this._dispatcher
        }
        Draw(e) {
            this._sdkInst.Draw(e)
        }
        OnCreate(e) {
            this._sdkInst.OnCreate(e)
        }
        _SetHasTilemap() {
            this._flags |= l
        }
        HasTilemap() {
            return (this._flags & l) !== 0
        }
        _MarkDestroyed() {
            this._flags |= c
        }
        IsDestroyed() {
            return (this._flags & c) !== 0
        }
        MustPreDraw() {
            return (this._flags & d) !== 0
        }
        _IsSolidEnabled() {
            return (this._flags & o) !== 0
        }
        _SetSolidEnabled(e) {
            e ? this._flags |= o : this._flags &= ~o
        }
        _IsJumpthruEnabled() {
            return (this._flags & i) !== 0
        }
        _SetJumpthruEnabled(e) {
            e ? this._flags |= i : this._flags &= ~i
        }
        SetFlag(e, t) {
            e <<= 16, t ? this._flags |= e : this._flags &= ~e
        }
        GetFlag(e) {
            return (this._flags & e << 16) !== 0
        }
        GetCurrentImageInfo() {
            return this._sdkInst.GetCurrentImageInfo()
        }
        GetCurrentSurfaceSize() {
            return this._sdkInst.GetCurrentSurfaceSize()
        }
        GetCurrentTexRect() {
            return this._sdkInst.GetCurrentTexRect()
        }
        GetImagePoint(e) {
            return this._sdkInst.GetImagePoint(e)
        }
        GetObjectClass() {
            return this._objectType
        }
        BelongsToObjectClass(e) {
            return e.IsFamily() ? e.FamilyHasMember(this.GetObjectClass()) : this.GetObjectClass() === e
        }
        VerifySupportsSceneGraph() {
            if (!this.GetPlugin().SupportsSceneGraph()) throw new Error("object does not support scene graph")
        }
        HasParent() {
            return this.GetParent() !== null
        }
        GetParent() {
            const e = this.GetWorldInfo();
            if (!e) return null;
            const t = e.GetParent();
            return t ? t.GetInstance() : null
        }
        GetTopParent() {
            const e = this.GetWorldInfo();
            if (!e) return null;
            const t = e.GetTopParent();
            return t ? t.GetInstance() : null
        }* parents() {
            const e = this.GetWorldInfo();
            if (!e) return;
            for (const t of e.parents()) yield t.GetInstance()
        }
        HasChildren() {
            const e = this.GetWorldInfo();
            return !!e && e.HasChildren()
        }
        GetChildren() {
            const e = this.GetWorldInfo();
            return e ? e.GetChildren().map(e => e.GetInstance()) : []
        }* children() {
            const e = this.GetWorldInfo();
            if (!e) return;
            for (const t of e.children()) yield t.GetInstance()
        }* allChildren() {
            const e = this.GetWorldInfo();
            if (!e) return;
            for (const t of e.allChildren()) yield t.GetInstance()
        }
        GetChildCount() {
            const e = this.GetWorldInfo();
            return e ? e.GetChildCount() : 0
        }
        GetChildAt(e) {
            const t = this.GetWorldInfo();
            if (!t) return null;
            const n = t.GetChildAt(e);
            return n ? n.GetInstance() : null
        }
        AddChild(e, t) {
            this.VerifySupportsSceneGraph(), e.VerifySupportsSceneGraph(), this.GetWorldInfo().AddChild(e.GetWorldInfo(), t || {})
        }
        RemoveChild(e) {
            const t = this.GetWorldInfo();
            if (!t) return;
            t.RemoveChild(e.GetWorldInfo())
        }
        GetDestroyWithParent() {
            const e = this.GetWorldInfo();
            return !!e && e.GetDestroyWithParent()
        }
        SetupInitialSceneGraphConnections() {
            const e = this.GetWorldInfo();
            if (!e) return;
            const t = e.GetSceneGraphChildrenExportData();
            if (!t) return;
            for (const e of t) {
                const n = this._runtime.GetInstanceByUID(e[2]);
                if (n) {
                    const t = e[3];
                    this.AddChild(n, {
                        transformX: !!(t >> 0 & 1),
                        transformY: !!(t >> 1 & 1),
                        transformWidth: !!(t >> 2 & 1),
                        transformHeight: !!(t >> 3 & 1),
                        transformAngle: !!(t >> 4 & 1),
                        destroyWithParent: !!(t >> 5 & 1),
                        transformZElevation: !!(t >> 6 & 1)
                    })
                }
            }
        }
        IsInContainer() {
            return this._siblings !== null
        }
        _AddSibling(e) {
            this._siblings.push(e)
        }
        GetSiblings() {
            return this._siblings
        }
        HasSibling(e) {
            return !!this.GetSibling(e)
        }
        GetSibling(e) {
            const t = this.siblings();
            if (t === null || t.length === 0) return !1;
            for (const n of t)
                if (n.GetObjectClass() === e) return n;
            return null
        }
        siblings() {
            return this._siblings
        }
        SetSiblingsSinglePicked() {
            for (const e of this.siblings()) e.GetObjectClass().GetCurrentSol().SetSinglePicked(e)
        }
        _PushSiblingsToSolInstances() {
            for (const e of this.siblings()) e.GetObjectClass().GetCurrentSol()._PushInstance(e)
        }
        _SetSiblingsToSolInstancesIndex(e) {
            for (const t of this.siblings()) t.GetObjectClass().GetCurrentSol()._GetOwnInstances()[e] = t
        }
        _PushSiblingsToSolElseInstances() {
            for (const e of this.siblings()) e.GetObjectClass().GetCurrentSol()._PushElseInstance(e)
        }
        _SetSiblingsToSolElseInstancesIndex(e) {
            for (const t of this.siblings()) t.GetObjectClass().GetCurrentSol()._GetOwnElseInstances()[e] = t
        }
        GetPlugin() {
            return this._objectType.GetPlugin()
        }
        _SetIID(e) {
            this._iid = e
        }
        GetIID() {
            return this._objectType._UpdateIIDs(), this._iid
        }
        GetUID() {
            return this._uid
        }
        GetPUID() {
            return this._puid
        }
        GetBehaviorInstances() {
            return this._behaviorInstances
        }
        GetBehaviorInstanceFromCtor(e) {
            if (!e) return null;
            for (const t of this._behaviorInstances)
                if (t.GetBehavior() instanceof e) return t;
            return null
        }
        GetBehaviorSdkInstanceFromCtor(e) {
            if (!e) return null;
            const t = this.GetBehaviorInstanceFromCtor(e);
            return t ? t.GetSdkInstance() : null
        }
        GetBehaviorIndexBySID(e) {
            const t = this._behaviorInstances;
            for (let n = 0, s = t.length; n < s; ++n)
                if (t[n].GetBehaviorType().GetSID() === e) return n;
            return -1
        }
        GetAllInstanceVariableValues() {
            return this._instVarValues
        }
        _GetAllInstanceVariableNames() {
            return this._objectType._GetAllInstanceVariableNames()
        }
        GetInstanceVariableCount() {
            return this._instVarValues.length
        }
        GetInstanceVariableValue(e) {
            e = e | 0;
            const t = this._instVarValues;
            if (e < 0 || e >= t.length) throw new RangeError("invalid instance variable");
            return t[e]
        }
        _GetInstanceVariableValueUnchecked(e) {
            return this._instVarValues[e]
        }
        _GetInstanceVariableTypedValue(e) {
            const t = this._instVarValues[e];
            return this._objectType.GetInstanceVariableType(e) === 0 ? !!t : t
        }
        SetInstanceVariableValue(e, t) {
            e = e | 0;
            const n = this._instVarValues;
            if (e < 0 || e >= n.length) throw new RangeError("invalid instance variable");
            const s = this._objectType.GetInstanceVariableType(e);
            switch (s) {
                case 0:
                    n[e] = t ? 1 : 0;
                    break;
                case 1:
                    n[e] = typeof t == "number" ? t : parseFloat(t);
                    break;
                case 2:
                    n[e] = typeof t == "string" ? t : t.toString();
                    break;
                default:
                    throw new Error("unknown instance variable type")
            }
        }
        SetInstanceVariableOffset(e, t) {
            if (t === 0) return;
            e = e | 0;
            const n = this._instVarValues;
            if (e < 0 || e >= n.length) throw new RangeError("invalid instance variable");
            const s = n[e];
            if (typeof s == "number") typeof t == "number" ? n[e] += t : n[e] += parseFloat(t);
            else throw typeof s == "boolean" ? new Error("can not set offset of boolean variable") : typeof s == "string" ? new Error("can not set offset of string variable") : new Error("unknown instance variable type")
        }
        GetSavedDataMap() {
            let e = t.get(this);
            return e || (e = new Map, t.set(this, e), e)
        }
        GetUnsavedDataMap() {
            let e = n.get(this);
            return e || (e = new Map, n.set(this, e), e)
        }
        _HasAnyCreateDestroyHandler(e) {
            const t = this.GetObjectClass();
            if (t.UserScriptDispatcher().HasAnyHandlerFor(e)) return !0;
            for (const n of t.GetFamilies())
                if (n.UserScriptDispatcher().HasAnyHandlerFor(e)) return !0;
            return !!this._runtime.UserScriptDispatcher().HasAnyHandlerFor(e)
        }
        _TriggerOnCreatedOnSelfAndRelated() {
            this._TriggerOnCreated();
            const t = this.GetWorldInfo(),
                e = new Set;
            if (t && t.HasChildren())
                for (const t of this.allChildren()) {
                    if (e.add(t), !t.IsInContainer()) continue;
                    for (const n of t.siblings()) e.add(n)
                }
            if (this.IsInContainer())
                for (const t of this.siblings()) e.add(t);
            for (const t of e.values()) t._TriggerOnCreated()
        }
        _TriggerOnCreated() {
            if (this._HasAnyCreateDestroyHandler("instancecreate")) {
                const n = this.GetObjectClass(),
                    t = new e.Event("instancecreate");
                t.instance = this.GetInterfaceClass(), n.DispatchUserScriptEvent(t);
                for (const e of n.GetFamilies()) e.DispatchUserScriptEvent(t);
                this._runtime.DispatchUserScriptEvent(t)
            }
            this._runtime.Trigger(this.GetPlugin().constructor.Cnds.OnCreated, this, null)
        }
        _TriggerOnDestroyed() {
            this._runtime.Trigger(this.GetPlugin().constructor.Cnds.OnDestroyed, this, null)
        }
        _FireDestroyedScriptEvents(t) {
            if (this._iScriptInterface) {
                const n = new e.Event("destroy");
                n.isEndingLayout = t, this.DispatchUserScriptEvent(n)
            }
            if (!this._HasAnyCreateDestroyHandler("instancedestroy")) return;
            const s = this.GetObjectClass(),
                n = new e.Event("instancedestroy");
            n.instance = this.GetInterfaceClass(), n.isEndingLayout = t, s.DispatchUserScriptEvent(n);
            for (const e of s.GetFamilies()) e.DispatchUserScriptEvent(n);
            this._runtime.DispatchUserScriptEvent(n)
        }
        _GetDebuggerProperties() {
            return this._sdkInst.GetDebuggerProperties()
        }
        SaveToJson(n = "full") {
            const s = {};
            if (n === "full" ? s.uid = this.GetUID() : s.c3 = !0, n !== "visual-state") {
                const n = t.get(this);
                if (n && n.size && (s.ex = e.ToSuperJSON(n)), this.GetTimeScale() !== -1 && (s.mts = this.GetTimeScale()), this._objectType.GetInstanceVariablesCount() > 0) {
                    const e = {},
                        t = this._objectType.GetInstanceVariableSIDs();
                    for (let n = 0, s = this._instVarValues.length; n < s; ++n) e[t[n].toString()] = this._instVarValues[n];
                    s.ivs = e
                }
                if (this._behaviorInstances.length) {
                    const e = {};
                    for (const t of this._behaviorInstances) {
                        const n = t.SaveToJson();
                        n && (e[t.GetBehaviorType().GetSID().toString()] = n)
                    }
                    s.behs = e
                }
            }
            this._worldInfo && (s.w = this._worldInfo._SaveToJson());
            const o = this._sdkInst.SaveToJson();
            return o && (s.data = o), s
        }
        LoadFromJson(n, s = "full") {
            if (s === "full") this._uid = n.uid;
            else if (!n.c3) return;
            if (s !== "visual-state") {
                let s = t.get(this);
                s && (s.clear(), t.delete(this));
                const o = n.ex;
                o && (s = e.FromSuperJSON(o), t.set(this, s)), this._timeScale = n.hasOwnProperty("mts") ? n.mts : -1;
                const i = n.ivs;
                if (i)
                    for (const [n, s] of Object.entries(i)) {
                        const o = parseInt(n, 10),
                            e = this._objectType.GetInstanceVariableIndexBySID(o);
                        if (e < 0 || e >= this._instVarValues.length) continue;
                        let t = s;
                        t === null && (t = NaN), this._instVarValues[e] = t
                    }
            }
            if (this.GetPlugin().IsWorldType()) {
                const e = n.w,
                    t = e.l;
                if (this._worldInfo.GetLayer().GetSID() !== t) {
                    const n = this._worldInfo.GetLayer(),
                        e = n.GetLayout().GetLayerBySID(t);
                    e ? (this._worldInfo._SetLayer(e), n._RemoveInstance(this, !0), e._AddInstance(this, !0), e.SetZIndicesChanged(), this._worldInfo.SetBboxChanged()) : s === "full" && this._runtime.DestroyInstance(this)
                }
                this._worldInfo._LoadFromJson(e)
            }
            if (s !== "visual-state") {
                const e = n.behs;
                if (e)
                    for (const [n, s] of Object.entries(e)) {
                        const o = parseInt(n, 10),
                            t = this.GetBehaviorIndexBySID(o);
                        if (t < 0 || t >= this._behaviorInstances.length) continue;
                        this._behaviorInstances[t].LoadFromJson(s)
                    }
            }
            const o = n.data;
            o && this._sdkInst.LoadFromJson(o)
        }
        GetInterfaceClass() {
            return this._iScriptInterface || this._InitUserScriptInterface()
        }
        _InitUserScriptInterface() {
            const e = this._worldInfo ? self.IWorldInstance : s,
                t = this._sdkInst.GetScriptInterfaceClass(),
                n = this._objectType._GetUserScriptInstanceClass(),
                o = n || t || e;
            if (s._Init(this), this._iScriptInterface = new o, s._Init(null), t && !(this._iScriptInterface instanceof e)) throw new TypeError(`script interface class '${t.name}' does not extend the right base class '${e.name}'`);
            if (n) {
                const s = t || e;
                if (!(this._iScriptInterface instanceof s)) throw new TypeError(`setInstanceClass(): class '${n.name}' does not extend the right base class '${s.name}'`)
            }
            return this._iScriptInterface
        }
        _GetInstVarsScriptDescriptor(t) {
            if (this._instVarValues.length === 0) return;
            const n = {},
                s = this._objectType._GetAllInstanceVariableJsPropNames();
            for (let t = 0, o = s.length; t < o; ++t) n[s[t]] = {
                configurable: !1,
                enumerable: !0,
                get: e.Instance.prototype._GetInstanceVariableTypedValue.bind(this, t),
                set: e.Instance.prototype.SetInstanceVariableValue.bind(this, t)
            };
            const o = Object.create(Object.prototype, n);
            t.instVars = {
                value: o,
                writable: !1
            }
        }
        _GetBehaviorsScriptDescriptor(e) {
            const t = this._behaviorInstances;
            if (t.length === 0) return;
            const n = {};
            for (const e of t) n[e.GetBehaviorType().GetJsPropName()] = {
                value: e.GetScriptInterface(),
                writable: !1
            };
            const s = Object.create(Object.prototype, n);
            e.behaviors = {
                value: s,
                writable: !1
            }
        }
        DispatchUserScriptEvent(e) {
            e.instance = this.GetInterfaceClass();
            const t = this._runtime,
                n = t.IsDebug() && !t.GetEventSheetManager().IsInEventEngine();
            n && a.StartMeasuringScriptTime(), this.GetInterfaceClass().dispatchEvent(e), n && a.AddScriptTime()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.SceneGraphInfo = class SceneGraphInfo extends e.DefendedBase {
        constructor(e) {
            super(), this._owner = e, this._parent = null, this._children = [], this._myStartWidth = e.GetWidth(), this._myStartHeight = e.GetHeight(), this._parentStartAngle = 0
        }
        Release() {
            this._parent = null, e.clearArray(this._children)
        }
        SetParent(e) {
            this._parent = e, this._parentStartAngle = e ? e.GetAngle() : 0
        }
        GetParent() {
            return this._parent
        }
        HasChildren() {
            return this._children.length > 0
        }
        GetChildren() {
            return this._children
        }
        _GetStartWidth() {
            return this._myStartWidth
        }
        _GetStartHeight() {
            return this._myStartHeight
        }
        GetParentScaleX() {
            return this._owner.GetTransformWithParentWidth() ? this._parent.GetWidth() / this._parent._GetSceneGraphInfo()._GetStartWidth() : 1
        }
        GetParentScaleY() {
            return this._owner.GetTransformWithParentHeight() ? this._parent.GetHeight() / this._parent._GetSceneGraphInfo()._GetStartHeight() : 1
        }
        GetParentStartAngle() {
            return this._parentStartAngle
        }
        _SaveToJson() {
            return {
                sw: this._myStartWidth,
                sh: this._myStartHeight,
                psa: this._parentStartAngle,
                c: this._children.map(e => {
                    let t = "";
                    return e.GetTransformWithParentX() && (t += "x"), e.GetTransformWithParentY() && (t += "y"), e.GetTransformWithParentWidth() && (t += "w"), e.GetTransformWithParentHeight() && (t += "h"), e.GetTransformWithParentAngle() && (t += "a"), e.GetTransformWithParentZElevation() && (t += "z"), e.GetDestroyWithParent() && (t += "d"), {
                        uid: e.GetInstance().GetUID(),
                        f: t
                    }
                })
            }
        }
        _LoadFromJson(e) {
            this._myStartWidth = e.sw, this._myStartHeight = e.sh, this._parentStartAngle = e.psa
        }
        _OnAfterLoad(e) {
            const t = this._owner,
                n = t.GetRuntime();
            for (const i of e.c) {
                const a = i.uid,
                    r = n.GetInstanceByUID(a),
                    c = r.GetWorldInfo(),
                    o = i.f,
                    s = {};
                s.transformX = o.includes("x"), s.transformY = o.includes("y"), s.transformWidth = o.includes("w"), s.transformHeight = o.includes("h"), s.transformAngle = o.includes("a"), s.transformZElevation = o.includes("z"), s.destroyWithParent = o.includes("d"), t.AddChild(c, s)
            }
        }
    }
}
"use strict";
{
    const e = self.C3,
        n = e.New(e.Rect),
        g = e.New(e.Quad),
        M = e.New(e.Event, "bboxchange", !1),
        t = e.New(e.Color, 0, 0, 0, 0),
        u = e.New(e.CollisionPoly),
        s = e.New(e.Color, 1, 1, 1, 1),
        r = e.New(e.Rect, 0, 0, -1, -1),
        c = e.New(e.Rect, 0, 0, -1, -1),
        T = new Set(["absolute", "relative"]),
        F = [];
    let i = !0;
    const b = 1 << 0,
        o = 1 << 1,
        f = 1 << 2,
        p = 1 << 3,
        a = 1 << 4,
        v = 1 << 5,
        k = 1 << 6,
        E = 1 << 7,
        y = 1 << 8,
        d = 1 << 9,
        l = 1 << 10,
        O = 1 << 11,
        x = 1 << 12,
        C = 1 << 13,
        m = 1 << 14,
        S = y | d | l | O | x | C | m,
        h = 1 << 15,
        j = 1 << 16,
        _ = 1 << 17,
        w = 26,
        A = 31 << w;
    e.WorldInfo = class WorldInfo extends e.DefendedBase {
        constructor(t, n) {
            super(), this._inst = t, this._objectClass = t.GetObjectClass(), this._runtime = t.GetRuntime(), this._layer = n, this._zIndex = -1, this._flags = b | o | p | a | h | j, this._objectClass.GetPlugin().IsRotatable() && (this._flags |= E), this._x = NaN, this._y = NaN, this._zElevation = NaN, this._w = NaN, this._h = NaN, this._a = NaN, this._sinA = NaN, this._cosA = NaN, this._ox = NaN, this._oy = NaN, this._boundingBox = e.New(e.Rect), this._boundingQuad = e.New(e.Quad), this._collisionCells = c, this._renderCells = r, this._sourceCollisionPoly = null, this._transformedPolyInfo = null, this._solidFilterTags = null, this._color = s, this._colorPremultiplied = s, this._stateGroup = null, this._instanceEffectList = null, this._inst.GetObjectClass().UsesEffects() && (this._instanceEffectList = e.New(e.InstanceEffectList, this._inst, this)), this._sceneGraphInfo = null, this._sceneGraphFlagsExportData = NaN, this._sceneGraphChildrenExportData = null, this._meshInfo = null
        }
        Release() {
            if (this._stateGroup && (this._runtime.GetRenderer().ReleaseStateGroup(this._stateGroup), this._stateGroup = null), this._sourceCollisionPoly = null, this._transformedPolyInfo && (this._transformedPolyInfo.poly.Release(), this._transformedPolyInfo = null), this._solidFilterTags && (this._solidFilterTags.clear(), this._solidFilterTags = null), this.ReleaseMesh(), this.HasParent() && this.GetParent().RemoveChild(this), this.HasChildren()) {
                const e = [...this.GetChildren()];
                for (const t of e) this.RemoveChild(t)
            }
            this._ReleaseSceneGraphInfo(), this._inst = null, this._objectClass = null, this._runtime = null, this._layer = null
        }
        Init(e) {
            i = !1, this.SetXY(e[0], e[1]), this.SetZElevation(e[2]), this.SetSize(e[3], e[4]), this.IsRotatable() ? this.SetAngle(e[6]) : this._a = 0, t.setFromJSON(e[7]), this._SetColor(t), this.SetOriginX(e[8]), this.SetOriginY(e[9]), this.SetBlendMode(e[10]), this._instanceEffectList && this._instanceEffectList._LoadEffectParameters(e[12]), e[14] && (this._sceneGraphFlagsExportData = e[14][0], this._sceneGraphChildrenExportData = e[14][1]), i = !0, this._UpdateRendererStateGroup()
        }
        InitNoData() {
            this._x = 0, this._y = 0, this._zElevation = 0, this._w = 0, this._h = 0, this._a = 0, this._sinA = 0, this._cosA = 1, this._ox = 0, this._oy = 0, this._UpdateRendererStateGroup()
        }
        GetRuntime() {
            return this._runtime
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetInstance() {
            return this._inst
        }
        _GetParentOffsetAngle() {
            return this.GetTransformWithParentAngle() ? this.GetParent().GetAngle() - this._sceneGraphInfo.GetParentStartAngle() : 0
        }
        SetX(e) {
            if (e = +e, this.GetTransformWithParentX()) {
                const t = this._sceneGraphInfo,
                    n = e - this.GetX(),
                    s = -this._GetParentOffsetAngle();
                s === 0 ? this._x += n / t.GetParentScaleX() : (this._x += Math.cos(s) * n / t.GetParentScaleX(), this.GetTransformWithParentY() && (this._y += Math.sin(s) * n / t.GetParentScaleY()))
            } else this._x = e
        }
        OffsetX(e) {
            e = +e, this.GetTransformWithParentX() ? this.SetX(this.GetX() + e) : this._x += e
        }
        GetX() {
            if (this.GetTransformWithParentX()) {
                let e = this._x;
                const t = this._sceneGraphInfo,
                    s = this.GetParent(),
                    n = this._GetParentOffsetAngle();
                return n === 0 ? e *= t.GetParentScaleX() : (e = e * t.GetParentScaleX() * Math.cos(n), this.GetTransformWithParentY() && (e -= this._y * t.GetParentScaleY() * Math.sin(n))), s.GetX() + e
            }
            return this._x
        }
        SetY(e) {
            if (e = +e, this.GetTransformWithParentY()) {
                const t = this._sceneGraphInfo,
                    n = e - this.GetY(),
                    s = -this._GetParentOffsetAngle();
                s === 0 ? this._y += n / t.GetParentScaleY() : (this.GetTransformWithParentX() && (this._x -= Math.sin(s) * n / t.GetParentScaleX()), this._y += Math.cos(s) * n / t.GetParentScaleY())
            } else this._y = e
        }
        OffsetY(e) {
            e = +e, this.GetTransformWithParentY() ? this.SetY(this.GetY() + e) : this._y += e
        }
        GetY() {
            if (this.GetTransformWithParentY()) {
                let e = this._y;
                const t = this._sceneGraphInfo,
                    s = this.GetParent(),
                    n = this._GetParentOffsetAngle();
                return n === 0 ? e *= t.GetParentScaleY() : (e = e * t.GetParentScaleY() * Math.cos(n), this.GetTransformWithParentX() && (e += this._x * t.GetParentScaleX() * Math.sin(n))), s.GetY() + e
            }
            return this._y
        }
        SetXY(e, t) {
            if (e = +e, t = +t, this.GetTransformWithParentXOrY()) {
                const i = this.GetTransformWithParentX(),
                    a = this.GetTransformWithParentY(),
                    n = this._sceneGraphInfo,
                    s = e - this.GetX(),
                    o = t - this.GetY(),
                    r = -this._GetParentOffsetAngle();
                if (r === 0) i ? this._x += s / n.GetParentScaleX() : this._x = e, a ? this._y += o / n.GetParentScaleY() : this._y = t;
                else {
                    const l = Math.sin(r),
                        c = Math.cos(r);
                    i ? a ? this._x += (c * s - l * o) / n.GetParentScaleX() : this._x += c * s / n.GetParentScaleX() : this._x = e, a ? i ? this._y += (l * s + c * o) / n.GetParentScaleY() : this._y += c * o / n.GetParentScaleY() : this._y = t
                }
            } else this._x = e, this._y = t
        }
        OffsetXY(e, t) {
            e = +e, t = +t, this.GetTransformWithParentXOrY() ? this.SetXY(this.GetX() + e, this.GetY() + t) : (this._x += e, this._y += t)
        }
        EqualsXY(e, t) {
            return this.GetX() === e && this.GetY() === t
        }
        SetZElevation(e) {
            if (e = +e, this.GetTransformWithParentZElevation() && (e -= this.GetParent().GetZElevation()), this._zElevation === e) return;
            this._zElevation = e, this._UpdateZElevation();
            const t = this.GetLayer();
            this._zElevation !== 0 && t._SetAnyInstanceZElevated(), t.SetZIndicesChanged()
        }
        _UpdateZElevation() {
            if (this._UpdateRendererStateGroup(), this.HasChildren()) {
                const e = this.GetChildren();
                for (let t = 0, s = e.length; t < s; t++) {
                    const n = e[t];
                    n.GetTransformWithParentZElevation() && n._UpdateZElevation()
                }
            }
        }
        OffsetZElevation(e) {
            this.SetZElevation(this.GetZElevation() + e)
        }
        GetZElevation() {
            return this.GetTransformWithParentZElevation() ? this.GetParent().GetZElevation() + this._zElevation : this._zElevation
        }
        GetTotalZElevation() {
            return this.GetLayer().GetZElevation() + this.GetZElevation()
        }
        SetWidth(e) {
            e = +e, this.GetTransformWithParentWidth() ? this._w *= e / this.GetWidth() : this._w = e
        }
        OffsetWidth(e) {
            e = +e, this.GetTransformWithParentWidth() ? this.SetWidth(this.GetWidth() + e) : this._w += e
        }
        GetWidth() {
            return this.GetTransformWithParentWidth() ? this.GetParent().GetWidth() * this._w : this._w
        }
        SetHeight(e) {
            e = +e, this.GetTransformWithParentHeight() ? this._h *= e / this.GetHeight() : this._h = e
        }
        OffsetHeight(e) {
            e = +e, this.GetTransformWithParentHeight() ? this.SetHeight(this.GetHeight() + e) : this._h += e
        }
        GetHeight() {
            return this.GetTransformWithParentHeight() ? this.GetParent().GetHeight() * this._h : this._h
        }
        SetSize(e, t) {
            e = +e, t = +t, this.GetTransformWithParentWidth() ? this._w *= e / this.GetWidth() : this._w = e, this.GetTransformWithParentHeight() ? this._h *= t / this.GetHeight() : this._h = t
        }
        GetSceneGraphScale() {
            if (this.HasParent()) {
                const e = this._sceneGraphInfo;
                return Math.min(e.GetParentScaleX(), e.GetParentScaleY())
            }
            return 1
        }
        IsRotatable() {
            return (this._flags & E) !== 0
        }
        SetAngle(t) {
            if (t = +t, !this.IsRotatable()) return;
            if (this.GetTransformWithParentAngle() && (t -= this.GetParent().GetAngle()), t = e.clampAngle(t), this._a === t) return;
            this._a = t, this._MarkSinCosAngleChanged()
        }
        OffsetAngle(t) {
            if (t = +t, t === 0 || !this.IsRotatable()) return;
            this._a = e.clampAngle(this._a + t), this._MarkSinCosAngleChanged()
        }
        _MarkSinCosAngleChanged() {
            if (this._flags |= _, this.HasChildren()) {
                const e = this.GetChildren();
                for (let t = 0, n = e.length; t < n; t++) e[t]._MarkSinCosAngleChanged()
            }
        }
        GetAngle() {
            return this.GetTransformWithParentAngle() ? e.clampAngle(this.GetParent().GetAngle() + this._a) : this._a
        }
        _MaybeUpdateSinCosAngle() {
            const e = this._flags;
            if ((e & _) === 0) return;
            const t = this.GetAngle();
            this._sinA = Math.sin(t), this._cosA = Math.cos(t), this._flags = e & ~_
        }
        GetSinAngle() {
            return this._MaybeUpdateSinCosAngle(), this._sinA
        }
        GetCosAngle() {
            return this._MaybeUpdateSinCosAngle(), this._cosA
        }
        SetOriginX(e) {
            this._ox = +e
        }
        OffsetOriginX(e) {
            this._ox += +e
        }
        GetOriginX() {
            return this._ox
        }
        SetOriginY(e) {
            this._oy = +e
        }
        OffsetOriginY(e) {
            this._oy += +e
        }
        GetOriginY() {
            return this._oy
        }
        _SetColor(t) {
            if (this._color.equals(t)) return;
            this._color === s ? (this._color = e.New(e.Color, t), this._colorPremultiplied = e.New(e.Color, t), this._colorPremultiplied.premultiply()) : t.equalsRgba(1, 1, 1, 1) ? (this._color = s, this._colorPremultiplied = s) : (this._color.set(t), this._colorPremultiplied.set(t), this._colorPremultiplied.premultiply()), this._UpdateRendererStateGroup()
        }
        SetOpacity(n) {
            if (n = e.clamp(+n, 0, 1), this._color.a === n) return;
            t.copyRgb(this._color), t.a = n, this._SetColor(t)
        }
        OffsetOpacity(e) {
            this.SetOpacity(this.GetOpacity() + e)
        }
        GetOpacity() {
            return this._color.a
        }
        SetUnpremultipliedColor(e) {
            if (this._color.equalsIgnoringAlpha(e)) return;
            t.copyRgb(e), t.a = this._color.a, this._SetColor(t)
        }
        SetUnpremultipliedColorRGB(e, n, s) {
            t.setRgb(e, n, s), this.SetUnpremultipliedColor(t)
        }
        OffsetUnpremultipliedColorRGB(e, n, s) {
            if (e === 0 && n === 0 && s === 0) return;
            t.copyRgb(this._color), t.r += e, t.g += n, t.b += s, this.SetUnpremultipliedColor(t)
        }
        GetUnpremultipliedColor() {
            return this._color
        }
        GetPremultipliedColor() {
            return this._colorPremultiplied
        }
        GetDestroyWithParent() {
            return (this._flags & y) !== 0
        }
        SetDestroyWithParent(e) {
            this._SetFlag(y, e)
        }
        GetTransformWithParentX() {
            return (this._flags & d) !== 0
        }
        SetTransformWithParentX(e) {
            this._SetFlag(d, e)
        }
        GetTransformWithParentY() {
            return (this._flags & l) !== 0
        }
        GetTransformWithParentXOrY() {
            return (this._flags & (d | l)) !== 0
        }
        SetTransformWithParentY(e) {
            this._SetFlag(l, e)
        }
        GetTransformWithParentWidth() {
            return (this._flags & O) !== 0
        }
        SetTransformWithParentWidth(e) {
            this._SetFlag(O, e)
        }
        GetTransformWithParentHeight() {
            return (this._flags & x) !== 0
        }
        SetTransformWithParentHeight(e) {
            this._SetFlag(x, e)
        }
        GetTransformWithParentAngle() {
            return (this._flags & C) !== 0
        }
        SetTransformWithParentAngle(e) {
            this._SetFlag(C, e)
        }
        GetTransformWithParentZElevation() {
            return (this._flags & m) !== 0
        }
        SetTransformWithParentZElevation(e) {
            this._SetFlag(m, e)
        }
        _ClearAllSceneGraphFlags() {
            this._flags &= ~S
        }
        AddChild(e, t) {
            if (e === this) return;
            if (e.HasParent()) return;
            if (this._HasChildRecursive(e)) return;
            if (this._HasAnyParent(e)) return;
            const n = e.GetX(),
                s = e.GetY(),
                o = e.GetWidth(),
                i = e.GetHeight(),
                a = e.GetAngle(),
                r = e.GetZElevation();
            e._SetParent(this), e.SetTransformWithParentX(t.transformX), e.SetTransformWithParentY(t.transformY), e.SetTransformWithParentWidth(t.transformWidth), e.SetTransformWithParentHeight(t.transformHeight), e.SetTransformWithParentAngle(t.transformAngle), e.SetTransformWithParentZElevation(t.transformZElevation), e.SetDestroyWithParent(t.destroyWithParent), t.transformX && (e._x = n - this.GetX()), t.transformY && (e._y = s - this.GetY()), t.transformWidth && (e._w = o / this.GetWidth()), t.transformHeight && (e._h = i / this.GetHeight()), t.transformAngle && (e._a = a - this.GetAngle()), t.transformZElevation && (e._zElevation = r - this.GetZElevation()), this._AddChildToSceneGraphInfo(e), this.SetBboxChanged()
        }
        RemoveChild(e) {
            if (e.GetParent() !== this) return;
            const t = e.GetX(),
                n = e.GetY(),
                s = e.GetWidth(),
                o = e.GetHeight(),
                i = e.GetAngle(),
                a = e.GetZElevation();
            e._SetParent(null), e._ClearAllSceneGraphFlags(), e.SetXY(t, n), e.SetSize(s, o), e.SetAngle(i), e.SetZElevation(a), this._RemoveChildFromSceneGraphInfo(e), this.SetBboxChanged()
        }
        _ResetAllSceneGraphState() {
            for (const e of this.children()) this.RemoveChild(e);
            const e = this.GetParent();
            e && e.RemoveChild(this), this._ClearAllSceneGraphFlags()
        }
        HasParent() {
            return this.GetParent() !== null
        }
        GetParent() {
            const e = this._sceneGraphInfo;
            return e !== null ? e.GetParent() : null
        }
        GetTopParent() {
            let e = this;
            for (; e.HasParent();) e = e.GetParent();
            return e
        }* parents() {
            let e = this.GetParent();
            for (; e;) yield e, e = e.GetParent()
        }
        HasChild(e) {
            return this.GetChildren().includes(e)
        }
        HasChildren() {
            const e = this._sceneGraphInfo;
            return e !== null && e.HasChildren()
        }
        GetChildren() {
            const e = this._sceneGraphInfo;
            return e !== null ? e.GetChildren() : F
        }
        children() {
            return this.GetChildren()
        }* allChildren() {
            for (const e of this.children()) yield e, yield* e.allChildren()
        }
        GetChildCount() {
            return this.GetChildren().length
        }
        GetChildAt(e) {
            const t = this.GetChildren();
            return e = Math.floor(+e), e < 0 || e >= t.length ? null : t[e]
        }
        _CreateSceneGraphInfo(t) {
            this._sceneGraphInfo || (this._sceneGraphInfo = e.New(e.SceneGraphInfo, this)), t && this._sceneGraphInfo.SetParent(t)
        }
        _GetSceneGraphInfo() {
            return this._sceneGraphInfo
        }
        _ReleaseSceneGraphInfo() {
            if (!this._sceneGraphInfo) return;
            this._sceneGraphInfo.Release(), this._sceneGraphInfo = null
        }
        _SetParent(e) {
            e ? (e._CreateSceneGraphInfo(null), this._CreateSceneGraphInfo(e)) : (this._sceneGraphInfo && this._sceneGraphInfo.SetParent(null), this.HasChildren() || this._ReleaseSceneGraphInfo())
        }
        _HasAnyParent(e) {
            if (!this.HasParent()) return !1;
            const t = this.GetParent();
            return t === e || t._HasAnyParent(e)
        }
        _HasChildRecursive(e) {
            if (this.HasChild(e)) return !0;
            for (const t of this.GetChildren())
                if (t._HasChildRecursive(e)) return !0;
            return !1
        }
        _AddChildToSceneGraphInfo(e) {
            this._sceneGraphInfo.GetChildren().push(e)
        }
        _RemoveChildFromSceneGraphInfo(e) {
            const t = this._sceneGraphInfo.GetChildren(),
                n = t.indexOf(e);
            n !== -1 && t.splice(n, 1), t.length === 0 && !this.HasParent() && this._ReleaseSceneGraphInfo(), e.HasChildren() || e._ReleaseSceneGraphInfo()
        }
        GetSceneGraphChildrenExportData() {
            return this._sceneGraphChildrenExportData
        }
        _UpdateRendererStateGroup() {
            if (!i) return;
            const e = this._runtime.GetRenderer();
            this._stateGroup && e.ReleaseStateGroup(this._stateGroup), this._stateGroup = e.AcquireStateGroup(e.GetTextureFillShaderProgram() || "<default>", this.GetBlendMode(), this._colorPremultiplied, this.GetZElevation())
        }
        GetRendererStateGroup() {
            return this._stateGroup
        }
        HasDefaultColor() {
            return this._color === s
        }
        SetBlendMode(e) {
            if (e = e | 0, e < 0 || e > 31) throw new RangeError("invalid blend mode");
            if (this.GetBlendMode() === e) return;
            this._flags = this._flags & ~A | e << w, this._UpdateRendererStateGroup()
        }
        GetBlendMode() {
            return (this._flags & A) >> w
        }
        _SetLayer(e) {
            this._layer = e, this.GetZElevation() !== 0 && this._layer._SetAnyInstanceZElevated()
        }
        GetLayer() {
            return this._layer
        }
        GetLayout() {
            return this.GetLayer().GetLayout()
        }
        _SetZIndex(e) {
            this._zIndex = e | 0
        }
        GetZIndex() {
            return this._layer._UpdateZIndices(), this._zIndex
        }
        _GetLastCachedZIndex() {
            return this._zIndex
        }
        _SetFlag(e, t) {
            t ? this._flags |= e : this._flags &= ~e
        }
        IsVisible() {
            return (this._flags & b) !== 0
        }
        SetVisible(e) {
            this._SetFlag(b, e)
        }
        IsCollisionEnabled() {
            return (this._flags & p) !== 0
        }
        SetCollisionEnabled(e) {
            if (e = !!e, this.IsCollisionEnabled() === e) return;
            this._SetFlag(p, e), e ? this.SetBboxChanged() : this._RemoveFromCollisionCells()
        }
        SetSolidCollisionFilter(e, t) {
            if (this._SetFlag(v, e), this._solidFilterTags && this._solidFilterTags.clear(), !t.trim()) {
                this._solidFilterTags = null;
                return
            }
            this._solidFilterTags || (this._solidFilterTags = new Set);
            for (const e of t.split(" ")) e && this._solidFilterTags.add(e.toLowerCase())
        }
        IsSolidCollisionAllowed(e) {
            const t = (this._flags & v) !== 0,
                n = this._solidFilterTags;
            if (!e || !n) return !t;
            for (const s of n)
                if (e.has(s)) return t;
            return !t
        }
        SetBboxChanged() {
            if (this._flags |= o | a | h, this._objectClass._SetAnyCollisionCellChanged(!0), this._runtime.UpdateRender(), this._layer.UsesRenderCells() && (this.CalculateBbox(this._boundingBox, this._boundingQuad, !0), this._flags &= ~o, this._UpdateRenderCell()), (this._flags & f) !== 0 && this._inst.Dispatcher().dispatchEvent(M), this._sceneGraphInfo !== null) {
                const e = this._sceneGraphInfo.GetChildren();
                for (let t = 0, n = e.length; t < n; ++t) e[t].SetBboxChanged()
            }
        }
        CalculateBbox(e, t, n) {
            const s = this.GetX(),
                o = this.GetY(),
                i = this.GetWidth(),
                a = this.GetHeight(),
                r = this.GetAngle();
            e.setWH(s - this._ox * i, o - this._oy * a, i, a), n && this.HasMesh() && this._ExpandBboxForMesh(e), r === 0 ? t.setFromRect(e) : (e.offset(-s, -o), t.setFromRotatedRectPrecalc(e, this.GetSinAngle(), this.GetCosAngle()), t.offset(s, o), t.getBoundingBox(e)), e.normalize()
        }
        _UpdateBbox() {
            const e = this._flags;
            (e & o) !== 0 && (this.CalculateBbox(this._boundingBox, this._boundingQuad, !0), this._flags = e & ~o)
        }
        GetBoundingBox() {
            return this._UpdateBbox(), this._boundingBox
        }
        GetBoundingQuad() {
            return this._UpdateBbox(), this._boundingQuad
        }
        PixelRoundQuad(e) {
            const t = this.GetX(),
                n = this.GetY(),
                s = Math.round(t) - t,
                o = Math.round(n) - n;
            return s === 0 && o === 0 ? e : (g.copy(e), g.offset(s, o), g)
        }
        OverwriteBoundingBox(e) {
            this._boundingBox.copy(e), this._boundingQuad.setFromRect(this._boundingBox), this._flags &= ~o, this._UpdateCollisionCell(), this._UpdateRenderCell()
        }
        SetBboxChangeEventEnabled(e) {
            this._SetFlag(f, e)
        }
        IsBboxChangeEventEnabled() {
            return (this._flags & f) !== 0
        }
        IsInViewport(e) {
            return this.GetZElevation() === 0 ? e.intersectsRect(this.GetBoundingBox()) : this._IsInViewport_ZElevated()
        }
        _IsInViewport_ZElevated() {
            const e = this.GetLayer(),
                t = this.GetTotalZElevation();
            return !(t >= e.GetCameraZ()) && (e.GetViewportForZ(t, n), n.intersectsRect(this.GetBoundingBox()))
        }
        SetSourceCollisionPoly(e) {
            this._sourceCollisionPoly = e, this._DiscardTransformedCollisionPoly(), this.HasMesh() && (this._meshInfo.meshPoly = null)
        }
        GetSourceCollisionPoly() {
            return this._sourceCollisionPoly
        }
        HasOwnCollisionPoly() {
            return this._sourceCollisionPoly !== null || this.HasMesh()
        }
        GetTransformedCollisionPoly() {
            return this._GetCustomTransformedCollisionPolyPrecalc(this.GetWidth(), this.GetHeight(), this.GetAngle(), this.GetSinAngle(), this.GetCosAngle())
        }
        GetCustomTransformedCollisionPoly(e, t, n) {
            let s = 0,
                o = 1;
            return n !== 0 && (s = Math.sin(n), o = Math.cos(n)), this._GetCustomTransformedCollisionPolyPrecalc(e, t, n, s, o)
        }
        _GetCustomTransformedCollisionPolyPrecalc(t, n, s, o, i) {
            let a = this._transformedPolyInfo;
            a === null && (a = {
                poly: e.New(e.CollisionPoly),
                width: NaN,
                height: NaN,
                angle: NaN
            }, this._transformedPolyInfo = a);
            const r = a.poly;
            if (a.width === t && a.height === n && a.angle === s) return r;
            const c = this._sourceCollisionPoly;
            if (this.HasMesh()) {
                const s = this.GetOriginX(),
                    a = this.GetOriginY(),
                    l = this.GetSourceMesh();
                let e = this._meshInfo.meshPoly;
                e || (c ? (u.copy(c), u.offset(s, a)) : u.setDefaultPoints(), e = l.InsertPolyMeshVertices(u), this._meshInfo.meshPoly = e), l.TransformCollisionPoly(e, r), r.offset(-s, -a), r.transformPrecalc(t, n, o, i)
            } else c ? (r.copy(c), r.transformPrecalc(t, n, o, i)) : r.setFromQuad(this.GetBoundingQuad(), -this.GetX(), -this.GetY());
            return a.width = t, a.height = n, a.angle = s, r
        }
        _DiscardTransformedCollisionPoly() {
            this.SetPhysicsBodyChanged(!0);
            const e = this._transformedPolyInfo;
            if (e === null) return;
            e.width = NaN
        }
        CreateMesh(t, n) {
            if (t = Math.floor(t), n = Math.floor(n), !this.GetInstance().GetPlugin().SupportsMesh()) throw new Error("object does not support mesh");
            this.ReleaseMesh(), this._meshInfo = {
                sourceMesh: e.New(e.Gfx.Mesh, t, n),
                transformedMesh: e.New(e.Gfx.Mesh, t, n),
                meshPoly: null
            }
        }
        HasMesh() {
            return this._meshInfo !== null
        }
        GetSourceMesh() {
            if (!this.HasMesh()) throw new Error("no mesh");
            return this._meshInfo.sourceMesh
        }
        GetTransformedMesh() {
            if (!this.HasMesh()) throw new Error("no mesh");
            return this._meshInfo.transformedMesh
        }
        SetMeshChanged(e) {
            this._SetFlag(h, e)
        }
        IsMeshChanged() {
            return (this._flags & h) !== 0
        }
        SetPhysicsBodyChanged(e) {
            this._SetFlag(j, e)
        }
        IsPhysicsBodyChanged() {
            return (this._flags & j) !== 0
        }
        _ExpandBboxForMesh(e) {
            const t = this._meshInfo.sourceMesh,
                o = Math.min(t.GetMinX(), 0),
                i = Math.min(t.GetMinY(), 0),
                a = Math.max(t.GetMaxX(), 1),
                r = Math.max(t.GetMaxY(), 1),
                n = e.width(),
                s = e.height();
            e.offsetLeft(o * n), e.offsetTop(i * s), e.offsetRight((a - 1) * n), e.offsetBottom((r - 1) * s)
        }
        ReleaseMesh() {
            if (!this._meshInfo) return;
            this._meshInfo.sourceMesh.Release(), this._meshInfo.transformedMesh.Release(), this._meshInfo = null, this._DiscardTransformedCollisionPoly()
        }
        SetMeshPoint(t, n, s) {
            t = Math.floor(t), n = Math.floor(n);
            const u = s.mode || "absolute";
            if (!T.has(u)) throw new Error("invalid mode");
            const i = u === "relative";
            let l = s.x,
                d = s.y,
                a = typeof s.u == "number" ? s.u : i ? 0 : -1,
                r = typeof s.v == "number" ? s.v : i ? 0 : -1;
            if (!this.HasMesh()) return !1;
            const c = this.GetSourceMesh(),
                o = c.GetMeshPointAt(t, n);
            return o !== null && (i && (l += t / (c.GetHSize() - 1), d += n / (c.GetVSize() - 1)), a === -1 && !i ? a = o.GetU() : (i && (a += t / (c.GetHSize() - 1)), a = e.clamp(a, 0, 1)), r === -1 && !i ? r = o.GetV() : (i && (r += n / (c.GetVSize() - 1)), r = e.clamp(r, 0, 1)), !(o.GetX() === l && o.GetY() === d && o.GetU() === a && o.GetV() === r) && (o.SetX(l), o.SetY(d), o.SetU(a), o.SetV(r), this._DiscardTransformedCollisionPoly(), !0))
        }
        HasTilemap() {
            return this._inst.HasTilemap()
        }
        ContainsPoint(e, t) {
            return !!this.GetBoundingBox().containsPoint(e, t) && !!this.GetBoundingQuad().containsPoint(e, t) && (this.HasTilemap() ? this._inst.GetSdkInstance().TestPointOverlapTile(e, t) : !this.HasOwnCollisionPoly() || this.GetTransformedCollisionPoly().containsPoint(e - this.GetX(), t - this.GetY()))
        }
        _IsCollisionCellChanged() {
            return (this._flags & a) !== 0
        }
        _UpdateCollisionCell() {
            if (!this._IsCollisionCellChanged() || !this.IsCollisionEnabled()) return;
            const s = this.GetBoundingBox(),
                t = this._objectClass._GetCollisionCellGrid(),
                o = this._collisionCells;
            if (n.set(t.XToCell(s.getLeft()), t.YToCell(s.getTop()), t.XToCell(s.getRight()), t.YToCell(s.getBottom())), o.equals(n)) return;
            const i = this._inst;
            o === c ? (t.Update(i, null, n), this._collisionCells = e.New(e.Rect, n)) : (t.Update(i, o, n), o.copy(n)), this._flags &= ~a
        }
        _RemoveFromCollisionCells() {
            const e = this._collisionCells;
            if (e === c) return;
            this._objectClass._GetCollisionCellGrid().Update(this._inst, e, null), this._collisionCells = c
        }
        _UpdateRenderCell() {
            const i = this.GetLayer();
            if (!i.UsesRenderCells()) return;
            const t = i.GetRenderGrid(),
                s = this.GetBoundingBox(),
                o = this._renderCells;
            if (n.set(t.XToCell(s.getLeft()), t.YToCell(s.getTop()), t.XToCell(s.getRight()), t.YToCell(s.getBottom())), o.equals(n)) return;
            const a = this._inst;
            o === r ? (t.Update(a, null, n), this._renderCells = e.New(e.Rect, n)) : (t.Update(a, o, n), o.copy(n)), i.SetRenderListStale()
        }
        _RemoveFromRenderCells() {
            const e = this._renderCells;
            if (e === r) return;
            this.GetLayer().GetRenderGrid().Update(this._inst, e, null), this._renderCells = r
        }
        GetRenderCellRange() {
            return this._renderCells
        }
        ZOrderMoveToTop() {
            const e = this._inst,
                t = this._layer,
                n = t._GetInstances();
            if (n.length && n[n.length - 1] === e) return;
            t._RemoveInstance(e, !1), t._AddInstance(e, !1), this._runtime.UpdateRender()
        }
        ZOrderMoveToBottom() {
            const e = this._inst,
                t = this._layer,
                n = t._GetInstances();
            if (n.length && n[0] === e) return;
            t._RemoveInstance(e, !1), t._PrependInstance(e, !1), this._runtime.UpdateRender()
        }
        ZOrderMoveToLayer(e) {
            const n = this._inst,
                t = this._layer;
            if (t.GetLayout() !== e.GetLayout()) throw new Error("layer from different layout");
            if (e === t) return;
            t._RemoveInstance(n, !0), this._SetLayer(e), e._AddInstance(n, !0), this._runtime.UpdateRender()
        }
        ZOrderMoveAdjacentToInstance(e, t) {
            const n = this._inst,
                o = this._layer;
            if (e.GetUID() === n.GetUID()) return;
            const i = e.GetWorldInfo();
            if (!i) throw new Error("expected world instance");
            const s = i.GetLayer();
            let a = !1;
            o.GetIndex() !== s.GetIndex() && (o._RemoveInstance(n, !0), this._SetLayer(s), s._AddInstance(n, !0), a = !0);
            const r = s.MoveInstanceAdjacent(n, e, !!t);
            (a || r) && this._runtime.UpdateRender()
        }
        GetInstanceEffectList() {
            return this._instanceEffectList
        }
        _SetHasAnyActiveEffect(e) {
            this._SetFlag(k, e)
        }
        HasAnyActiveEffect() {
            return (this._flags & k) !== 0
        }
        _SaveToJson() {
            const e = {
                x: this.GetX(),
                y: this.GetY(),
                w: this.GetWidth(),
                h: this.GetHeight(),
                l: this.GetLayer().GetSID(),
                zi: this.GetZIndex()
            };
            this.GetZElevation() !== 0 && (e.ze = this.GetZElevation()), this.GetAngle() !== 0 && (e.a = this.GetAngle()), this.HasDefaultColor() || (e.c = this._color.toJSON()), this.GetOriginX() !== .5 && (e.oX = this.GetOriginX()), this.GetOriginY() !== .5 && (e.oY = this.GetOriginY()), this.GetBlendMode() !== 0 && (e.bm = this.GetBlendMode()), this.IsVisible() || (e.v = this.IsVisible()), this.IsCollisionEnabled() || (e.ce = this.IsCollisionEnabled()), this.IsBboxChangeEventEnabled() && (e.be = this.IsBboxChangeEventEnabled()), this._instanceEffectList && (e.fx = this._instanceEffectList._SaveToJson());
            const t = (this._flags & v) !== 0;
            return t && (e.sfi = t), this._solidFilterTags && (e.sft = [...this._solidFilterTags].join(" ")), this._sceneGraphInfo && (e.sgi = this._sceneGraphInfo._SaveToJson()), e
        }
        _LoadFromJson(e) {
            if (i = !1, this._ResetAllSceneGraphState(), this.SetX(e.x), this.SetY(e.y), this.SetWidth(e.w), this.SetHeight(e.h), this._SetZIndex(e.zi), this.SetZElevation(e.hasOwnProperty("ze") ? e.ze : 0), this.SetAngle(e.hasOwnProperty("a") ? e.a : 0), e.hasOwnProperty("c") ? t.setFromJSON(e.c) : e.hasOwnProperty("o") ? (t.copyRgb(this._color), t.a = e.o) : t.setRgba(1, 1, 1, 1), this._SetColor(t), this.SetOriginX(e.hasOwnProperty("oX") ? e.oX : .5), this.SetOriginY(e.hasOwnProperty("oY") ? e.oY : .5), this.SetBlendMode(e.hasOwnProperty("bm") ? e.bm : 0), this.SetVisible(!e.hasOwnProperty("v") || e.v), this.SetCollisionEnabled(!e.hasOwnProperty("ce") || e.ce), this.SetBboxChangeEventEnabled(!!e.hasOwnProperty("be") && e.be), this.SetSolidCollisionFilter(!!e.hasOwnProperty("sfi") && e.sfi, e.hasOwnProperty("sft") ? e.sft : ""), this._instanceEffectList && e.hasOwnProperty("fx") && this._instanceEffectList._LoadFromJson(e.fx), e.hasOwnProperty("sgi")) {
                this._CreateSceneGraphInfo(null);
                const t = this._sceneGraphInfo,
                    n = e.sgi;
                t._LoadFromJson(n);
                const s = this.GetRuntime().Dispatcher(),
                    o = () => {
                        s.removeEventListener("afterload", o), t._OnAfterLoad(n)
                    };
                s.addEventListener("afterload", o)
            }
            this.SetBboxChanged(), i = !0, this._UpdateRendererStateGroup()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.BehaviorType = class BehaviorType extends e.DefendedBase {
        constructor(t, n) {
            super();
            const o = t.GetRuntime(),
                i = o.GetPluginManager(),
                s = o.GetObjectReference(n[1]);
            i.HasBehaviorByConstructorFunction(s) || i.CreateBehavior(n), this._runtime = o, this._objectClass = t, this._behavior = i.GetBehaviorByConstructorFunction(s), this._sdkType = null, this._instSdkCtor = s.Instance, this._sid = n[2], this._name = n[0], this._jsPropName = this._runtime.GetJsPropName(n[3]), this._sdkType = e.New(s.Type, this), this.OnCreate()
        }
        static Create(t, n) {
            return e.New(e.BehaviorType, t, n)
        }
        Release() {
            this._runtime = null, this._behavior = null, this._sdkType.Release(), this._sdkType = null, this._instSdkCtor = null
        }
        GetSdkType() {
            return this._sdkType
        }
        OnCreate() {
            this._sdkType.OnCreate()
        }
        GetRuntime() {
            return this._runtime
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetBehavior() {
            return this._behavior
        }
        GetInstanceSdkCtor() {
            return this._instSdkCtor
        }
        GetName() {
            return this._name
        }
        GetSID() {
            return this._sid
        }
        GetJsPropName() {
            return this._jsPropName
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = self.IBehaviorInstance;
    e.BehaviorInstance = class BehaviorInstance extends e.DefendedBase {
        constructor(e) {
            super(), this._runtime = e.runtime, this._behaviorType = e.behaviorType, this._behavior = this._behaviorType.GetBehavior(), this._inst = e.instance, this._index = e.index, this._sdkInst = null, this._iScriptInterface = null, this._behavior._AddInstance(this._inst)
        }
        Release() {
            this._iScriptInterface && (this._iScriptInterface._Release(), this._iScriptInterface = null), this._behavior._RemoveInstance(this._inst), this._sdkInst.Release(), this._sdkInst = null, this._iScriptInterface = null, this._runtime = null, this._behaviorType = null, this._behavior = null, this._inst = null
        }
        _CreateSdkInstance(t) {
            if (this._sdkInst) throw new Error("already got sdk instance");
            this._sdkInst = e.New(this._behaviorType.GetInstanceSdkCtor(), this, t), this._InitScriptInterface()
        }
        GetSdkInstance() {
            return this._sdkInst
        }
        GetObjectInstance() {
            return this._inst
        }
        GetRuntime() {
            return this._runtime
        }
        GetBehaviorType() {
            return this._behaviorType
        }
        GetBehavior() {
            return this._behavior
        }
        _GetIndex() {
            return this._index
        }
        PostCreate() {
            this._sdkInst.PostCreate()
        }
        OnSpriteFrameChanged(e, t) {
            this._sdkInst.OnSpriteFrameChanged(e, t)
        }
        _GetDebuggerProperties() {
            return this._sdkInst.GetDebuggerProperties()
        }
        SaveToJson() {
            return this._sdkInst.SaveToJson()
        }
        LoadFromJson(e) {
            return this._sdkInst.LoadFromJson(e)
        }
        static SortByTickSequence(e, t) {
            const n = e.GetObjectInstance(),
                s = t.GetObjectInstance(),
                o = n.GetObjectClass().GetIndex(),
                i = s.GetObjectClass().GetIndex();
            if (o !== i) return o - i;
            const a = n.GetPUID(),
                r = s.GetPUID();
            return a !== r ? a - r : e.GetBehaviorInstance()._GetIndex() - t.GetBehaviorInstance()._GetIndex()
        }
        _InitScriptInterface() {
            const e = t,
                n = this._sdkInst.GetScriptInterfaceClass(),
                s = n || e;
            if (t._Init(this), this._iScriptInterface = new s, t._Init(null), n && !(this._iScriptInterface instanceof e)) throw new TypeError(`script interface class '${n.name}' does not extend the right base class '${e.name}'`)
        }
        GetScriptInterface() {
            return this._iScriptInterface
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.EffectList = class EffectList extends e.DefendedBase {
        constructor(t, n) {
            super(), this._owner = t, this._allEffectTypes = [], this._activeEffectTypes = [], this._effectTypesByName = new Map, this._effectParams = [], this._preservesOpaqueness = !0;
            for (const t of n) {
                const s = e.New(e.EffectType, this, t, this._allEffectTypes.length);
                this._allEffectTypes.push(s), this._effectTypesByName.set(s.GetName().toLowerCase(), s), t.length >= 3 && this._effectParams.push(this._LoadSingleEffectParameters(t[2]))
            }
            this.GetRuntime()._AddEffectList(this)
        }
        Release() {
            e.clearArray(this._allEffectTypes), e.clearArray(this._activeEffectTypes), this._effectTypesByName.clear(), e.clearArray(this._effectParams), this._owner = null
        }
        PrependEffectTypes(e) {
            if (!e.length) return;
            this._allEffectTypes = e.concat(this._allEffectTypes);
            for (const t of e) this._effectTypesByName.set(t.GetName().toLowerCase(), t);
            for (let e = 0, t = this._allEffectTypes.length; e < t; ++e) this._allEffectTypes[e]._SetIndex(e)
        }
        _LoadSingleEffectParameters(t) {
            const n = t.slice(0);
            for (let t = 0, o = n.length; t < o; ++t) {
                const s = n[t];
                if (Array.isArray(s)) {
                    const o = e.New(e.Color);
                    o.setFromJSON(s), n[t] = o
                }
            }
            return n
        }
        GetOwner() {
            return this._owner
        }
        GetRuntime() {
            return this._owner.GetRuntime()
        }
        UpdateActiveEffects() {
            e.clearArray(this._activeEffectTypes);
            let t = !0;
            for (const e of this._allEffectTypes) e.IsActive() && (this._activeEffectTypes.push(e), e.GetShaderProgram().PreservesOpaqueness() || (t = !1));
            this._preservesOpaqueness = t
        }
        GetAllEffectTypes() {
            return this._allEffectTypes
        }
        HasAnyEffectType() {
            return this._allEffectTypes.length > 0
        }
        GetEffectTypeByName(e) {
            return this._effectTypesByName.get(e.toLowerCase()) || null
        }
        GetEffectTypeByIndex(e) {
            if (e = Math.floor(+e), e < 0 || e >= this._allEffectTypes.length) throw new RangeError("invalid effect type index");
            return this._allEffectTypes[e]
        }
        IsEffectIndexActive(e) {
            return this.GetEffectTypeByIndex(e).IsActive()
        }
        SetEffectIndexActive(e, t) {
            this.GetEffectTypeByIndex(e).SetActive(t)
        }
        GetActiveEffectTypes() {
            return this._activeEffectTypes
        }
        HasAnyActiveEffect() {
            return this._activeEffectTypes.length > 0
        }
        PreservesOpaqueness() {
            return this._preservesOpaqueness
        }
        GetEffectParametersForIndex(e) {
            return this._effectParams[e]
        }
        static SaveFxParamToJson(t) {
            return t && t instanceof e.Color ? {
                t: "color",
                v: t.toJSON()
            } : t
        }
        static LoadFxParamFromJson(t) {
            if (typeof t == "object") {
                const n = t.t;
                if (n === "color") {
                    const n = e.New(e.Color);
                    return n.setFromJSON(t.v), n
                }
                throw new Error("invalid effect parameter type")
            } else return t
        }
        static SaveFxParamsToJson(t) {
            return t.map(e.EffectList.SaveFxParamToJson)
        }
        static LoadFxParamsFromJson(t) {
            return t.map(e.EffectList.LoadFxParamFromJson)
        }
        SaveToJson() {
            return this._allEffectTypes.map(t => ({
                name: t.GetName(),
                active: t.IsActive(),
                params: e.EffectList.SaveFxParamsToJson(this._effectParams[t.GetIndex()])
            }))
        }
        LoadFromJson(t) {
            for (const n of t) {
                const s = this.GetEffectTypeByName(n.name);
                if (!s) continue;
                s.SetActive(n.active), this._effectParams[s.GetIndex()] = e.EffectList.LoadFxParamsFromJson(n.params)
            }
            this.UpdateActiveEffects()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.EffectType = class EffectType extends e.DefendedBase {
        constructor(e, t, n) {
            super(), this._effectList = e, this._id = t[0], this._name = t[1], this._index = n, this._shaderProgram = null, this._isActive = !0
        }
        Release() {
            this._effectList = null, this._shaderProgram = null
        }
        Clone(t) {
            const n = e.New(e.EffectType, t, [this._id, this._name], -1);
            return n._shaderProgram = this._shaderProgram, n._isActive = this._isActive, n
        }
        _InitRenderer(e) {
            const t = e.GetShaderProgramByName(this._id);
            if (!t) throw new Error("failed to find shader program '" + this._id + "'");
            this._shaderProgram = t
        }
        GetEffectList() {
            return this._effectList
        }
        GetName() {
            return this._name
        }
        _SetIndex(e) {
            this._index = e
        }
        GetIndex() {
            return this._index
        }
        GetOwner() {
            return this._effectList.GetOwner()
        }
        GetRuntime() {
            return this._effectList.GetRuntime()
        }
        SetActive(e) {
            this._isActive = !!e
        }
        IsActive() {
            return this._isActive
        }
        GetShaderProgram() {
            return this._shaderProgram
        }
        GetDefaultParameterValues() {
            const t = [];
            for (let n = 0, o = this._shaderProgram.GetParameterCount(); n < o; ++n) {
                const s = this._shaderProgram.GetParameterType(n);
                if (s === "float" || s === "percent") t.push(0);
                else if (s === "color") t.push(e.New(e.Color, 1, 1, 1, 1));
                else throw new TypeError("unknown effect parameter type")
            }
            return t
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.InstanceEffectList = class InstanceEffectList extends e.DefendedBase {
        constructor(e, t) {
            super(), this._inst = e, this._wi = t, this._effectList = e.GetObjectClass().GetEffectList(), this._activeEffectFlags = [], this._activeEffectTypes = [], this._preservesOpaqueness = !0, this._effectParams = [];
            for (const e of this._effectList.GetAllEffectTypes()) this._activeEffectFlags.push(!0);
            this.UpdateActiveEffects()
        }
        Release() {
            e.clearArray(this._activeEffectFlags), e.clearArray(this._activeEffectTypes), e.clearArray(this._effectParams), this._inst = null, this._effectList = null
        }
        _LoadEffectParameters(e) {
            for (const t of e) this._effectParams.push(this._LoadSingleEffectParameters(t))
        }
        _LoadSingleEffectParameters(t) {
            const n = t.slice(0);
            for (let t = 0, o = n.length; t < o; ++t) {
                const s = n[t];
                if (Array.isArray(s)) {
                    const o = e.New(e.Color);
                    o.setFromJSON(s), n[t] = o
                }
            }
            return n
        }
        LoadDefaultEffectParameters() {
            for (const e of this._effectList.GetAllEffectTypes()) this._effectParams.push(e.GetDefaultParameterValues())
        }
        GetOwner() {
            return this._owner
        }
        GetEffectList() {
            return this._effectList
        }
        GetRuntime() {
            return this._inst.GetRuntime()
        }
        UpdateActiveEffects() {
            e.clearArray(this._activeEffectTypes);
            const t = this._effectList.GetAllEffectTypes(),
                n = this._activeEffectTypes,
                o = this._activeEffectFlags;
            let s = !0;
            for (let e = 0, i = t.length; e < i; ++e)
                if (o[e]) {
                    const o = t[e];
                    n.push(o), o.GetShaderProgram().PreservesOpaqueness() || (s = !1)
                } this._preservesOpaqueness = s, this._wi._SetHasAnyActiveEffect(!!n.length)
        }
        GetActiveEffectTypes() {
            return this._activeEffectTypes
        }
        GetEffectParametersForIndex(e) {
            return this._effectParams[e]
        }
        PreservesOpaqueness() {
            return this._preservesOpaqueness
        }
        HasAnyActiveBackgroundBlendingEffect() {
            return this._activeEffectTypes.some(e => e.GetShaderProgram().UsesDest())
        }
        IsEffectIndexActive(e) {
            return this._activeEffectFlags[e]
        }
        SetEffectIndexActive(e, t) {
            this._activeEffectFlags[e] = !!t
        }
        GetAllEffectTypes() {
            return this._effectList.GetAllEffectTypes()
        }
        _SaveToJson() {
            return this._effectList.GetAllEffectTypes().map(t => ({
                name: t.GetName(),
                active: this._activeEffectFlags[t.GetIndex()],
                params: e.EffectList.SaveFxParamsToJson(this._effectParams[t.GetIndex()])
            }))
        }
        _LoadFromJson(t) {
            for (const n of t) {
                const s = this._effectList.GetEffectTypeByName(n.name);
                if (!s) continue;
                this._activeEffectFlags[s.GetIndex()] = n.active, this._effectParams[s.GetIndex()] = e.EffectList.LoadFxParamsFromJson(n.params)
            }
            this.UpdateActiveEffects()
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = [],
        o = [],
        c = [],
        n = e.New(e.CollisionPoly),
        i = e.New(e.CollisionPoly),
        s = e.New(e.Quad),
        a = e.New(e.Rect),
        r = e.New(e.Rect);
    e.CollisionEngine = class CollisionEngine extends e.DefendedBase {
        constructor(e) {
            super(), this._runtime = e, this._registeredCollisions = [], this._collisionCheckCount = 0, this._collisionCheckSec = 0, this._polyCheckCount = 0, this._polyCheckSec = 0
        }
        Release() {
            this._runtime = null
        }
        _Update1sStats() {
            this._collisionCheckSec = this._collisionCheckCount, this._collisionCheckCount = 0, this._polyCheckSec = this._polyCheckCount, this._polyCheckCount = 0
        }
        Get1secCollisionChecks() {
            return this._collisionCheckSec
        }
        Get1secPolyChecks() {
            return this._polyCheckSec
        }
        RegisterCollision(e, t) {
            const n = e.GetWorldInfo(),
                s = t.GetWorldInfo();
            if (!n || !s) return;
            if (!n.IsCollisionEnabled() || !s.IsCollisionEnabled()) return;
            this._registeredCollisions.push([e, t])
        }
        AddRegisteredCollisionCandidates(e, t, n) {
            for (const [o, i] of this._registeredCollisions) {
                let s = null;
                if (e === o) s = i;
                else if (e === i) s = o;
                else continue;
                if (!s.BelongsToObjectClass(t)) continue;
                n.includes(s) || n.push(s)
            }
        }
        CheckRegisteredCollision(e, t) {
            if (!this._registeredCollisions.length) return !1;
            for (const [n, s] of this._registeredCollisions)
                if (e === n && t === s || e === s && t === n) return !0;
            return !1
        }
        ClearRegisteredCollisions() {
            e.clearArray(this._registeredCollisions)
        }
        TestOverlap(e, t) {
            if (!e || !t || e === t) return !1;
            const n = e.GetWorldInfo(),
                s = t.GetWorldInfo();
            if (!n.IsCollisionEnabled() || !s.IsCollisionEnabled()) return !1;
            this._collisionCheckCount++;
            const o = n.GetLayer(),
                i = s.GetLayer(),
                a = o.IsTransformCompatibleWith(i);
            return a ? this._TestOverlap_SameLayers(n, s) : this._TestOverlap_DifferentLayers(n, s)
        }
        _TestOverlap_SameLayers(e, t) {
            if (!e.GetBoundingBox().intersectsRect(t.GetBoundingBox())) return !1;
            if (this._polyCheckCount++, !e.GetBoundingQuad().intersectsQuad(t.GetBoundingQuad())) return !1;
            if (e.HasTilemap() && t.HasTilemap()) return !1;
            if (e.HasTilemap()) return this.TestTilemapOverlap(e, t);
            if (t.HasTilemap()) return this.TestTilemapOverlap(t, e);
            if (!e.HasOwnCollisionPoly() && !t.HasOwnCollisionPoly()) return !0;
            const n = e.GetTransformedCollisionPoly(),
                s = t.GetTransformedCollisionPoly();
            return n.intersectsPoly(s, t.GetX() - e.GetX(), t.GetY() - e.GetY())
        }
        _TestOverlap_DifferentLayers(e, t) {
            const a = e.GetLayer(),
                r = t.GetLayer();
            n.copy(e.GetTransformedCollisionPoly()), i.copy(t.GetTransformedCollisionPoly());
            const s = n.pointsArr();
            for (let t = 0, o = s.length; t < o; t += 2) {
                const n = t + 1,
                    i = s[t],
                    r = s[n],
                    [c, l] = a.LayerToCanvasCss(i + e.GetX(), r + e.GetY());
                s[t] = c, s[n] = l
            }
            const o = i.pointsArr();
            for (let e = 0, s = o.length; e < s; e += 2) {
                const n = e + 1,
                    i = o[e],
                    a = o[n],
                    [c, l] = r.LayerToCanvasCss(i + t.GetX(), a + t.GetY());
                o[e] = c, o[n] = l
            }
            return n.setBboxChanged(), i.setBboxChanged(), this._polyCheckCount++, n.intersectsPoly(i, 0, 0)
        }
        TestTilemapOverlap(t, i) {
            const l = i.GetBoundingBox(),
                r = t.GetX(),
                c = t.GetY(),
                m = t.GetInstance().GetSdkInstance(),
                d = i.GetX(),
                u = i.GetY(),
                f = i.HasOwnCollisionPoly(),
                h = i.GetBoundingQuad(),
                a = o;
            m.GetCollisionRectCandidates(l, a);
            for (let o = 0, p = a.length; o < p; ++o) {
                const m = a[o],
                    t = m.GetRect();
                if (this._collisionCheckCount++, l.intersectsRectOffset(t, r, c) && (s.setFromRect(t), s.offset(r, c), s.intersectsQuad(h)))
                    if (f) {
                        {
                            const o = i.GetTransformedCollisionPoly(),
                                l = m.GetPoly();
                            if (l) {
                                if (this._polyCheckCount++, l.intersectsPoly(o, d - (r + t.getLeft()), u - (c + t.getTop()))) return e.clearArray(a), !0
                            } else if (n.setFromQuad(s, 0, 0), n.intersectsPoly(o, d, u)) return e.clearArray(a), !0
                        }
                    } else {
                        const s = m.GetPoly();
                        if (s) {
                            if (n.setFromQuad(h, 0, 0), s.intersectsPoly(n, -(r + t.getLeft()), -(c + t.getTop()))) return e.clearArray(a), !0
                        } else return e.clearArray(a), !0
                    }
            }
            return e.clearArray(a), !1
        }
        TestAndSelectCanvasPointOverlap(t, n, s, o) {
            const i = t.GetCurrentSol(),
                r = this._runtime.GetCurrentEvent();
            if (!r) throw new Error("cannot call outside event");
            const a = r.IsOrBlock();
            if (i.IsSelectAll()) {
                o || (i._SetSelectAll(!1), e.clearArray(i._GetOwnInstances()));
                for (const e of t.GetInstances()) {
                    const r = e.GetWorldInfo(),
                        c = r.GetLayer(),
                        [l, d] = c.CanvasCssToLayer(n, s, r.GetTotalZElevation());
                    if (r.ContainsPoint(l, d))
                        if (o) return !1;
                        else i._PushInstance(e);
                    else a && i._PushElseInstance(e)
                }
            } else {
                const e = a ? i._GetOwnElseInstances() : i._GetOwnInstances();
                let t = 0;
                for (let c = 0, d = e.length; c < d; ++c) {
                    const r = e[c],
                        l = r.GetWorldInfo(),
                        u = l.GetLayer(),
                        [h, m] = u.CanvasCssToLayer(n, s, l.GetTotalZElevation());
                    if (l.ContainsPoint(h, m))
                        if (o) return !1;
                        else a ? i._PushInstance(r) : e[t++] = r;
                    else a && (e[t++] = r)
                }
                o || (e.length = t)
            }
            return t.ApplySolToContainer(), !!o || i.HasAnyInstances()
        }
        GetCollisionCandidates(t, n, s, o) {
            const i = !!t && (t.GetParallaxX() !== 1 || t.GetParallaxY() !== 1);
            if (n.IsFamily())
                for (const t of n.GetFamilyMembers()) i || t.IsAnyInstanceParallaxed() ? e.appendArray(o, t.GetInstances()) : (t._UpdateAllCollisionCells(), t._GetCollisionCellGrid().QueryRange(s, o));
            else i || n.IsAnyInstanceParallaxed() ? e.appendArray(o, n.GetInstances()) : (n._UpdateAllCollisionCells(), n._GetCollisionCellGrid().QueryRange(s, o))
        }
        GetObjectClassesCollisionCandidates(e, t, n, s) {
            for (const o of t) this.GetCollisionCandidates(e, o, n, s)
        }
        GetSolidCollisionCandidates(e, t, n) {
            const s = this._runtime.GetSolidBehavior();
            if (!s) return;
            this.GetObjectClassesCollisionCandidates(e, s.GetObjectClasses(), t, n)
        }
        GetJumpthruCollisionCandidates(e, t, n) {
            const s = this._runtime.GetJumpthruBehavior();
            if (!s) return;
            this.GetObjectClassesCollisionCandidates(e, s.GetObjectClasses(), t, n)
        }
        IsSolidCollisionAllowed(e, t) {
            return e._IsSolidEnabled() && (!t || t.GetWorldInfo().IsSolidCollisionAllowed(e.GetSavedDataMap().get("solidTags")))
        }
        TestOverlapSolid(n) {
            const s = n.GetWorldInfo();
            this.GetSolidCollisionCandidates(s.GetLayer(), s.GetBoundingBox(), t);
            for (const s of t) {
                if (!this.IsSolidCollisionAllowed(s, n)) continue;
                if (this.TestOverlap(n, s)) return e.clearArray(t), s
            }
            return e.clearArray(t), null
        }
        TestRectOverlapSolid(n, s) {
            this.GetSolidCollisionCandidates(null, n, t);
            for (const o of t) {
                if (!this.IsSolidCollisionAllowed(o, s)) continue;
                if (this.TestRectOverlap(n, o)) return e.clearArray(t), o
            }
            return e.clearArray(t), null
        }
        TestOverlapJumpthru(n, s) {
            let o = null;
            s && (o = c, e.clearArray(o));
            const i = n.GetWorldInfo();
            this.GetJumpthruCollisionCandidates(i.GetLayer(), i.GetBoundingBox(), t);
            for (const i of t) {
                if (!i._IsJumpthruEnabled()) continue;
                if (this.TestOverlap(n, i))
                    if (s) o.push(i);
                    else return e.clearArray(t), i
            }
            return e.clearArray(t), o
        }
        PushOut(e, t, n, s, o) {
            s = s || 50;
            const i = e.GetWorldInfo(),
                a = i.GetX(),
                r = i.GetY();
            for (let c = 0; c < s; ++c)
                if (i.SetXY(a + t * c, r + n * c), i.SetBboxChanged(), !this.TestOverlap(e, o)) return !0;
            return i.SetXY(a, r), i.SetBboxChanged(), !1
        }
        PushOutSolid(e, t, n, s, o, i) {
            s = s || 50;
            const r = e.GetWorldInfo(),
                l = r.GetX(),
                d = r.GetY();
            let a = null,
                c = null;
            for (let u = 0; u < s; ++u)
                if (r.SetXY(l + t * u, d + n * u), r.SetBboxChanged(), !this.TestOverlap(e, a))
                    if (a = this.TestOverlapSolid(e), a) c = a;
                    else if (o && (i ? a = this.TestOverlap(e, i) ? i : null : a = this.TestOverlapJumpthru(e), a && (c = a)), !a) return c && this.PushInFractional(e, t, n, c, 16, !0), !0;
            return r.SetXY(l, d), r.SetBboxChanged(), !1
        }
        PushOutSolidAxis(e, t, n, s) {
            s = s || 50;
            const o = e.GetWorldInfo(),
                r = o.GetX(),
                c = o.GetY();
            let i = null,
                a = null;
            for (let l = 0; l < s; ++l)
                for (let d = 0; d < 2; ++d) {
                    const s = d * 2 - 1;
                    if (o.SetXY(r + t * l * s, c + n * l * s), o.SetBboxChanged(), !this.TestOverlap(e, i))
                        if (i = this.TestOverlapSolid(e), i) a = i;
                        else return a && this.PushInFractional(e, t * s, n * s, a, 16, !0), !0
                }
            return o.SetXY(r, c), o.SetBboxChanged(), !1
        }
        PushInFractional(e, t, n, s, o, i) {
            let c = 2,
                r = !1,
                l = !1;
            const a = e.GetWorldInfo();
            let d = a.GetX(),
                u = a.GetY();
            for (; c <= o;) {
                const o = 1 / c;
                c *= 2, a.OffsetXY(t * o * (r ? 1 : -1), n * o * (r ? 1 : -1)), a.SetBboxChanged(), this.TestOverlap(e, s) || i && this.TestOverlapSolid(e) ? (r = !0, l = !0) : (r = !1, l = !1, d = a.GetX(), u = a.GetY())
            }
            l && (a.SetXY(d, u), a.SetBboxChanged())
        }
        PushOutSolidNearest(e, t = 100) {
            let s = 0;
            const n = e.GetWorldInfo(),
                a = n.GetX(),
                r = n.GetY();
            let i = 0,
                o = this.TestOverlapSolid(e);
            if (!o) return !0;
            for (; s <= t;) {
                let t = 0,
                    c = 0;
                switch (i) {
                    case 0:
                        t = 0, c = -1, s++;
                        break;
                    case 1:
                        t = 1, c = -1;
                        break;
                    case 2:
                        t = 1, c = 0;
                        break;
                    case 3:
                        t = 1, c = 1;
                        break;
                    case 4:
                        t = 0, c = 1;
                        break;
                    case 5:
                        t = -1, c = 1;
                        break;
                    case 6:
                        t = -1, c = 0;
                        break;
                    case 7:
                        t = -1, c = -1;
                        break
                }
                if (i = (i + 1) % 8, n.SetXY(Math.floor(a + t * s), Math.floor(r + c * s)), n.SetBboxChanged(), !this.TestOverlap(e, o) && (o = this.TestOverlapSolid(e), !o)) return !0
            }
            return n.SetXY(a, r), n.SetBboxChanged(), !1
        }
        CalculateBounceAngle(t, n, s, o) {
            const a = t.GetWorldInfo(),
                p = a.GetX(),
                f = a.GetY(),
                h = Math.max(10, e.distanceTo(n, s, p, f)),
                c = e.angleTo(n, s, p, f),
                m = o || this.TestOverlapSolid(t);
            if (!m) return e.clampAngle(c + Math.PI);
            let l = m,
                d = 0,
                r = 0;
            const g = e.toRadians(5);
            let i;
            for (i = 1; i < 36; ++i) {
                const e = c - i * g;
                if (a.SetXY(n + Math.cos(e) * h, s + Math.sin(e) * h), a.SetBboxChanged(), !this.TestOverlap(t, l) && (l = o ? null : this.TestOverlapSolid(t), !l)) {
                    d = e;
                    break
                }
            }
            i === 36 && (d = e.clampAngle(c + Math.PI)), l = m;
            for (i = 1; i < 36; ++i) {
                const e = c + i * g;
                if (a.SetXY(n + Math.cos(e) * h, s + Math.sin(e) * h), a.SetBboxChanged(), !this.TestOverlap(t, l) && (l = o ? null : this.TestOverlapSolid(t), !l)) {
                    r = e;
                    break
                }
            }
            if (i === 36 && (r = e.clampAngle(c + Math.PI)), a.SetXY(p, f), a.SetBboxChanged(), r === d) return r;
            const v = e.angleDiff(r, d) / 2;
            let u;
            e.angleClockwise(r, d) ? u = e.clampAngle(d + v + Math.PI) : u = e.clampAngle(r + v);
            const b = Math.cos(c),
                j = Math.sin(c),
                y = Math.cos(u),
                _ = Math.sin(u),
                w = b * y + j * _,
                O = b - 2 * w * y,
                x = j - 2 * w * _;
            return e.angleTo(0, 0, O, x)
        }
        TestSegmentOverlap(e, t, n, s, o) {
            if (!o) return !1;
            const i = o.GetWorldInfo();
            if (!i.IsCollisionEnabled()) return !1;
            if (this._collisionCheckCount++, a.set(Math.min(e, n), Math.min(t, s), Math.max(e, n), Math.max(t, s)), !i.GetBoundingBox().intersectsRect(a)) return !1;
            if (o.HasTilemap()) return this._TestSegmentOverlapTilemap(e, t, n, s, o, i);
            if (this._polyCheckCount++, !i.GetBoundingQuad().intersectsSegment(e, t, n, s)) return !1;
            if (!i.HasOwnCollisionPoly()) return !0;
            const r = i.GetTransformedCollisionPoly();
            return r.intersectsSegment(i.GetX(), i.GetY(), e, t, n, s)
        }
        _TestSegmentOverlapTilemap(t, n, i, c, l, d) {
            const h = d.GetX(),
                m = d.GetY(),
                f = l.GetSdkInstance(),
                u = o;
            r.set(t, n, i, c), r.normalize(), f.GetCollisionRectCandidates(r, u);
            for (let r = 0, d = u.length; r < d; ++r) {
                const l = u[r],
                    o = l.GetRect();
                if (this._collisionCheckCount++, a.intersectsRectOffset(o, h, m) && (s.setFromRect(o), s.offset(h, m), s.intersectsSegment(t, n, i, c))) {
                    const s = l.GetPoly();
                    if (s) {
                        if (this._polyCheckCount++, s.intersectsSegment(h + o.getLeft(), m + o.getTop(), t, n, i, c)) return e.clearArray(u), !0
                    } else return e.clearArray(u), !0
                }
            }
            return e.clearArray(u), !1
        }
        TestRectOverlap(e, t) {
            if (!t) return !1;
            const o = t.GetWorldInfo();
            if (!o.IsCollisionEnabled()) return !1;
            if (this._collisionCheckCount++, !o.GetBoundingBox().intersectsRect(e)) return !1;
            if (t.HasTilemap()) return this._TestRectOverlapTilemap(e, t, o);
            if (this._polyCheckCount++, s.setFromRect(e), !o.GetBoundingQuad().intersectsQuad(s)) return !1;
            if (!o.HasOwnCollisionPoly()) return !0;
            const i = n;
            i.setFromRect(e, o.GetX(), o.GetY());
            const a = o.GetTransformedCollisionPoly();
            return i.intersectsPoly(a, 0, 0)
        }
        _TestRectOverlapTilemap(t, s, i) {
            const r = i.GetX(),
                c = i.GetY(),
                l = s.GetSdkInstance(),
                a = o;
            l.GetCollisionRectCandidates(t, a);
            for (let s = 0, l = a.length; s < l; ++s) {
                const i = a[s],
                    o = i.GetRect();
                if (this._collisionCheckCount++, t.intersectsRectOffset(o, r, c)) {
                    const s = i.GetPoly();
                    if (s) {
                        if (this._polyCheckCount++, n.setFromRect(t, 0, 0), s.intersectsPoly(n, -(r + o.getLeft()), -(c + o.getTop()))) return e.clearArray(a), !0
                    } else return e.clearArray(a), !0
                }
            }
            return e.clearArray(a), !1
        }
        TestRayIntersectsInstance(e, t) {
            if (!e) return;
            const n = e.GetWorldInfo();
            if (!n.IsCollisionEnabled()) return;
            if (this._collisionCheckCount++, !n.GetBoundingBox().intersectsRect(t.rect)) return;
            if (e.HasTilemap()) {
                this._TestRayIntersectsTilemap(e, n, t);
                return
            }
            this._polyCheckCount++, n.HasOwnCollisionPoly() ? t.TestInstancePoly(e, n.GetX(), n.GetY(), n.GetTransformedCollisionPoly()) : t.TestInstanceQuad(e, n.GetBoundingQuad())
        }
        _TestRayIntersectsTilemap(t, n, s) {
            const a = n.GetX(),
                r = n.GetY(),
                i = o;
            t.GetSdkInstance().GetCollisionRectCandidates(s.rect, i);
            for (let o = 0, l = i.length; o < l; o++) {
                const c = i[o],
                    e = c.GetRect();
                if (this._collisionCheckCount++, s.rect.intersectsRectOffset(e, a, r)) {
                    const o = c.GetPoly();
                    this._polyCheckCount++, o ? s.TestInstancePoly(t, a + e.getLeft(), r + e.getTop(), o) : s.TestInstanceRect(t, n.GetX(), n.GetY(), e)
                }
            }
            e.clearArray(i)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.SparseGrid = class SparseGrid extends e.DefendedBase {
        constructor(t, n) {
            super(), this._cellWidth = t, this._cellHeight = n, this._cells = e.New(e.PairMap)
        }
        Release() {
            this._cells.Release(), this._cells = null
        }
        GetCell(t, n, s) {
            let o = this._cells.Get(t, n);
            return o ? o : s ? (o = e.New(e.GridCell, this, t, n), this._cells.Set(t, n, o), o) : null
        }
        XToCell(e) {
            const t = Math.floor(e / this._cellWidth);
            return isFinite(t) ? t : 0
        }
        YToCell(e) {
            const t = Math.floor(e / this._cellHeight);
            return isFinite(t) ? t : 0
        }
        Update(e, t, n) {
            if (t)
                for (let s = t.getLeft(), o = t.getRight(); s <= o; ++s)
                    for (let o = t.getTop(), a = t.getBottom(); o <= a; ++o) {
                        if (n && n.containsPoint(s, o)) continue;
                        const i = this.GetCell(s, o, !1);
                        if (!i) continue;
                        i.Remove(e), i.IsEmpty() && this._cells.Delete(s, o)
                    }
            if (n)
                for (let s = n.getLeft(), o = n.getRight(); s <= o; ++s)
                    for (let o = n.getTop(), i = n.getBottom(); o <= i; ++o) {
                        if (t && t.containsPoint(s, o)) continue;
                        this.GetCell(s, o, !0).Insert(e)
                    }
        }
        QueryRange(e, t) {
            let n = this.XToCell(e.getLeft());
            const i = this.YToCell(e.getTop()),
                s = this.XToCell(e.getRight()),
                o = this.YToCell(e.getBottom());
            if (!isFinite(s) || !isFinite(o)) return;
            for (; n <= s; ++n)
                for (let e = i; e <= o; ++e) {
                    const s = this.GetCell(n, e, !1);
                    if (!s) continue;
                    s.Dump(t)
                }
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.GridCell = class GridCell extends e.DefendedBase {
        constructor(t, n, s) {
            super(), this._grid = t, this._x = n, this._y = s, this._instances = e.New(e.ArraySet)
        }
        Release() {
            this._instances.Release(), this._instances = null, this._grid = null
        }
        IsEmpty() {
            return this._instances.IsEmpty()
        }
        Insert(e) {
            this._instances.Add(e)
        }
        Remove(e) {
            this._instances.Delete(e)
        }
        Dump(t) {
            e.appendArray(t, this._instances.GetArray())
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = 1e-6,
        n = 2;
    e.Ray = class Ray {
        constructor() {
            this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.dx = 0, this.dy = 0, this.rect = new e.Rect, this.hitFraction = n, this.hitUid = null, this.hitNormal = 0, this.hitNormalDx = 0, this.hitNormalDy = 0, this.hitX = 0, this.hitY = 0, this.distance = 0, this.normalX = 1, this.normalY = 0, this.reflectionX = 1, this.reflectionY = 0
        }
        DidCollide() {
            return this.hitFraction < 1 + t
        }
        Set(e, t, s, o) {
            return this.x1 = e, this.y1 = t, this.x2 = s, this.y2 = o, this.dx = s - e, this.dy = o - t, this.rect.set(e, t, s, o), this.rect.normalize(), this.hitFraction = n, this.hitUid = null, this.hitNormal = 0, this.hitNormalDx = 0, this.hitNormalDy = 0, this.hitX = 0, this.hitY = 0, this.distance = 0, this.normalX = 1, this.normalY = 0, this.reflectionX = 1, this.reflectionY = 0, this
        }
        Complete() {
            if (this.DidCollide() === !1) return;
            const n = this.dx * this.hitFraction,
                s = this.dy * this.hitFraction,
                o = Math.sqrt(n * n + s * s),
                i = n / o,
                a = s / o;
            this.distance = o - t, this.hitX = this.x1 + i * this.distance, this.hitY = this.y1 + a * this.distance, this.hitNormal = Math.atan2(this.hitNormalDy, this.hitNormalDx) + Math.PI / 2, this.normalX = Math.cos(this.hitNormal), this.normalY = Math.sin(this.hitNormal);
            const r = i * this.normalX + a * this.normalY;
            if (this.reflectionX = i - 2 * this.normalX * r, this.reflectionY = a - 2 * this.normalY * r, r > 0) {
                const t = Math.PI;
                this.hitNormal = e.clampAngle(this.hitNormal + t), this.normalX = -this.normalX, this.normalY = -this.normalY
            }
        }
        TestInstanceSegment(t, n, s, o, i) {
            const a = e.rayIntersect(this.x1, this.y1, this.x2, this.y2, n, s, o, i);
            a >= 0 && a < this.hitFraction && (this.hitFraction = a, this.hitUid = t.GetUID(), this.hitNormalDx = n - o, this.hitNormalDy = s - i)
        }
        TestInstanceRect(e, t, n, s) {
            const o = t + s.getLeft(),
                i = t + s.getRight(),
                a = n + s.getTop(),
                r = n + s.getBottom();
            this.TestInstanceSegment(e, o, a, i, a), this.TestInstanceSegment(e, i, a, i, r), this.TestInstanceSegment(e, i, r, o, r), this.TestInstanceSegment(e, o, r, o, a)
        }
        TestInstanceQuad(e, t) {
            const n = t.getTlx(),
                s = t.getTly(),
                o = t.getTrx(),
                i = t.getTry(),
                a = t.getBrx(),
                r = t.getBry(),
                c = t.getBlx(),
                l = t.getBly();
            this.TestInstanceSegment(e, n, s, o, i), this.TestInstanceSegment(e, o, i, a, r), this.TestInstanceSegment(e, a, r, c, l), this.TestInstanceSegment(e, c, l, n, s)
        }
        TestInstancePoly(e, t, n, s) {
            const o = s.pointsArr();
            for (let s = 0, i = o.length; s < i; s += 2) {
                const a = (s + 2) % i,
                    r = o[s] + t,
                    c = o[s + 1] + n,
                    l = o[a] + t,
                    d = o[a + 1] + n;
                this.TestInstanceSegment(e, r, c, l, d)
            }
        }
    }
}
"use strict";
{
    const e = self.C3,
        i = new Set(["off", "crop", "scale-inner", "scale-outer", "letterbox-scale", "letterbox-integer-scale"]),
        c = new Set(["high", "low"]),
        a = 300,
        r = 200,
        o = 120,
        l = 8,
        n = e.New(e.Quad),
        t = e.New(e.Rect),
        d = 3e3,
        u = 200,
        s = 300;
    e.CanvasManager = class CanvasManager extends e.DefendedBase {
        constructor(t) {
            super(), this._runtime = t, this._canvas = null, this._webglRenderer = null, this._gpuPreference = "high-performance", this._windowInnerWidth = 0, this._windowInnerHeight = 0, this._canvasCssWidth = 0, this._canvasCssHeight = 0, this._canvasDeviceWidth = 0, this._canvasDeviceHeight = 0, this._canvasCssOffsetX = 0, this._canvasCssOffsetY = 0, this._enableMipmaps = !0, this._drawWidth = 0, this._drawHeight = 0, this._fullscreenMode = "letterbox-scale", this._documentFullscreenMode = "letterbox-scale", this._deviceTransformOffX = 0, this._deviceTransformOffY = 0, this._wantFullscreenScalingQuality = "high", this._fullscreenScalingQuality = this._wantFullscreenScalingQuality, this._isDocumentFullscreen = !1, this._availableAdditionalRenderTargets = [], this._usedAdditionalRenderTargets = new Set, this._shaderData = null, this._gpuFrameTimingsBuffer = null, this._gpuTimeStartFrame = 0, this._gpuTimeEndFrame = 0, this._gpuCurUtilisation = NaN, this._gpuLastUtilisation = 0, this._layersGpuProfile = new Map, this._snapshotFormat = "", this._snapshotQuality = 1, this._snapshotArea = e.New(e.Rect), this._snapshotUrl = "", this._snapshotPromise = null, this._snapshotResolve = null, this._loaderStartTime = 0, this._rafId = -1, this._loadingProgress = 0, this._loadingprogress_handler = e => this._loadingProgress = e.progress, this._percentText = null, this._loadingLogoAsset = null, this._splashTextures = {
                logo: null,
                powered: null,
                website: null
            }, this._splashFrameNumber = 0, this._splashFadeInFinishTime = 0, this._splashFadeOutStartTime = 0, this._splashState = "fade-in", this._splashDoneResolve = null, this._splashDonePromise = new Promise(e => this._splashDoneResolve = e)
        }
        _SetGPUPowerPreference(e) {
            this._gpuPreference = e
        }
        async CreateCanvas(t) {
            this._canvas = t.canvas, this._canvas.addEventListener("webglcontextlost", e => this._OnWebGLContextLost(e)), this._canvas.addEventListener("webglcontextrestored", e => this._OnWebGLContextRestored(e));
            const n = {
                powerPreference: this._gpuPreference,
                enableGpuProfiling: !0
            };
            e.Platform.OS === "Android" && e.Platform.BrowserEngine === "Chromium" && e.Platform.BrowserVersionNumber < 75 && (console.warn("[Construct 3] Disabling WebGL 2 because this device appears to be affected by crbug.com/934823. Install software updates to avoid this."), n.maxWebGLVersion = 1), this._runtime.GetCompositingMode() === "standard" ? n.alpha = !0 : (n.alpha = !1, n.lowLatency = !0), this._webglRenderer = e.New(e.Gfx.WebGLRenderer, this._canvas, n), await this._webglRenderer.InitState(), this._webglRenderer.SupportsGPUProfiling() || (this._gpuLastUtilisation = NaN), this._runtime.AddDOMComponentMessageHandler("runtime", "window-resize", e => this._OnWindowResize(e)), this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenchange", e => this._OnFullscreenChange(e)), this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenerror", e => this._OnFullscreenError(e)), this._isDocumentFullscreen = !!t.isFullscreen, this.SetSize(t.windowInnerWidth, t.windowInnerHeight, !0), this._shaderData = self.C3_Shaders, await this._LoadShaderPrograms();
            let s = !1;
            for (const e of this._runtime._GetAllEffectLists()) {
                for (const t of e.GetAllEffectTypes()) t._InitRenderer(this._webglRenderer), t.GetShaderProgram().UsesDest() && (s = !0);
                e.UpdateActiveEffects()
            }
            this._runtime._SetUsesAnyBackgroundBlending(s), this._webglRenderer.SupportsGPUProfiling() && (this._gpuFrameTimingsBuffer = e.New(e.Gfx.WebGLQueryResultBuffer, this._webglRenderer)), this._webglRenderer.SetMipmapsEnabled(this._enableMipmaps)
        }
        async _LoadShaderPrograms() {
            if (!this._shaderData) return;
            const t = [];
            for (const [n, s] of Object.entries(this._shaderData)) {
                const o = e.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource(this._webglRenderer.Is3D());
                t.push(this._webglRenderer.CreateShaderProgram(s, o, n))
            }
            await Promise.all(t), this._webglRenderer.ResetLastProgram(), this._webglRenderer.SetTextureFillMode()
        }
        Release() {
            this._runtime = null, this._webglRenderer = null, this._canvas = null
        }
        _OnWindowResize(e) {
            const t = e.devicePixelRatio;
            this._runtime.IsInWorker() && (self.devicePixelRatio = t), this._runtime._SetDevicePixelRatio(t), this.SetSize(e.innerWidth, e.innerHeight), this._runtime.UpdateRender()
        }
        _OnFullscreenChange(e) {
            this._isDocumentFullscreen = !!e.isFullscreen, this.SetSize(e.innerWidth, e.innerHeight, !0), this._runtime.UpdateRender()
        }
        _OnFullscreenError(e) {
            this._isDocumentFullscreen = !!e.isFullscreen, this.SetSize(e.innerWidth, e.innerHeight, !0), this._runtime.UpdateRender()
        }
        SetSize(e, t, n = !1) {
            if (e = Math.floor(e), t = Math.floor(t), e <= 0 || t <= 0) throw new Error("invalid size");
            if (this._windowInnerWidth === e && this._windowInnerHeight === t && !n) return;
            this._windowInnerWidth = e, this._windowInnerHeight = t;
            const s = this.GetCurrentFullscreenMode();
            s === "letterbox-scale" ? this._CalculateLetterboxScale(e, t) : s === "letterbox-integer-scale" ? this._CalculateLetterboxIntegerScale(e, t) : s === "off" ? this._CalculateFixedSizeCanvas(e, t) : this._CalculateFullsizeCanvas(e, t), this._UpdateFullscreenScalingQuality(s), this._canvas.width = this._canvasDeviceWidth, this._canvas.height = this._canvasDeviceHeight, this._runtime.PostComponentMessageToDOM("canvas", "update-size", {
                marginLeft: this._canvasCssOffsetX,
                marginTop: this._canvasCssOffsetY,
                styleWidth: this._canvasCssWidth,
                styleHeight: this._canvasCssHeight
            }), this._webglRenderer.SetSize(this._canvasDeviceWidth, this._canvasDeviceHeight, !0)
        }
        _CalculateLetterboxScale(e, t) {
            const s = this._runtime.GetDevicePixelRatio(),
                o = this._runtime.GetOriginalViewportWidth(),
                i = this._runtime.GetOriginalViewportHeight(),
                n = o / i,
                a = e / t;
            if (a > n) {
                const s = t * n;
                this._canvasCssWidth = Math.round(s), this._canvasCssHeight = t, this._canvasCssOffsetX = Math.floor((e - this._canvasCssWidth) / 2), this._canvasCssOffsetY = 0
            } else {
                const s = e / n;
                this._canvasCssWidth = e, this._canvasCssHeight = Math.round(s), this._canvasCssOffsetX = 0, this._canvasCssOffsetY = Math.floor((t - this._canvasCssHeight) / 2)
            }
            this._canvasDeviceWidth = Math.round(this._canvasCssWidth * s), this._canvasDeviceHeight = Math.round(this._canvasCssHeight * s), this._runtime.SetViewportSize(o, i)
        }
        _CalculateLetterboxIntegerScale(e, t) {
            const s = this._runtime.GetDevicePixelRatio();
            s !== 1 && (e += 1, t += 1);
            const o = this._runtime.GetOriginalViewportWidth(),
                i = this._runtime.GetOriginalViewportHeight(),
                a = o / i,
                r = e / t;
            let n;
            if (r > a) {
                const e = t * a;
                n = e * s / o
            } else {
                const t = e / a;
                n = t * s / i
            }
            n > 1 ? n = Math.floor(n) : n < 1 && (n = 1 / Math.ceil(1 / n)), this._canvasDeviceWidth = Math.round(o * n), this._canvasDeviceHeight = Math.round(i * n), this._canvasCssWidth = this._canvasDeviceWidth / s, this._canvasCssHeight = this._canvasDeviceHeight / s, this._canvasCssOffsetX = Math.max(Math.floor((e - this._canvasCssWidth) / 2), 0), this._canvasCssOffsetY = Math.max(Math.floor((t - this._canvasCssHeight) / 2), 0), this._runtime.SetViewportSize(o, i)
        }
        _CalculateFullsizeCanvas(e, t) {
            const n = this._runtime.GetDevicePixelRatio();
            this._canvasCssWidth = e, this._canvasCssHeight = t, this._canvasDeviceWidth = Math.round(this._canvasCssWidth * n), this._canvasDeviceHeight = Math.round(this._canvasCssHeight * n), this._canvasCssOffsetX = 0, this._canvasCssOffsetY = 0;
            const s = this.GetDisplayScale();
            this._runtime.SetViewportSize(this._canvasCssWidth / s, this._canvasCssHeight / s)
        }
        _CalculateFixedSizeCanvas(e, t) {
            const n = this._runtime.GetDevicePixelRatio();
            this._canvasCssWidth = this._runtime.GetViewportWidth(), this._canvasCssHeight = this._runtime.GetViewportHeight(), this._canvasDeviceWidth = Math.round(this._canvasCssWidth * n), this._canvasDeviceHeight = Math.round(this._canvasCssHeight * n), this.IsDocumentFullscreen() ? (this._canvasCssOffsetX = Math.floor((e - this._canvasCssWidth) / 2), this._canvasCssOffsetY = Math.floor((t - this._canvasCssHeight) / 2)) : (this._canvasCssOffsetX = 0, this._canvasCssOffsetY = 0), this._runtime.SetViewportSize(this._runtime.GetViewportWidth(), this._runtime.GetViewportHeight())
        }
        _UpdateFullscreenScalingQuality(e) {
            if (this._wantFullscreenScalingQuality === "high") this._drawWidth = this._canvasDeviceWidth, this._drawHeight = this._canvasDeviceHeight, this._fullscreenScalingQuality = "high";
            else {
                let t, n;
                if (this.GetCurrentFullscreenMode() === "off" ? (t = this._runtime.GetViewportWidth(), n = this._runtime.GetViewportHeight()) : (t = this._runtime.GetOriginalViewportWidth(), n = this._runtime.GetOriginalViewportHeight()), this._canvasDeviceWidth < t && this._canvasDeviceHeight < n) this._drawWidth = this._canvasDeviceWidth, this._drawHeight = this._canvasDeviceHeight, this._fullscreenScalingQuality = "high";
                else if (this._drawWidth = t, this._drawHeight = n, this._fullscreenScalingQuality = "low", e === "scale-inner") {
                    const s = t / n,
                        e = this._windowInnerWidth / this._windowInnerHeight;
                    e < s ? this._drawWidth = this._drawHeight * e : e > s && (this._drawHeight = this._drawWidth / e)
                } else if (e === "scale-outer") {
                    const s = t / n,
                        e = this._windowInnerWidth / this._windowInnerHeight;
                    e > s ? this._drawWidth = this._drawHeight * e : e < s && (this._drawHeight = this._drawWidth / e)
                }
            }
        }
        IsDocumentFullscreen() {
            return this._isDocumentFullscreen
        }
        SetFullscreenMode(e) {
            if (!i.has(e)) throw new Error("invalid fullscreen mode");
            this._fullscreenMode = e
        }
        GetFullscreenMode() {
            return this._fullscreenMode
        }
        SetDocumentFullscreenMode(e) {
            if (!i.has(e)) throw new Error("invalid fullscreen mode");
            this._documentFullscreenMode = e
        }
        GetDocumentFullscreenMode() {
            return this._documentFullscreenMode
        }
        GetCurrentFullscreenMode() {
            return this.IsDocumentFullscreen() ? this.GetDocumentFullscreenMode() : this.GetFullscreenMode()
        }
        SetFullscreenScalingQuality(e) {
            if (!c.has(e)) throw new Error("invalid fullscreen scaling quality");
            this._wantFullscreenScalingQuality = e
        }
        GetSetFullscreenScalingQuality() {
            return this._wantFullscreenScalingQuality
        }
        GetCurrentFullscreenScalingQuality() {
            return this._fullscreenScalingQuality
        }
        static _FullscreenModeNumberToString(e) {
            switch (e) {
                case 0:
                    return "off";
                case 1:
                    return "crop";
                case 2:
                    return "scale-inner";
                case 3:
                    return "scale-outer";
                case 4:
                    return "letterbox-scale";
                case 5:
                    return "letterbox-integer-scale";
                default:
                    throw new Error("invalid fullscreen mode")
            }
        }
        GetLastWidth() {
            return this._windowInnerWidth
        }
        GetLastHeight() {
            return this._windowInnerHeight
        }
        GetDrawWidth() {
            return this._drawWidth
        }
        GetDrawHeight() {
            return this._drawHeight
        }
        SetMipmapsEnabled(e) {
            this._enableMipmaps = !!e
        }
        IsWebGLContextLost() {
            return this._webglRenderer.IsContextLost()
        }
        _OnWebGLContextLost(e) {
            console.log("[Construct 3] WebGL context lost"), e.preventDefault(), this._availableAdditionalRenderTargets = [], this._usedAdditionalRenderTargets.clear(), this._webglRenderer.OnContextLost(), this._runtime._OnWebGLContextLost()
        }
        async _OnWebGLContextRestored() {
            await this._webglRenderer.OnContextRestored(), await this._LoadShaderPrograms();
            for (const e of this._runtime._GetAllEffectLists())
                for (const t of e.GetAllEffectTypes()) t._InitRenderer(this._webglRenderer);
            await this._runtime._OnWebGLContextRestored(), console.log("[Construct 3] WebGL context restored")
        }
        GetWebGLRenderer() {
            return this._webglRenderer
        }
        GetRenderScale() {
            return this._fullscreenScalingQuality === "low" ? 1 / this._runtime.GetDevicePixelRatio() : this.GetDisplayScale()
        }
        GetDisplayScale() {
            const e = this.GetCurrentFullscreenMode();
            if (e === "off" || e === "crop") return 1;
            const t = this._runtime.GetOriginalViewportWidth(),
                n = this._runtime.GetOriginalViewportHeight(),
                s = t / n,
                o = this._canvasDeviceWidth / this._canvasDeviceHeight;
            return e !== "scale-inner" && o > s || e === "scale-inner" && o < s ? this._canvasCssHeight / n : this._canvasCssWidth / t
        }
        SetDeviceTransformOffset(e, t) {
            this._deviceTransformOffX = e, this._deviceTransformOffY = t
        }
        SetDeviceTransform(e, t, n) {
            const s = (t || this._drawWidth) / 2 + this._deviceTransformOffX,
                o = (n || this._drawHeight) / 2 + this._deviceTransformOffY;
            e.SetCameraXYZ(s, o, 100 * this._runtime.GetDevicePixelRatio()), e.SetLookXYZ(s, o, 0), e.ResetModelView(), e.UpdateModelView()
        }
        SetCssTransform(e) {
            const t = this._canvasCssWidth / 2,
                n = this._canvasCssHeight / 2;
            e.SetCameraXYZ(t, n, 100), e.SetLookXYZ(t, n, 0), e.ResetModelView(), e.UpdateModelView()
        }
        GetDeviceWidth() {
            return this._canvasDeviceWidth
        }
        GetDeviceHeight() {
            return this._canvasDeviceHeight
        }
        GetCssWidth() {
            return this._canvasCssWidth
        }
        GetCssHeight() {
            return this._canvasCssHeight
        }
        GetCanvasClientX() {
            return this._canvasCssOffsetX
        }
        GetCanvasClientY() {
            return this._canvasCssOffsetY
        }
        GetAdditionalRenderTarget(e) {
            const n = this._availableAdditionalRenderTargets,
                s = n.findIndex(t => t.IsCompatibleWithOptions(e));
            let t;
            return s !== -1 ? (t = n[s], n.splice(s, 1)) : t = this._webglRenderer.CreateRenderTarget(e), this._usedAdditionalRenderTargets.add(t), t
        }
        ReleaseAdditionalRenderTarget(e) {
            if (!this._usedAdditionalRenderTargets.has(e)) throw new Error("render target not in use");
            this._usedAdditionalRenderTargets.delete(e), this._availableAdditionalRenderTargets.push(e)
        }* activeLayersGpuProfiles() {
            for (const e of this._runtime.GetLayoutManager().runningLayouts())
                for (const n of e.GetLayers()) {
                    const t = this._layersGpuProfile.get(n);
                    t && (yield t)
                }
        }
        GetLayerTimingsBuffer(t) {
            if (!this._webglRenderer.SupportsGPUProfiling()) return null;
            let n = this._layersGpuProfile.get(t);
            return n || (n = {
                name: t.GetName(),
                timingsBuffer: e.New(e.Gfx.WebGLQueryResultBuffer, this._webglRenderer),
                curUtilisation: 0,
                lastUtilisation: 0
            }, this._layersGpuProfile.set(t, n)), n.timingsBuffer
        }
        _Update1sFrameRange() {
            if (!this._webglRenderer.SupportsGPUProfiling()) return;
            if (this._gpuTimeEndFrame === 0) {
                this._gpuTimeEndFrame = this._webglRenderer.GetFrameNumber(), this._gpuCurUtilisation = NaN;
                for (const e of this.activeLayersGpuProfiles()) e.curUtilisation = NaN
            }
        }
        _UpdateTick() {
            if (!this._webglRenderer.SupportsGPUProfiling() || !isNaN(this._gpuCurUtilisation)) return;
            if (this._gpuCurUtilisation = this._gpuFrameTimingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame), isNaN(this._gpuCurUtilisation)) return;
            if (this._runtime.IsDebug())
                for (const e of this.activeLayersGpuProfiles())
                    if (e.curUtilisation = e.timingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame), isNaN(e.curUtilisation)) return;
            if (this._gpuFrameTimingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame), this._gpuLastUtilisation = Math.min(this._gpuCurUtilisation, 1), this._runtime.IsDebug()) {
                for (const e of this.activeLayersGpuProfiles()) e.timingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame), e.lastUtilisation = Math.min(e.curUtilisation, 1);
                self.C3Debugger.UpdateGPUProfile(this._gpuLastUtilisation, [...this.activeLayersGpuProfiles()])
            }
            this._gpuTimeStartFrame = this._gpuTimeEndFrame, this._gpuTimeEndFrame = 0
        }
        GetGPUFrameTimingsBuffer() {
            return this._gpuFrameTimingsBuffer
        }
        GetGPUUtilisation() {
            return this._gpuLastUtilisation
        }
        SnapshotCanvas(e, t, n, s, o, i) {
            return this._snapshotFormat = e, this._snapshotQuality = t, this._snapshotArea.setWH(n, s, o, i), this._snapshotPromise ? this._snapshotPromise : (this._snapshotPromise = new Promise(e => {
                this._snapshotResolve = e
            }), this._snapshotPromise)
        }
        _MaybeTakeSnapshot() {
            if (!this._snapshotFormat) return;
            let t = this._canvas;
            const o = this._snapshotArea,
                i = e.clamp(Math.floor(o.getLeft()), 0, t.width),
                a = e.clamp(Math.floor(o.getTop()), 0, t.height);
            let n = o.width();
            n === 0 ? n = t.width - i : n = e.clamp(Math.floor(n), 0, t.width - i);
            let s = o.height();
            if (s === 0 ? s = t.height - a : s = e.clamp(Math.floor(s), 0, t.height - a), (i !== 0 || a !== 0 || n !== t.width || s !== t.height) && n > 0 && s > 0) {
                t = e.CreateCanvas(n, s);
                const o = t.getContext("2d");
                o.drawImage(this._canvas, i, a, n, s, 0, 0, n, s)
            }
            e.CanvasToBlob(t, this._snapshotFormat, this._snapshotQuality).then(e => {
                this._snapshotUrl = URL.createObjectURL(e), this._snapshotPromise = null, this._snapshotResolve(this._snapshotUrl)
            }), this._snapshotFormat = "", this._snapshotQuality = 1
        }
        GetCanvasSnapshotUrl() {
            return this._snapshotUrl
        }
        InitLoadingScreen(t) {
            if (t === 2) this._percentText = e.New(e.Gfx.RendererText, this._webglRenderer), this._percentText.SetIsAsync(!1), this._percentText.SetFontName("Arial"), this._percentText.SetFontSize(16), this._percentText.SetHorizontalAlignment("center"), this._percentText.SetVerticalAlignment("center"), this._percentText.SetSize(a, r);
            else if (t === 0) {
                const e = this._runtime.GetLoadingLogoFilename(),
                    t = this._runtime.GetAssetManager();
                let n;
                if (this._runtime.IsPreview()) {
                    if (!t._HasLocalUrlBlob(e)) return;
                    n = t.GetLocalUrlAsBlobUrl(e)
                } else n = t.GetIconsSubfolder() + e;
                this._loadingLogoAsset = t.LoadImage({
                    url: n
                }), this._loadingLogoAsset.LoadStaticTexture(this._webglRenderer).catch(t => console.warn(`[C3 runtime] Failed to load '${e}' for loading screen. Check the project has an icon with that name.`, t))
            } else t === 4 && (this._LoadSvgSplashImage("splash-images/splash-logo.svg").then(e => {
                this._splashState === "done" ? this._webglRenderer.DeleteTexture(e) : this._splashTextures.logo = e
            }).catch(e => console.warn("Failed to load splash image: ", e)), this._LoadBitmapSplashImage("splash-images/splash-poweredby-512.png").then(e => {
                this._splashState === "done" ? this._webglRenderer.DeleteTexture(e) : this._splashTextures.powered = e
            }).catch(e => console.warn("Failed to load splash image: ", e)), this._LoadBitmapSplashImage("splash-images/splash-website-512.png").then(e => {
                this._splashState === "done" ? this._webglRenderer.DeleteTexture(e) : this._splashTextures.website = e
            }).catch(e => console.warn("Failed to load splash image: ", e)))
        }
        async _LoadSvgSplashImage(t) {
            t = new URL(t, this._runtime.GetBaseURL()).toString();
            const n = await e.FetchBlob(t),
                s = await this._runtime.RasterSvgImage(n, 2048, 2048);
            return await this._webglRenderer.CreateStaticTextureAsync(s, {
                mipMapQuality: "high"
            })
        }
        async _LoadBitmapSplashImage(t) {
            t = new URL(t, this._runtime.GetBaseURL()).toString();
            const n = await e.FetchBlob(t);
            return await this._webglRenderer.CreateStaticTextureAsync(n, {
                mipMapQuality: "high"
            })
        }
        HideCordovaSplashScreen() {
            this._runtime.PostComponentMessageToDOM("runtime", "hide-cordova-splash")
        }
        StartLoadingScreen() {
            this._loaderStartTime = Date.now(), this._runtime.Dispatcher().addEventListener("loadingprogress", this._loadingprogress_handler), this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen());
            const e = this._runtime.GetLoaderStyle();
            e !== 3 && this.HideCordovaSplashScreen()
        }
        async EndLoadingScreen() {
            this._loadingProgress = 1;
            const e = this._runtime.GetLoaderStyle();
            e === 4 && await this._splashDonePromise, this._splashDoneResolve = null, this._splashDonePromise = null, this._rafId !== -1 && (cancelAnimationFrame(this._rafId), this._rafId = -1), this._runtime.Dispatcher().removeEventListener("loadingprogress", this._loadingprogress_handler), this._loadingprogress_handler = null, this._percentText && (this._percentText.Release(), this._percentText = null), this._loadingLogoAsset && (this._loadingLogoAsset.Release(), this._loadingLogoAsset = null), this._webglRenderer.Start(), this._splashTextures.logo && (this._webglRenderer.DeleteTexture(this._splashTextures.logo), this._splashTextures.logo = null), this._splashTextures.powered && (this._webglRenderer.DeleteTexture(this._splashTextures.powered), this._splashTextures.powered = null), this._splashTextures.website && (this._webglRenderer.DeleteTexture(this._splashTextures.website), this._splashTextures.website = null), this._webglRenderer.ClearRgba(0, 0, 0, 0), this._webglRenderer.Finish(), this._splashState = "done", this._gpuTimeStartFrame = this._webglRenderer.GetFrameNumber(), e === 3 && this.HideCordovaSplashScreen()
        }
        _DrawLoadingScreen() {
            if (this._rafId === -1) return;
            const t = this._webglRenderer;
            t.Start(), this._rafId = -1;
            const s = this._runtime.GetAssetManager().HasHadErrorLoading(),
                n = this._runtime.GetLoaderStyle();
            if (n !== 3 && (this.SetCssTransform(t), t.ClearRgba(0, 0, 0, 0), t.ResetColor(), t.SetTextureFillMode(), t.SetTexture(null)), n === 0) this._DrawProgressBarAndLogoLoadingScreen(s);
            else if (n === 1) this._DrawProgressBarLoadingScreen(s, o, 0);
            else if (n === 2) this._DrawPercentTextLoadingScreen(s);
            else if (n === 3) e.noop();
            else if (n === 4) this._DrawSplashLoadingScreen(s);
            else throw new Error("invalid loader style");
            t.Finish(), this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen())
        }
        _DrawPercentTextLoadingScreen(e) {
            e ? this._percentText.SetColorRgb(1, 0, 0) : this._percentText.SetColorRgb(.6, .6, .6), this._percentText.SetText(Math.round(this._loadingProgress * 100) + "%");
            const t = this._canvasCssWidth / 2,
                s = this._canvasCssHeight / 2,
                o = a / 2,
                i = r / 2;
            n.setRect(t - o, s - i, t + o, s + i), this._webglRenderer.SetTexture(this._percentText.GetTexture()), this._webglRenderer.Quad3(n, this._percentText.GetTexRect())
        }
        _DrawProgressBarLoadingScreen(e, n, s) {
            const o = this._webglRenderer,
                i = l;
            o.SetColorFillMode(), e ? o.SetColorRgba(1, 0, 0, 1) : o.SetColorRgba(.118, .565, 1, 1);
            const a = this._canvasCssWidth / 2,
                r = this._canvasCssHeight / 2,
                c = n / 2,
                d = i / 2;
            t.setWH(a - c, r - d + s, Math.floor(n * this._loadingProgress), i), o.Rect(t), t.setWH(a - c, r - d + s, n, i), t.offset(-.5, -.5), t.inflate(.5, .5), o.SetColorRgba(0, 0, 0, 1), o.LineRect2(t), t.inflate(1, 1), o.SetColorRgba(1, 1, 1, 1), o.LineRect2(t)
        }
        _DrawProgressBarAndLogoLoadingScreen(e) {
            if (!this._loadingLogoAsset) {
                this._DrawProgressBarLoadingScreen(e, o, 0);
                return
            }
            const t = this._loadingLogoAsset.GetTexture();
            if (!t) {
                this._DrawProgressBarLoadingScreen(e, o, 0);
                return
            }
            const i = t.GetWidth(),
                l = t.GetHeight(),
                a = this._canvasCssWidth / 2,
                r = this._canvasCssHeight / 2,
                c = i / 2,
                s = l / 2;
            n.setRect(a - c, r - s, a + c, r + s), this._webglRenderer.SetTexture(t), this._webglRenderer.Quad(n), this._DrawProgressBarLoadingScreen(e, i, s + 16)
        }
        _DrawSplashLoadingScreen(n) {
            const a = this._webglRenderer,
                m = this._splashTextures.logo,
                g = this._splashTextures.powered,
                p = this._splashTextures.website,
                h = Date.now();
            this._splashFrameNumber === 0 && (this._loaderStartTime = h);
            const f = this._runtime.IsPreview() || this._runtime.IsFBInstantAvailable() && !this._runtime.IsCordova(),
                b = f ? 0 : u,
                v = f ? 0 : d;
            let o = 1;
            this._splashState === "fade-in" ? o = Math.min((h - this._loaderStartTime) / s, 1) : this._splashState === "fade-out" && (o = Math.max(1 - (h - this._splashFadeOutStartTime) / s, 0)), a.SetColorFillMode(), a.SetColorRgba(.231 * o, .251 * o, .271 * o, o), t.set(0, 0, this._canvasCssWidth, this._canvasCssHeight), a.Rect(t);
            const l = Math.ceil(this._canvasCssWidth),
                c = Math.ceil(this._canvasCssHeight);
            let i, r;
            this._canvasCssHeight > 256 ? (a.SetColorRgba(.302 * o, .334 * o, .365 * o, o), i = l, r = Math.max(c * .005, 2), t.setWH(0, c * .8 - r / 2, i, r), a.Rect(t), n ? a.SetColorRgba(o, 0, 0, o) : a.SetColorRgba(.161 * o, .953 * o, .816 * o, o), i = l * this._loadingProgress, t.setWH(l * .5 - i / 2, c * .8 - r / 2, i, r), a.Rect(t), a.SetColorRgba(o, o, o, o), a.SetTextureFillMode(), g && (i = e.clamp(c * .22, 105, l * .6) * 1.5, r = i / 8, t.setWH(l * .5 - i / 2, c * .2 - r / 2, i, r), a.SetTexture(g), a.Rect(t)), m && (i = Math.min(c * .395, l * .95), r = i, t.setWH(l * .5 - i / 2, c * .485 - r / 2, i, r), a.SetTexture(m), a.Rect(t)), p && (i = e.clamp(c * .22, 105, l * .6) * 1.5, r = i / 8, t.setWH(l * .5 - i / 2, c * .868 - r / 2, i, r), a.SetTexture(p), a.Rect(t))) : (a.SetColorRgba(.302 * o, .334 * o, .365 * o, o), i = l, r = Math.max(c * .005, 2), t.setWH(0, c * .85 - r / 2, i, r), a.Rect(t), n ? a.SetColorRgba(o, 0, 0, o) : a.SetColorRgba(.161 * o, .953 * o, .816 * o, o), i = l * this._loadingProgress, t.setWH(l * .5 - i / 2, c * .85 - r / 2, i, r), a.Rect(t), a.SetColorRgba(o, o, o, o), a.SetTextureFillMode(), m && (i = c * .55, r = i, t.setWH(l * .5 - i / 2, c * .45 - r / 2, i, r), a.SetTexture(m), a.Rect(t))), this._splashFrameNumber++, this._splashState === "fade-in" && h - this._loaderStartTime >= s && this._splashFrameNumber >= 2 && (this._splashState = "wait", this._splashFadeInFinishTime = h), this._splashState === "wait" && h - this._splashFadeInFinishTime >= v && this._loadingProgress >= 1 && (this._splashState = "fade-out", this._splashFadeOutStartTime = h), (this._splashState === "fade-out" && h - this._splashFadeOutStartTime >= s + b || f && this._loadingProgress >= 1 && h - this._loaderStartTime < 500) && this._splashDoneResolve()
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = self.C3Debugger,
        o = self.assert,
        s = {
            messagePort: null,
            baseUrl: "",
            headless: !1,
            hasDom: !0,
            isInWorker: !1,
            useAudio: !0,
            projectData: "",
            exportType: ""
        };
    let n = !0;
    e.Runtime = class C3Runtime extends e.DefendedBase {
        constructor(t) {
            t = Object.assign({}, s, t), super(), this._messagePort = t.messagePort, this._baseUrl = t.baseUrl, this._isHeadless = !!t.headless, this._hasDom = !!t.hasDom, this._isInWorker = !!t.isInWorker, n = t.ife, this._useAudio = !!t.useAudio, this._exportType = t.exportType, this._isiOSCordova = !!t.isiOSCordova, this._isiOSWebView = !!t.isiOSWebView, this._isFBInstantAvailable = !!t.isFBInstantAvailable, this._opusWasmScriptUrl = t.opusWasmScriptUrl, this._opusWasmBinaryUrl = t.opusWasmBinaryUrl, this._isDebug = !!(this._exportType === "preview" && t.isDebug), this._breakpointsEnabled = this._isDebug, this._isDebugging = this._isDebug, this._debuggingDisabled = 0, this._additionalLoadPromises = [], this._additionalCreatePromises = [], this._isUsingCreatePromises = !1, this._projectName = "", this._projectVersion = "", this._projectUniqueId = "", this._appId = "", this._originalViewportWidth = 0, this._originalViewportHeight = 0, this._devicePixelRatio = self.devicePixelRatio, this._parallaxXorigin = 0, this._parallaxYorigin = 0, this._viewportWidth = 0, this._viewportHeight = 0, this._loaderStyle = 0, this._usesLoaderLayout = !1, this._isLoading = !0, this._usesAnyBackgroundBlending = !1, this._loadingLogoFilename = "loading-logo.png", this._assetManager = e.New(e.AssetManager, this, t), this._layoutManager = e.New(e.LayoutManager, this), this._eventSheetManager = e.New(e.EventSheetManager, this), this._pluginManager = e.New(e.PluginManager, this), this._collisionEngine = e.New(e.CollisionEngine, this), this._timelineManager = e.New(e.TimelineManager, this), this._transitionManager = e.New(e.TransitionManager, this), this._allObjectClasses = [], this._objectClassesByName = new Map, this._objectClassesBySid = new Map, this._familyCount = 0, this._allContainers = [], this._allEffectLists = [], this._currentLayoutStack = [], this._instancesPendingCreate = [], this._instancesPendingDestroy = new Map, this._hasPendingInstances = !1, this._isFlushingPendingInstances = !1, this._objectCount = 0, this._nextUid = 0, this._instancesByUid = new Map, this._instancesToReleaseAtEndOfTick = new Set, this._instancesToReleaseAffectedObjectClasses = new Set, this._objectReferenceTable = [], this._jsPropNameTable = [], this._canvasManager = null, this._framerateMode = "vsync", this._compositingMode = "standard", this._sampling = "trilinear", this._isPixelRoundingEnabled = !1, this._needRender = !0, this._pauseOnBlur = !1, this._isPausedOnBlur = !1, this._tickCallbacks = {
                normal: e => {
                    this._rafId = -1, this._ruafId = -1, this.Tick(e)
                },
                tickOnly: e => {
                    this._ruafId = -1, this.Tick(e, !1, "skip-render")
                },
                renderOnly: () => {
                    this._rafId = -1, this.Render()
                }
            }, this._rafId = -1, this._ruafId = -1, this._tickCount = 0, this._tickCountNoSave = 0, this._execCount = 0, this._hasStarted = !1, this._isInTick = !1, this._hasStartedTicking = !1, this._isLayoutFirstTick = !0, this._suspendCount = 0, this._scheduleTriggersThrottle = new e.PromiseThrottle(1), this._randomNumberCallback = () => Math.random(), this._startTime = 0, this._lastTickTime = 0, this._dt1 = 0, this._dt = 0, this._timeScale = 1, this._minimumFramerate = 30, this._gameTime = e.New(e.KahanSum), this._wallTime = e.New(e.KahanSum), this._fpsFrameCount = -1, this._fpsLastTime = 0, this._fps = 0, this._mainThreadTimeCounter = 0, this._mainThreadTime = 0, this._isLoadingState = !1, this._saveToSlotName = "", this._loadFromSlotName = "", this._loadFromJson = null, this._lastSaveJson = "", this._projectStorage = null, this._savegamesStorage = null, this._dispatcher = e.New(e.Event.Dispatcher), this._domEventHandlers = new Map, this._pendingResponsePromises = new Map, this._nextDomResponseId = 0, this._didRequestDeviceOrientationEvent = !1, this._didRequestDeviceMotionEvent = !1, this._isReadyToHandleEvents = !1, this._waitingToHandleEvents = [], this._eventObjects = {
                pretick: e.New(e.Event, "pretick", !1),
                tick: e.New(e.Event, "tick", !1),
                tick2: e.New(e.Event, "tick2", !1),
                instancedestroy: e.New(e.Event, "instancedestroy", !1),
                beforelayoutchange: e.New(e.Event, "beforelayoutchange", !1),
                layoutchange: e.New(e.Event, "layoutchange", !1)
            }, this._eventObjects.instancedestroy.instance = null, this._userScriptDispatcher = e.New(e.Event.Dispatcher), this._userScriptEventObjects = null, this._behInstsToTick = e.New(e.RedBlackSet, e.BehaviorInstance.SortByTickSequence), this._behInstsToPostTick = e.New(e.RedBlackSet, e.BehaviorInstance.SortByTickSequence), this._behInstsToTick2 = e.New(e.RedBlackSet, e.BehaviorInstance.SortByTickSequence), this._jobScheduler = e.New(e.JobSchedulerRuntime, this, t.jobScheduler), t.canvas && (this._canvasManager = e.New(e.CanvasManager, this)), this._messagePort.onmessage = e => this._OnMessageFromDOM(e.data), this.AddDOMComponentMessageHandler("runtime", "visibilitychange", e => this._OnVisibilityChange(e)), this.AddDOMComponentMessageHandler("runtime", "opus-decode", e => this._WasmDecodeWebMOpus(e.arrayBuffer)), this.AddDOMComponentMessageHandler("runtime", "get-remote-preview-status-info", () => this._GetRemotePreviewStatusInfo()), this.AddDOMComponentMessageHandler("runtime", "js-invoke-function", e => this._InvokeFunctionFromJS(e)), this.AddDOMComponentMessageHandler("runtime", "go-to-last-error-script", self.goToLastErrorScript), this._dispatcher.addEventListener("window-blur", e => this._OnWindowBlur(e)), this._dispatcher.addEventListener("window-focus", () => this._OnWindowFocus()), this._timelineManager.AddRuntimeListeners(), this._iRuntime = null, this._interfaceMap = new WeakMap, this._commonScriptInterfaces = {
                keyboard: null,
                mouse: null,
                touch: null
            }
        }
        static Create(t) {
            return e.New(e.Runtime, t)
        }
        Release() {
            e.clearArray(this._allObjectClasses), this._objectClassesByName.clear(), this._objectClassesBySid.clear(), this._layoutManager.Release(), this._layoutManager = null, this._eventSheetManager.Release(), this._eventSheetManager = null, this._pluginManager.Release(), this._pluginManager = null, this._assetManager.Release(), this._assetManager = null, this._collisionEngine.Release(), this._collisionEngine = null, this._timelineManager.Release(), this._timelineManager = null, this._transitionManager.Release(), this._transitionManager = null, this._canvasManager && (this._canvasManager.Release(), this._canvasManager = null), this._dispatcher.Release(), this._dispatcher = null, this._tickEvent = null
        } ["_OnMessageFromDOM"](e) {
            const t = e.type;
            if (t === "event") this._OnEventFromDOM(e);
            else if (t === "result") this._OnResultFromDOM(e);
            else throw new Error(`unknown message '${t}'`)
        }
        _OnEventFromDOM(t) {
            if (!this._isReadyToHandleEvents) {
                this._waitingToHandleEvents.push(t);
                return
            }
            const n = t.component,
                s = t.handler,
                r = t.data,
                a = t.dispatchOpts,
                c = !!(a && a.dispatchRuntimeEvent),
                l = !!(a && a.dispatchUserScriptEvent),
                o = t.responseId;
            if (n === "runtime") {
                if (c) {
                    const t = new e.Event(s);
                    t.data = r, this._dispatcher.dispatchEventAndWaitAsyncSequential(t)
                }
                if (l) {
                    const t = new e.Event(s, !0);
                    for (const [e, n] of Object.entries(r)) t[e] = n;
                    this.DispatchUserScriptEvent(t)
                }
            }
            const d = this._domEventHandlers.get(n);
            if (!d) {
                !c && !l && console.warn(`[Runtime] No DOM event handlers for component '${n}'`);
                return
            }
            const u = d.get(s);
            if (!u) {
                !c && !l && console.warn(`[Runtime] No DOM handler '${s}' for component '${n}'`);
                return
            }
            let i = null;
            try {
                i = u(r)
            } catch (e) {
                console.error(`Exception in '${n}' handler '${s}':`, e), o !== null && this._PostResultToDOM(o, !1, "" + e);
                return
            }
            o !== null && (i && i.then ? i.then(e => this._PostResultToDOM(o, !0, e)).catch(e => {
                console.error(`Rejection from '${n}' handler '${s}':`, e), this._PostResultToDOM(o, !1, "" + e)
            }) : this._PostResultToDOM(o, !0, i))
        }
        _PostResultToDOM(e, t, n) {
            this._messagePort.postMessage({
                type: "result",
                responseId: e,
                isOk: t,
                result: n
            })
        }
        _OnResultFromDOM(e) {
            const t = e.responseId,
                o = e.isOk,
                n = e.result,
                s = this._pendingResponsePromises.get(t);
            o ? s.resolve(n) : s.reject(n), this._pendingResponsePromises.delete(t)
        }
        AddDOMComponentMessageHandler(e, t, n) {
            let s = this._domEventHandlers.get(e);
            if (s || (s = new Map, this._domEventHandlers.set(e, s)), s.has(t)) throw new Error(`[Runtime] Component '${e}' already has handler '${t}'`);
            s.set(t, n)
        }
        PostComponentMessageToDOM(e, t, n) {
            this._messagePort.postMessage({
                type: "event",
                component: e,
                handler: t,
                data: n,
                responseId: null
            })
        }
        PostComponentMessageToDOMAsync(e, t, n) {
            const s = this._nextDomResponseId++,
                o = new Promise((e, t) => {
                    this._pendingResponsePromises.set(s, {
                        resolve: e,
                        reject: t
                    })
                });
            return this._messagePort.postMessage({
                type: "event",
                component: e,
                handler: t,
                data: n,
                responseId: s
            }), o
        }
        PostToDebugger(e) {
            if (!this.IsDebug()) throw new Error("not in debug mode");
            this.PostComponentMessageToDOM("runtime", "post-to-debugger", e)
        }
        async Init(n) {
            this.IsDebug() ? await t.Init(this) : self.C3Debugger && self.C3Debugger.InitPreview(this);
            const [o] = await Promise.all([this._assetManager.FetchJson("https://cdn.jsdelivr.net/gh/gahaden/ags@f4f7f1596bda19448c9534261835ec7a356baa17/data.json"), this._MaybeLoadOpusDecoder(), this._jobScheduler.Init()]);
            this._LoadDataJson(o), await this._InitialiseCanvas(n), this.IsPreview() || console.info("Made with Construct 3, the game and app creator :: https://www.construct.net");
            const s = this.GetWebGLRenderer();
            console.info(`[C3 runtime] Hosted in ${this.IsInWorker()?"worker":"DOM"}, using ${this._assetManager.GetScriptsType()} scripts, rendering with WebGL ${s.GetWebGLVersionNumber()} [${s.GetUnmaskedRenderer()}] (${s.IsDesynchronized()?"desynchronized":"standard"} compositing)`), s.HasMajorPerformanceCaveat() && console.warn("[C3 runtime] WebGL indicates a major performance caveat. Software rendering may be in use. This can result in significantly degraded performance."), this._isReadyToHandleEvents = !0;
            for (const e of this._waitingToHandleEvents) this._OnEventFromDOM(e);
            e.clearArray(this._waitingToHandleEvents), this._canvasManager && this._canvasManager.StartLoadingScreen();
            for (const e of n.runOnStartupFunctions) this._additionalLoadPromises.push(this._RunOnStartupFunction(e));
            if (await Promise.all([this._assetManager.WaitForAllToLoad(), ...this._additionalLoadPromises]), e.clearArray(this._additionalLoadPromises), this._assetManager.HasHadErrorLoading()) {
                this._canvasManager && this._canvasManager.HideCordovaSplashScreen();
                return
            }
            return this._canvasManager && await this._canvasManager.EndLoadingScreen(), await this._dispatcher.dispatchEventAndWaitAsync(new e.Event("beforeruntimestart")), await this.Start(), this._messagePort.postMessage({
                type: "runtime-ready"
            }), this
        }
        async _RunOnStartupFunction(e) {
            try {
                await e(this._iRuntime)
            } catch (e) {
                console.error("[C3 runtime] Error in runOnStartup function: ", e)
            }
        }
        _LoadDataJson(t) {
            const n = t.project;
            this._projectName = n[0], this._projectVersion = n[16], this._projectUniqueId = n[31], this._appId = n[38], this._loadingLogoFilename = n[39], this._isPixelRoundingEnabled = !!n[9], this._originalViewportWidth = this._viewportWidth = n[10], this._originalViewportHeight = this._viewportHeight = n[11], this._parallaxXorigin = this._originalViewportWidth / 2, this._parallaxYorigin = this._originalViewportHeight / 2, this._compositingMode = n[36], this._framerateMode = n[37], this._compositingMode === "low-latency" && this.IsAndroidWebView() && e.Platform.BrowserVersionNumber <= 77 && (console.warn("[C3 runtime] Desynchronized (low-latency) compositing is enabled, but is disabled in the Android WebView <=77 due to crbug.com/1008842. Reverting to synchronized (standard) compositing."), this._compositingMode = "standard"), this._sampling = n[14], this._usesLoaderLayout = !!n[18], this._loaderStyle = n[19], this._nextUid = n[21], this._pauseOnBlur = n[22], this._assetManager._SetAudioFiles(n[7], n[25]), this._assetManager._SetMediaSubfolder(n[8]), this._assetManager._SetFontsSubfolder(n[32]), this._assetManager._SetIconsSubfolder(n[28]), this._assetManager._SetWebFonts(n[29]), this._canvasManager && (this._canvasManager.SetFullscreenMode(e.CanvasManager._FullscreenModeNumberToString(n[12])), this._canvasManager.SetFullscreenScalingQuality(n[23] ? "high" : "low"), this._canvasManager.SetMipmapsEnabled(n[24] !== 0), this._canvasManager._SetGPUPowerPreference(n[34])), this._pluginManager.CreateSystemPlugin(), this._objectReferenceTable = self.C3_GetObjectRefTable();
            for (const e of n[2]) this._pluginManager.CreatePlugin(e);
            this._objectReferenceTable = self.C3_GetObjectRefTable(), this._LoadJsPropNameTable();
            for (const s of n[3]) {
                const t = e.ObjectClass.Create(this, this._allObjectClasses.length, s);
                this._allObjectClasses.push(t), this._objectClassesByName.set(t.GetName().toLowerCase(), t), this._objectClassesBySid.set(t.GetSID(), t)
            }
            for (const e of n[4]) {
                const t = this._allObjectClasses[e[0]];
                t._LoadFamily(e)
            }
            for (const t of n[27]) {
                const s = t.map(e => this._allObjectClasses[e]);
                this._allContainers.push(e.New(e.Container, this, s))
            }
            for (const e of this._allObjectClasses) e._OnAfterCreate();
            for (const e of n[5]) this._layoutManager.Create(e);
            const o = n[1];
            if (o) {
                const e = this._layoutManager.GetLayoutByName(o);
                e && this._layoutManager.SetFirstLayout(e)
            }
            for (const e of n[33]) this._timelineManager.Create(e);
            for (const e of n[35]) this._transitionManager.Create(e);
            this._InitScriptInterfaces();
            for (const e of n[6]) this._eventSheetManager.Create(e);
            this._eventSheetManager._PostInit(), this._InitGlobalVariableScriptInterface(), e.clearArray(this._objectReferenceTable), this.FlushPendingInstances();
            let s = "any";
            const i = n[20];
            i === 1 ? s = "portrait" : i === 2 && (s = "landscape"), this.PostComponentMessageToDOM("runtime", "set-target-orientation", {
                targetOrientation: s
            })
        }
        GetLoaderStyle() {
            return this._loaderStyle
        }
        IsFBInstantAvailable() {
            return this._isFBInstantAvailable
        }
        IsLoading() {
            return this._isLoading
        }
        AddLoadPromise(e) {
            this._additionalLoadPromises.push(e)
        }
        SetUsingCreatePromises(e) {
            this._isUsingCreatePromises = !!e
        }
        AddCreatePromise(e) {
            if (!this._isUsingCreatePromises) return;
            this._additionalCreatePromises.push(e)
        }
        GetCreatePromises() {
            return this._additionalCreatePromises
        }
        _GetNextFamilyIndex() {
            return this._familyCount++
        }
        GetFamilyCount() {
            return this._familyCount
        }
        _AddEffectList(e) {
            this._allEffectLists.push(e)
        }
        _GetAllEffectLists() {
            return this._allEffectLists
        }
        async _InitialiseCanvas(e) {
            if (!this._canvasManager) return;
            await this._canvasManager.CreateCanvas(e), this._canvasManager.InitLoadingScreen(this._loaderStyle)
        }
        async _MaybeLoadOpusDecoder() {
            if (this._assetManager.IsAudioFormatSupported("audio/webm; codecs=opus")) return;
            let t = null,
                e = null;
            try {
                this.IsiOSCordova() && location.protocol === "file:" ? e = await this._assetManager.CordovaFetchLocalFileAsArrayBuffer(this._opusWasmBinaryUrl) : t = await this._assetManager.FetchBlob(this._opusWasmBinaryUrl)
            } catch (e) {
                console.info("Failed to fetch Opus decoder WASM; assuming project has no Opus audio.", e);
                return
            }
            e ? this.AddJobWorkerBuffer(e, "opus-decoder-wasm") : this.AddJobWorkerBlob(t, "opus-decoder-wasm"), await this.AddJobWorkerScripts([this._opusWasmScriptUrl])
        }
        async _WasmDecodeWebMOpus(e) {
            const t = await this.AddJob("OpusDecode", {
                arrayBuffer: e
            }, [e]);
            return t
        }
        async Start() {
            if (this._hasStarted = !0, this._startTime = Date.now(), this._usesLoaderLayout) {
                for (const e of this._allObjectClasses) !e.IsFamily() && !e.IsOnLoaderLayout() && e.IsWorldType() && e.OnCreate();
                this._assetManager.WaitForAllToLoad().then(() => {
                    this._isLoading = !1, this._OnLoadFinished()
                })
            } else this._isLoading = !1;
            this._assetManager.SetInitialLoadFinished(), this.IsDebug() && t.RuntimeInit(n);
            for (const e of this._layoutManager.GetAllLayouts()) e._CreateGlobalNonWorlds();
            const e = this._layoutManager.GetFirstLayout();
            await e._Load(null, this.GetWebGLRenderer()), await e._StartRunning(!0), this._fpsLastTime = performance.now(), this._usesLoaderLayout || this._OnLoadFinished();
            const s = await this.PostComponentMessageToDOMAsync("runtime", "before-start-ticking");
            s.isSuspended ? this._suspendCount++ : this.Tick()
        }
        _OnLoadFinished() {
            this.Trigger(e.Plugins.System.Cnds.OnLoadFinished, null, null), this.PostComponentMessageToDOM("runtime", "register-sw")
        }
        GetObjectReference(e) {
            e = Math.floor(e);
            const t = this._objectReferenceTable;
            if (e < 0 || e >= t.length) throw new Error("invalid object reference");
            return t[e]
        }
        _LoadJsPropNameTable() {
            for (const t of self.C3_JsPropNameTable) {
                const n = e.first(Object.keys(t));
                this._jsPropNameTable.push(n)
            }
        }
        GetJsPropName(e) {
            e = Math.floor(e);
            const t = this._jsPropNameTable;
            if (e < 0 || e >= t.length) throw new Error("invalid prop reference");
            return t[e]
        }
        HasDOM() {
            return this._hasDom
        }
        IsHeadless() {
            return this._isHeadless
        }
        IsInWorker() {
            return this._isInWorker
        }
        GetBaseURL() {
            return this._baseUrl
        }
        GetEventSheetManager() {
            return this._eventSheetManager
        }
        GetEventStack() {
            return this._eventSheetManager.GetEventStack()
        }
        GetCurrentEventStackFrame() {
            return this._eventSheetManager.GetCurrentEventStackFrame()
        }
        GetCurrentEvent() {
            return this._eventSheetManager.GetCurrentEvent()
        }
        GetCurrentCondition() {
            return this._eventSheetManager.GetCurrentCondition()
        }
        IsCurrentConditionFirst() {
            return this.GetCurrentEventStackFrame().GetConditionIndex() === 0
        }
        GetCurrentAction() {
            return this._eventSheetManager.GetCurrentAction()
        }
        GetPluginManager() {
            return this._pluginManager
        }
        GetSystemPlugin() {
            return this._pluginManager.GetSystemPlugin()
        }
        GetObjectClassByIndex(e) {
            if (e = Math.floor(e), e < 0 || e >= this._allObjectClasses.length) throw new RangeError("invalid index");
            return this._allObjectClasses[e]
        }
        GetObjectClassByName(e) {
            return this._objectClassesByName.get(e.toLowerCase()) || null
        }
        GetObjectClassBySID(e) {
            return this._objectClassesBySid.get(e) || null
        }
        GetSingleGlobalObjectClassByCtor(e) {
            const t = this._pluginManager.GetPluginByConstructorFunction(e);
            return t ? t.GetSingleGlobalObjectClass() : null
        }
        GetAllObjectClasses() {
            return this._allObjectClasses
        }
        Dispatcher() {
            return this._dispatcher
        }
        UserScriptDispatcher() {
            return this._userScriptDispatcher
        }
        DispatchUserScriptEvent(e) {
            e.runtime = this.GetIRuntime();
            const n = this.IsDebug() && !this._eventSheetManager.IsInEventEngine();
            n && t.StartMeasuringScriptTime(), this._userScriptDispatcher.dispatchEvent(e), n && t.AddScriptTime()
        }
        DispatchUserScriptEventAsyncWait(e) {
            return e.runtime = this.GetIRuntime(), this._userScriptDispatcher.dispatchEventAndWaitAsync(e)
        }
        GetOriginalViewportWidth() {
            return this._originalViewportWidth
        }
        GetOriginalViewportHeight() {
            return this._originalViewportHeight
        }
        SetOriginalViewportSize(e, t) {
            this._originalViewportWidth = e, this._originalViewportHeight = t
        }
        GetViewportWidth() {
            return this._viewportWidth
        }
        GetViewportHeight() {
            return this._viewportHeight
        }
        SetViewportSize(e, t) {
            this._viewportWidth = e, this._viewportHeight = t
        }
        _SetDevicePixelRatio(e) {
            this._devicePixelRatio = e
        }
        GetDevicePixelRatio() {
            return this._devicePixelRatio
        }
        GetParallaxXOrigin() {
            return this._parallaxXorigin
        }
        GetParallaxYOrigin() {
            return this._parallaxYorigin
        }
        GetCanvasManager() {
            return this._canvasManager
        }
        GetDrawWidth() {
            return this._canvasManager ? this._canvasManager.GetDrawWidth() : this._viewportWidth
        }
        GetDrawHeight() {
            return this._canvasManager ? this._canvasManager.GetDrawHeight() : this._viewportHeight
        }
        GetRenderScale() {
            return this._canvasManager ? this._canvasManager.GetRenderScale() : 1
        }
        GetDisplayScale() {
            return this._canvasManager ? this._canvasManager.GetDisplayScale() : 1
        }
        GetCanvasClientX() {
            return this._canvasManager ? this._canvasManager.GetCanvasClientX() : 0
        }
        GetCanvasClientY() {
            return this._canvasManager ? this._canvasManager.GetCanvasClientY() : 0
        }
        GetCanvasCssWidth() {
            return this._canvasManager ? this._canvasManager.GetCssWidth() : 0
        }
        GetCanvasCssHeight() {
            return this._canvasManager ? this._canvasManager.GetCssHeight() : 0
        }
        GetFullscreenMode() {
            return this._canvasManager ? this._canvasManager.GetFullscreenMode() : "off"
        }
        GetAdditionalRenderTarget(e) {
            return this._canvasManager ? this._canvasManager.GetAdditionalRenderTarget(e) : null
        }
        ReleaseAdditionalRenderTarget(e) {
            if (!this._canvasManager) return;
            this._canvasManager.ReleaseAdditionalRenderTarget(e)
        }
        _SetUsesAnyBackgroundBlending(e) {
            this._usesAnyBackgroundBlending = !!e
        }
        UsesAnyBackgroundBlending() {
            return this._usesAnyBackgroundBlending
        }
        GetGPUUtilisation() {
            return this._canvasManager ? this._canvasManager.GetGPUUtilisation() : NaN
        }
        IsLinearSampling() {
            return this.GetSampling() !== "nearest"
        }
        GetFramerateMode() {
            return this._framerateMode
        }
        GetCompositingMode() {
            return this._compositingMode
        }
        GetSampling() {
            return this._sampling
        }
        UsesLoaderLayout() {
            return this._usesLoaderLayout
        }
        GetLoadingLogoFilename() {
            return this._loadingLogoFilename
        }
        GetLayoutManager() {
            return this._layoutManager
        }
        GetMainRunningLayout() {
            return this._layoutManager.GetMainRunningLayout()
        }
        GetTimelineManager() {
            return this._timelineManager
        }
        GetTransitionManager() {
            return this._transitionManager
        }
        GetAssetManager() {
            return this._assetManager
        }
        LoadImage(e) {
            return this._assetManager.LoadImage(e)
        }
        CreateInstance(e, t, n, s, o) {
            return this.CreateInstanceFromData(e, t, !1, n, s, !1, o)
        }
        CreateInstanceFromData(n, s, o, i, a, r, c) {
            let u = null,
                l = null;
            if (n instanceof e.ObjectClass) {
                if (l = n, l.IsFamily()) {
                    const e = l.GetFamilyMembers(),
                        t = Math.floor(this.Random() * e.length);
                    l = e[t]
                }
                u = l.GetDefaultInstanceData()
            } else u = n, l = this.GetObjectClassByIndex(u[1]);
            const f = l.GetPlugin().IsWorldType();
            if (this._isLoading && f && !l.IsOnLoaderLayout()) return null;
            const v = s;
            f || (s = null);
            let p;
            o && !r && u && !this._instancesByUid.has(u[2]) ? p = u[2] : p = this._nextUid++;
            const m = u ? u[0] : null,
                d = e.New(e.Instance, {
                    runtime: this,
                    objectType: l,
                    layer: s,
                    worldData: m,
                    instVarData: u ? u[3] : null,
                    uid: p
                });
            this._instancesByUid.set(p, d);
            let h = null;
            if (f && (h = d.GetWorldInfo(), typeof i != "undefined" && typeof a != "undefined" && (h.SetX(i), h.SetY(a)), l._SetAnyCollisionCellChanged(!0)), s && (s._AddInstance(d, !0), (s.GetParallaxX() !== 1 || s.GetParallaxY() !== 1) && l._SetAnyInstanceParallaxed(!0), s.GetLayout().MaybeLoadTexturesFor(l)), this._objectCount++, l.IsInContainer() && !o && !r) {
                for (const e of l.GetContainer().objectTypes()) {
                    if (e === l) continue;
                    const t = this.CreateInstanceFromData(e, v, !1, h ? h.GetX() : i, h ? h.GetY() : a, !0, !1);
                    d._AddSibling(t)
                }
                for (const e of d.siblings()) {
                    e._AddSibling(d);
                    for (const t of d.siblings()) e !== t && e._AddSibling(t)
                }
            }
            if (f && !o && !!c && this._CreateChildInstancesFromData(d, m, h, s, i, a), l.IsInContainer() && !o && !r && !!c)
                for (const e of d.siblings()) {
                    const t = e.GetWorldInfo(),
                        n = e.GetObjectClass().GetDefaultInstanceData()[0];
                    this._CreateChildInstancesFromData(e, n, t, s, t.GetX(), t.GetY())
                }
            if (!r && !!c) {
                typeof i == "undefined" && (i = m[0]), typeof a == "undefined" && (a = m[1]);
                const e = h.GetTopParent(),
                    t = i - h.GetX() + e.GetX(),
                    n = a - h.GetY() + e.GetY();
                e.SetXY(t, n)
            }
            l._SetIIDsStale();
            const b = u ? e.cloneArray(u[5]) : null,
                j = u ? u[4].map(t => e.cloneArray(t)) : null,
                g = f && m && m.length === 14;
            if (g && d._SetHasTilemap(), d._CreateSdkInstance(b, j), g) {
                const e = m[13];
                d.GetSdkInstance().LoadTilemapData(e[2], e[0], e[1])
            }
            return this._instancesPendingCreate.push(d), this._hasPendingInstances = !0, this.IsDebug() && t.InstanceCreated(d), d
        }
        _CreateChildInstancesFromData(e, t, n, s, o, i) {
            const a = n.GetSceneGraphChildrenExportData();
            if (!a) return;
            typeof o == "undefined" && (o = t[0]), typeof i == "undefined" && (i = t[1]);
            const r = new Set,
                c = t[0],
                l = t[1];
            for (const d of a) {
                const h = d[0],
                    m = d[1],
                    f = d[2],
                    t = d[3],
                    p = !!d[4],
                    g = this._layoutManager.GetLayoutBySID(h),
                    v = g.GetLayer(m),
                    n = v.GetInitialInstanceData(f),
                    u = this.GetObjectClassByIndex(n[1]),
                    b = e.HasSibling(u),
                    j = r.has(u);
                if (b && !j && p) {
                    const s = e.GetSibling(u),
                        a = o + n[0][0] - c,
                        d = i + n[0][1] - l;
                    s.GetWorldInfo().SetXY(a, d), e.AddChild(s, {
                        transformX: !!(t >> 0 & 1),
                        transformY: !!(t >> 1 & 1),
                        transformWidth: !!(t >> 2 & 1),
                        transformHeight: !!(t >> 3 & 1),
                        transformAngle: !!(t >> 4 & 1),
                        destroyWithParent: !!(t >> 5 & 1),
                        transformZElevation: !!(t >> 6 & 1)
                    }), r.add(u)
                } else {
                    const a = o + n[0][0] - c,
                        r = i + n[0][1] - l,
                        d = this.CreateInstanceFromData(n, s, !1, a, r, !1, !0);
                    e.AddChild(d, {
                        transformX: !!(t >> 0 & 1),
                        transformY: !!(t >> 1 & 1),
                        transformWidth: !!(t >> 2 & 1),
                        transformHeight: !!(t >> 3 & 1),
                        transformAngle: !!(t >> 4 & 1),
                        destroyWithParent: !!(t >> 5 & 1),
                        transformZElevation: !!(t >> 6 & 1)
                    })
                }
            }
        }
        DestroyInstance(e) {
            if (this._instancesToReleaseAtEndOfTick.has(e)) return;
            const s = e.GetObjectClass();
            let n = this._instancesPendingDestroy.get(s);
            if (n) {
                if (n.has(e)) return;
                n.add(e)
            } else n = new Set, n.add(e), this._instancesPendingDestroy.set(s, n);
            if (this.IsDebug() && t.InstanceDestroyed(e), e._MarkDestroyed(), this._hasPendingInstances = !0, e.IsInContainer())
                for (const t of e.siblings()) this.DestroyInstance(t);
            for (const t of e.children()) t.GetDestroyWithParent() && this.DestroyInstance(t);
            if (!this._layoutManager.IsEndingLayout() && !this._isLoadingState) {
                const t = this.GetEventSheetManager();
                t.BlockFlushingInstances(!0), e._TriggerOnDestroyed(), t.BlockFlushingInstances(!1)
            }
            e._FireDestroyedScriptEvents(this._layoutManager.IsEndingLayout())
        }
        FlushPendingInstances() {
            if (!this._hasPendingInstances) return;
            this._isFlushingPendingInstances = !0, this._FlushInstancesPendingCreate(), this._FlushInstancesPendingDestroy(), this._isFlushingPendingInstances = !1, this._hasPendingInstances = !1, this.UpdateRender()
        }
        _FlushInstancesPendingCreate() {
            for (const e of this._instancesPendingCreate) {
                const t = e.GetObjectClass();
                t._AddInstance(e);
                for (const n of t.GetFamilies()) n._AddInstance(e), n._SetIIDsStale()
            }
            e.clearArray(this._instancesPendingCreate)
        }
        _FlushInstancesPendingDestroy() {
            this._dispatcher.SetDelayRemoveEventsEnabled(!0);
            for (const [t, e] of this._instancesPendingDestroy.entries()) this._FlushInstancesPendingDestroyForObjectClass(t, e), e.clear();
            this._instancesPendingDestroy.clear(), this._dispatcher.SetDelayRemoveEventsEnabled(!1)
        }
        _FlushInstancesPendingDestroyForObjectClass(t, n) {
            for (const e of n) {
                const s = this._eventObjects.instancedestroy;
                s.instance = e, this._dispatcher.dispatchEvent(s), this._instancesByUid.delete(e.GetUID());
                const t = e.GetWorldInfo();
                t && (t._RemoveFromCollisionCells(), t._RemoveFromRenderCells()), this._instancesToReleaseAtEndOfTick.add(e), this._objectCount--
            }
            e.arrayRemoveAllInSet(t.GetInstances(), n), t._SetIIDsStale(), this._instancesToReleaseAffectedObjectClasses.add(t), t.GetInstances().length === 0 && t._SetAnyInstanceParallaxed(!1);
            for (const s of t.GetFamilies()) e.arrayRemoveAllInSet(s.GetInstances(), n), s._SetIIDsStale(), this._instancesToReleaseAffectedObjectClasses.add(s);
            if (t.GetPlugin().IsWorldType()) {
                const e = new Set([...n].map(e => e.GetWorldInfo().GetLayer()));
                for (const t of e) t._RemoveAllInstancesInSet(n)
            }
        }
        _GetInstancesPendingCreate() {
            return this._instancesPendingCreate
        }
        _GetNewUID() {
            return this._nextUid++
        }
        _MapInstanceByUID(e, t) {
            this._instancesByUid.set(e, t)
        }
        _OnWebGLContextLost() {
            this._dispatcher.dispatchEvent(e.New(e.Event, "webglcontextlost")), this.SetSuspended(!0);
            for (const e of this._allObjectClasses) !e.IsFamily() && e.HasLoadedTextures() && e.ReleaseTextures();
            const t = this.GetMainRunningLayout();
            t && t._OnWebGLContextLost(), e.ImageInfo.OnWebGLContextLost(), e.ImageAsset.OnWebGLContextLost()
        }
        async _OnWebGLContextRestored() {
            await this.GetMainRunningLayout()._Load(null, this.GetWebGLRenderer()), this._dispatcher.dispatchEvent(e.New(e.Event, "webglcontextrestored")), this.SetSuspended(!1), this.UpdateRender()
        }
        _OnVisibilityChange(e) {
            this.SetSuspended(e.hidden)
        }
        _OnWindowBlur(t) {
            if (!this.IsPreview() || !this._pauseOnBlur || e.Platform.IsMobile) return;
            t.data.parentHasFocus || (this.SetSuspended(!0), this._isPausedOnBlur = !0)
        }
        _OnWindowFocus() {
            if (!this._isPausedOnBlur) return;
            this.SetSuspended(!1), this._isPausedOnBlur = !1
        }
        _RequestAnimationFrame() {
            const t = this._tickCallbacks;
            this._framerateMode === "vsync" ? this._rafId === -1 && (this._rafId = e.RequestPostAnimationFrame(t.normal)) : this._framerateMode === "unlimited-tick" ? (this._ruafId === -1 && (this._ruafId = e.RequestUnlimitedAnimationFrame(t.tickOnly)), this._rafId === -1 && (this._rafId = e.RequestPostAnimationFrame(t.renderOnly))) : this._ruafId === -1 && (this._ruafId = e.RequestUnlimitedAnimationFrame(t.normal))
        }
        _CancelAnimationFrame() {
            this._rafId !== -1 && (e.CancelPostAnimationFrame(this._rafId), this._rafId = -1), this._ruafId !== -1 && (e.CancelUnlimitedAnimationFrame(this._ruafId), this._ruafId = -1)
        }
        IsSuspended() {
            return this._suspendCount > 0
        }
        SetSuspended(t) {
            const n = this.IsSuspended();
            this._suspendCount += t ? 1 : -1, this._suspendCount < 0 && (this._suspendCount = 0);
            const s = this.IsSuspended();
            if (!n && s) console.log("[Construct 3] Suspending"), this._CancelAnimationFrame(), this._dispatcher.dispatchEvent(e.New(e.Event, "suspend")), this.Trigger(e.Plugins.System.Cnds.OnSuspend, null, null);
            else if (n && !s) {
                console.log("[Construct 3] Resuming");
                const t = performance.now();
                this._lastTickTime = t, this._fpsLastTime = t, this._fpsFrameCount = 0, this._fps = 0, this._mainThreadTime = 0, this._mainThreadTimeCounter = 0, this._dispatcher.dispatchEvent(e.New(e.Event, "resume")), this.Trigger(e.Plugins.System.Cnds.OnResume, null, null), this.HitBreakpoint() || this.Tick(t)
            }
        }
        _AddBehInstToTick(e) {
            this._behInstsToTick.Add(e)
        }
        _AddBehInstToPostTick(e) {
            this._behInstsToPostTick.Add(e)
        }
        _AddBehInstToTick2(e) {
            this._behInstsToTick2.Add(e)
        }
        _RemoveBehInstToTick(e) {
            this._behInstsToTick.Remove(e)
        }
        _RemoveBehInstToPostTick(e) {
            this._behInstsToPostTick.Remove(e)
        }
        _RemoveBehInstToTick2(e) {
            this._behInstsToTick2.Remove(e)
        }
        _BehaviorTick() {
            this._behInstsToTick.SetQueueingEnabled(!0);
            for (const e of this._behInstsToTick) e.Tick();
            this._behInstsToTick.SetQueueingEnabled(!1)
        }
        _BehaviorPostTick() {
            this._behInstsToPostTick.SetQueueingEnabled(!0);
            for (const e of this._behInstsToPostTick) e.PostTick();
            this._behInstsToPostTick.SetQueueingEnabled(!1)
        }
        _BehaviorTick2() {
            this._behInstsToTick2.SetQueueingEnabled(!0);
            for (const e of this._behInstsToTick2) e.Tick2();
            this._behInstsToTick2.SetQueueingEnabled(!1)
        }* _DebugBehaviorTick() {
            this._behInstsToTick.SetQueueingEnabled(!0);
            for (const n of this._behInstsToTick) {
                const t = n.Tick();
                e.IsIterator(t) && (yield* t)
            }
            this._behInstsToTick.SetQueueingEnabled(!1)
        }* _DebugBehaviorPostTick() {
            this._behInstsToPostTick.SetQueueingEnabled(!0);
            for (const n of this._behInstsToPostTick) {
                const t = n.PostTick();
                e.IsIterator(t) && (yield* t)
            }
            this._behInstsToPostTick.SetQueueingEnabled(!1)
        }* _DebugBehaviorTick2() {
            this._behInstsToTick2.SetQueueingEnabled(!0);
            for (const n of this._behInstsToTick2) {
                const t = n.Tick2();
                e.IsIterator(t) && (yield* t)
            }
            this._behInstsToTick2.SetQueueingEnabled(!1)
        }
        async Tick(e, t, n) {
            this._hasStartedTicking = !0;
            const s = n === "background-wake",
                a = n !== "background-wake" && n !== "skip-render";
            if (!this._hasStarted || this.IsSuspended() && !t && !s) return;
            const o = performance.now();
            this._isInTick = !0, e || (e = o), this._MeasureDt(e);
            const r = this.Step_BeforePreTick();
            this.IsDebugging() && await r;
            const i = this._dispatcher.dispatchEventAndWait_AsyncOptional(this._eventObjects.pretick);
            i instanceof Promise && await i;
            const c = this.Step_AfterPreTick();
            this.IsDebugging() && await c, this._NeedsHandleSaveOrLoad() && await this._HandleSaveOrLoad(), this.GetLayoutManager().IsPendingChangeMainLayout() && await this._MaybeChangeLayout();
            const l = this.Step_RunEventsEtc();
            this.IsDebugging() && await l, a && this.Render(), !this.IsSuspended() && !s && this._RequestAnimationFrame(), this._tickCount++, this._tickCountNoSave++, this._execCount++, this._isInTick = !1, this._mainThreadTimeCounter += performance.now() - o
        }
        async Step_BeforePreTick() {
            const e = this._eventSheetManager,
                n = this.IsDebug();
            this.FlushPendingInstances(), e.BlockFlushingInstances(!0), this.PushCurrentLayout(this.GetMainRunningLayout()), n && t.StartMeasuringTime(), this.IsDebugging() ? await e.DebugRunScheduledWaits() : e.RunScheduledWaits(), n && t.AddEventsTime(), this.PopCurrentLayout(), e.BlockFlushingInstances(!1), this.FlushPendingInstances(), e.BlockFlushingInstances(!0)
        }
        async Step_AfterPreTick() {
            const e = this.IsDebug(),
                n = this.IsDebugging(),
                o = this._dispatcher,
                s = this._eventObjects,
                i = this._userScriptEventObjects;
            e && t.StartMeasuringTime(), n ? await this.DebugIterateAndBreak(this._DebugBehaviorTick()) : this._BehaviorTick(), n ? await this.DebugIterateAndBreak(this._DebugBehaviorPostTick()) : this._BehaviorPostTick(), e && t.AddBehaviorTickTime(), e && t.StartMeasuringTime(), n ? await this.DebugFireGeneratorEventAndBreak(s.tick) : o.dispatchEvent(s.tick), e && t.AddPluginTickTime(), this._eventSheetManager.BlockFlushingInstances(!1), this.DispatchUserScriptEvent(i.tick)
        }
        async Step_RunEventsEtc() {
            const n = this._eventSheetManager,
                o = this._dispatcher,
                i = this._eventObjects,
                e = this.IsDebug(),
                s = this.IsDebugging();
            if (e && t.StartMeasuringTime(), s ? await n.DebugRunEvents(this._layoutManager) : n.RunEvents(this._layoutManager), e && t.AddEventsTime(), this._collisionEngine.ClearRegisteredCollisions(), this._instancesToReleaseAtEndOfTick.size > 0) {
                o.SetDelayRemoveEventsEnabled(!0);
                for (const e of this._instancesToReleaseAffectedObjectClasses) e.GetSolStack().RemoveInstances(this._instancesToReleaseAtEndOfTick);
                this._instancesToReleaseAffectedObjectClasses.clear(), this._eventSheetManager.RemoveInstancesFromScheduledWaits(this._instancesToReleaseAtEndOfTick);
                for (const e of this._instancesToReleaseAtEndOfTick) e.Release();
                this._instancesToReleaseAtEndOfTick.clear(), o.SetDelayRemoveEventsEnabled(!1)
            }
            this._isLayoutFirstTick = !1, n.BlockFlushingInstances(!0), e && t.StartMeasuringTime(), s ? await this.DebugIterateAndBreak(this._DebugBehaviorTick2()) : this._BehaviorTick2(), e && t.AddBehaviorTickTime(), e && t.StartMeasuringTime(), s ? await this.DebugFireGeneratorEventAndBreak(i.tick2) : o.dispatchEvent(i.tick2), e && t.AddPluginTickTime(), n.BlockFlushingInstances(!1), s && await n.RunQueuedDebugTriggersAsync()
        }
        async _MaybeChangeLayout() {
            const e = this.GetLayoutManager();
            let t = 0;
            for (; e.IsPendingChangeMainLayout() && t++ < 10;) await this._DoChangeLayout(e.GetPendingChangeMainLayout())
        }
        _MeasureDt(e) {
            if (this._lastTickTime !== 0) {
                const n = Math.max(e - this._lastTickTime, 0);
                this._dt1 = n / 1e3;
                const t = 1 / this._minimumFramerate;
                this._dt1 > .5 ? this._dt1 = 0 : this._dt1 > t && (this._dt1 = t)
            }
            this._lastTickTime = e, this._dt = this._dt1 * this._timeScale, this._gameTime.Add(this._dt), this._wallTime.Add(this._dt1), this._canvasManager && this._canvasManager._UpdateTick(), e - this._fpsLastTime >= 1e3 && (this._fpsLastTime += 1e3, e - this._fpsLastTime >= 1e3 && (this._fpsLastTime = e), this._fps = this._fpsFrameCount, this._fpsFrameCount = 0, this._mainThreadTime = Math.min(this._mainThreadTimeCounter / 1e3, 1), this._mainThreadTimeCounter = 0, this._canvasManager && this._canvasManager._Update1sFrameRange(), this._collisionEngine._Update1sStats(), this.IsDebug() && t.Update1sPerfStats()), this._fpsFrameCount++
        }
        async _DoChangeLayout(t) {
            const s = this._dispatcher,
                o = this.GetLayoutManager(),
                n = o.GetMainRunningLayout();
            await n._StopRunning(), n._Unload(t, this.GetWebGLRenderer()), n === t && this._eventSheetManager.ClearAllScheduledWaits(), this._collisionEngine.ClearRegisteredCollisions(), s.dispatchEvent(this._eventObjects.beforelayoutchange), e.Asyncify.SetHighThroughputMode(!0), await t._Load(n, this.GetWebGLRenderer()), e.Asyncify.SetHighThroughputMode(!1), await t._StartRunning(!1), s.dispatchEvent(this._eventObjects.layoutchange), this.UpdateRender(), this._isLayoutFirstTick = !0, this.FlushPendingInstances()
        }
        UpdateRender() {
            this._needRender = !0
        }
        GetWebGLRenderer() {
            return this._canvasManager ? this._canvasManager.GetWebGLRenderer() : null
        }
        GetRenderer() {
            return this.GetWebGLRenderer()
        }
        Render() {
            if (!this._canvasManager || this._canvasManager.IsWebGLContextLost()) return;
            const e = this.GetWebGLRenderer();
            if (e.Start(), e.CheckForQueryResults(), !this._needRender) {
                e.IncrementFrameNumber();
                return
            }
            const s = this.IsDebug();
            s && t.StartMeasuringTime(), this._needRender = !1;
            let n = null;
            e.SupportsGPUProfiling() && (n = this._canvasManager.GetGPUFrameTimingsBuffer().AddTimeElapsedQuery(), e.StartQuery(n)), e.SetTextureFillMode(), e.SetAlphaBlend(), e.SetColorRgba(1, 1, 1, 1), e.SetRenderTarget(null), e.SetTexture(null);
            const o = this._layoutManager.GetMainRunningLayout();
            o.Draw(e), n && e.EndQuery(n), e.Finish(), s && (t.AddDrawCallsTime(), t.UpdateInspectHighlight()), this._canvasManager && this._canvasManager._MaybeTakeSnapshot()
        }
        Trigger(e, n, s) {
            if (!this._hasStarted) return !1;
            const i = !this._isInTick && !this._eventSheetManager.IsInTrigger();
            let a = 0;
            i && (a = performance.now());
            const o = this.IsDebug();
            o && this.SetDebuggingEnabled(!1);
            const r = this._eventSheetManager._Trigger(this._layoutManager, e, n, s);
            if (i) {
                const e = performance.now() - a;
                this._mainThreadTimeCounter += e, o && t.AddTriggersTime(e)
            }
            return o && this.SetDebuggingEnabled(!0), r
        }
        DebugTrigger(e, t, n) {
            if (!this.IsDebug()) return this.Trigger(e, t, n);
            if (this.HitBreakpoint()) throw new Error("called DebugTrigger() while stopped on breakpoint");
            if (!this._isInTick && !this._eventSheetManager.IsInTrigger()) throw new Error("called DebugTrigger() outside of event code - use TriggerAsync() instead");
            return this._eventSheetManager._DebugTrigger(this._layoutManager, e, t, n)
        }
        async TriggerAsync(e, t, n) {
            if (!this.IsDebugging()) return this.Trigger(e, t, n);
            if (!this._hasStarted) return !1;
            if (this.HitBreakpoint()) return this._eventSheetManager.QueueDebugTrigger(e, t, n);
            if (!this.GetMainRunningLayout()) return this._eventSheetManager.QueueTrigger(e, t, n);
            const i = performance.now(),
                o = this._eventSheetManager._DebugTrigger(this._layoutManager, e, t, n);
            let s = o.next();
            for (; !s.done;) await this.DebugBreak(s.value), s = o.next();
            return !this.IsSuspended() && !this._eventSheetManager.IsInTrigger() && (await this._eventSheetManager.RunQueuedDebugTriggersAsync(), this._hasStartedTicking && !this._isInTick && this._RequestAnimationFrame()), this._mainThreadTimeCounter += performance.now() - i, s.value
        }
        FastTrigger(e, t, n) {
            const s = this.IsDebug();
            s && this.SetDebuggingEnabled(!1);
            const o = this._eventSheetManager._FastTrigger(this._layoutManager, e, t, n);
            return s && this.SetDebuggingEnabled(!0), o
        }
        DebugFastTrigger(e, t, n) {
            return this._eventSheetManager._DebugFastTrigger(this._layoutManager, e, t, n)
        }
        ScheduleTriggers(e) {
            return this._scheduleTriggersThrottle.Add(e)
        }
        PushCurrentLayout(e) {
            this._currentLayoutStack.push(e)
        }
        PopCurrentLayout() {
            if (!this._currentLayoutStack.length) throw new Error("layout stack empty");
            this._currentLayoutStack.pop()
        }
        GetCurrentLayout() {
            return this._currentLayoutStack.length ? this._currentLayoutStack[this._currentLayoutStack.length - 1] : this.GetMainRunningLayout()
        }
        GetDt(e) {
            return !e || e.GetTimeScale() === -1 ? this._dt : this._dt1 * e.GetTimeScale()
        }
        _GetDtFast() {
            return this._dt
        }
        GetDt1() {
            return this._dt1
        }
        GetTimeScale() {
            return this._timeScale
        }
        SetTimeScale(e) {
            (isNaN(e) || e < 0) && (e = 0), this._timeScale = e
        }
        SetMinimumFramerate(t) {
            this._minimumFramerate = e.clamp(t, 1, 120)
        }
        GetMinimumFramerate() {
            return this._minimumFramerate
        }
        GetFPS() {
            return this._fps
        }
        GetMainThreadTime() {
            return this._mainThreadTime
        }
        GetStartTime() {
            return this._startTime
        }
        GetGameTime() {
            return this._gameTime.Get()
        }
        GetWallTime() {
            return this._wallTime.Get()
        }
        GetTickCount() {
            return this._tickCount
        }
        GetTickCountNoSave() {
            return this._tickCountNoSave
        }
        IncrementExecCount() {
            ++this._execCount
        }
        GetExecCount() {
            return this._execCount
        }
        GetObjectCount() {
            return this._objectCount
        }
        GetProjectName() {
            return this._projectName
        }
        GetProjectVersion() {
            return this._projectVersion
        }
        GetProjectUniqueId() {
            return this._projectUniqueId
        }
        GetAppId() {
            return this._appId
        }
        GetInstanceByUID(e) {
            if (this._isLoadingState) throw new Error("cannot call while loading state - wait until afterload event");
            return this._instancesByUid.get(e) || null
        }
        _RefreshUidMap() {
            this._instancesByUid.clear();
            for (const e of this._allObjectClasses) {
                if (e.IsFamily()) continue;
                for (const t of e.GetInstances()) this._instancesByUid.set(t.GetUID(), t)
            }
        }
        IsPreview() {
            return this._exportType === "preview"
        }
        IsDebug() {
            return this._isDebug
        }
        GetExportType() {
            return this._exportType
        }
        IsCordova() {
            return this._exportType === "cordova"
        }
        IsAndroidWebView() {
            return e.Platform.OS === "Android" && (this._exportType === "cordova" || this._exportType === "playable-ad" || this._exportType === "instant-games")
        }
        IsiOSCordova() {
            return this._isiOSCordova
        }
        IsiOSWebView() {
            return this._isiOSWebView
        }
        GetCollisionEngine() {
            return this._collisionEngine
        }
        GetSolidBehavior() {
            return this._pluginManager.GetSolidBehavior()
        }
        GetJumpthruBehavior() {
            return this._pluginManager.GetJumpthruBehavior()
        }
        IsLayoutFirstTick() {
            return this._isLayoutFirstTick
        }
        SetPixelRoundingEnabled(e) {
            if (e = !!e, this._isPixelRoundingEnabled === e) return;
            this._isPixelRoundingEnabled = e, this.UpdateRender()
        }
        IsPixelRoundingEnabled() {
            return this._isPixelRoundingEnabled
        }
        SaveToSlot(e) {
            this._saveToSlotName = e
        }
        LoadFromSlot(e) {
            this._loadFromSlotName = e
        }
        LoadFromJsonString(e) {
            this._loadFromJson = e
        }
        GetLastSaveJsonString() {
            return this._lastSaveJson
        }
        _NeedsHandleSaveOrLoad() {
            return !!(this._saveToSlotName || this._loadFromSlotName || this._loadFromJson !== null)
        }
        async _HandleSaveOrLoad() {
            if (this._saveToSlotName && (this.FlushPendingInstances(), await this._DoSaveToSlot(this._saveToSlotName), this._ClearSaveOrLoad()), this._loadFromSlotName && (await this._DoLoadFromSlot(this._loadFromSlotName), this._ClearSaveOrLoad(), this.IsDebug() && t.StepIfPausedInDebugger()), this._loadFromJson !== null) {
                this.FlushPendingInstances();
                try {
                    await this._DoLoadFromJsonString(this._loadFromJson), this._lastSaveJson = this._loadFromJson, await this.TriggerAsync(e.Plugins.System.Cnds.OnLoadComplete, null), this._lastSaveJson = ""
                } catch (t) {
                    console.error("[Construct 3] Failed to load state from JSON string: ", t), await this.TriggerAsync(e.Plugins.System.Cnds.OnLoadFailed, null)
                }
                this._ClearSaveOrLoad()
            }
        }
        _ClearSaveOrLoad() {
            this._saveToSlotName = "", this._loadFromSlotName = "", this._loadFromJson = null
        }
        _GetProjectStorage() {
            return this._projectStorage || (this._projectStorage = localforage.createInstance({
                name: "c3-localstorage-" + this.GetProjectUniqueId(),
                description: this.GetProjectName()
            })), this._projectStorage
        }
        _GetSavegamesStorage() {
            return this._savegamesStorage || (this._savegamesStorage = localforage.createInstance({
                name: "c3-savegames-" + this.GetProjectUniqueId(),
                description: this.GetProjectName()
            })), this._savegamesStorage
        }
        async _DoSaveToSlot(t) {
            const n = await this._SaveToJsonString();
            try {
                await this._GetSavegamesStorage().setItem(t, n), console.log("[Construct 3] Saved state to storage (" + n.length + " chars)"), this._lastSaveJson = n, await this.TriggerAsync(e.Plugins.System.Cnds.OnSaveComplete, null), this._lastSaveJson = ""
            } catch (t) {
                console.error("[Construct 3] Failed to save state to storage: ", t), await this.TriggerAsync(e.Plugins.System.Cnds.OnSaveFailed, null)
            }
        }
        async _DoLoadFromSlot(t) {
            try {
                const n = await this._GetSavegamesStorage().getItem(t);
                if (!n) throw new Error("empty slot");
                console.log("[Construct 3] Loaded state from storage (" + n.length + " chars)"), await this._DoLoadFromJsonString(n), this._lastSaveJson = n, await this.TriggerAsync(e.Plugins.System.Cnds.OnLoadComplete, null), this._lastSaveJson = ""
            } catch (t) {
                console.error("[Construct 3] Failed to load state from storage: ", t), await this.TriggerAsync(e.Plugins.System.Cnds.OnLoadFailed, null)
            }
        }
        async _SaveToJsonString() {
            const e = {
                c3save: !0,
                version: 1,
                rt: {
                    time: this.GetGameTime(),
                    walltime: this.GetWallTime(),
                    timescale: this.GetTimeScale(),
                    tickcount: this.GetTickCount(),
                    execcount: this.GetExecCount(),
                    next_uid: this._nextUid,
                    running_layout: this.GetMainRunningLayout().GetSID(),
                    start_time_offset: Date.now() - this._startTime
                },
                types: {},
                layouts: {},
                events: this._eventSheetManager._SaveToJson(),
                timelines: this._timelineManager._SaveToJson(),
                user_script_data: null
            };
            for (const t of this._allObjectClasses) {
                if (t.IsFamily() || t.HasNoSaveBehavior()) continue;
                e.types[t.GetSID().toString()] = t._SaveToJson()
            }
            for (const t of this._layoutManager.GetAllLayouts()) e.layouts[t.GetSID().toString()] = t._SaveToJson();
            const t = this._CreateUserScriptEvent("save");
            return t.saveData = null, await this.DispatchUserScriptEventAsyncWait(t), e.user_script_data = t.saveData, JSON.stringify(e)
        }
        IsLoadingState() {
            return this._isLoadingState
        }
        async _DoLoadFromJsonString(t) {
            const n = JSON.parse(t);
            if (n.c2save) throw new Error("C2 saves are incompatible with C3 runtime");
            if (!n.c3save) throw new Error("not valid C3 save data");
            if (n.version > 1) throw new Error("C3 save data from future version");
            this._isLoadingState = !0;
            const s = n.rt;
            this._gameTime.Set(s.time), this._wallTime.Set(s.walltime), this._timeScale = s.timescale, this._tickCount = s.tickcount, this._execCount = s.execcount, this._startTime = Date.now() - s.start_time_offset;
            const o = s.running_layout;
            if (o !== this.GetMainRunningLayout().GetSID()) {
                const e = this._layoutManager.GetLayoutBySID(o);
                if (e) await this._DoChangeLayout(e);
                else return
            }
            for (const [t, s] of Object.entries(n.types)) {
                const o = parseInt(t, 10),
                    e = this.GetObjectClassBySID(o);
                if (!e || e.IsFamily() || e.HasNoSaveBehavior()) continue;
                e._LoadFromJson(s)
            }
            this.FlushPendingInstances(), this._RefreshUidMap(), this._isLoadingState = !1, this._nextUid = s.next_uid;
            for (const [t, s] of Object.entries(n.layouts)) {
                const o = parseInt(t, 10),
                    e = this._layoutManager.GetLayoutBySID(o);
                if (!e) continue;
                e._LoadFromJson(s)
            }
            this._eventSheetManager._LoadFromJson(n.events);
            for (const e of this._allObjectClasses) {
                if (e.IsFamily() || !e.IsInContainer()) continue;
                for (const n of e.GetInstances()) {
                    const t = n.GetIID();
                    for (const s of e.GetContainer().objectTypes()) {
                        if (s === e) continue;
                        const o = s.GetInstances();
                        if (t < 0 || t >= o.length) throw new Error("missing sibling instance");
                        n._AddSibling(o[t])
                    }
                }
            }
            this._timelineManager._LoadFromJson(n.timelines), this._dispatcher.dispatchEvent(e.New(e.Event, "afterload"));
            const i = this._CreateUserScriptEvent("load");
            i.saveData = n.user_script_data, await this.DispatchUserScriptEventAsyncWait(i), this.UpdateRender()
        }
        async AddJobWorkerScripts(e) {
            const t = await Promise.all(e.map(e => this._assetManager.FetchBlob(e))),
                n = t.map(e => URL.createObjectURL(e));
            this._jobScheduler.ImportScriptsToJobWorkers(n)
        }
        AddJobWorkerBlob(e, t) {
            this._jobScheduler.SendBlobToJobWorkers(e, t)
        }
        AddJobWorkerBuffer(e, t) {
            this._jobScheduler.SendBufferToJobWorkers(e, t)
        }
        AddJob(e, t, n) {
            return this._jobScheduler.AddJob(e, t, n)
        }
        BroadcastJob(e, t, n) {
            return this._jobScheduler.BroadcastJob(e, t, n)
        }
        InvokeDownload(e, t) {
            this.PostComponentMessageToDOM("runtime", "invoke-download", {
                url: e,
                filename: t
            })
        }
        async RasterSvgImage(e, t, n, s, o, i) {
            if (s = s || t, o = o || n, this.IsInWorker()) {
                const a = await this.PostComponentMessageToDOMAsync("runtime", "raster-svg-image", {
                    blob: e,
                    imageWidth: t,
                    imageHeight: n,
                    surfaceWidth: s,
                    surfaceHeight: o,
                    imageBitmapOpts: i
                });
                return a.imageBitmap
            }
            const a = await self.C3_RasterSvgImageBlob(e, t, n, s, o);
            return i ? await self.createImageBitmap(a, i) : a
        }
        async GetSvgImageSize(e) {
            return this.IsInWorker() ? await this.PostComponentMessageToDOMAsync("runtime", "get-svg-image-size", {
                blob: e
            }) : await self.C3_GetSvgImageSize(e)
        }
        RequestDeviceOrientationEvent() {
            if (this._didRequestDeviceOrientationEvent) return;
            this._didRequestDeviceOrientationEvent = !0, this.PostComponentMessageToDOM("runtime", "enable-device-orientation")
        }
        RequestDeviceMotionEvent() {
            if (this._didRequestDeviceMotionEvent) return;
            this._didRequestDeviceMotionEvent = !0, this.PostComponentMessageToDOM("runtime", "enable-device-motion")
        }
        Random() {
            return this._randomNumberCallback()
        }
        SetRandomNumberGeneratorCallback(e) {
            this._randomNumberCallback = e
        }
        _GetRemotePreviewStatusInfo() {
            return {
                fps: this.GetFPS(),
                cpu: this.GetMainThreadTime(),
                gpu: this.GetGPUUtilisation(),
                layout: this.GetMainRunningLayout() ? this.GetMainRunningLayout().GetName() : "",
                renderer: this.GetWebGLRenderer().GetUnmaskedRenderer()
            }
        }
        HitBreakpoint() {
            return !!this.IsDebug() && t.HitBreakpoint()
        }
        DebugBreak(e) {
            return this.IsDebugging() ? t.DebugBreak(e) : Promise.resolve()
        }
        DebugBreakNext() {
            return !!this.IsDebugging() && t.BreakNext()
        }
        SetDebugBreakpointsEnabled(e) {
            this._breakpointsEnabled = !!e, this._UpdateDebuggingFlag()
        }
        AreDebugBreakpointsEnabled() {
            return this._breakpointsEnabled
        }
        IsDebugging() {
            return this._isDebugging
        }
        SetDebuggingEnabled(e) {
            e ? this._debuggingDisabled-- : this._debuggingDisabled++, this._UpdateDebuggingFlag()
        }
        _UpdateDebuggingFlag() {
            this._isDebugging = this.IsDebug() && this._breakpointsEnabled && this._debuggingDisabled === 0
        }
        IsCPUProfiling() {
            return this.IsDebug() && t.IsCPUProfiling()
        }
        IsGPUProfiling() {
            return this.IsDebug() && this.GetWebGLRenderer().SupportsGPUProfiling() && t.IsGPUProfiling()
        }
        async DebugIterateAndBreak(e) {
            if (!e) return;
            for (const t of e) await this.DebugBreak(t)
        }
        DebugFireGeneratorEventAndBreak(e) {
            return this.DebugIterateAndBreak(this._dispatcher.dispatchGeneratorEvent(e))
        }
        _InvokeFunctionFromJS(e) {
            return this._eventSheetManager._InvokeFunctionFromJS(e.name, e.params)
        }
        GetIRuntime() {
            return this._iRuntime
        }
        _CreateUserScriptEvent(t) {
            const n = e.New(e.Event, t, !1);
            return n.runtime = this._iRuntime, n
        }
        _InitScriptInterfaces() {
            const e = {};
            for (const t of this._allObjectClasses) e[t.GetJsPropName()] = {
                value: t.GetIObjectClass(),
                enumerable: !0,
                writable: !1
            };
            const t = Object.create(Object.prototype, e);
            this._iRuntime = new self.IRuntime(this, t), this._userScriptEventObjects = {
                tick: this._CreateUserScriptEvent("tick")
            }
        }
        _InitGlobalVariableScriptInterface() {
            const e = {};
            for (const t of this.GetEventSheetManager().GetAllGlobalVariables()) e[t.GetJsPropName()] = t._GetScriptInterfaceDescriptor();
            this._iRuntime._InitGlobalVars(e)
        }
        _GetCommonScriptInterfaces() {
            return this._commonScriptInterfaces
        }
        _MapScriptInterface(e, t) {
            this._interfaceMap.set(e, t)
        }
        _UnwrapScriptInterface(e) {
            return this._interfaceMap.get(e)
        }
    }, self.C3_CreateRuntime = e.Runtime.Create, self.C3_InitRuntime = (e, t) => e.Init(t)
}
"use strict";
{
    const e = self.C3;
    e.JobSchedulerRuntime = class JobSchedulerRuntime extends e.DefendedBase {
        constructor(e, t) {
            super(), this._runtime = e, this._jobPromises = new Map, this._nextJobId = 0, this._inputPort = t.inputPort, t.outputPort.onmessage = e => this._OnJobWorkerMessage(e), this._maxNumWorkers = t.maxNumWorkers, this._jobWorkerCount = 1, this._isCreatingWorker = !1, this._hadErrorCreatingWorker = !1
        }
        async Init() {}
        ImportScriptsToJobWorkers(e) {
            this._inputPort.postMessage({
                type: "_import_scripts",
                scripts: e
            })
        }
        SendBlobToJobWorkers(e, t) {
            this._inputPort.postMessage({
                type: "_send_blob",
                blob: e,
                id: t
            })
        }
        SendBufferToJobWorkers(e, t) {
            this._inputPort.postMessage({
                type: "_send_buffer",
                buffer: e,
                id: t
            }, [e])
        }
        AddJob(e, t, n, s, o) {
            n || (n = []);
            const i = this._nextJobId++,
                a = {
                    type: e,
                    isBroadcast: !1,
                    jobId: i,
                    params: t,
                    transferables: n
                },
                r = new Promise((e, t) => {
                    this._jobPromises.set(i, {
                        resolve: e,
                        progress: s,
                        reject: t,
                        cancelled: !1
                    })
                });
            return o && o.SetAction(() => this._CancelJob(i)), this._inputPort.postMessage(a, n), this._MaybeCreateExtraWorker(), r
        }
        BroadcastJob(e, t, n) {
            n || (n = []);
            const s = this._nextJobId++,
                o = {
                    type: e,
                    isBroadcast: !0,
                    jobId: s,
                    params: t,
                    transferables: n
                };
            this._inputPort.postMessage(o, n)
        }
        _CancelJob(e) {
            const t = this._jobPromises.get(e);
            t && (t.cancelled = !0, t.resolve = null, t.progress = null, t.reject = null, this._inputPort.postMessage({
                type: "_cancel",
                jobId: e
            }))
        }
        _OnJobWorkerMessage(e) {
            const t = e.data,
                s = t.type,
                n = t.jobId;
            switch (s) {
                case "result":
                    this._OnJobResult(n, t.result);
                    break;
                case "progress":
                    this._OnJobProgress(n, t.progress);
                    break;
                case "error":
                    this._OnJobError(n, t.error);
                    break;
                case "ready":
                    this._OnJobWorkerReady();
                    break;
                default:
                    throw new Error(`unknown message from worker '${s}'`)
            }
        }
        _OnJobResult(e, t) {
            const n = this._jobPromises.get(e);
            if (!n) throw new Error("invalid job ID");
            n.cancelled || n.resolve(t), this._jobPromises.delete(e)
        }
        _OnJobProgress(e, t) {
            const n = this._jobPromises.get(e);
            if (!n) throw new Error("invalid job ID");
            !n.cancelled && n.progress && n.progress(t)
        }
        _OnJobError(e, t) {
            const n = this._jobPromises.get(e);
            if (!n) throw new Error("invalid job ID");
            n.cancelled || n.reject(t), this._jobPromises.delete(e)
        }
        _OnJobWorkerReady() {
            if (!this._isCreatingWorker) return;
            this._isCreatingWorker = !1, this._jobWorkerCount++, this._jobWorkerCount < this._maxNumWorkers ? this._MaybeCreateExtraWorker() : this._inputPort.postMessage({
                type: "_no_more_workers"
            })
        }
        async _MaybeCreateExtraWorker() {
            if (this._jobWorkerCount >= this._maxNumWorkers || this._isCreatingWorker || this._hadErrorCreatingWorker || this._jobPromises.size <= this._jobWorkerCount) return;
            try {
                this._isCreatingWorker = !0;
                const e = await this._runtime.PostComponentMessageToDOMAsync("runtime", "create-job-worker");
                e.outputPort.onmessage = e => this._OnJobWorkerMessage(e)
            } catch (e) {
                this._hadErrorCreatingWorker = !0, this._isCreatingWorker = !1, console.error(`[Construct 3] Failed to create job worker; stopping creating any more (created ${this._jobWorkerCount} so far)`, e)
            }
        }
    }
}
self.C3_Shaders = {}, self.C3_Shaders.replacesolidcolor = {
    src: `varying mediump vec2 vTex;
uniform lowp sampler2D samplerFront;
uniform lowp vec3 sourceColor;
uniform lowp vec3 destColor;
uniform lowp float tolerance;
void main(void)
{
lowp vec4 front = texture2D(samplerFront, vTex);
lowp float a = front.a;
if (a != 0.0)
front.rgb /= a;
lowp float diff = length(front.rgb - sourceColor);
if (diff <= tolerance)
{
front.rgb = destColor;
}
front.rgb *= a;
gl_FragColor = front;
}`,
    extendBoxHorizontal: 0,
    extendBoxVertical: 0,
    crossSampling: !1,
    mustPreDraw: !1,
    preservesOpaqueness: !0,
    animated: !1,
    parameters: [
        ["sourceColor", 0, "color"],
        ["destColor", 0, "color"],
        ["tolerance", 0, "percent"]
    ]
}, self.C3_Shaders.replacecolor = {
    src: `varying mediump vec2 vTex;
uniform lowp sampler2D samplerFront;
uniform lowp vec3 sourceColor;
uniform lowp vec3 destColor;
uniform lowp float tolerance;
void main(void)
{
lowp vec4 front = texture2D(samplerFront, vTex);
lowp float a = front.a;
if (a != 0.0)
front.rgb /= a;
lowp float diff = length(front.rgb - sourceColor);
if (diff <= tolerance)
{
front.rgb = mix(front.rgb, destColor, 1.0 - diff / tolerance);
}
front.rgb *= a;
gl_FragColor = front;
}`,
    extendBoxHorizontal: 0,
    extendBoxVertical: 0,
    crossSampling: !1,
    mustPreDraw: !1,
    preservesOpaqueness: !0,
    animated: !1,
    parameters: [
        ["sourceColor", 0, "color"],
        ["destColor", 0, "color"],
        ["tolerance", 0, "percent"]
    ]
}, self.C3_Shaders.oline = {
    src: `#ifdef GL_ES
precision highp float;
#endif
uniform  float seconds;
varying  vec2 vTex;
uniform  sampler2D samplerFront;
uniform  vec2 pixelSize;
uniform  vec3 cl;
uniform float width,justoutline,speed;
void main(void)
{
vec4 front = texture2D(samplerFront, vTex);
float dx = pixelSize.x*width;
float dy = pixelSize.y*width;
float diag = 0.7071;
float a0 = texture2D(samplerFront, vTex + vec2(-dx*diag, dy*diag)).a;
float a1 = texture2D(samplerFront, vTex + vec2(dx*diag, -dy*diag)).a;
float a2 = texture2D(samplerFront, vTex + vec2(-dx*diag, -dy*diag)).a;
float a3 = texture2D(samplerFront, vTex + vec2(dx*diag, dy*diag)).a;
float a4 = texture2D(samplerFront, vTex + vec2(-dx, 0.0)).a;
float a5 = texture2D(samplerFront, vTex + vec2(dx, 0.0)).a;
float a6 = texture2D(samplerFront, vTex + vec2(0.0, dy)).a;
float a7 = texture2D(samplerFront, vTex + vec2(0.0, -dy)).a;
float ina=max(max(max(max(max(max(max(a0,a1),a2),a3),a4),a5),a6),a7)-front.a;
if(justoutline!=1.0)
{
float outa = ina + front.a*(1.0-ina);
vec3 outrgb = (vec3(cl.x, cl.y, cl.z)*ina + front.rgb*front.a*(1.0-ina));
gl_FragColor = vec4(outrgb, outa);
}
else if(ina>0.0)
{
gl_FragColor = vec4(vec3(cl.x, cl.y, cl.z)*ina, ina);
}
}`,
    extendBoxHorizontal: 0,
    extendBoxVertical: 0,
    crossSampling: !1,
    mustPreDraw: !1,
    preservesOpaqueness: !0,
    animated: !1,
    parameters: [
        ["justoutline", 0, "float"],
        ["width", 0, "float"],
        ["cl", 0, "color"]
    ]
}, self.C3_Shaders.brightness = {
    src: `varying mediump vec2 vTex;
uniform lowp sampler2D samplerFront;
uniform lowp float brightness;
void main(void)
{
lowp vec4 front = texture2D(samplerFront, vTex);
lowp float a = front.a;
if (a != 0.0)
front.rgb /= front.a;
front.rgb += (brightness - 1.0);
front.rgb *= a;
gl_FragColor = front;
}`,
    extendBoxHorizontal: 0,
    extendBoxVertical: 0,
    crossSampling: !1,
    mustPreDraw: !1,
    preservesOpaqueness: !0,
    animated: !1,
    parameters: [
        ["brightness", 0, "percent"]
    ]
}, self.C3_Shaders.oilpainting = {
    src: `#ifdef GL_FRAGMENT_PRECISION_HIGH
#define highmedp highp
#else
#define highmedp mediump
#endif
varying mediump vec2 vTex;
uniform lowp sampler2D samplerFront;
precision highmedp float;
uniform mediump vec2 pixelSize;
void main (void)
{
const int radius = 3;
vec2 src_size = 1.0 / pixelSize;
lowp float alpha = texture2D(samplerFront, vTex).a;
vec2 uv = vTex;
float n = float((radius + 1) * (radius + 1));
vec3 m[4];
vec3 s[4];
for (int k = 0; k < 4; ++k) {
m[k] = vec3(0.0);
s[k] = vec3(0.0);
}
for (int j = -radius; j <= 0; ++j)  {
for (int i = -radius; i <= 0; ++i)  {
vec3 c = texture2D(samplerFront, uv + vec2(i,j) / src_size).rgb;
m[0] += c;
s[0] += c * c;
}
}
for (int j = -radius; j <= 0; ++j)  {
for (int i = 0; i <= radius; ++i)  {
vec3 c = texture2D(samplerFront, uv + vec2(i,j) / src_size).rgb;
m[1] += c;
s[1] += c * c;
}
}
for (int j = 0; j <= radius; ++j)  {
for (int i = 0; i <= radius; ++i)  {
vec3 c = texture2D(samplerFront, uv + vec2(i,j) / src_size).rgb;
m[2] += c;
s[2] += c * c;
}
}
for (int j = 0; j <= radius; ++j)  {
for (int i = -radius; i <= 0; ++i)  {
vec3 c = texture2D(samplerFront, uv + vec2(i,j) / src_size).rgb;
m[3] += c;
s[3] += c * c;
}
}
float min_sigma2 = 1e+2;
for (int k = 0; k < 4; ++k) {
m[k] /= n;
s[k] = abs(s[k] / n - m[k] * m[k]);
float sigma2 = s[k].r + s[k].g + s[k].b;
if (sigma2 < min_sigma2) {
min_sigma2 = sigma2;
gl_FragColor = vec4(m[k], alpha);
}
}
}`,
    extendBoxHorizontal: 0,
    extendBoxVertical: 0,
    crossSampling: !1,
    mustPreDraw: !1,
    preservesOpaqueness: !0,
    animated: !1,
    parameters: []
}, self.C3_Shaders.radialblur = {
    src: `precision mediump float;
varying vec2 vTex;
uniform sampler2D samplerFront;
uniform vec2 srcStart;
uniform vec2 srcEnd;
uniform float layerScale;
uniform float intensity;
uniform float radius;
void main(void)
{
vec2 dir = ((srcStart + srcEnd) / 2.0 - vTex) / (length(srcEnd - srcStart) / 2.0);
float dist = sqrt(dir.x*dir.x + dir.y*dir.y);
dir = dir/dist;
vec4 front = texture2D(samplerFront, vTex);
vec4 sum = front;
float scaledRadius = radius * layerScale;
sum += texture2D(samplerFront, vTex + dir * -0.08 * scaledRadius);
sum += texture2D(samplerFront, vTex + dir * -0.05 * scaledRadius);
sum += texture2D(samplerFront, vTex + dir * -0.03 * scaledRadius);
sum += texture2D(samplerFront, vTex + dir * -0.02 * scaledRadius);
sum += texture2D(samplerFront, vTex + dir * -0.01 * scaledRadius);
sum += texture2D(samplerFront, vTex + dir * 0.01 * scaledRadius);
sum += texture2D(samplerFront, vTex + dir * 0.02 * scaledRadius);
sum += texture2D(samplerFront, vTex + dir * 0.03 * scaledRadius);
sum += texture2D(samplerFront, vTex + dir * 0.05 * scaledRadius);
sum += texture2D(samplerFront, vTex + dir * 0.08 * scaledRadius);
sum /= 11.0;
float t = dist * 2.2;
t = clamp(t, 0.0, 1.0);
gl_FragColor = mix(front, mix(front, sum, t), intensity);
}`,
    extendBoxHorizontal: 50,
    extendBoxVertical: 50,
    crossSampling: !1,
    mustPreDraw: !1,
    preservesOpaqueness: !1,
    animated: !1,
    parameters: [
        ["radius", 0, "percent"],
        ["intensity", 0, "percent"]
    ]
}, "use strict";
{
    const e = self.C3;
    let n = null,
        o = "",
        i = "",
        s = [],
        a = "",
        r = "",
        c = "";
    const t = e.New(e.ArrayStack);

    function ForEachOrdered_SortInstances(e, t) {
        const n = e[1],
            s = t[1];
        if (typeof n == "number" && typeof s == "number") return n - s;
        const o = "" + n,
            i = "" + s;
        return o < i ? -1 : o > i ? 1 : 0
    }
    e.Plugins.System = class SystemPlugin extends e.SDKPluginBase {
        constructor(e) {
            super(e), this._loopStack = this._runtime.GetEventSheetManager().GetLoopStack(), this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._imagesLoadingTotal = 0, this._imagesLoadingComplete = 0, this._functionMaps = new Map
        }
        Release() {
            super.Release()
        }
        UpdateRender() {
            this._runtime.UpdateRender()
        }
        Trigger(e) {
            this._runtime.Trigger(e, null, null)
        }
        GetRegex(e, t) {
            return (!n || e !== o || t !== i) && (n = new RegExp(e, t), o = e, i = t), n.lastIndex = 0, n
        }
        GetRegexMatches(e, t, n) {
            if (e === a && t === r && n === c) return s;
            const o = this.GetRegex(t, n);
            return s = e.match(o), a = e, r = t, c = n, s
        }
        async _LoadTexturesForObjectClasses(t, n) {
            if (!n.length) return;
            this._imagesLoadingTotal += n.length;
            const s = [];
            for (const e of n) s.push(t.MaybeLoadTexturesFor(e));
            await e.PromiseAllWithProgress(s, () => {
                this._imagesLoadingComplete++
            }), this._imagesLoadingComplete++, this._imagesLoadingComplete === this._imagesLoadingTotal && (this._runtime.Trigger(e.Plugins.System.Cnds.OnImageLoadingComplete, null, null), this._imagesLoadingComplete = 0, this._imagesLoadingTotal = 0)
        }
        _UnloadTexturesForObjectClasses(e, t) {
            for (const n of t) n.GetInstanceCount() === 0 && e.MaybeUnloadTexturesFor(n)
        }
        _GetForEachStack() {
            return t
        }
        _Repeat(e) {
            const n = this._runtime.GetEventSheetManager(),
                i = n.GetEventStack(),
                s = i.GetCurrentStackFrame(),
                o = s.GetCurrentEvent(),
                a = o.GetSolModifiers(),
                l = s.IsSolModifierAfterCnds(),
                r = i.Push(o),
                c = n.GetLoopStack(),
                t = c.Push();
            if (t.SetEnd(e), l)
                for (let i = 0; i < e && !t.IsStopped(); ++i) n.PushCopySol(a), t.SetIndex(i), o.Retrigger(s, r), n.PopSol(a);
            else
                for (let n = 0; n < e && !t.IsStopped(); ++n) t.SetIndex(n), o.Retrigger(s, r);
            return i.Pop(), c.Pop(), !1
        }* _DebugRepeat(e) {
            const n = this._runtime.GetEventSheetManager(),
                i = n.GetEventStack(),
                s = i.GetCurrentStackFrame(),
                o = s.GetCurrentEvent(),
                a = o.GetSolModifiers(),
                l = s.IsSolModifierAfterCnds(),
                r = i.Push(o),
                c = n.GetLoopStack(),
                t = c.Push();
            if (t.SetEnd(e), l)
                for (let i = 0; i < e && !t.IsStopped(); ++i) n.PushCopySol(a), t.SetIndex(i), yield* o.DebugRetrigger(s, r), n.PopSol(a);
            else
                for (let n = 0; n < e && !t.IsStopped(); ++n) t.SetIndex(n), yield* o.DebugRetrigger(s, r);
            return i.Pop(), c.Pop(), !1
        }
        _While() {
            const t = this._runtime.GetEventSheetManager(),
                o = t.GetEventStack(),
                n = o.GetCurrentStackFrame(),
                s = n.GetCurrentEvent(),
                i = s.GetSolModifiers(),
                c = n.IsSolModifierAfterCnds(),
                a = o.Push(s),
                r = t.GetLoopStack(),
                e = r.Push();
            if (c)
                for (let o = 0; !e.IsStopped(); ++o) t.PushCopySol(i), e.SetIndex(o), s.Retrigger(n, a) || e.Stop(), t.PopSol(i);
            else
                for (let t = 0; !e.IsStopped(); ++t) e.SetIndex(t), s.Retrigger(n, a) || e.Stop();
            return o.Pop(), r.Pop(), !1
        }* _DebugWhile() {
            const t = this._runtime.GetEventSheetManager(),
                o = t.GetEventStack(),
                n = o.GetCurrentStackFrame(),
                s = n.GetCurrentEvent(),
                i = s.GetSolModifiers(),
                c = n.IsSolModifierAfterCnds(),
                a = o.Push(s),
                r = t.GetLoopStack(),
                e = r.Push();
            if (c)
                for (let o = 0; !e.IsStopped(); ++o) {
                    t.PushCopySol(i), e.SetIndex(o);
                    const r = yield* s.DebugRetrigger(n, a);
                    r || e.Stop(), t.PopSol(i)
                } else
                    for (let t = 0; !e.IsStopped(); ++t) {
                        e.SetIndex(t);
                        const o = yield* s.DebugRetrigger(n, a);
                        o || e.Stop()
                    }
            return o.Pop(), r.Pop(), !1
        }
        _For(e, t, n) {
            const o = this._runtime.GetEventSheetManager(),
                l = o.GetEventStack(),
                i = l.GetCurrentStackFrame(),
                a = i.GetCurrentEvent(),
                r = a.GetSolModifiers(),
                d = i.IsSolModifierAfterCnds(),
                c = l.Push(a),
                u = o.GetLoopStack(),
                s = u.Push();
            if (s.SetName(e), s.SetEnd(n), n < t)
                if (d)
                    for (let e = t; e >= n && !s.IsStopped(); --e) o.PushCopySol(r), s.SetIndex(e), a.Retrigger(i, c), o.PopSol(r);
                else
                    for (let e = t; e >= n && !s.IsStopped(); --e) s.SetIndex(e), a.Retrigger(i, c);
            else if (d)
                for (let e = t; e <= n && !s.IsStopped(); ++e) o.PushCopySol(r), s.SetIndex(e), a.Retrigger(i, c), o.PopSol(r);
            else
                for (let e = t; e <= n && !s.IsStopped(); ++e) s.SetIndex(e), a.Retrigger(i, c);
            return l.Pop(), u.Pop(), !1
        }* _DebugFor(e, t, n) {
            const o = this._runtime.GetEventSheetManager(),
                l = o.GetEventStack(),
                i = l.GetCurrentStackFrame(),
                a = i.GetCurrentEvent(),
                r = a.GetSolModifiers(),
                d = i.IsSolModifierAfterCnds(),
                c = l.Push(a),
                u = o.GetLoopStack(),
                s = u.Push();
            if (s.SetName(e), s.SetEnd(n), n < t)
                if (d)
                    for (let e = t; e >= n && !s.IsStopped(); --e) o.PushCopySol(r), s.SetIndex(e), yield* a.DebugRetrigger(i, c), o.PopSol(r);
                else
                    for (let e = t; e >= n && !s.IsStopped(); --e) s.SetIndex(e), yield* a.DebugRetrigger(i, c);
            else if (d)
                for (let e = t; e <= n && !s.IsStopped(); ++e) o.PushCopySol(r), s.SetIndex(e), yield* a.DebugRetrigger(i, c), o.PopSol(r);
            else
                for (let e = t; e <= n && !s.IsStopped(); ++e) s.SetIndex(e), yield* a.DebugRetrigger(i, c);
            return l.Pop(), u.Pop(), !1
        }
        _ForEach(n) {
            const i = this._runtime.GetEventSheetManager(),
                c = i.GetEventStack(),
                a = c.GetCurrentStackFrame(),
                r = a.GetCurrentEvent(),
                d = r.GetSolModifiers(),
                f = a.IsSolModifierAfterCnds(),
                u = c.Push(r),
                h = i.GetLoopStack(),
                o = h.Push(),
                m = n.IsInContainer(),
                l = n.GetCurrentSol(),
                s = t.Push();
            if (e.shallowAssignArray(s, l.GetInstances()), o.SetEnd(s.length), f)
                for (let e = 0, c = s.length; e < c && !o.IsStopped(); ++e) {
                    i.PushCopySol(d);
                    const t = s[e];
                    n.GetCurrentSol().SetSinglePicked(t), m && t.SetSiblingsSinglePicked(), o.SetIndex(e), r.Retrigger(a, u), i.PopSol(d)
                } else {
                    l._SetSelectAll(!1);
                    const t = l._GetOwnInstances();
                    e.clearArray(t), t.push(null);
                    for (let e = 0, i = s.length; e < i && !o.IsStopped(); ++e) {
                        const n = s[e];
                        t[0] = n, m && n.SetSiblingsSinglePicked(), o.SetIndex(e), r.Retrigger(a, u)
                    }
                }
            return c.Pop(), h.Pop(), e.clearArray(s), t.Pop(), !1
        }* _DebugForEach(n) {
            const i = this._runtime.GetEventSheetManager(),
                c = i.GetEventStack(),
                a = c.GetCurrentStackFrame(),
                r = a.GetCurrentEvent(),
                d = r.GetSolModifiers(),
                f = a.IsSolModifierAfterCnds(),
                u = c.Push(r),
                h = i.GetLoopStack(),
                o = h.Push(),
                m = n.IsInContainer(),
                l = n.GetCurrentSol(),
                s = t.Push();
            if (e.shallowAssignArray(s, l.GetInstances()), o.SetEnd(s.length), f)
                for (let e = 0, c = s.length; e < c && !o.IsStopped(); ++e) {
                    i.PushCopySol(d);
                    const t = s[e];
                    n.GetCurrentSol().SetSinglePicked(t), m && t.SetSiblingsSinglePicked(), o.SetIndex(e), yield* r.DebugRetrigger(a, u), i.PopSol(d)
                } else {
                    l._SetSelectAll(!1);
                    const t = l._GetOwnInstances();
                    e.clearArray(t), t.push(null);
                    for (let e = 0, i = s.length; e < i && !o.IsStopped(); ++e) {
                        const n = s[e];
                        t[0] = n, m && n.SetSiblingsSinglePicked(), o.SetIndex(e), yield* r.DebugRetrigger(a, u)
                    }
                }
            return c.Pop(), h.Pop(), e.clearArray(s), t.Pop(), !1
        }
        _ForEachOrdered(n, s) {
            const i = this._runtime.GetEventSheetManager(),
                d = i.GetEventStack(),
                v = i.GetCurrentCondition(),
                r = d.GetCurrentStackFrame(),
                c = r.GetCurrentEvent(),
                h = c.GetSolModifiers(),
                g = r.IsSolModifierAfterCnds(),
                m = d.Push(c),
                f = i.GetLoopStack(),
                a = f.Push(),
                p = n.IsInContainer(),
                l = n.GetCurrentSol(),
                o = t.Push();
            e.clearArray(o);
            const u = l.GetInstances();
            a.SetEnd(u.length);
            for (let e = 0, t = u.length; e < t; ++e) o.push([u[e], v.ReevaluateParameter(1, e)]);
            if (o.sort(ForEachOrdered_SortInstances), s === 1 && o.reverse(), g)
                for (let e = 0, s = o.length; e < s && !a.IsStopped(); ++e) {
                    i.PushCopySol(h);
                    const t = o[e][0];
                    n.GetCurrentSol().SetSinglePicked(t), p && t.SetSiblingsSinglePicked(), a.SetIndex(e), c.Retrigger(r, m), i.PopSol(h)
                } else {
                    l._SetSelectAll(!1);
                    const t = l._GetOwnInstances();
                    e.clearArray(t), t.push(null);
                    for (let e = 0, s = o.length; e < s && !a.IsStopped(); ++e) {
                        const n = o[e][0];
                        t[0] = n, p && n.SetSiblingsSinglePicked(), a.SetIndex(e), c.Retrigger(r, m)
                    }
                }
            return d.Pop(), f.Pop(), e.clearArray(o), t.Pop(), !1
        }* _DebugForEachOrdered(n, s) {
            const i = this._runtime.GetEventSheetManager(),
                d = i.GetEventStack(),
                v = i.GetCurrentCondition(),
                r = d.GetCurrentStackFrame(),
                c = r.GetCurrentEvent(),
                h = c.GetSolModifiers(),
                g = r.IsSolModifierAfterCnds(),
                m = d.Push(c),
                f = i.GetLoopStack(),
                a = f.Push(),
                p = n.IsInContainer(),
                l = n.GetCurrentSol(),
                o = t.Push();
            e.clearArray(o);
            const u = l.GetInstances();
            a.SetEnd(u.length);
            for (let e = 0, t = u.length; e < t; ++e) o.push([u[e], v.ReevaluateParameter(1, e)]);
            if (o.sort(ForEachOrdered_SortInstances), s === 1 && o.reverse(), g)
                for (let e = 0, s = o.length; e < s && !a.IsStopped(); ++e) {
                    i.PushCopySol(h);
                    const t = o[e][0];
                    n.GetCurrentSol().SetSinglePicked(t), p && t.SetSiblingsSinglePicked(), a.SetIndex(e), yield* c.DebugRetrigger(r, m), i.PopSol(h)
                } else {
                    l._SetSelectAll(!1);
                    const t = l._GetOwnInstances();
                    e.clearArray(t), t.push(null);
                    for (let e = 0, s = o.length; e < s && !a.IsStopped(); ++e) {
                        const n = o[e][0];
                        t[0] = n, p && n.SetSiblingsSinglePicked(), a.SetIndex(e), yield* c.DebugRetrigger(r, m)
                    }
                }
            return d.Pop(), f.Pop(), e.clearArray(o), t.Pop(), !1
        }
        _GetFunctionMap(e, t) {
            let n = this._functionMaps.get(e);
            return n ? n : t ? (n = {
                defaultFunc: null,
                strMap: new Map
            }, this._functionMaps.set(e, n), n) : null
        }
        _DoCallMappedFunction(e, t, n, s, o) {
            t.GetEventBlock().RunAsMappedFunctionCall(n), s && e.PopSol(o)
        }* _DebugDoCallMappedFunction(e, t, n, s, o) {
            yield* t.GetEventBlock().DebugRunAsMappedFunctionCall(n), s && e.PopSol(o)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.System.Type = class SystemType extends e.DefendedBase {
        constructor(e) {
            super(), this._objectClass = e, this._runtime = e.GetRuntime(), this._plugin = e.GetPlugin()
        }
        OnCreate() {}
        Release() {
            this._objectClass = null, this._runtime = null, this._plugin = null
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.System.Instance = class SystemInstance extends e.DefendedBase {
        constructor(e) {
            super(), this._inst = e, this._objectClass = this._inst.GetObjectClass(), this._sdkType = this._objectClass.GetSdkType(), this._runtime = this._inst.GetRuntime()
        }
        Release() {
            this._inst = null, this._objectClass = null, this._sdkType = null, this._runtime = null
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = [];
    e.Plugins.System.Cnds = {
        EveryTick() {
            return !0
        },
        OnLayoutStart() {
            return !0
        },
        OnLayoutEnd() {
            return !0
        },
        OnSuspend() {
            return !0
        },
        OnResume() {
            return !0
        },
        IsSuspended() {
            return this._runtime.IsSuspended()
        },
        Else() {
            const e = this._runtime.GetCurrentEventStackFrame();
            return !e.GetElseBranchRan() && !e.GetLastEventTrue()
        },
        TriggerOnce() {
            const s = this._runtime.GetCurrentCondition(),
                e = s.GetSavedDataMap();
            let t = e.get("TriggerOnce_lastTick");
            typeof t == "undefined" && (t = -1, e.set("TriggerOnce_lastTick", -1));
            const n = this._runtime.GetTickCount();
            return e.set("TriggerOnce_lastTick", n), this._runtime.IsLayoutFirstTick() || t !== n - 1
        },
        Every(e) {
            const i = this._runtime.GetCurrentCondition(),
                t = i.GetSavedDataMap(),
                s = t.get("Every_lastTime") || 0,
                n = this._runtime.GetGameTime();
            t.has("Every_seconds") || t.set("Every_seconds", e);
            const o = t.get("Every_seconds");
            return n >= s + o ? (t.set("Every_lastTime", s + o), n >= t.get("Every_lastTime") + .04 && t.set("Every_lastTime", n), t.set("Every_seconds", e), !0) : (n < s - .1 && t.set("Every_lastTime", n), !1)
        },
        IsGroupActive(e) {
            const t = this._runtime.GetEventSheetManager().GetEventGroupByName(e);
            return t && t.IsGroupActive()
        },
        IsPreview() {
            return this._runtime.IsPreview()
        },
        IsMobile() {
            return e.Platform.IsMobile
        },
        OnLoadFinished() {
            return !0
        },
        OnCanvasSnapshot() {
            return !0
        },
        EffectsSupported() {
            return !0
        },
        OnSaveComplete() {
            return !0
        },
        OnSaveFailed() {
            return !0
        },
        OnLoadComplete() {
            return !0
        },
        OnLoadFailed() {
            return !0
        },
        ObjectUIDExists(e) {
            return !!this._runtime.GetInstanceByUID(e)
        },
        IsOnPlatform(t) {
            switch (t) {
                case 0:
                    return e.Platform.Context === "browser";
                case 1:
                    return e.Platform.OS === "iOS";
                case 2:
                    return e.Platform.OS === "Android";
                case 8:
                    return e.Platform.Context === "cordova";
                case 9:
                    return this._runtime.GetExportType() === "scirra-arcade";
                case 10:
                    return e.Platform.Context === "nwjs";
                case 13:
                    return this._runtime.GetExportType() === "windows-uwp";
                default:
                    return !1
            }
        },
        RegexTest(e, t, n) {
            const s = this.GetRegex(t, n);
            return s.test(e)
        },
        Compare(t, n, s) {
            return e.compare(t, n, s)
        },
        CompareBetween(e, t, n) {
            return e >= t && e <= n
        },
        CompareVar(t, n, s) {
            return e.compare(t.GetValue(), n, s)
        },
        CompareBoolVar(e) {
            return !!e.GetValue()
        },
        CompareTime(t, n) {
            const s = this._runtime.GetGameTime();
            if (t === 0) {
                const t = this._runtime.GetCurrentCondition(),
                    e = t.GetSavedDataMap();
                return !e.get("CompareTime_executed") && s >= n && (e.set("CompareTime_executed", !0), !0)
            }
            return e.compare(s, t, n)
        },
        IsNaN(e) {
            return isNaN(e)
        },
        AngleWithin(t, n, s) {
            return e.angleDiff(e.toRadians(t), e.toRadians(s)) <= e.toRadians(n)
        },
        IsClockwiseFrom(t, n) {
            return e.angleClockwise(e.toRadians(t), e.toRadians(n))
        },
        IsBetweenAngles(t, n, s) {
            let o = e.toRadians(t),
                i = e.toRadians(n),
                a = e.toRadians(s),
                r = !e.angleClockwise(a, i);
            return r ? !!e.angleClockwise(o, i) || !e.angleClockwise(o, a) : e.angleClockwise(o, i) && !e.angleClockwise(o, a)
        },
        IsValueType(e, t) {
            return typeof e == "number" ? t === 0 : t === 1
        },
        EvaluateExpression(e) {
            return !!e
        },
        PickByComparison(t, n, s, o) {
            if (!t) return !1;
            const c = this._GetForEachStack(),
                i = c.Push(),
                a = t.GetCurrentSol();
            e.shallowAssignArray(i, a.GetInstances()), a.IsSelectAll() && e.clearArray(a._GetOwnElseInstances());
            const l = this._runtime.GetCurrentCondition();
            let r = 0;
            for (let t = 0, d = i.length; t < d; ++t) {
                const c = i[t];
                i[r] = c, n = l.ReevaluateParameter(1, t), o = l.ReevaluateParameter(3, t), e.compare(n, s, o) ? ++r : a._PushElseInstance(c)
            }
            e.truncateArray(i, r), a.SetArrayPicked(i);
            const d = !!i.length;
            return e.clearArray(i), c.Pop(), t.ApplySolToContainer(), d
        },
        PickByEvaluate(t, n) {
            if (!t) return !1;
            const a = this._GetForEachStack(),
                s = a.Push(),
                o = t.GetCurrentSol();
            e.shallowAssignArray(s, o.GetInstances()), o.IsSelectAll() && e.clearArray(o._GetOwnElseInstances());
            const r = this._runtime.GetCurrentCondition();
            let i = 0;
            for (let e = 0, a = s.length; e < a; ++e) {
                const t = s[e];
                s[i] = t, n = r.ReevaluateParameter(1, e), n ? ++i : o._PushElseInstance(t)
            }
            e.truncateArray(s, i), o.SetArrayPicked(s);
            const c = !!s.length;
            return e.clearArray(s), a.Pop(), t.ApplySolToContainer(), c
        },
        PickNth(e, t) {
            if (!e) return !1;
            const n = e.GetCurrentSol(),
                s = n.GetInstances();
            if (t = Math.floor(t), t >= s.length) return !1;
            const o = s[t];
            return n.PickOne(o), e.ApplySolToContainer(), !0
        },
        PickRandom(e) {
            if (!e) return !1;
            const n = e.GetCurrentSol(),
                t = n.GetInstances(),
                s = Math.floor(this._runtime.Random() * t.length);
            if (s >= t.length) return !1;
            const o = t[s];
            return n.PickOne(o), e.ApplySolToContainer(), !0
        },
        PickAll(e) {
            if (!e) return !1;
            if (!e.GetInstanceCount()) return !1;
            const t = e.GetCurrentSol();
            return t._SetSelectAll(!0), e.ApplySolToContainer(), !0
        },
        PickOverlappingPoint(n, s, o) {
            if (!n) return !1;
            const i = n.GetCurrentSol(),
                r = i.GetInstances(),
                c = this._runtime.GetCurrentEvent(),
                l = c.IsOrBlock(),
                a = this._runtime.GetCurrentCondition().IsInverted();
            i.IsSelectAll() ? (e.shallowAssignArray(t, r), i.ClearArrays(), i._SetSelectAll(!1)) : l ? (e.shallowAssignArray(t, i._GetOwnElseInstances()), e.clearArray(i._GetOwnElseInstances())) : (e.shallowAssignArray(t, i._GetOwnInstances()), e.clearArray(i._GetOwnInstances()));
            for (let n = 0, c = t.length; n < c; ++n) {
                const r = t[n];
                e.xor(r.GetWorldInfo().ContainsPoint(s, o), a) ? i._PushInstance(r) : i._PushElseInstance(r)
            }
            return n.ApplySolToContainer(), e.xor(!!i._GetOwnInstances().length, a)
        },
        PickLastCreated(e) {
            if (!e) return !1;
            const s = e.IsFamily();
            let t = null;
            const n = this._runtime._GetInstancesPendingCreate();
            for (let i = n.length - 1; i >= 0; --i) {
                const o = n[i];
                if (s) {
                    if (o.GetObjectClass().BelongsToFamily(e)) {
                        t = o;
                        break
                    }
                } else if (o.GetObjectClass() === e) {
                    t = o;
                    break
                }
            }
            if (!t) {
                const n = e.GetInstances();
                n.length && (t = n[n.length - 1])
            }
            if (!t) return !1;
            const o = e.GetCurrentSol();
            return o.PickOne(t), e.ApplySolToContainer(), !0
        },
        Repeat(e) {
            return this._runtime.IsDebugging() ? this._DebugRepeat(e) : this._Repeat(e)
        },
        While() {
            return this._runtime.IsDebugging() ? this._DebugWhile() : this._While()
        },
        For(e, t, n) {
            return this._runtime.IsDebugging() ? this._DebugFor(e, t, n) : this._For(e, t, n)
        },
        ForEach(e) {
            return this._runtime.IsDebugging() ? this._DebugForEach(e) : this._ForEach(e)
        },
        ForEachOrdered(e, t, n) {
            return this._runtime.IsDebugging() ? this._DebugForEachOrdered(e, n) : this._ForEachOrdered(e, n)
        },
        LayerVisible(e) {
            return !!e && e.IsVisible()
        },
        LayerEmpty(e) {
            return !!e && !e.GetInstanceCount()
        },
        LayerCmpOpacity(t, n, s) {
            return !!t && e.compare(t.GetOpacity() * 100, n, s)
        },
        OnImageLoadingComplete() {
            return !0
        },
        IsLoadingImages() {
            return this._imagesLoadingTotal > 0
        }
    }
}
"use strict";
{
    const e = self.C3;

    function SortZOrderList(e, t) {
        const s = e[0],
            o = t[0],
            n = s - o;
        if (n !== 0) return n;
        const i = e[1],
            a = t[1];
        return i - a
    }

    function SortInstancesByValue(e, t) {
        return e[1] - t[1]
    }
    const n = [],
        s = [],
        o = e.New(e.Rect),
        t = e.New(e.Color);
    e.Plugins.System.Acts = {
        SetVar(e, t) {
            e.SetValue(t)
        },
        AddVar(e, t) {
            e.IsNumber() && typeof t != "number" && (t = parseFloat(t)), e.SetValue(e.GetValue() + t)
        },
        SubVar(e, t) {
            if (!e.IsNumber()) return;
            e.SetValue(e.GetValue() - t)
        },
        SetBoolVar(e, t) {
            e.SetValue(!!t)
        },
        ToggleBoolVar(e) {
            e.SetValue(!e.GetValue())
        },
        ResetGlobals() {
            this._runtime.GetEventSheetManager().ResetAllGlobalsToInitialValue()
        },
        CreateObject(e, t, n, s, o) {
            if (!e || !t) return;
            const i = this._runtime.CreateInstance(e, t, n, s, o);
            if (!i) return;
            const a = this._runtime.GetEventSheetManager();
            a.BlockFlushingInstances(!0), i._TriggerOnCreatedOnSelfAndRelated(), a.BlockFlushingInstances(!1), e.GetCurrentSol().SetSinglePicked(i), i.IsInContainer() && i.SetSiblingsSinglePicked()
        },
        CreateObjectByName(t, n, s, o, i) {
            if (!t || !n) return;
            const a = this._runtime.GetObjectClassByName(t);
            if (!a) return;
            e.Plugins.System.Acts.CreateObject.call(this, a, n, s, o, i)
        },
        RecreateInitialObjects(e, t, n, s, i, a, r, c, l, d) {
            if (!e) return;
            let u = this._runtime.GetCurrentLayout();
            if (a) {
                const e = this._runtime.GetLayoutManager().GetLayoutByName(a);
                if (e) u = e;
                else return
            }
            let h = null;
            if ((typeof r != "number" || r >= 0) && (h = u.GetLayer(r), !h)) return;
            o.set(t, n, s, i);
            const m = u.RecreateInitialObjects(e, o, h, c, l, d);
            e.GetCurrentSol().SetArrayPicked(m), e.ApplySolToContainer()
        },
        StopLoop() {
            const e = this._loopStack;
            if (!e.IsInLoop()) return;
            e.GetCurrent().Stop()
        },
        SetGroupActive(e, t) {
            const n = this._runtime.GetEventSheetManager().GetEventGroupByName(e);
            if (!n) return;
            t === 0 ? n.SetGroupActive(!1) : t === 1 ? n.SetGroupActive(!0) : n.SetGroupActive(!n.IsGroupActive())
        },
        SetTimescale(e) {
            this._runtime.SetTimeScale(e)
        },
        SetObjectTimescale(e, t) {
            if (t < 0 && (t = 0), !e) return;
            const n = e.GetCurrentSol(),
                s = n.GetInstances();
            for (const e of s) e.SetTimeScale(t)
        },
        RestoreObjectTimescale(e) {
            if (!e) return;
            const t = e.GetCurrentSol(),
                n = t.GetInstances();
            for (const e of n) e.RestoreTimeScale()
        },
        Wait(e) {
            if (e < 0) return;
            return this._runtime.GetEventSheetManager().AddScheduledWait().InitTimer(e), !0
        },
        WaitForSignal(e) {
            return this._runtime.GetEventSheetManager().AddScheduledWait().InitSignal(e), !0
        },
        WaitForPreviousActions() {
            const e = this._runtime.GetEventSheetManager();
            return e.AddScheduledWait().InitPromise(e.GetPromiseForAllAsyncActions()), !0
        },
        Signal(e) {
            const t = e.toLowerCase();
            for (const e of this._runtime.GetEventSheetManager().scheduledWaits()) e.IsSignal() && e.GetSignalTag() === t && e.SetSignalled()
        },
        async SnapshotCanvas(t, n, s, o, i, a) {
            const r = this._runtime.GetCanvasManager();
            if (!r) return;
            this.UpdateRender(), await r.SnapshotCanvas(t === 0 ? "image/png" : "image/jpeg", n / 100, s, o, i, a), await this._runtime.TriggerAsync(e.Plugins.System.Cnds.OnCanvasSnapshot, null)
        },
        SetCanvasSize(e, t) {
            if (e <= 0 || t <= 0) return;
            this._runtime.SetViewportSize(e, t);
            const s = this._runtime.GetCurrentLayout();
            s.BoundScrolling();
            for (const e of s.GetLayers()) e.UpdateViewport();
            const n = this._runtime.GetCanvasManager();
            if (!n) return;
            n.GetCurrentFullscreenMode() === "off" ? n.SetSize(n.GetLastWidth(), n.GetLastHeight(), !0) : (this._runtime.SetOriginalViewportSize(e, t), n.SetSize(n.GetLastWidth(), n.GetLastHeight(), !0)), this._runtime.UpdateRender()
        },
        SetFullscreenQuality(e) {
            const t = this._runtime.GetCanvasManager();
            if (!t) return;
            if (t.GetCurrentFullscreenMode() === "off") return;
            t.SetFullscreenScalingQuality(e !== 0 ? "high" : "low"), t.SetSize(t.GetLastWidth(), t.GetLastHeight(), !0)
        },
        SaveState(e) {
            this._runtime.SaveToSlot(e)
        },
        LoadState(e) {
            this._runtime.LoadFromSlot(e)
        },
        LoadStateJSON(e) {
            this._runtime.LoadFromJsonString(e)
        },
        SetHalfFramerateMode() {},
        ResetPersisted() {
            for (const e of this._runtime.GetLayoutManager().GetAllLayouts()) e.ResetPersistData()
        },
        SetPixelRounding(e) {
            this._runtime.SetPixelRoundingEnabled(e !== 0)
        },
        SetMinimumFramerate(e) {
            this._runtime.SetMinimumFramerate(e)
        },
        SortZOrderByInstVar(t, o) {
            if (!t) return;
            const l = t.GetCurrentSol(),
                r = l.GetInstances(),
                i = n,
                a = s,
                d = this._runtime.GetCurrentLayout(),
                u = t.IsFamily(),
                h = t.GetFamilyIndex();
            for (let t = 0, c = r.length; t < c; ++t) {
                const e = r[t],
                    n = e.GetWorldInfo();
                if (!n) continue;
                let s;
                u ? s = e.GetInstanceVariableValue(o + e.GetObjectClass().GetFamilyInstanceVariableOffset(h)) : s = e.GetInstanceVariableValue(o), i.push([n.GetLayer().GetIndex(), n.GetZIndex()]), a.push([e, s])
            }
            if (!i.length) return;
            i.sort(SortZOrderList), a.sort(SortInstancesByValue);
            let c = !1;
            for (let e = 0, r = i.length; e < r; ++e) {
                const t = a[e][0],
                    n = d.GetLayerByIndex(i[e][0]),
                    s = i[e][1],
                    o = n._GetInstances();
                o[s] !== t && (o[s] = t, t.GetWorldInfo()._SetLayer(n), n.SetZIndicesChanged(), c = !0)
            }
            c && this._runtime.UpdateRender(), e.clearArray(n), e.clearArray(s)
        },
        GoToLayout(e) {
            if (this._runtime.IsLoading()) return;
            const t = this._runtime.GetLayoutManager();
            if (t.IsPendingChangeMainLayout()) return;
            t.ChangeMainLayout(e)
        },
        GoToLayoutByName(e) {
            if (this._runtime.IsLoading()) return;
            const t = this._runtime.GetLayoutManager();
            if (t.IsPendingChangeMainLayout()) return;
            const n = t.GetLayoutByName(e);
            n && t.ChangeMainLayout(n)
        },
        NextPrevLayout(e) {
            if (this._runtime.IsLoading()) return;
            const t = this._runtime.GetLayoutManager();
            if (t.IsPendingChangeMainLayout()) return;
            const n = t.GetAllLayouts(),
                s = n.indexOf(t.GetMainRunningLayout());
            if (e && s === 0) return;
            if (!e && s === n.length - 1) return;
            const o = n[s + (e ? -1 : 1)];
            t.ChangeMainLayout(o)
        },
        RestartLayout() {
            if (this._runtime.IsLoading()) return;
            const e = this._runtime.GetLayoutManager();
            if (e.IsPendingChangeMainLayout()) return;
            e.ChangeMainLayout(e.GetMainRunningLayout()), this._runtime.GetEventSheetManager().ResetAllGroupsInitialActivation()
        },
        SetLayerVisible(e, t) {
            if (!e) return;
            e.SetVisible(t)
        },
        SetLayerOpacity(e, t) {
            if (!e) return;
            e.SetOpacity(t / 100)
        },
        SetLayerScale(e, t) {
            if (!e) return;
            e.SetOwnScale(t)
        },
        SetLayerScaleRate(e, t) {
            if (!e) return;
            e.SetScaleRate(t)
        },
        SetLayerAngle(t, n) {
            if (!t) return;
            if (n = e.clampAngle(e.toRadians(+n)), t.GetOwnAngle() === n) return;
            t.SetAngle(n), this.UpdateRender()
        },
        SetLayerParallax(e, t, n) {
            if (!e) return;
            e.SetParallax(t / 100, n / 100)
        },
        SetLayerZElevation(e, t) {
            if (!e) return;
            e.SetZElevation(t)
        },
        SetLayerBackground(e, n) {
            if (!e) return;
            t.setFromRgbValue(n), t.clamp();
            const s = e.GetBackgroundColor();
            if (s.equalsIgnoringAlpha(t)) return;
            s.copyRgb(t), this.UpdateRender()
        },
        SetLayerTransparent(e, t) {
            if (!e) return;
            if (t = !!t, e.IsTransparent() === t) return;
            e.SetTransparent(t), this.UpdateRender()
        },
        SetLayerBlendMode(e, t) {
            if (!e) return;
            if (e.GetBlendMode() === t) return;
            e.SetBlendMode(t), this.UpdateRender()
        },
        SetLayerEffectEnabled(e, t, n) {
            if (!e) return;
            const o = e.GetEffectList(),
                s = o.GetEffectTypeByName(n);
            if (!s) return;
            const i = t === 1;
            if (s.IsActive() === i) return;
            s.SetActive(i), o.UpdateActiveEffects(), this._runtime.UpdateRender()
        },
        SetLayerEffectParam(e, n, s, o) {
            if (!e) return;
            const r = e.GetEffectList(),
                i = r.GetEffectTypeByName(n);
            if (!i) return;
            const l = i.GetIndex(),
                a = r.GetEffectParametersForIndex(l);
            if (s = Math.floor(s), s < 0 || s >= a.length) return;
            const c = i.GetShaderProgram().GetParameterType(s);
            if (c === "color") {
                t.setFromRgbValue(o);
                const e = a[s];
                if (t.equalsIgnoringAlpha(e)) return;
                e.copyRgb(t)
            } else {
                if (c === "percent" && (o /= 100), a[s] === o) return;
                a[s] = o
            }
            i.IsActive() && this._runtime.UpdateRender()
        },
        SetLayerForceOwnTexture(e, t) {
            if (!e) return;
            if (t = !!t, e.IsForceOwnTexture() === t) return;
            e.SetForceOwnTexture(t), this.UpdateRender()
        },
        SetLayoutScale(e) {
            const t = this._runtime.GetCurrentLayout();
            if (t.GetScale() === e) return;
            t.SetScale(e), this.UpdateRender()
        },
        SetLayoutAngle(t) {
            t = e.clampAngle(e.toRadians(+t));
            const n = this._runtime.GetCurrentLayout();
            if (n.GetAngle() === t) return;
            n.SetAngle(t), this.UpdateRender()
        },
        SetLayoutEffectEnabled(e, t) {
            const i = this._runtime.GetCurrentLayout(),
                s = i.GetEffectList(),
                n = s.GetEffectTypeByName(t);
            if (!n) return;
            const o = e === 1;
            if (n.IsActive() === o) return;
            n.SetActive(o), s.UpdateActiveEffects(), this._runtime.UpdateRender()
        },
        SetLayoutEffectParam(e, n, s) {
            const c = this._runtime.GetCurrentLayout(),
                a = c.GetEffectList(),
                o = a.GetEffectTypeByName(e);
            if (!o) return;
            const l = o.GetIndex(),
                i = a.GetEffectParametersForIndex(l);
            if (n = Math.floor(n), n < 0 || n >= i.length) return;
            const r = o.GetShaderProgram().GetParameterType(n);
            if (r === "color") {
                t.setFromRgbValue(s);
                const e = i[n];
                if (t.equalsIgnoringAlpha(e)) return;
                e.copyRgb(t)
            } else {
                if (r === "percent" && (s /= 100), i[n] === s) return;
                i[n] = s
            }
            o.IsActive() && this._runtime.UpdateRender()
        },
        ScrollX(e) {
            const t = this._runtime.GetCurrentLayout();
            t.SetScrollX(e)
        },
        ScrollY(e) {
            const t = this._runtime.GetCurrentLayout();
            t.SetScrollY(e)
        },
        Scroll(e, t) {
            const n = this._runtime.GetCurrentLayout();
            n.SetScrollX(e), n.SetScrollY(t)
        },
        ScrollToObject(e) {
            if (!e) return;
            const n = e.GetFirstPicked();
            if (!n) return;
            const t = n.GetWorldInfo();
            if (!t) return;
            const s = this._runtime.GetCurrentLayout();
            s.SetScrollX(t.GetX()), s.SetScrollY(t.GetY())
        },
        async LoadObjectTextures(e) {
            const t = this._runtime.GetMainRunningLayout();
            if (!t || !e || this._runtime.IsLoading()) return;
            const n = e.IsFamily() ? e.GetFamilyMembers() : [e];
            await this._LoadTexturesForObjectClasses(t, n)
        },
        async LoadObjectTexturesByName(t) {
            await e.Plugins.System.Acts.LoadObjectTextures.call(this, this._runtime.GetObjectClassByName(t))
        },
        UnloadObjectTextures(e) {
            const t = this._runtime.GetMainRunningLayout();
            if (!t || !e) return;
            const n = e.IsFamily() ? e.GetFamilyMembers() : [e];
            this._UnloadTexturesForObjectClasses(t, n)
        },
        UnloadObjectTexturesByName(t) {
            e.Plugins.System.Acts.UnloadObjectTexturesByName.call(this, this._runtime.GetObjectClassByName(t))
        },
        UnloadUnusedTextures() {
            const e = this._runtime.GetMainRunningLayout();
            if (!e) return;
            const t = e._GetTextureLoadedObjectTypes();
            this._UnloadTexturesForObjectClasses(e, t)
        },
        async LoadLayoutTextures(e) {
            const t = this._runtime.GetMainRunningLayout();
            if (!e || !t || this._runtime.IsLoading()) return;
            await this._LoadTexturesForObjectClasses(t, e._GetInitialObjectClasses())
        },
        async LoadLayoutTexturesByName(e) {
            const t = this._runtime.GetMainRunningLayout(),
                n = this._runtime.GetLayoutManager().GetLayoutByName(e);
            if (!n || !t || this._runtime.IsLoading()) return;
            await this._LoadTexturesForObjectClasses(t, n._GetInitialObjectClasses())
        },
        SetFunctionReturnValue(e) {
            const t = this._eventStack.GetCurrentExpFuncStackFrame();
            if (!t) return;
            switch (t.GetFunctionReturnType()) {
                case 1:
                    typeof e == "number" && t.SetFunctionReturnValue(e);
                    break;
                case 2:
                    typeof e == "string" && t.SetFunctionReturnValue(e);
                    break;
                case 3:
                    t.SetFunctionReturnValue(e);
                    break
            }
        },
        MapFunction(t, n, s) {
            const i = this._GetFunctionMap(t.toLowerCase(), !0),
                o = i.strMap,
                a = n.toLowerCase();
            o.has(a) && console.warn(`[Construct 3] Function map '${t}' string '${n}' already in map; overwriting entry`);
            const r = e.first(o.values()) || i.defaultFunc;
            if (r) {
                const e = r.GetReturnType() !== 0,
                    o = s.GetReturnType() !== 0;
                if (e !== o) {
                    console.error(`[Construct 3] Function map '${t}' string '${n}' function return type not compatible with other functions in the map; entry ignored`);
                    return
                }
            }
            o.set(a, s)
        },
        MapFunctionDefault(t, n) {
            const s = this._GetFunctionMap(t.toLowerCase(), !0);
            s.defaultFunc && console.warn(`[Construct 3] Function map '${t}' already has a default; overwriting entry`);
            const o = e.first(s.strMap.values()) || s.defaultFunc;
            if (o) {
                const e = o.GetReturnType() !== 0,
                    s = n.GetReturnType() !== 0;
                if (e !== s) {
                    console.error(`[Construct 3] Function map '${t}' default: function return type not compatible with other functions in the map; entry ignored`);
                    return
                }
            }
            s.defaultFunc = n
        },
        CallMappedFunction(e, t, n) {
            n = Math.floor(n);
            const a = this._GetFunctionMap(e.toLowerCase(), !1);
            if (!a) {
                console.warn(`[Construct 3] Call mapped function: map name '${e}' not found; call ignored`);
                return
            }
            let s = a.strMap.get(t.toLowerCase());
            if (!s)
                if (a.defaultFunc) s = a.defaultFunc, n = 0;
                else {
                    console.warn(`[Construct 3] Call mapped function: no function associated with map '${e}' string '${t}'; call ignored (consider setting a default)`);
                    return
                } if (!s.IsEnabled()) return;
            if (s.GetReturnType() !== 0) {
                console.warn(`[Construct 3] Call mapped function: map '${e}' string '${t}' has a return type so cannot be called`);
                return
            }
            const l = this._runtime,
                o = l.GetEventSheetManager(),
                d = o.GetCurrentEvent(),
                r = d.GetSolModifiersIncludingParents(),
                c = r.length > 0;
            c && o.PushCleanSol(r);
            const i = [],
                u = o.FindFirstFunctionBlockParent(d);
            if (u) {
                const e = u.GetFunctionParameters();
                for (let t = n, s = e.length; t < s; ++t) i.push(e[t].GetValue())
            }
            const h = s.GetFunctionParameters();
            for (let e = i.length, t = h.length; e < t; ++e) i.push(h[e].GetInitialValue());
            return l.IsDebugging() ? this._DebugDoCallMappedFunction(o, s, i, c, r) : this._DoCallMappedFunction(o, s, i, c, r)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.System.Exps = {
        int: function(e) {
            return typeof e == "string" && (e = parseInt(e, 10), isNaN(e) && (e = 0)), Math.floor(e)
        },
        float: function(e) {
            return typeof e == "string" && (e = parseFloat(e), isNaN(e) && (e = 0)), e
        },
        str(e) {
            return e.toString()
        },
        len(e) {
            return typeof e == "string" ? e.length : 0
        },
        random(e, t) {
            return typeof t == "undefined" ? this._runtime.Random() * e : this._runtime.Random() * (t - e) + e
        },
        choose(...e) {
            const t = Math.floor(this._runtime.Random() * e.length);
            return e[t]
        },
        pi() {
            return Math.PI
        },
        infinity() {
            return 1 / 0
        },
        sqrt(e) {
            return Math.sqrt(e)
        },
        abs(e) {
            return Math.abs(e)
        },
        round(e) {
            return Math.round(e)
        },
        floor(e) {
            return Math.floor(e)
        },
        ceil(e) {
            return Math.ceil(e)
        },
        sign(e) {
            return Math.sign(e)
        },
        sin(t) {
            return Math.sin(e.toRadians(t))
        },
        cos(t) {
            return Math.cos(e.toRadians(t))
        },
        tan(t) {
            return Math.tan(e.toRadians(t))
        },
        asin(t) {
            return e.toDegrees(Math.asin(t))
        },
        acos(t) {
            return e.toDegrees(Math.acos(t))
        },
        atan(t) {
            return e.toDegrees(Math.atan(t))
        },
        exp(e) {
            return Math.exp(e)
        },
        ln(e) {
            return Math.log(e)
        },
        log10(e) {
            return Math.log(e) / Math.LN10
        },
        max(...t) {
            let e = t[0];
            typeof e != "number" && (e = 0);
            for (let n = 1, o = t.length; n < o; ++n) {
                let s = t[n];
                if (typeof s != "number") continue;
                e < s && (e = s)
            }
            return e
        },
        min(...t) {
            let e = t[0];
            typeof e != "number" && (e = 0);
            for (let n = 1, o = t.length; n < o; ++n) {
                let s = t[n];
                if (typeof s != "number") continue;
                e > s && (e = s)
            }
            return e
        },
        clamp(t, n, s) {
            return e.clamp(t, n, s)
        },
        distance(t, n, s, o) {
            return e.distanceTo(t, n, s, o)
        },
        angle(t, n, s, o) {
            return e.toDegrees(e.angleTo(t, n, s, o))
        },
        lerp(t, n, s) {
            return e.lerp(t, n, s)
        },
        unlerp(t, n, s) {
            return e.unlerp(t, n, s)
        },
        qarp(t, n, s, o) {
            return e.qarp(t, n, s, o)
        },
        cubic(t, n, s, o, i) {
            return e.cubic(t, n, s, o, i)
        },
        cosp(t, n, s) {
            return e.cosp(t, n, s)
        },
        anglediff(t, n) {
            return e.toDegrees(e.angleDiff(e.toRadians(t), e.toRadians(n)))
        },
        anglelerp(t, n, s) {
            return e.toDegrees(e.angleLerp(e.toRadians(t), e.toRadians(n), s))
        },
        anglerotate(t, n, s) {
            return e.toDegrees(e.angleRotate(e.toRadians(t), e.toRadians(n), e.toRadians(s)))
        },
        setbit(e, t, n) {
            return e = e | 0, t = t | 0, n = n !== 0 ? 1 : 0, e & ~(1 << t) | n << t
        },
        togglebit(e, t) {
            return e = e | 0, t = t | 0, e ^ 1 << t
        },
        getbit(e, t) {
            return e = e | 0, t = t | 0, e & 1 << t ? 1 : 0
        },
        newline() {
            return `
`
        },
        uppercase(e) {
            return typeof e == "string" ? e.toUpperCase() : ""
        },
        lowercase(e) {
            return typeof e == "string" ? e.toLowerCase() : ""
        },
        left(e, t) {
            return typeof e == "string" ? e.substr(0, t) : ""
        },
        mid(e, t, n) {
            return typeof e != "string" ? "" : n < 0 ? e.substr(t) : e.substr(t, n)
        },
        right(e, t) {
            return typeof e == "string" ? e.substr(e.length - t) : ""
        },
        trim(e) {
            return typeof e == "string" ? e.trim() : ""
        },
        tokenat(e, t, n) {
            if (typeof e != "string" || typeof n != "string") return "";
            let s = e.split(n);
            return t = Math.floor(t), t < 0 || t >= s.length ? "" : s[t]
        },
        tokencount(e, t) {
            return typeof e != "string" || typeof t != "string" || !e.length ? 0 : e.split(t).length
        },
        find(t, n) {
            return typeof t == "string" && typeof n == "string" ? t.search(new RegExp(e.EscapeRegex(n), "i")) : -1
        },
        findcase(t, n) {
            return typeof t == "string" && typeof n == "string" ? t.search(new RegExp(e.EscapeRegex(n), "")) : -1
        },
        replace(t, n, s) {
            return typeof t == "string" && typeof n == "string" && typeof s == "string" ? t.replace(new RegExp(e.EscapeRegex(n), "gi"), s) : typeof t == "string" ? t : ""
        },
        regexsearch(e, t, n) {
            const s = this.GetRegex(t, n);
            return e ? e.search(s) : -1
        },
        regexreplace(e, t, n, s) {
            const o = this.GetRegex(t, n);
            return e ? e.replace(o, s) : ""
        },
        regexmatchcount(e, t, n) {
            const s = this.GetRegexMatches(e.toString(), t, n);
            return s ? s.length : 0
        },
        regexmatchat(e, t, n, s) {
            s = Math.floor(s);
            const o = this.GetRegexMatches(e.toString(), t, n);
            return !o || s < 0 || s >= o.length ? "" : o[s]
        },
        zeropad(e, t) {
            let n = e < 0 ? "-" : "";
            e < 0 && (e = -e);
            const s = t - e.toString().length;
            return n += "0".repeat(Math.max(s, 0)), n + e.toString()
        },
        urlencode(e) {
            return encodeURIComponent(e)
        },
        urldecode(e) {
            return decodeURIComponent(e)
        },
        dt() {
            return this._runtime._GetDtFast()
        },
        timescale() {
            return this._runtime.GetTimeScale()
        },
        wallclocktime() {
            return (Date.now() - this._runtime.GetStartTime()) / 1e3
        },
        unixtime() {
            return Date.now()
        },
        time() {
            return this._runtime.GetGameTime()
        },
        tickcount() {
            return this._runtime.GetTickCount()
        },
        objectcount() {
            return this._runtime.GetObjectCount()
        },
        fps() {
            return this._runtime.GetFPS()
        },
        cpuutilisation() {
            return this._runtime.GetMainThreadTime()
        },
        gpuutilisation() {
            return this._runtime.GetGPUUtilisation()
        },
        windowwidth() {
            return this._runtime.GetCanvasManager().GetDeviceWidth()
        },
        windowheight() {
            return this._runtime.GetCanvasManager().GetDeviceHeight()
        },
        originalwindowwidth() {
            return this._runtime.GetOriginalViewportWidth()
        },
        originalwindowheight() {
            return this._runtime.GetOriginalViewportHeight()
        },
        originalviewportwidth() {
            return this._runtime.GetOriginalViewportWidth()
        },
        originalviewportheight() {
            return this._runtime.GetOriginalViewportHeight()
        },
        scrollx() {
            return this._runtime.GetCurrentLayout().GetScrollX()
        },
        scrolly() {
            return this._runtime.GetCurrentLayout().GetScrollY()
        },
        layoutname() {
            return this._runtime.GetCurrentLayout().GetName()
        },
        layoutscale() {
            return this._runtime.GetCurrentLayout().GetScale()
        },
        layoutangle() {
            return e.toDegrees(this._runtime.GetCurrentLayout().GetAngle())
        },
        layoutwidth() {
            return this._runtime.GetCurrentLayout().GetWidth()
        },
        layoutheight() {
            return this._runtime.GetCurrentLayout().GetHeight()
        },
        viewportleft(e) {
            const t = this._runtime.GetCurrentLayout().GetLayer(e);
            return t ? t.GetViewport().getLeft() : 0
        },
        viewporttop(e) {
            const t = this._runtime.GetCurrentLayout().GetLayer(e);
            return t ? t.GetViewport().getTop() : 0
        },
        viewportright(e) {
            const t = this._runtime.GetCurrentLayout().GetLayer(e);
            return t ? t.GetViewport().getRight() : 0
        },
        viewportbottom(e) {
            const t = this._runtime.GetCurrentLayout().GetLayer(e);
            return t ? t.GetViewport().getBottom() : 0
        },
        viewportwidth(e) {
            const t = this._runtime.GetCurrentLayout().GetLayer(e);
            return t ? t.GetViewport().width() : 0
        },
        viewportheight(e) {
            const t = this._runtime.GetCurrentLayout().GetLayer(e);
            return t ? t.GetViewport().height() : 0
        },
        canvastolayerx(e, t, n) {
            const s = this._runtime.GetCurrentLayout().GetLayer(e);
            return s ? s.CanvasCssToLayer(t, n)[0] : 0
        },
        canvastolayery(e, t, n) {
            const s = this._runtime.GetCurrentLayout().GetLayer(e);
            return s ? s.CanvasCssToLayer(t, n)[1] : 0
        },
        layertocanvasx(e, t, n) {
            const s = this._runtime.GetCurrentLayout().GetLayer(e);
            return s ? s.LayerToCanvasCss(t, n)[0] : 0
        },
        layertocanvasy(e, t, n) {
            const s = this._runtime.GetCurrentLayout().GetLayer(e);
            return s ? s.LayerToCanvasCss(t, n)[1] : 0
        },
        layerscale(e) {
            const t = this._runtime.GetCurrentLayout().GetLayer(e);
            return t ? t.GetOwnScale() : 0
        },
        layerangle(t) {
            const n = this._runtime.GetCurrentLayout().GetLayer(t);
            return n ? e.toDegrees(n.GetOwnAngle()) : 0
        },
        layeropacity(e) {
            const t = this._runtime.GetCurrentLayout().GetLayer(e);
            return t ? t.GetOpacity() * 100 : 0
        },
        layerscalerate(e) {
            const t = this._runtime.GetCurrentLayout().GetLayer(e);
            return t ? t.GetScaleRate() : 0
        },
        layerparallaxx(e) {
            const t = this._runtime.GetCurrentLayout().GetLayer(e);
            return t ? t.GetParallaxX() * 100 : 0
        },
        layerparallaxy(e) {
            const t = this._runtime.GetCurrentLayout().GetLayer(e);
            return t ? t.GetParallaxY() * 100 : 0
        },
        layerzelevation(e) {
            const t = this._runtime.GetCurrentLayout().GetLayer(e);
            return t ? t.GetZElevation() : 0
        },
        layerindex(e) {
            const t = this._runtime.GetCurrentLayout().GetLayer(e);
            return t ? t.GetIndex() : -1
        },
        canvassnapshot() {
            const e = this._runtime.GetCanvasManager();
            return e ? e.GetCanvasSnapshotUrl() : ""
        },
        loopindex(e) {
            const t = this._loopStack;
            if (!t.IsInLoop()) return 0;
            if (e) {
                const n = t.FindByName(e);
                return n ? n.GetIndex() : 0
            }
            return t.GetCurrent().GetIndex()
        },
        savestatejson() {
            return this._runtime.GetLastSaveJsonString()
        },
        callmapped(n, o, ...i) {
            const t = this._GetFunctionMap(n.toLowerCase(), !1);
            if (!t) return console.warn(`[Construct 3] Call mapped function: map name '${n}' not found; returning 0`), 0;
            let e = t.strMap.get(o.toLowerCase());
            if (!e)
                if (t.defaultFunc) e = t.defaultFunc;
                else return console.warn(`[Construct 3] Call mapped function: no function associated with map '${n}' string '${o}'; returning 0 (consider setting a default)`), 0;
            const c = e.GetReturnType(),
                r = e.GetDefaultReturnValue();
            if (c === 0) return console.warn(`[Construct 3] Call mapped function: map '${n}' string '${o}' has no return type so cannot be called from an expression; returning 0`), 0;
            if (!e.IsEnabled()) return r;
            const h = this._runtime,
                s = h.GetEventSheetManager(),
                m = s.GetCurrentEvent(),
                a = m.GetSolModifiersIncludingParents(),
                l = a.length > 0;
            l && s.PushCleanSol(a);
            const d = e.GetFunctionParameters();
            for (let e = i.length, t = d.length; e < t; ++e) i.push(d[e].GetInitialValue());
            const u = e.GetEventBlock(),
                f = u.RunAsExpressionFunctionCall(u.GetSolModifiersIncludingParents(), c, r, ...i);
            return l && s.PopSol(a), f
        },
        loadingprogress() {
            return this._runtime.GetAssetManager().GetLoadProgress()
        },
        imageloadingprogress() {
            return this._imagesLoadingTotal === 0 ? 1 : this._imagesLoadingComplete / this._imagesLoadingTotal
        },
        renderer() {
            return "webgl"
        },
        rendererdetail() {
            return this._runtime.GetWebGLRenderer().GetUnmaskedRenderer()
        },
        imagememoryusage() {
            let e = this._runtime.GetWebGLRenderer().GetEstimatedTextureMemoryUsage();
            return Math.round(100 * e / (1024 * 1024)) / 100
        },
        rgb(t, n, s) {
            return e.PackRGB(t, n, s)
        },
        rgbex(t, n, s) {
            return e.PackRGBEx(t / 100, n / 100, s / 100)
        },
        rgba(t, n, s, o) {
            return e.PackRGBAEx(t / 100, n / 100, s / 100, o / 100)
        },
        rgbex255(t, n, s) {
            return e.PackRGBEx(t / 255, n / 255, s / 255)
        },
        rgba255(t, n, s, o) {
            return e.PackRGBAEx(t / 255, n / 255, s / 255, o / 255)
        },
        projectname() {
            return this._runtime.GetProjectName()
        },
        projectversion() {
            return this._runtime.GetProjectVersion()
        },
        currenteventsheetname() {
            return this._runtime.GetCurrentEvent().GetEventSheet().GetName()
        },
        currenteventnumber() {
            return this._runtime.GetCurrentEvent().GetDisplayNumber()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Sprite = class SpritePlugin extends e.SDKPluginBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Sprite.Type = class SpriteType extends e.SDKTypeBase {
        constructor(e) {
            super(e), this._animations = e.GetAnimations()
        }
        Release() {
            e.clearArray(this._animations), super.Release()
        }
        OnCreate() {
            for (const e of this._animations) e.LoadAllAssets(this._runtime)
        }
        LoadTextures(e) {
            const t = {
                sampling: this._runtime.GetSampling()
            };
            return Promise.all(this._animations.map(n => n.LoadAllTextures(e, t)))
        }
        ReleaseTextures() {
            for (const e of this._animations) e.ReleaseAllTextures()
        }
        OnDynamicTextureLoadComplete() {
            this._UpdateAllCurrentTexture()
        }
        _UpdateAllCurrentTexture() {
            for (const e of this._objectClass.instancesIncludingPendingCreate()) e.GetSdkInstance()._UpdateCurrentTexture()
        }
        FinishCondition(t) {
            e.Plugins.Sprite._FinishCondition(this, t)
        }
    }
}
"use strict";
{
    const e = self.C3,
        h = 0,
        u = 1,
        i = 2,
        o = 3,
        d = e.New(e.Rect),
        r = e.New(e.Quad),
        n = e.New(e.Vector2),
        a = 1 << 0,
        s = 1 << 1,
        c = 1 << 2;
    e.Plugins.Sprite.Instance = class SpriteInstance extends e.SDKWorldInstanceBase {
        constructor(t, n) {
            super(t);
            let c = !0,
                l = "",
                d = 0,
                m = !0;
            n && (c = !!n[h], l = n[u], d = n[i], m = n[o]), this._currentAnimation = this._objectClass.GetAnimationByName(l) || this._objectClass.GetAnimations()[0], this._currentFrameIndex = e.clamp(d, 0, this._currentAnimation.GetFrameCount() - 1), this._currentAnimationFrame = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
            const f = this._currentAnimationFrame.GetImageInfo();
            this._currentTexture = f.GetTexture(), this._currentRcTex = f.GetTexRect(), this.HandleWebGLContextLoss(), t.SetFlag(s, !0), t.SetFlag(a, this._currentAnimation.GetSpeed() >= 0), this._currentAnimationSpeed = Math.abs(this._currentAnimation.GetSpeed()), this._currentAnimationRepeatTo = this._currentAnimation.GetRepeatTo(), this._animationTimer = e.New(e.KahanSum), this._frameStartTime = 0, this._animationRepeats = 0, this._animTriggerName = "", this._changeAnimFrameIndex = -1, this._changeAnimationName = "", this._changeAnimationFrom = 0;
            const r = this.GetWorldInfo();
            this._bquadRef = r.GetBoundingQuad(), r.SetVisible(c), r.SetCollisionEnabled(m), r.SetOriginX(this._currentAnimationFrame.GetOriginX()), r.SetOriginY(this._currentAnimationFrame.GetOriginY()), r.SetSourceCollisionPoly(this._currentAnimationFrame.GetCollisionPoly()), r.SetBboxChanged(), (this._objectClass.GetAnimationCount() !== 1 || this._objectClass.GetAnimations()[0].GetFrameCount() !== 1) && this._currentAnimationSpeed !== 0 && this._StartTicking()
        }
        Release() {
            this._currentAnimation = null, this._currentAnimationFrame = null, this._currentTexture = null, this._animationTimer = null, super.Release()
        }
        GetCurrentImageInfo() {
            return this._currentAnimationFrame.GetImageInfo()
        }
        OnWebGLContextLost() {
            this._currentTexture = null
        }
        OnWebGLContextRestored() {
            this._UpdateCurrentTexture()
        }
        Draw(e) {
            const n = this._currentTexture;
            if (n === null) return;
            e.SetTexture(n);
            const t = this.GetWorldInfo();
            t.HasMesh() ? this._DrawMesh(t, e) : this._DrawStandard(t, e)
        }
        _DrawStandard(e, t) {
            let n = this._bquadRef;
            this._runtime.IsPixelRoundingEnabled() && (n = e.PixelRoundQuad(n)), t.Quad3(n, this._currentRcTex)
        }
        _DrawMesh(e, t) {
            const n = e.GetTransformedMesh();
            if (e.IsMeshChanged()) {
                e.CalculateBbox(d, r, !1);
                let t = r;
                this._runtime.IsPixelRoundingEnabled() && (t = e.PixelRoundQuad(t)), n.CalculateTransformedMesh(e.GetSourceMesh(), t, this._currentRcTex), e.SetMeshChanged(!1)
            }
            n.Draw(t)
        }
        GetAnimationTime() {
            return this._animationTimer.Get()
        }
        IsAnimationPlaying() {
            return this._inst.GetFlag(s)
        }
        SetAnimationPlaying(e) {
            this._inst.SetFlag(s, e)
        }
        IsPlayingForwards() {
            return this._inst.GetFlag(a)
        }
        SetPlayingForwards(e) {
            this._inst.SetFlag(a, e)
        }
        IsInAnimationTrigger() {
            return this._inst.GetFlag(c)
        }
        SetInAnimationTrigger(e) {
            this._inst.SetFlag(c, e)
        }
        Tick() {
            this._changeAnimationName && this._DoChangeAnimation(), this._changeAnimFrameIndex >= 0 && this._DoChangeAnimFrame();
            const s = this._currentAnimationSpeed;
            if (!this.IsAnimationPlaying() || s === 0) {
                this._StopTicking();
                return
            }
            const h = this._runtime.GetDt(this._inst);
            this._animationTimer.Add(h);
            const o = this.GetAnimationTime(),
                c = this._currentAnimationFrame,
                l = c.GetDuration() / s;
            if (o < this._frameStartTime + l) return;
            const t = this._currentAnimation,
                n = this._currentAnimationRepeatTo,
                i = t.GetFrameCount(),
                a = t.GetRepeatCount(),
                r = t.IsLooping(),
                d = t.IsPingPong();
            this.IsPlayingForwards() ? this._currentFrameIndex++ : this._currentFrameIndex--, this._frameStartTime += l, this._currentFrameIndex >= i && (d ? (this.SetPlayingForwards(!1), this._currentFrameIndex = i - 2) : r ? this._currentFrameIndex = n : (this._animationRepeats++, this._animationRepeats >= a ? this._FinishAnimation(!1) : this._currentFrameIndex = n)), this._currentFrameIndex < 0 && (d ? (this._currentFrameIndex = 1, this.SetPlayingForwards(!0), r || (this._animationRepeats++, this._animationRepeats >= a && this._FinishAnimation(!0))) : r ? this._currentFrameIndex = n : (this._animationRepeats++, this._animationRepeats >= a ? this._FinishAnimation(!0) : this._currentFrameIndex = n)), this._currentFrameIndex = e.clamp(this._currentFrameIndex, 0, i - 1);
            const u = t.GetFrameAt(this._currentFrameIndex);
            o > this._frameStartTime + u.GetDuration() / s && (this._frameStartTime = o), this._OnFrameChanged(c, u)
        }
        _FinishAnimation(t) {
            this._currentFrameIndex = t ? 0 : this._currentAnimation.GetFrameCount() - 1, this.SetAnimationPlaying(!1), this._animTriggerName = this._currentAnimation.GetName(), this.SetInAnimationTrigger(!0), this.Trigger(e.Plugins.Sprite.Cnds.OnAnyAnimFinished), this.Trigger(e.Plugins.Sprite.Cnds.OnAnimFinished), this.SetInAnimationTrigger(!1), this._animationRepeats = 0
        }
        _OnFrameChanged(t, n) {
            if (t === n) return;
            const s = this.GetWorldInfo(),
                i = t.GetImageInfo(),
                o = n.GetImageInfo(),
                a = i.GetWidth(),
                r = i.GetHeight(),
                c = o.GetWidth(),
                l = o.GetHeight();
            a !== c && s.SetWidth(s.GetWidth() * (c / a)), r !== l && s.SetHeight(s.GetHeight() * (l / r)), s.SetOriginX(n.GetOriginX()), s.SetOriginY(n.GetOriginY()), s.SetSourceCollisionPoly(n.GetCollisionPoly()), s.SetBboxChanged(), this._currentAnimationFrame = n, this._currentTexture = o.GetTexture(), this._currentRcTex = o.GetTexRect();
            const d = this.GetInstance().GetBehaviorInstances();
            for (let e = 0, s = d.length; e < s; ++e) d[e].OnSpriteFrameChanged(t, n);
            this.Trigger(e.Plugins.Sprite.Cnds.OnFrameChanged), this._runtime.UpdateRender()
        }
        _StartAnim(e) {
            this.SetAnimationPlaying(!0), this._frameStartTime = this.GetAnimationTime(), e === 1 && this._currentFrameIndex !== 0 && (this._changeAnimFrameIndex = 0, this.IsInAnimationTrigger() || this._DoChangeAnimFrame()), this._StartTicking()
        }
        _SetAnim(e, t) {
            this._changeAnimationName = e, this._changeAnimationFrom = t, this._StartTicking(), this.IsInAnimationTrigger() || this._DoChangeAnimation()
        }
        _GetCurrentAnimationName() {
            return this._changeAnimationName ? this._changeAnimationName : this._currentAnimation.GetName()
        }
        _SetAnimFrame(e) {
            if (!isFinite(e)) return;
            this._changeAnimFrameIndex = e, this.IsInAnimationTrigger() || this._DoChangeAnimFrame()
        }
        _GetAnimFrame() {
            return this._currentFrameIndex
        }
        _SetAnimSpeed(e) {
            this._currentAnimationSpeed = Math.abs(e), this.SetPlayingForwards(e >= 0), this._currentAnimationSpeed > 0 && this._StartTicking()
        }
        _GetAnimSpeed() {
            return this.IsPlayingForwards() ? this._currentAnimationSpeed : -this._currentAnimationSpeed
        }
        _SetAnimRepeatToFrame(t) {
            t = e.clamp(Math.floor(t), 0, this._currentAnimation.GetFrameCount() - 1), this._currentAnimationRepeatTo = t
        }
        _GetAnimRepeatToFrame() {
            return this._currentAnimationRepeatTo
        }
        _DoChangeAnimation() {
            const n = this._currentAnimationFrame,
                t = this._objectClass.GetAnimationByName(this._changeAnimationName);
            if (this._changeAnimationName = "", !t) return;
            if (t === this._currentAnimation && this.IsAnimationPlaying()) return;
            this._currentAnimation = t, this.SetPlayingForwards(t.GetSpeed() >= 0), this._currentAnimationSpeed = Math.abs(t.GetSpeed()), this._currentAnimationRepeatTo = t.GetRepeatTo(), this._currentFrameIndex = e.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1), this._changeAnimationFrom === 1 && (this._currentFrameIndex = 0), this.SetAnimationPlaying(!0), this._frameStartTime = this.GetAnimationTime();
            const s = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
            this._OnFrameChanged(n, s)
        }
        _DoChangeAnimFrame() {
            const t = this._currentAnimationFrame,
                n = this._currentFrameIndex;
            if (this._currentFrameIndex = e.clamp(Math.floor(this._changeAnimFrameIndex), 0, this._currentAnimation.GetFrameCount() - 1), this._changeAnimFrameIndex = -1, n === this._currentFrameIndex) return;
            const s = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
            this._OnFrameChanged(t, s), this._frameStartTime = this.GetAnimationTime()
        }
        _UpdateCurrentTexture() {
            const e = this._currentAnimationFrame.GetImageInfo();
            this._currentTexture = e.GetTexture(), this._currentRcTex = e.GetTexRect(), this.GetWorldInfo().SetMeshChanged(!0)
        }
        GetImagePointCount() {
            return this._currentAnimationFrame.GetImagePointCount()
        }
        GetImagePoint(e) {
            const s = this._currentAnimationFrame,
                t = this.GetWorldInfo();
            let o = null;
            if (typeof e == "string") o = s.GetImagePointByName(e);
            else if (typeof e == "number") o = s.GetImagePointByIndex(e - 1);
            else throw new TypeError("expected string or number");
            if (!o) return [t.GetX(), t.GetY()];
            if (n.copy(o.GetVec2()), t.HasMesh()) {
                const [e, s] = t.GetSourceMesh().TransformPoint(n.getX(), n.getY());
                n.set(e, s)
            }
            return n.offset(-s.GetOriginX(), -s.GetOriginY()), n.scale(t.GetWidth(), t.GetHeight()), n.rotate(t.GetAngle()), n.offset(t.GetX(), t.GetY()), [n.getX(), n.getY()]
        }
        GetCollisionPolyPointCount() {
            return this.GetWorldInfo().GetTransformedCollisionPoly().pointCount()
        }
        GetCollisionPolyPoint(e) {
            e = Math.floor(e);
            const t = this.GetWorldInfo(),
                n = t.GetTransformedCollisionPoly(),
                s = n.pointCount();
            if (e === s && (e = 0), e < 0 || e >= s) return [0, 0];
            const o = n.pointsArr();
            return [o[e * 2 + 0] + t.GetX(), o[e * 2 + 1] + t.GetY()]
        }
        GetDebuggerProperties() {
            const n = e.Plugins.Sprite.Acts,
                t = "plugins.sprite.debugger.animation-properties";
            return [{
                title: t + ".title",
                properties: [{
                    name: t + ".current-animation",
                    value: this._currentAnimation.GetName(),
                    onedit: e => this.CallAction(n.SetAnim, e, 0)
                }, {
                    name: t + ".current-frame",
                    value: this._currentFrameIndex,
                    onedit: e => this.CallAction(n.SetAnimFrame, e)
                }, {
                    name: t + ".is-playing",
                    value: this.IsAnimationPlaying(),
                    onedit: e => e ? this.CallAction(n.StartAnim, 0) : this.CallAction(n.StopAnim)
                }, {
                    name: t + ".speed",
                    value: this._currentAnimationSpeed,
                    onedit: e => this.CallAction(n.SetAnimSpeed, e)
                }, {
                    name: t + ".repeats",
                    value: this._animationRepeats,
                    onedit: e => this._animationRepeats = e
                }]
            }]
        }
        SaveToJson() {
            const e = {
                a: this._currentAnimation.GetSID()
            };
            this._frameStartTime !== 0 && (e.fs = this._frameStartTime);
            const t = this.GetAnimationTime();
            t !== 0 && (e.at = t), this._currentFrameIndex !== 0 && (e.f = this._currentFrameIndex), this._currentAnimationSpeed !== 0 && (e.cas = this._currentAnimationSpeed), this._animationRepeats !== 1 && (e.ar = this._animationRepeats), this._currentAnimationRepeatTo !== 0 && (e.rt = this._currentAnimationRepeatTo), this.IsAnimationPlaying() || (e.ap = this.IsAnimationPlaying()), this.IsPlayingForwards() || (e.af = this.IsPlayingForwards());
            const n = this.GetWorldInfo();
            return n.IsCollisionEnabled() && (e.ce = n.IsCollisionEnabled()), e
        }
        LoadFromJson(t) {
            const o = this.GetObjectClass().GetAnimationBySID(t.a);
            o && (this._currentAnimation = o), this._frameStartTime = t.hasOwnProperty("fs") ? t.fs : 0, this._animationTimer.Set(t.hasOwnProperty("at") ? t.at : 0);
            const i = t.hasOwnProperty("f") ? t.f : 0;
            this._currentFrameIndex = e.clamp(i, 0, this._currentAnimation.GetFrameCount() - 1), this._currentAnimationSpeed = t.hasOwnProperty("cas") ? t.cas : 0, this._animationRepeats = t.hasOwnProperty("ar") ? t.ar : 1;
            const a = t.hasOwnProperty("rt") ? t.rt : 0;
            this._currentAnimationRepeatTo = e.clamp(a, 0, this._currentAnimation.GetFrameCount() - 1), this.SetAnimationPlaying(!t.hasOwnProperty("ap") || !!t.ap), this.SetPlayingForwards(!t.hasOwnProperty("af") || !!t.af);
            const n = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
            this._currentAnimationFrame = n, this._UpdateCurrentTexture();
            const s = this.GetWorldInfo();
            s.SetOriginX(n.GetOriginX()), s.SetOriginY(n.GetOriginY()), s.SetSourceCollisionPoly(n.GetCollisionPoly()), s.SetCollisionEnabled(!!t.ce)
        }
        GetPropertyValueByIndex(t) {
            const n = this.GetWorldInfo();
            switch (t) {
                case o:
                    return n.IsCollisionEnabled();
                case i:
                    return e.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1)
            }
        }
        SetPropertyValueByIndex(t, n) {
            const s = this.GetWorldInfo();
            switch (t) {
                case o:
                    s.SetCollisionEnabled(!!n);
                    break;
                case i:
                    this.SetAnimationPlaying(!1);
                    const t = this._currentAnimation.GetFrameCount() - 1,
                        a = n = e.clamp(n, 0, t),
                        r = this._currentAnimation.GetFrameAt(this._currentFrameIndex),
                        c = this._currentAnimation.GetFrameAt(a);
                    this._OnFrameChanged(r, c), this._currentFrameIndex = e.clamp(a, 0, t);
                    break
            }
        }
        GetScriptInterfaceClass() {
            return self.ISpriteInstance
        }
    };
    const t = new WeakMap,
        l = new Map([
            ["current-frame", 0],
            ["beginning", 1]
        ]);
    self.ISpriteInstance = class ISpriteInstance extends self.IWorldInstance {
        constructor() {
            super(), t.set(this, self.IInstance._GetInitInst().GetSdkInstance())
        }
        getImagePointCount() {
            return t.get(this).GetImagePointCount()
        }
        getImagePointX(e) {
            if (typeof e != "string" && typeof e != "number") throw new TypeError("expected string or number");
            return t.get(this).GetImagePoint(e)[0]
        }
        getImagePointY(e) {
            if (typeof e != "string" && typeof e != "number") throw new TypeError("expected string or number");
            return t.get(this).GetImagePoint(e)[1]
        }
        getImagePoint(e) {
            if (typeof e != "string" && typeof e != "number") throw new TypeError("expected string or number");
            return t.get(this).GetImagePoint(e)
        }
        getPolyPointCount() {
            return t.get(this).GetCollisionPolyPointCount()
        }
        getPolyPointX(e) {
            return t.get(this).GetCollisionPolyPoint(e)[0]
        }
        getPolyPointY(e) {
            return t.get(this).GetCollisionPolyPoint(e)[1]
        }
        getPolyPoint(e) {
            return t.get(this).GetCollisionPolyPoint(e)
        }
        stopAnimation() {
            t.get(this).SetAnimationPlaying(!1)
        }
        startAnimation(e = "current-frame") {
            const n = l.get(e);
            if (typeof n == "undefined") throw new Error("invalid mode");
            t.get(this)._StartAnim(n)
        }
        setAnimation(e, n = "beginning") {
            const s = l.get(n);
            if (typeof s == "undefined") throw new Error("invalid mode");
            t.get(this)._SetAnim(e, s)
        }
        get animationName() {
            return t.get(this)._GetCurrentAnimationName()
        }
        set animationFrame(e) {
            t.get(this)._SetAnimFrame(e)
        }
        get animationFrame() {
            return t.get(this)._GetAnimFrame()
        }
        set animationSpeed(e) {
            t.get(this)._SetAnimSpeed(e)
        }
        get animationSpeed() {
            return t.get(this)._GetAnimSpeed()
        }
        set animationRepeatToFrame(e) {
            t.get(this)._SetAnimRepeatToFrame(e)
        }
        get animationRepeatToFrame() {
            return t.get(this)._GetAnimRepeatToFrame()
        }
        get imageWidth() {
            return t.get(this).GetCurrentImageInfo().GetWidth()
        }
        get imageHeight() {
            return t.get(this).GetCurrentImageInfo().GetHeight()
        }
    }
}
"use strict";
{
    const e = self.C3,
        o = e.New(e.Rect),
        n = [],
        i = [];
    let a = !1,
        s = null,
        r = !1;
    const t = new Set;

    function CollMemory_Add(e, t, n, s) {
        const o = t.GetUID(),
            i = n.GetUID();
        o < i ? e.Set(t, n, s) : e.Set(n, t, s)
    }

    function CollMemory_Remove(e, t, n) {
        const s = t.GetUID(),
            o = n.GetUID();
        s < o ? e.Delete(t, n) : e.Delete(n, t)
    }

    function CollMemory_RemoveInstance(e, t) {
        e.DeleteEither(t)
    }

    function CollMemory_Get(e, t, n) {
        const s = t.GetUID(),
            o = n.GetUID();
        return s < o ? e.Get(t, n) : e.Get(n, t)
    }

    function DoOverlapCondition(n, c, l, d) {
        if (!c) return !1;
        const g = n.GetInstance(),
            y = l !== 0 || d !== 0,
            u = g.GetWorldInfo(),
            f = g.GetRuntime(),
            v = f.GetCollisionEngine(),
            p = f.GetCurrentCondition(),
            x = p.GetEventBlock().IsOrBlock(),
            C = p.GetObjectClass(),
            b = p.IsInverted(),
            h = c.GetCurrentSol(),
            j = C !== c;
        s = c, a = j && !b, r = !1;
        let m, _ = 0,
            w = 0,
            O = !1;
        h.IsSelectAll() ? (o.copy(u.GetBoundingBox()), o.offset(l, d), v.GetCollisionCandidates(u.GetLayer(), c, o, i), m = i) : x ? f.IsCurrentConditionFirst() && !h._GetOwnElseInstances().length && h._GetOwnInstances().length ? m = h._GetOwnInstances() : (m = h._GetOwnElseInstances(), r = !0) : m = h._GetOwnInstances(), y && (_ = u.GetX(), w = u.GetY(), u.OffsetXY(l, d), u.SetBboxChanged());
        for (const e of m)
            if (v.TestOverlap(g, e)) {
                if (O = !0, b) break;
                j && t.add(e)
            } return y && (u.SetXY(_, w), u.SetBboxChanged()), e.clearArray(i), O
    }

    function FinishCollisionConditionPicking(n) {
        const i = n.GetRuntime().GetCurrentEvent().IsOrBlock(),
            o = s.GetCurrentSol(),
            a = o._GetOwnInstances(),
            c = o._GetOwnElseInstances();
        o.IsSelectAll() ? (o.SetSetPicked(t), i && (e.clearArray(c), o.AddElseInstances(t, s.GetInstances()))) : i ? r ? o.TransferElseInstancesToOwn(t) : (o.AddElseInstances(t, a), o.SetSetPicked(t)) : o.SetSetPicked(t), s.ApplySolToContainer()
    }
    e.Plugins.Sprite._FinishCondition = function(e, n) {
        if (!a) return;
        n && FinishCollisionConditionPicking(e), t.clear(), s = null, a = !1
    }, e.Plugins.Sprite.Cnds = {
        OnCollision(t) {
            if (this._runtime.IsDebugging()) return e.Plugins.Sprite.Cnds.DebugOnCollision.call(this, t);
            if (!t) return !1;
            const c = this._runtime,
                a = c.GetCollisionEngine(),
                r = c.GetEventSheetManager(),
                d = r.GetEventStack(),
                u = r.GetCurrentCondition(),
                o = u.GetObjectClass(),
                v = u.GetSavedDataMap(),
                f = u.GetUnsavedDataMap(),
                h = d.GetCurrentStackFrame(),
                m = c.GetTickCount(),
                b = m - 1,
                l = h.GetCurrentEvent(),
                j = d.Push(l);
            let s = v.get("collmemory");
            s || (s = e.New(e.PairMap), v.set("collmemory", s)), f.get("spriteCreatedDestroyCallback") || (f.set("spriteCreatedDestroyCallback", !0), c.Dispatcher().addEventListener("instancedestroy", e => CollMemory_RemoveInstance(s, e.instance)));
            const y = o.GetCurrentSol(),
                p = t.GetCurrentSol(),
                g = y.GetInstances();
            let i = null;
            for (let d = 0; d < g.length; ++d) {
                const c = g[d];
                p.IsSelectAll() ? (a.GetCollisionCandidates(c.GetWorldInfo().GetLayer(), t, c.GetWorldInfo().GetBoundingBox(), n), i = n, a.AddRegisteredCollisionCandidates(c, t, i)) : i = p.GetInstances();
                for (let d = 0; d < i.length; ++d) {
                    const n = i[d];
                    if (a.TestOverlap(c, n) || a.CheckRegisteredCollision(c, n)) {
                        {
                            const i = CollMemory_Get(s, c, n);
                            let a = !1,
                                d = -2;
                            typeof i == "number" && (a = !0, d = i);
                            const u = !a || d < b;
                            if (CollMemory_Add(s, c, n, m), u) {
                                const i = l.GetSolModifiers();
                                r.PushCopySol(i);
                                const s = o.GetCurrentSol(),
                                    a = t.GetCurrentSol();
                                if (s._SetSelectAll(!1), a._SetSelectAll(!1), o === t) {
                                    const t = s._GetOwnInstances();
                                    e.clearArray(t), t.push(c), t.push(n), o.ApplySolToContainer()
                                } else {
                                    const i = s._GetOwnInstances(),
                                        r = a._GetOwnInstances();
                                    e.clearArray(i), e.clearArray(r), i.push(c), r.push(n), o.ApplySolToContainer(), t.ApplySolToContainer()
                                }
                                l.Retrigger(h, j), r.PopSol(i)
                            }
                        }
                    } else CollMemory_Remove(s, c, n)
                }
                e.clearArray(n)
            }
            return d.Pop(), !1
        },
        * DebugOnCollision(t) {
            if (!t) return !1;
            const c = this._runtime,
                a = c.GetCollisionEngine(),
                r = c.GetEventSheetManager(),
                d = r.GetEventStack(),
                v = d.GetCurrentStackFrame(),
                f = c.GetTickCount(),
                j = f - 1,
                u = v.GetCurrentEvent(),
                b = d.Push(u),
                l = r.GetCurrentCondition(),
                i = l.GetObjectClass(),
                m = l.GetSavedDataMap(),
                h = l.GetUnsavedDataMap();
            let s = m.get("collmemory");
            s || (s = e.New(e.PairMap), m.set("collmemory", s)), h.get("spriteCreatedDestroyCallback") || (h.set("spriteCreatedDestroyCallback", !0), c.Dispatcher().addEventListener("instancedestroy", e => CollMemory_RemoveInstance(s, e.instance)));
            const y = i.GetCurrentSol(),
                p = t.GetCurrentSol(),
                g = y.GetInstances();
            let o = null;
            for (let l = 0; l < g.length; ++l) {
                const c = g[l];
                p.IsSelectAll() ? (a.GetCollisionCandidates(c.GetWorldInfo().GetLayer(), t, c.GetWorldInfo().GetBoundingBox(), n), o = n, a.AddRegisteredCollisionCandidates(c, t, o)) : o = p.GetInstances();
                for (let l = 0; l < o.length; ++l) {
                    const n = o[l];
                    if (a.TestOverlap(c, n) || a.CheckRegisteredCollision(c, n)) {
                        {
                            const o = CollMemory_Get(s, c, n);
                            let a = !1,
                                l = -2;
                            typeof o == "number" && (a = !0, l = o);
                            const d = !a || l < j;
                            if (CollMemory_Add(s, c, n, f), d) {
                                const o = u.GetSolModifiers();
                                r.PushCopySol(o);
                                const s = i.GetCurrentSol(),
                                    a = t.GetCurrentSol();
                                if (s._SetSelectAll(!1), a._SetSelectAll(!1), i === t) {
                                    const t = s._GetOwnInstances();
                                    e.clearArray(t), t.push(c), t.push(n), i.ApplySolToContainer()
                                } else {
                                    const o = s._GetOwnInstances(),
                                        r = a._GetOwnInstances();
                                    e.clearArray(o), e.clearArray(r), o.push(c), r.push(n), i.ApplySolToContainer(), t.ApplySolToContainer()
                                }
                                yield* u.DebugRetrigger(v, b), r.PopSol(o)
                            }
                        }
                    } else CollMemory_Remove(s, c, n)
                }
                e.clearArray(n)
            }
            return d.Pop(), !1
        },
        IsOverlapping(e) {
            return DoOverlapCondition(this, e, 0, 0)
        },
        IsOverlappingOffset(e, t, n) {
            return DoOverlapCondition(this, e, t, n)
        },
        IsAnimPlaying(t) {
            return e.equalsNoCase(this._GetCurrentAnimationName(), t)
        },
        CompareFrame(t, n) {
            return e.compare(this._currentFrameIndex, t, n)
        },
        CompareAnimSpeed(t, n) {
            return e.compare(this._GetAnimSpeed(), t, n)
        },
        OnAnimFinished(t) {
            return e.equalsNoCase(this._animTriggerName, t)
        },
        OnAnyAnimFinished() {
            return !0
        },
        OnFrameChanged() {
            return !0
        },
        IsMirrored() {
            return this.GetWorldInfo().GetWidth() < 0
        },
        IsFlipped() {
            return this.GetWorldInfo().GetHeight() < 0
        },
        OnURLLoaded() {
            return !0
        },
        OnURLFailed() {
            return !0
        },
        IsCollisionEnabled() {
            return this.GetWorldInfo().IsCollisionEnabled()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Sprite.Acts = {
        Spawn(t, n, s, o) {
            if (!t || !n) return;
            const [l, d] = this.GetImagePoint(s), i = this._runtime.CreateInstance(t, n, l, d, o);
            if (!i) return;
            if (t.GetPlugin().IsRotatable()) {
                const e = i.GetWorldInfo();
                e.SetAngle(this.GetWorldInfo().GetAngle()), e.SetBboxChanged()
            }
            const c = this._runtime.GetEventSheetManager();
            c.BlockFlushingInstances(!0), i._TriggerOnCreatedOnSelfAndRelated(), c.BlockFlushingInstances(!1);
            const u = this._runtime.GetCurrentAction(),
                a = u.GetSavedDataMap();
            let r = !1;
            if ((!a.has("Spawn_LastExec") || a.get("Spawn_LastExec") < this._runtime.GetExecCount()) && (r = !0, a.set("Spawn_LastExec", this._runtime.GetExecCount())), t !== this.GetObjectClass()) {
                const s = t.GetCurrentSol();
                s._SetSelectAll(!1);
                const n = s._GetOwnInstances();
                if (r ? (e.clearArray(n), n.push(i)) : n.push(i), i.IsInContainer())
                    for (const e of i.siblings()) {
                        const t = e.GetObjectClass().GetCurrentSol();
                        r ? t.SetSinglePicked(e) : (t._SetSelectAll(!1), t._PushInstance(e))
                    }
            }
        },
        StopAnim() {
            this.SetAnimationPlaying(!1)
        },
        StartAnim(e) {
            this._StartAnim(e)
        },
        SetAnim(e, t) {
            this._SetAnim(e, t)
        },
        SetAnimFrame(e) {
            this._SetAnimFrame(e)
        },
        SetAnimSpeed(e) {
            this._SetAnimSpeed(e)
        },
        SetAnimRepeatToFrame(e) {
            this._SetAnimRepeatToFrame(e)
        },
        SetMirrored(e) {
            const t = this.GetWorldInfo(),
                n = t.GetWidth(),
                s = Math.abs(n) * (e === 0 ? -1 : 1);
            if (n === s) return;
            t.SetWidth(s), t.SetBboxChanged()
        },
        SetFlipped(e) {
            const t = this.GetWorldInfo(),
                n = t.GetHeight(),
                s = Math.abs(n) * (e === 0 ? -1 : 1);
            if (n === s) return;
            t.SetHeight(s), t.SetBboxChanged()
        },
        SetScale(e) {
            const i = this._currentAnimationFrame,
                n = i.GetImageInfo(),
                t = this.GetWorldInfo(),
                a = t.GetWidth() < 0 ? -1 : 1,
                r = t.GetHeight() < 0 ? -1 : 1,
                s = n.GetWidth() * e * a,
                o = n.GetHeight() * e * r;
            (t.GetWidth() !== s || t.GetHeight() !== o) && (t.SetSize(s, o), t.SetBboxChanged())
        },
        async LoadURL(t, n) {
            const c = this._currentAnimationFrame,
                o = c.GetImageInfo(),
                i = this.GetWorldInfo(),
                r = this._runtime;
            if (o.GetURL() === t) {
                n === 0 && (i.SetSize(o.GetWidth(), o.GetHeight()), i.SetBboxChanged()), this.Trigger(e.Plugins.Sprite.Cnds.OnURLLoaded);
                return
            }
            const a = e.New(e.ImageInfo);
            if (await a.LoadDynamicAsset(r, t), !a.IsLoaded()) {
                this.Trigger(e.Plugins.Sprite.Cnds.OnURLFailed);
                return
            }
            await a.LoadStaticTexture(r.GetWebGLRenderer(), {
                sampling: this._runtime.GetSampling()
            }), o.ReplaceWith(a), this._sdkType._UpdateAllCurrentTexture(), !this.WasReleased() && n === 0 && (i.SetSize(o.GetWidth(), o.GetHeight()), i.SetBboxChanged()), r.UpdateRender(), this.WasReleased() || await this.TriggerAsync(e.Plugins.Sprite.Cnds.OnURLLoaded)
        },
        SetCollisions(e) {
            this.GetWorldInfo().SetCollisionEnabled(e)
        },
        SetSolidCollisionFilter(e, t) {
            this.GetWorldInfo().SetSolidCollisionFilter(e === 0, t)
        },
        SetEffect(e) {
            this.GetWorldInfo().SetBlendMode(e), this._runtime.UpdateRender()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Sprite.Exps = {
        AnimationFrame() {
            return this._currentFrameIndex
        },
        AnimationFrameCount() {
            return this._currentAnimation.GetFrameCount()
        },
        AnimationName() {
            return this._currentAnimation.GetName()
        },
        AnimationSpeed() {
            return this._GetAnimSpeed()
        },
        OriginalAnimationSpeed() {
            return this._currentAnimation.GetSpeed()
        },
        ImagePointX(e) {
            return this.GetImagePoint(e)[0]
        },
        ImagePointY(e) {
            return this.GetImagePoint(e)[1]
        },
        ImagePointCount() {
            return this.GetImagePointCount()
        },
        ImageWidth() {
            return this.GetCurrentImageInfo().GetWidth()
        },
        ImageHeight() {
            return this.GetCurrentImageInfo().GetHeight()
        },
        PolyPointXAt(e) {
            return this.GetCollisionPolyPoint(e)[0]
        },
        PolyPointYAt(e) {
            return this.GetCollisionPolyPoint(e)[1]
        },
        PolyPointCount() {
            return this.GetCollisionPolyPointCount()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Text = class TextPlugin extends e.SDKPluginBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Text.Type = class TextType extends e.SDKTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        LoadTextures() {}
        ReleaseTextures() {}
    }
}
"use strict";
{
    const t = self.C3,
        o = [0, 0, 0],
        m = 0,
        f = 1,
        g = 2,
        h = 3,
        l = 4,
        p = 5,
        c = 6,
        s = 7,
        d = 8,
        u = 9,
        a = 10,
        y = 11,
        x = 12,
        b = ["left", "center", "right"],
        v = ["top", "center", "bottom"],
        i = 0,
        j = 1,
        r = new t.Rect,
        n = new t.Quad;
    t.Plugins.Text.Instance = class TextInstance extends t.SDKWorldInstanceBase {
        constructor(e, n) {
            if (super(e), this._text = "", this._enableBBcode = !0, this._faceName = "Arial", this._ptSize = 12, this._lineHeightOffset = 0, this._isBold = !1, this._isItalic = !1, this._color = t.New(t.Color), this._horizontalAlign = 0, this._verticalAlign = 0, this._wrapByWord = !0, this._typewriterStartTime = -1, this._typewriterEndTime = -1, this._typewriterLength = 0, this._rendererText = t.New(t.Gfx.RendererText, this._runtime.GetWebGLRenderer(), {
                    timeout: 5
                }), this._rendererText.ontextureupdate = () => this._runtime.UpdateRender(), this._rendererText.SetIsAsync(!1), n) {
                this._text = n[m], this._enableBBcode = !!n[f], this._faceName = n[g], this._ptSize = n[h], this._lineHeightOffset = n[l], this._isBold = !!n[p], this._isItalic = !!n[c], this._horizontalAlign = n[d], this._verticalAlign = n[u], this._wrapByWord = n[a] === i;
                const e = n[s];
                this._color.setRgb(e[0], e[1], e[2]), this.GetWorldInfo().SetVisible(n[y])
            }
            this._UpdateTextSettings()
        }
        Release() {
            this._CancelTypewriter(), this._rendererText.Release(), this._rendererText = null, super.Release()
        }
        _UpdateTextSettings() {
            const e = this._rendererText;
            e.SetText(this._text), e.SetBBCodeEnabled(this._enableBBcode), e.SetFontName(this._faceName), e.SetLineHeight(this._lineHeightOffset), e.SetBold(this._isBold), e.SetItalic(this._isItalic), e.SetColor(this._color), e.SetHorizontalAlignment(b[this._horizontalAlign]), e.SetVerticalAlignment(v[this._verticalAlign]), e.SetWordWrapMode(this._wrapByWord ? "word" : "character")
        }
        _UpdateTextSize() {
            const e = this.GetWorldInfo();
            this._rendererText.SetFontSize(this._ptSize * e.GetSceneGraphScale());
            const t = e.GetLayer(),
                n = t.GetRenderScale() * t.Get2DScaleFactorToZ(e.GetTotalZElevation());
            this._rendererText.SetSize(e.GetWidth(), e.GetHeight(), n)
        }
        Draw(e) {
            const s = this.GetWorldInfo();
            this._UpdateTextSize();
            const o = this._rendererText.GetTexture();
            if (!o) return;
            const i = s.GetLayer();
            let t = s.GetBoundingQuad();
            if (s.GetAngle() === 0 && s.GetLayer().GetAngle() === 0 && s.GetTotalZElevation() === 0) {
                const [s, a] = i.LayerToDrawSurface(t.getTlx(), t.getTly()), [c, l] = i.LayerToDrawSurface(t.getBrx(), t.getBry()), d = s - Math.round(s), u = a - Math.round(a);
                r.set(s, a, c, l), r.offset(-d, -u), n.setFromRect(r);
                const [h, m] = e.GetRenderTargetSize(e.GetRenderTarget());
                this._runtime.GetCanvasManager().SetDeviceTransform(e, h, m), e.SetTexture(o), e.Quad3(n, this._rendererText.GetTexRect()), i._SetTransform(e)
            } else {
                let s = 0,
                    i = 0;
                this._runtime.IsPixelRoundingEnabled() && (s = t.getTlx() - Math.round(t.getTlx()), i = t.getTly() - Math.round(t.getTly())), (s !== 0 || i !== 0) && (n.copy(t), n.offset(-s, -i), t = n), e.SetTexture(o), e.Quad3(t, this._rendererText.GetTexRect())
            }
        }
        SaveToJson() {
            const e = {
                t: this._text,
                c: this._color.toJSON(),
                fn: this._faceName,
                ps: this._ptSize
            };
            return this._enableBBcode && (e.bbc = this._enableBBcode), this._horizontalAlign !== 0 && (e.ha = this._horizontalAlign), this._verticalAlign !== 0 && (e.va = this._verticalAlign), this._wrapByWord || (e.wr = this._wrapByWord), this._lineHeightOffset !== 0 && (e.lho = this._lineHeightOffset), this._isBold && (e.b = this._isBold), this._isItalic && (e.i = this._isItalic), this._typewriterEndTime !== -1 && (e.tw = {
                st: this._typewriterStartTime,
                en: this._typewriterEndTime,
                l: this._typewriterLength
            }), e
        }
        LoadFromJson(e) {
            if (this._CancelTypewriter(), this._text = e.t, this._color.setFromJSON(e.c), this._faceName = e.fn, this._ptSize = e.ps, this._enableBBcode = !!e.hasOwnProperty("bbc") && e.bbc, this._horizontalAlign = e.hasOwnProperty("ha") ? e.ha : 0, this._verticalAlign = e.hasOwnProperty("va") ? e.va : 0, this._wrapByWord = !e.hasOwnProperty("wr") || e.wr, this._lineHeightOffset = e.hasOwnProperty("lho") ? e.lho : 0, this._isBold = !!e.hasOwnProperty("b") && e.b, this._isItalic = !!e.hasOwnProperty("i") && e.i, e.hasOwnProperty("tw")) {
                const t = e.tw;
                this._typewriterStartTime = t.st, this._typewriterEndTime = t.en, this._typewriterLength = t.l
            }
            this._UpdateTextSettings(), this._typewriterEndTime !== -1 && this._StartTicking()
        }
        GetPropertyValueByIndex(e) {
            switch (e) {
                case m:
                    return this._text;
                case f:
                    return this._enableBBcode;
                case g:
                    return this._faceName;
                case h:
                    return this._ptSize;
                case l:
                    return this._lineHeightOffset;
                case p:
                    return this._isBold;
                case c:
                    return this._isItalic;
                case s:
                    return o[0] = this._color.getR(), o[1] = this._color.getG(), o[2] = this._color.getB(), o;
                case d:
                    return this._horizontalAlign;
                case u:
                    return this._verticalAlign;
                case a:
                    return this._wrapByWord ? j : i
            }
        }
        SetPropertyValueByIndex(e, t) {
            switch (e) {
                case m:
                    if (this._text === t) return;
                    this._text = t, this._UpdateTextSettings();
                    break;
                case f:
                    if (this._enableBBcode === !!t) return;
                    this._enableBBcode = !!t, this._UpdateTextSettings();
                    break;
                case g:
                    if (this._faceName === t) return;
                    this._faceName = t, this._UpdateTextSettings();
                    break;
                case h:
                    if (this._ptSize === t) return;
                    this._ptSize = t, this._UpdateTextSettings();
                    break;
                case l:
                    if (this._lineHeightOffset === t) return;
                    this._lineHeightOffset = t, this._UpdateTextSettings();
                    break;
                case p:
                    if (this._isBold === !!t) return;
                    this._isBold = !!t, this._UpdateTextSettings();
                    break;
                case c:
                    if (this._isItalic === !!t) return;
                    this._isItalic = !!t, this._UpdateTextSettings();
                    break;
                case s:
                    const n = this._color,
                        e = t;
                    if (n.getR() === e[0] && n.getG() === e[1] && n.getB() === e[2]) return;
                    this._color.setRgb(e[0], e[1], e[2]), this._UpdateTextSettings();
                    break;
                case d:
                    if (this._horizontalAlign === t) return;
                    this._horizontalAlign = t, this._UpdateTextSettings();
                    break;
                case u:
                    if (this._verticalAlign === t) return;
                    this._verticalAlign = t, this._UpdateTextSettings();
                    break;
                case a:
                    if (this._wrapByWord === (t === i)) return;
                    this._wrapByWord = t === i, this._UpdateTextSettings();
                    break
            }
        }
        SetPropertyColorOffsetValueByIndex(e, t, n, o) {
            if (t === 0 && n === 0 && o === 0) return;
            switch (e) {
                case s:
                    this._color.addRgb(t, n, o), this._UpdateTextSettings();
                    break
            }
        }
        _SetText(e) {
            if (this._text === e) return;
            this._text = e, this._rendererText.SetText(e), this._runtime.UpdateRender()
        }
        GetText() {
            return this._text
        }
        _StartTypewriter(e, n) {
            this._SetText(e), this._typewriterStartTime = this._runtime.GetWallTime(), this._typewriterEndTime = this._typewriterStartTime + n / this.GetInstance().GetActiveTimeScale(), this._typewriterLength = t.BBString.StripAnyTags(e).length, this._rendererText.SetDrawMaxCharacterCount(0), this._StartTicking()
        }
        _CancelTypewriter() {
            this._typewriterStartTime = -1, this._typewriterEndTime = -1, this._typewriterLength = 0, this._rendererText.SetDrawMaxCharacterCount(-1), this._StopTicking()
        }
        _FinishTypewriter() {
            if (this._typewriterEndTime === -1) return;
            this._CancelTypewriter(), this.Trigger(t.Plugins.Text.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender()
        }
        _SetFontFace(e) {
            if (this._faceName === e) return;
            this._faceName = e, this._rendererText.SetFontName(e), this._runtime.UpdateRender()
        }
        _GetFontFace() {
            return this._faceName
        }
        _SetBold(e) {
            if (e = !!e, this._isBold === e) return;
            this._isBold = e, this._rendererText.SetBold(e), this._runtime.UpdateRender()
        }
        _IsBold() {
            return this._isBold
        }
        _SetItalic(e) {
            if (e = !!e, this._isItalic === e) return;
            this._isItalic = e, this._rendererText.SetItalic(e), this._runtime.UpdateRender()
        }
        _IsItalic() {
            return this._isItalic
        }
        _SetFontSize(e) {
            if (this._ptSize === e) return;
            this._ptSize = e, this._runtime.UpdateRender()
        }
        _GetFontSize() {
            return this._ptSize
        }
        _SetLineHeight(e) {
            if (this._lineHeightOffset === e) return;
            this._lineHeightOffset = e, this._UpdateTextSettings(), this._runtime.UpdateRender()
        }
        _GetLineHeight() {
            return this._lineHeightOffset
        }
        _SetHAlign(e) {
            if (this._horizontalAlign === e) return;
            this._horizontalAlign = e, this._UpdateTextSettings(), this._runtime.UpdateRender()
        }
        _GetHAlign() {
            return this._horizontalAlign
        }
        _SetVAlign(e) {
            if (this._verticalAlign === e) return;
            this._verticalAlign = e, this._UpdateTextSettings(), this._runtime.UpdateRender()
        }
        _GetVAlign() {
            return this._verticalAlign
        }
        _SetWrapByWord(e) {
            if (e = !!e, this._wrapByWord === e) return;
            this._wrapByWord = e, this._UpdateTextSettings(), this._runtime.UpdateRender()
        }
        _IsWrapByWord() {
            return this._wrapByWord
        }
        Tick() {
            const e = this._runtime.GetWallTime();
            if (e >= this._typewriterEndTime) this._CancelTypewriter(), this.Trigger(t.Plugins.Text.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender();
            else {
                let n = t.relerp(this._typewriterStartTime, this._typewriterEndTime, e, 0, this._typewriterLength);
                n = Math.floor(n), n !== this._rendererText.GetDrawMaxCharacterCount() && (this._rendererText.SetDrawMaxCharacterCount(n), this._runtime.UpdateRender())
            }
        }
        GetDebuggerProperties() {
            const e = "plugins.text";
            return [{
                title: e + ".name",
                properties: [{
                    name: e + ".properties.text.name",
                    value: this._text,
                    onedit: e => this._SetText(e)
                }]
            }]
        }
        GetScriptInterfaceClass() {
            return self.ITextInstance
        }
    };
    const e = new WeakMap,
        _ = new Map([
            ["left", 0],
            ["center", 1],
            ["right", 2]
        ]),
        w = new Map([
            ["top", 0],
            ["center", 1],
            ["bottom", 2]
        ]),
        O = new Map([
            ["word", !0],
            ["character", !1]
        ]);
    self.ITextInstance = class ITextInstance extends self.IWorldInstance {
        constructor() {
            super(), e.set(this, self.IInstance._GetInitInst().GetSdkInstance())
        }
        get text() {
            return e.get(this).GetText()
        }
        set text(t) {
            const n = e.get(this);
            n._CancelTypewriter(), n._SetText(t)
        }
        typewriterText(t, n) {
            const s = e.get(this);
            s._CancelTypewriter(), s._StartTypewriter(t, n)
        }
        typewriterFinish() {
            e.get(this)._FinishTypewriter()
        }
        set fontFace(t) {
            e.get(this)._SetFontFace(t)
        }
        get fontFace() {
            return e.get(this)._GetFontFace()
        }
        set isBold(t) {
            e.get(this)._SetBold(t)
        }
        get isBold() {
            return e.get(this)._IsBold()
        }
        set isItalic(t) {
            e.get(this)._SetItalic(t)
        }
        get isItalic() {
            return e.get(this)._IsItalic()
        }
        set sizePt(t) {
            e.get(this)._SetFontSize(t)
        }
        get sizePt() {
            return e.get(this)._GetFontSize()
        }
        set lineHeight(t) {
            e.get(this)._SetLineHeight(t)
        }
        get lineHeight() {
            return e.get(this)._GetLineHeight()
        }
        set horizontalAlign(t) {
            const n = _.get(t);
            if (typeof n == "undefined") throw new Error("invalid mode");
            e.get(this)._SetHAlign(n)
        }
        get horizontalAlign() {
            return b[e.get(this)._GetHAlign()]
        }
        set verticalAlign(t) {
            const n = w.get(t);
            if (typeof n == "undefined") throw new Error("invalid mode");
            e.get(this)._SetVAlign(n)
        }
        get verticalAlign() {
            return v[e.get(this)._GetVAlign()]
        }
        set wordWrapMode(t) {
            const n = O.get(t);
            if (typeof n == "undefined") throw new Error("invalid mode");
            e.get(this)._SetWrapByWord(n)
        }
        get wordWrapMode() {
            return e.get(this)._IsWrapByWord() ? "word" : "character"
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Text.Cnds = {
        CompareText(t, n) {
            return n ? this._text === t : e.equalsNoCase(this._text, t)
        },
        IsRunningTypewriterText() {
            return this._typewriterEndTime !== -1
        },
        OnTypewriterTextFinished() {
            return !0
        }
    }
}
"use strict";
{
    const t = self.C3,
        e = t.New(t.Color);
    t.Plugins.Text.Acts = {
        SetText(e) {
            this._CancelTypewriter(), typeof e == "number" && e < 1e9 && (e = Math.round(e * 1e10) / 1e10), this._SetText(e.toString())
        },
        AppendText(e) {
            if (this._CancelTypewriter(), typeof e == "number" && e < 1e9 && (e = Math.round(e * 1e10) / 1e10), e = e.toString(), !e) return;
            this._SetText(this._text + e)
        },
        TypewriterText(e, t) {
            this._CancelTypewriter(), typeof e == "number" && e < 1e9 && (e = Math.round(e * 1e10) / 1e10), this._StartTypewriter(e.toString(), t)
        },
        SetFontFace(e, t) {
            let n = !1,
                s = !1;
            switch (t) {
                case 1:
                    n = !0;
                    break;
                case 2:
                    s = !0;
                    break;
                case 3:
                    n = !0, s = !0;
                    break
            }
            if (e === this._faceName && n === this._isBold && s === this._isItalic) return;
            this._SetFontFace(e), this._SetBold(n), this._SetItalic(s)
        },
        SetFontSize(e) {
            this._SetFontSize(e)
        },
        SetFontColor(t) {
            if (e.setFromRgbValue(t), e.clamp(), this._color.equalsIgnoringAlpha(e)) return;
            this._color.copyRgb(e), this._rendererText.SetColor(this._color), this._runtime.UpdateRender()
        },
        SetWebFont() {
            console.warn("[Text] 'Set web font' action is deprecated and no longer has any effect")
        },
        SetEffect(e) {
            this.GetWorldInfo().SetBlendMode(e), this._runtime.UpdateRender()
        },
        TypewriterFinish() {
            this._FinishTypewriter()
        },
        SetLineHeight(e) {
            this._SetLineHeight(e)
        },
        SetHAlign(e) {
            this._SetHAlign(e)
        },
        SetVAlign(e) {
            this._SetVAlign(e)
        },
        SetWrapping(e) {
            this._SetWrapByWord(e === 0)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Text.Exps = {
        Text() {
            return this._text
        },
        PlainText() {
            return this._enableBBcode ? e.BBString.StripAnyTags(this._text) : this._text
        },
        FaceName() {
            return this._faceName
        },
        FaceSize() {
            return this._ptSize
        },
        TextWidth() {
            return this._UpdateTextSize(), this._rendererText.GetTextWidth()
        },
        TextHeight() {
            return this._UpdateTextSize(), this._rendererText.GetTextHeight()
        },
        LineHeight() {
            return this._lineHeightOffset
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Keyboard = class KeyboardPlugin extends e.SDKPluginBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Keyboard.Type = class KeyboardType extends e.SDKTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        GetScriptInterfaceClass() {
            return self.IKeyboardObjectType
        }
    };
    let t = null;

    function GetKeyboardSdkInstance() {
        return t.GetSingleGlobalInstance().GetSdkInstance()
    }
    self.IKeyboardObjectType = class IKeyboardObjectType extends self.IObjectClass {
        constructor(e) {
            super(e), t = e, e.GetRuntime()._GetCommonScriptInterfaces().keyboard = this
        }
        isKeyDown(e) {
            const t = GetKeyboardSdkInstance();
            if (typeof e == "string") return t.IsKeyDown(e);
            if (typeof e == "number") return t.IsKeyCodeDown(e);
            throw new TypeError("expected string or number")
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Keyboard.Instance = class KeyboardInstance extends e.SDKInstanceBase {
        constructor(t) {
            super(t), this._keysDownByString = new Set, this._keysDownByWhich = new Set, this._triggerWhich = 0, this._triggerString = "", this._triggerTypedKey = "";
            const s = this.GetRuntime().Dispatcher();
            this._disposables = new e.CompositeDisposable(e.Disposable.From(s, "keydown", e => this._OnKeyDown(e.data)), e.Disposable.From(s, "keyup", e => this._OnKeyUp(e.data)), e.Disposable.From(s, "window-blur", () => this._OnWindowBlur()))
        }
        Release() {
            super.Release()
        }
        _OnKeyDown(t) {
            const n = t.which,
                s = t.code || n.toString(),
                o = t.key;
            if (this._keysDownByString.has(s)) return;
            this._keysDownByString.add(s), this._keysDownByWhich.add(n), this._triggerString = s, this._triggerWhich = n, this._triggerTypedKey = o, this.Trigger(e.Plugins.Keyboard.Cnds.OnAnyKey), this.Trigger(e.Plugins.Keyboard.Cnds.OnKey), this.Trigger(e.Plugins.Keyboard.Cnds.OnLeftRightKeyPressed), this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyCode)
        }
        _OnKeyUp(t) {
            const n = t.which,
                s = t.code || n.toString(),
                o = t.key;
            this._keysDownByString.delete(s), this._keysDownByWhich.delete(n), this._triggerString = s, this._triggerWhich = n, this._triggerTypedKey = o, this.Trigger(e.Plugins.Keyboard.Cnds.OnAnyKeyReleased), this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyReleased), this.Trigger(e.Plugins.Keyboard.Cnds.OnLeftRightKeyReleased), this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyCodeReleased)
        }
        _OnWindowBlur() {
            for (const t of this._keysDownByWhich) this._keysDownByWhich.delete(t), this._triggerWhich = t, this.Trigger(e.Plugins.Keyboard.Cnds.OnAnyKeyReleased), this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyReleased), this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyCodeReleased);
            this._keysDownByString.clear()
        }
        IsKeyDown(e) {
            return this._keysDownByString.has(e)
        }
        IsKeyCodeDown(e) {
            return this._keysDownByWhich.has(e)
        }
        SaveToJson() {
            return {
                tk: this._triggerWhich,
                tkk: this._triggerTypedKey
            }
        }
        LoadFromJson(e) {
            this._triggerWhich = e.tk, e.hasOwnProperty("tkk") && (this._triggerTypedKey = e.tkk)
        }
        GetDebuggerProperties() {
            const t = "plugins.keyboard";
            return [{
                title: t + ".name",
                properties: [{
                    name: t + ".debugger.last-key-code",
                    value: this._triggerWhich
                }, {
                    name: t + ".debugger.last-key-string",
                    value: e.Plugins.Keyboard.Exps.StringFromKeyCode(this._triggerWhich)
                }, {
                    name: t + ".debugger.last-typed-key",
                    value: this._triggerTypedKey
                }]
            }]
        }
    }
}
"use strict";
{
    const t = self.C3,
        e = ["ShiftLeft", "ShiftRight", "ControlLeft", "ControlRight", "AltLeft", "AltRight", "MetaLeft", "MetaRight"];
    t.Plugins.Keyboard.Cnds = {
        IsKeyDown(e) {
            return this._keysDownByWhich.has(e)
        },
        OnKey(e) {
            return this._triggerWhich === e
        },
        OnAnyKey() {
            return !0
        },
        OnAnyKeyReleased() {
            return !0
        },
        OnKeyReleased(e) {
            return this._triggerWhich === e
        },
        IsKeyCodeDown(e) {
            return e = Math.floor(e), this._keysDownByWhich.has(e)
        },
        OnKeyCode(e) {
            return this._triggerWhich === e
        },
        OnKeyCodeReleased(e) {
            return this._triggerWhich === e
        },
        OnLeftRightKeyPressed(t) {
            const n = e[t];
            return this._triggerString === n
        },
        OnLeftRightKeyReleased(t) {
            const n = e[t];
            return this._triggerString === n
        },
        IsLeftRightKeyDown(t) {
            const n = e[t];
            return this._keysDownByString.has(n)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Keyboard.Acts = {}
}
"use strict";
{
    const e = self.C3;

    function StringFromCharCode(e) {
        switch (e = Math.floor(e), e) {
            case 8:
                return "backspace";
            case 9:
                return "tab";
            case 13:
                return "enter";
            case 16:
                return "shift";
            case 17:
                return "control";
            case 18:
                return "alt";
            case 19:
                return "pause";
            case 20:
                return "capslock";
            case 27:
                return "esc";
            case 33:
                return "pageup";
            case 34:
                return "pagedown";
            case 35:
                return "end";
            case 36:
                return "home";
            case 37:
                return "";
            case 38:
                return "";
            case 39:
                return "";
            case 40:
                return "";
            case 45:
                return "insert";
            case 46:
                return "del";
            case 91:
                return "left window key";
            case 92:
                return "right window key";
            case 93:
                return "select";
            case 96:
                return "numpad 0";
            case 97:
                return "numpad 1";
            case 98:
                return "numpad 2";
            case 99:
                return "numpad 3";
            case 100:
                return "numpad 4";
            case 101:
                return "numpad 5";
            case 102:
                return "numpad 6";
            case 103:
                return "numpad 7";
            case 104:
                return "numpad 8";
            case 105:
                return "numpad 9";
            case 106:
                return "numpad *";
            case 107:
                return "numpad +";
            case 109:
                return "numpad -";
            case 110:
                return "numpad .";
            case 111:
                return "numpad /";
            case 112:
                return "F1";
            case 113:
                return "F2";
            case 114:
                return "F3";
            case 115:
                return "F4";
            case 116:
                return "F5";
            case 117:
                return "F6";
            case 118:
                return "F7";
            case 119:
                return "F8";
            case 120:
                return "F9";
            case 121:
                return "F10";
            case 122:
                return "F11";
            case 123:
                return "F12";
            case 144:
                return "numlock";
            case 145:
                return "scroll lock";
            case 186:
                return ";";
            case 187:
                return "=";
            case 188:
                return ",";
            case 189:
                return "-";
            case 190:
                return ".";
            case 191:
                return "/";
            case 192:
                return "'";
            case 219:
                return "[";
            case 220:
                return "\\";
            case 221:
                return "]";
            case 222:
                return "#";
            case 223:
                return "`";
            default:
                return String.fromCharCode(e)
        }
    }
    e.Plugins.Keyboard.Exps = {
        LastKeyCode() {
            return this._triggerWhich
        },
        StringFromKeyCode(e) {
            return StringFromCharCode(e)
        },
        TypedKey() {
            return this._triggerTypedKey
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Mouse = class MousePlugin extends e.SDKPluginBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Mouse.Type = class MouseType extends e.SDKTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        GetScriptInterfaceClass() {
            return self.IMouseObjectType
        }
    };
    let t = null;

    function GetMouseSdkInstance() {
        return t.GetSingleGlobalInstance().GetSdkInstance()
    }
    self.IMouseObjectType = class IMouseObjectType extends self.IObjectClass {
        constructor(e) {
            super(e), t = e, e.GetRuntime()._GetCommonScriptInterfaces().mouse = this
        }
        getMouseX(e) {
            return GetMouseSdkInstance().GetMousePositionForLayer(e)[0]
        }
        getMouseY(e) {
            return GetMouseSdkInstance().GetMousePositionForLayer(e)[1]
        }
        getMousePosition(e) {
            return GetMouseSdkInstance().GetMousePositionForLayer(e)
        }
        isMouseButtonDown(e) {
            return GetMouseSdkInstance().IsMouseButtonDown(e)
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = "mouse";
    e.Plugins.Mouse.Instance = class MouseInstance extends e.SDKInstanceBase {
        constructor(n) {
            super(n, t), this._buttonMap = [!1, !1, !1], this._mouseXcanvas = 0, this._mouseYcanvas = 0, this._triggerButton = 0, this._triggerType = 0, this._triggerDir = 0;
            const o = this.GetRuntime().Dispatcher();
            this._disposables = new e.CompositeDisposable(e.Disposable.From(o, "pointermove", e => this._OnPointerMove(e.data)), e.Disposable.From(o, "pointerdown", e => this._OnPointerDown(e.data)), e.Disposable.From(o, "pointerup", e => this._OnPointerUp(e.data)), e.Disposable.From(o, "dblclick", e => this._OnDoubleClick(e.data)), e.Disposable.From(o, "wheel", e => this._OnMouseWheel(e.data)), e.Disposable.From(o, "window-blur", () => this._OnWindowBlur()))
        }
        Release() {
            super.Release()
        }
        _OnPointerDown(e) {
            if (e.pointerType !== "mouse") return;
            this._mouseXcanvas = e.pageX - this._runtime.GetCanvasClientX(), this._mouseYcanvas = e.pageY - this._runtime.GetCanvasClientY(), this._CheckButtonChanges(e.lastButtons, e.buttons)
        }
        _OnPointerMove(e) {
            if (e.pointerType !== "mouse") return;
            this._mouseXcanvas = e.pageX - this._runtime.GetCanvasClientX(), this._mouseYcanvas = e.pageY - this._runtime.GetCanvasClientY(), this._CheckButtonChanges(e.lastButtons, e.buttons)
        }
        _OnPointerUp(e) {
            if (e.pointerType !== "mouse") return;
            this._CheckButtonChanges(e.lastButtons, e.buttons)
        }
        _CheckButtonChanges(e, t) {
            this._CheckButtonChange(e, t, 1, 0), this._CheckButtonChange(e, t, 4, 1), this._CheckButtonChange(e, t, 2, 2)
        }
        _CheckButtonChange(e, t, n, s) {
            !(e & n) && t & n ? this._OnMouseDown(s) : e & n && !(t & n) && this._OnMouseUp(s)
        }
        _OnMouseDown(t) {
            this._buttonMap[t] = !0, this.Trigger(e.Plugins.Mouse.Cnds.OnAnyClick), this._triggerButton = t, this._triggerType = 0, this.Trigger(e.Plugins.Mouse.Cnds.OnClick), this.Trigger(e.Plugins.Mouse.Cnds.OnObjectClicked)
        }
        _OnMouseUp(t) {
            if (!this._buttonMap[t]) return;
            this._buttonMap[t] = !1, this._triggerButton = t, this.Trigger(e.Plugins.Mouse.Cnds.OnRelease)
        }
        _OnDoubleClick(t) {
            this._triggerButton = t.button, this._triggerType = 1, this.Trigger(e.Plugins.Mouse.Cnds.OnClick), this.Trigger(e.Plugins.Mouse.Cnds.OnObjectClicked)
        }
        _OnMouseWheel(t) {
            this._triggerDir = t.deltaY < 0 ? 1 : 0, this.Trigger(e.Plugins.Mouse.Cnds.OnWheel)
        }
        _OnWindowBlur() {
            for (let t = 0, n = this._buttonMap.length; t < n; ++t) {
                if (!this._buttonMap[t]) return;
                this._buttonMap[t] = !1, this._triggerButton = t, this.Trigger(e.Plugins.Mouse.Cnds.OnRelease)
            }
        }
        GetMousePositionForLayer(e) {
            const t = this._runtime.GetMainRunningLayout(),
                n = this._mouseXcanvas,
                s = this._mouseYcanvas;
            if (typeof e == "undefined") {
                const e = t.GetLayerByIndex(0);
                return e.CanvasCssToLayer_DefaultTransform(n, s)
            }
            const o = t.GetLayer(e);
            return o ? o.CanvasCssToLayer(n, s) : [0, 0]
        }
        IsMouseButtonDown(e) {
            return e = Math.floor(e), !!this._buttonMap[e]
        }
        _IsMouseOverCanvas() {
            return this._mouseXcanvas >= 0 && this._mouseYcanvas >= 0 && this._mouseXcanvas < this._runtime.GetCanvasCssWidth() && this._mouseYcanvas < this._runtime.GetCanvasCssHeight()
        }
        GetDebuggerProperties() {
            const e = "plugins.mouse";
            return [{
                title: e + ".name",
                properties: [{
                    name: e + ".debugger.absolute-position",
                    value: this._mouseXcanvas + "," + this._mouseYcanvas
                }, {
                    name: e + ".debugger.left-button",
                    value: this._buttonMap[0]
                }, {
                    name: e + ".debugger.middle-button",
                    value: this._buttonMap[1]
                }, {
                    name: e + ".debugger.right-button",
                    value: this._buttonMap[2]
                }]
            }, {
                title: e + ".debugger.position-on-each-layer",
                properties: this._runtime.GetMainRunningLayout().GetLayers().map(e => ({
                    name: "$" + e.GetName(),
                    value: e.CanvasCssToLayer(this._mouseXcanvas, this._mouseYcanvas).join(", ")
                }))
            }]
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Mouse.Cnds = {
        OnClick(e, t) {
            return this._triggerButton === e && this._triggerType === t
        },
        OnAnyClick() {
            return !0
        },
        IsButtonDown(e) {
            return this._buttonMap[e]
        },
        OnRelease(e) {
            return this._triggerButton === e
        },
        IsOverObject(t) {
            if (!this._IsMouseOverCanvas()) return !1;
            const s = this._runtime.GetCurrentCondition(),
                n = s.IsInverted(),
                o = this._mouseXcanvas,
                i = this._mouseYcanvas;
            return e.xor(this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, o, i, n), n)
        },
        OnObjectClicked(e, t, n) {
            if (e !== this._triggerButton || t !== this._triggerType) return !1;
            if (!this._IsMouseOverCanvas()) return !1;
            const s = this._mouseXcanvas,
                o = this._mouseYcanvas;
            return this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(n, s, o, !1)
        },
        OnWheel(e) {
            return this._triggerDir === e
        }
    }
}
"use strict";
{
    const t = self.C3;
    let e = null;
    const n = ["auto", "pointer", "text", "crosshair", "move", "help", "wait", "none"];
    t.Plugins.Mouse.Acts = {
        SetCursor(t) {
            const s = n[t];
            if (e === s) return;
            e = s, this.PostToDOM("cursor", s)
        },
        SetCursorSprite(n) {
            if (t.Platform.IsMobile || !n) return;
            const o = n.GetFirstPicked();
            if (!o) return;
            const i = o.GetWorldInfo(),
                s = o.GetCurrentImageInfo();
            if (!i || !s) return;
            if (e === s) return;
            e = s, s.ExtractImageToCanvas().then(e => t.CanvasToBlob(e)).then(e => {
                const t = URL.createObjectURL(e),
                    n = `url(${t}) ${Math.round(i.GetOriginX()*s.GetWidth())} ${Math.round(i.GetOriginY()*s.GetHeight())}, auto`;
                this.PostToDOM("cursor", ""), this.PostToDOM("cursor", n)
            })
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Mouse.Exps = {
        X(e) {
            return this.GetMousePositionForLayer(e)[0]
        },
        Y(e) {
            return this.GetMousePositionForLayer(e)[1]
        },
        AbsoluteX() {
            return this._mouseXcanvas
        },
        AbsoluteY() {
            return this._mouseYcanvas
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.TiledBg = class TiledBgPlugin extends e.SDKPluginBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const e = self.C3;

    function WrapModeToStr(e) {
        switch (e) {
            case 0:
                return "clamp-to-edge";
            case 1:
                return "repeat";
            case 2:
                return "mirror-repeat"
        }
        return "repeat"
    }
    e.Plugins.TiledBg.Type = class TiledBgType extends e.SDKTypeBase {
        constructor(e, t) {
            super(e), this._wrapX = "repeat", this._wrapY = "repeat", t && (this._wrapX = WrapModeToStr(t[0]), this._wrapY = WrapModeToStr(t[1]))
        }
        Release() {
            super.Release()
        }
        OnCreate() {
            this.GetImageInfo().LoadAsset(this._runtime)
        }
        LoadTextures(e) {
            return this.GetImageInfo().LoadStaticTexture(e, {
                sampling: this._runtime.GetSampling(),
                wrapX: this._wrapX,
                wrapY: this._wrapY
            })
        }
        ReleaseTextures() {
            this.GetImageInfo().ReleaseTexture()
        }
    }
}
"use strict";
{
    const e = self.C3,
        u = 0,
        h = 1,
        c = 4,
        a = 5,
        i = 6,
        o = 7,
        r = 8,
        d = e.New(e.Rect),
        l = e.New(e.Quad),
        n = e.New(e.Rect),
        s = e.New(e.Quad);
    e.Plugins.TiledBg.Instance = class TiledBgInstance extends e.SDKWorldInstanceBase {
        constructor(t, n) {
            super(t), this._imageOffsetX = 0, this._imageOffsetY = 0, this._imageScaleX = 1, this._imageScaleY = 1, this._imageAngle = 0, this._ownImageInfo = null, n && (this.GetWorldInfo().SetVisible(!!n[u]), this._imageOffsetX = n[c], this._imageOffsetY = n[a], this._imageScaleX = n[i], this._imageScaleY = n[o], this._imageAngle = e.toRadians(n[r]))
        }
        Release() {
            this._ReleaseOwnImage(), super.Release()
        }
        _ReleaseOwnImage() {
            this._ownImageInfo && (this._ownImageInfo.Release(), this._ownImageInfo = null)
        }
        Draw(e) {
            const s = this.GetCurrentImageInfo(),
                o = s.GetTexture();
            if (o === null) return;
            e.SetTexture(o);
            const i = s.GetWidth(),
                a = s.GetHeight(),
                r = this._imageOffsetX / i,
                c = this._imageOffsetY / a,
                t = this.GetWorldInfo();
            n.set(0, 0, t.GetWidth() / (i * this._imageScaleX), t.GetHeight() / (a * this._imageScaleY)), n.offset(-r, -c), t.HasMesh() ? this._DrawMesh(t, e) : this._DrawStandard(t, e)
        }
        _DrawStandard(e, t) {
            let o = e.GetBoundingQuad();
            this._runtime.IsPixelRoundingEnabled() && (o = e.PixelRoundQuad(o)), this._imageAngle === 0 ? t.Quad3(o, n) : (s.setFromRotatedRect(n, -this._imageAngle), t.Quad4(o, s))
        }
        _DrawMesh(e, t) {
            const o = e.GetTransformedMesh();
            if (e.IsMeshChanged()) {
                e.CalculateBbox(d, l, !1);
                let t = l;
                this._runtime.IsPixelRoundingEnabled() && (t = e.PixelRoundQuad(t));
                let i = n;
                this._imageAngle !== 0 && (s.setFromRotatedRect(n, -this._imageAngle), i = s), o.CalculateTransformedMesh(e.GetSourceMesh(), t, i), e.SetMeshChanged(!1)
            }
            o.Draw(t)
        }
        GetCurrentImageInfo() {
            return this._ownImageInfo || this._objectClass.GetImageInfo()
        }
        _SetMeshChanged() {
            this.GetWorldInfo().SetMeshChanged(!0)
        }
        _SetImageOffsetX(e) {
            if (this._imageOffsetX === e) return;
            this._imageOffsetX = e, this._runtime.UpdateRender(), this._SetMeshChanged()
        }
        _GetImageOffsetX() {
            return this._imageOffsetX
        }
        _SetImageOffsetY(e) {
            if (this._imageOffsetY === e) return;
            this._imageOffsetY = e, this._runtime.UpdateRender(), this._SetMeshChanged()
        }
        _GetImageOffsetY() {
            return this._imageOffsetY
        }
        _SetImageScaleX(e) {
            if (this._imageScaleX === e) return;
            this._imageScaleX = e, this._runtime.UpdateRender(), this._SetMeshChanged()
        }
        _GetImageScaleX() {
            return this._imageScaleX
        }
        _SetImageScaleY(e) {
            if (this._imageScaleY === e) return;
            this._imageScaleY = e, this._runtime.UpdateRender(), this._SetMeshChanged()
        }
        _GetImageScaleY() {
            return this._imageScaleY
        }
        _SetImageAngle(e) {
            if (this._imageAngle === e) return;
            this._imageAngle = e, this._runtime.UpdateRender(), this._SetMeshChanged()
        }
        _GetImageAngle() {
            return this._imageAngle
        }
        GetPropertyValueByIndex(e) {
            switch (e) {
                case c:
                    return this._GetImageOffsetX();
                case a:
                    return this._GetImageOffsetY();
                case i:
                    return this._GetImageScaleX();
                case o:
                    return this._GetImageScaleY();
                case r:
                    return this._GetImageAngle()
            }
        }
        SetPropertyValueByIndex(e, t) {
            switch (e) {
                case c:
                    this._SetImageOffsetX(t);
                    break;
                case a:
                    this._SetImageOffsetY(t);
                    break;
                case i:
                    this._SetImageScaleX(t);
                    break;
                case o:
                    this._SetImageScaleY(t);
                    break;
                case r:
                    this._SetImageAngle(t);
                    break
            }
        }
        GetScriptInterfaceClass() {
            return self.ITiledBackgroundInstance
        }
    };
    const t = new WeakMap;
    self.ITiledBackgroundInstance = class ITiledBackgroundInstance extends self.IWorldInstance {
        constructor() {
            super(), t.set(this, self.IInstance._GetInitInst().GetSdkInstance())
        }
        set imageOffsetX(e) {
            t.get(this)._SetImageOffsetX(e)
        }
        get imageOffsetX() {
            return t.get(this)._GetImageOffsetX()
        }
        set imageOffsetY(e) {
            t.get(this)._SetImageOffsetY(e)
        }
        get imageOffsetY() {
            return t.get(this)._GetImageOffsetY()
        }
        set imageScaleX(e) {
            t.get(this)._SetImageScaleX(e)
        }
        get imageScaleX() {
            return t.get(this)._GetImageScaleX()
        }
        set imageScaleY(e) {
            t.get(this)._SetImageScaleY(e)
        }
        get imageScaleY() {
            return t.get(this)._GetImageScaleY()
        }
        set imageAngle(e) {
            t.get(this)._SetImageAngle(e)
        }
        get imageAngle() {
            return t.get(this)._GetImageAngle()
        }
        set imageAngleDegrees(n) {
            t.get(this)._SetImageAngle(e.toRadians(n))
        }
        get imageAngleDegrees() {
            return e.toDegrees(t.get(this)._GetImageAngle())
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.TiledBg.Cnds = {
        OnURLLoaded() {
            return !0
        },
        OnURLFailed() {
            return !0
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.TiledBg.Acts = {
        SetImageOffsetX(e) {
            this._SetImageOffsetX(e)
        },
        SetImageOffsetY(e) {
            this._SetImageOffsetY(e)
        },
        SetImageScaleX(e) {
            this._SetImageScaleX(e / 100)
        },
        SetImageScaleY(e) {
            this._SetImageScaleY(e / 100)
        },
        SetImageAngle(t) {
            this._SetImageAngle(e.toRadians(t))
        },
        SetEffect(e) {
            this.GetWorldInfo().SetBlendMode(e), this._runtime.UpdateRender()
        },
        async LoadURL(t) {
            if (this._ownImageInfo && this._ownImageInfo.GetURL() === t) return;
            const o = this._runtime,
                s = e.New(e.ImageInfo);
            if (await s.LoadDynamicAsset(o, t), !s.IsLoaded()) {
                this.Trigger(e.Plugins.TiledBg.Cnds.OnURLFailed);
                return
            }
            if (this.WasReleased()) return s.Release(), null;
            const i = await s.LoadStaticTexture(o.GetWebGLRenderer(), {
                sampling: this._runtime.GetSampling(),
                wrapX: "repeat",
                wrapY: "repeat"
            });
            if (!i) return;
            if (this.WasReleased()) {
                s.Release();
                return
            }
            this._ReleaseOwnImage(), this._ownImageInfo = s, o.UpdateRender(), await this.TriggerAsync(e.Plugins.TiledBg.Cnds.OnURLLoaded)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.TiledBg.Exps = {
        ImageWidth() {
            return this.GetCurrentImageInfo().GetWidth()
        },
        ImageHeight() {
            return this.GetCurrentImageInfo().GetHeight()
        },
        ImageOffsetX() {
            return this._imageOffsetX
        },
        ImageOffsetY() {
            return this._imageOffsetY
        },
        ImageScaleX() {
            return this._imageScaleX * 100
        },
        ImageScaleY() {
            return this._imageScaleY * 100
        },
        ImageAngle() {
            return e.toDegrees(this._imageAngle)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Audio = class AudioPlugin extends e.SDKPluginBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Audio.Type = class AudioType extends e.SDKTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        GetScriptInterfaceClass() {
            return self.IAudioObjectType
        }
    };

    function GetAudioDOMInterface() {
        if (self.C3Audio_DOMInterface) return self.C3Audio_DOMInterface;
        throw new Error("audio scripting API cannot be used here - make sure the project is using DOM mode, not worker mode")
    }
    self.IAudioObjectType = class IAudioObjectType extends self.IObjectClass {
        constructor(e) {
            super(e)
        }
        get audioContext() {
            return GetAudioDOMInterface().GetAudioContext()
        }
        get destinationNode() {
            return GetAudioDOMInterface().GetDestinationNode()
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = "audio",
        n = ["interactive", "balanced", "playback"];
    e.Plugins.Audio.Instance = class AudioInstance extends e.SDKInstanceBase {
        constructor(s, o) {
            super(s, t), this._nextPlayTime = 0, this._triggerTag = "", this._timeScaleMode = 0, this._saveLoadMode = 0, this._playInBackground = !1, this._panningModel = 1, this._distanceModel = 1, this._listenerX = this._runtime.GetViewportWidth() / 2, this._listenerY = this._runtime.GetViewportHeight() / 2, this._listenerZ = -600, this._referenceDistance = 600, this._maxDistance = 1e4, this._rolloffFactor = 1, this._listenerInst = null, this._loadListenerUid = -1, this._masterVolume = 1, this._isSilent = !1, this._sampleRate = 0, this._effectCount = new Map, this._preloadTotal = 0, this._preloadCount = 0, this._remoteUrls = new Map;
            let a = "interactive";
            o && (this._timeScaleMode = o[0], this._saveLoadMode = o[1], this._playInBackground = o[2], a = n[o[3]], this._panningModel = o[4], this._distanceModel = o[5], this._listenerZ = -o[6], this._referenceDistance = o[7], this._maxDistance = o[8], this._rolloffFactor = o[9]), this._lastAIState = [], this._lastFxState = [], this._lastAnalysersData = [], this.AddDOMMessageHandlers([
                ["state", e => this._OnUpdateState(e)],
                ["fxstate", e => this._OnUpdateFxState(e)],
                ["trigger", e => this._OnTrigger(e)]
            ]);
            const i = this.GetRuntime().Dispatcher();
            this._disposables = new e.CompositeDisposable(e.Disposable.From(i, "instancedestroy", e => this._OnInstanceDestroyed(e.instance)), e.Disposable.From(i, "afterload", () => this._OnAfterLoad()), e.Disposable.From(i, "suspend", () => this._OnSuspend()), e.Disposable.From(i, "resume", () => this._OnResume())), this._runtime.AddLoadPromise(this.PostToDOMAsync("create-audio-context", {
                preloadList: this._runtime.GetAssetManager().GetAudioToPreload().map(e => ({
                    originalUrl: e.originalUrl,
                    url: e.url,
                    type: e.type,
                    fileSize: e.fileSize
                })),
                isiOSCordova: this._runtime.IsiOSCordova(),
                timeScaleMode: this._timeScaleMode,
                latencyHint: a,
                panningModel: this._panningModel,
                distanceModel: this._distanceModel,
                refDistance: this._referenceDistance,
                maxDistance: this._maxDistance,
                rolloffFactor: this._rolloffFactor,
                listenerPos: [this._listenerX, this._listenerY, this._listenerZ]
            }).then(e => {
                this._sampleRate = e.sampleRate
            })), this._StartTicking()
        }
        Release() {
            this._listenerInst = null, super.Release()
        }
        _OnInstanceDestroyed(e) {
            this._listenerInst === e && (this._listenerInst = null)
        }
        DbToLinearNoCap(e) {
            return Math.pow(10, e / 20)
        }
        DbToLinear(e) {
            const t = this.DbToLinearNoCap(e);
            return isFinite(t) ? Math.max(Math.min(t, 1), 0) : 0
        }
        LinearToDbNoCap(e) {
            return Math.log(e) / Math.log(10) * 20
        }
        LinearToDb(e) {
            return this.LinearToDbNoCap(Math.max(Math.min(e, 1), 0))
        }
        _OnSuspend() {
            if (this._playInBackground) return;
            this.PostToDOM("set-suspended", {
                isSuspended: !0
            })
        }
        _OnResume() {
            if (this._playInBackground) return;
            this.PostToDOM("set-suspended", {
                isSuspended: !1
            })
        }
        _OnUpdateState(t) {
            const s = t.tickCount,
                n = this._lastAIState.filter(e => e.hasOwnProperty("placeholder") && (e.placeholder > s || e.placeholder === -1));
            this._lastAIState = t.audioInstances, this._lastAnalysersData = t.analysers, n.length > 0 && e.appendArray(this._lastAIState, n)
        }
        _OnUpdateFxState(e) {
            this._lastFxState = e.fxstate
        }
        _GetFirstAudioStateByTag(t) {
            for (const n of this._lastAIState)
                if (e.equalsNoCase(n.tag, t)) return n;
            return null
        }
        _IsTagPlaying(t) {
            return this._lastAIState.some(n => e.equalsNoCase(t, n.tag) && n.isPlaying)
        }
        _MaybeMarkAsPlaying(e, t, n, s) {
            if (this._IsTagPlaying(e)) return null;
            const o = {
                tag: e,
                duration: 0,
                volume: s,
                isPlaying: !0,
                playbackTime: 0,
                playbackRate: 1,
                uid: -1,
                bufferOriginalUrl: "",
                bufferUrl: "",
                bufferType: "",
                isMusic: t,
                isLooping: n,
                isMuted: !1,
                resumePosition: 0,
                pan: null,
                placeholder: -1
            };
            return this._lastAIState.push(o), o
        }
        async _OnTrigger(t) {
            const n = t.type;
            this._triggerTag = t.tag;
            const s = t.aiid;
            if (n === "ended") {
                for (const e of this._lastAIState)
                    if (e.aiid === s) {
                        e.isPlaying = !1;
                        break
                    } await this.TriggerAsync(e.Plugins.Audio.Cnds.OnEnded)
            } else n === "fade-ended" && await this.TriggerAsync(e.Plugins.Audio.Cnds.OnFadeEnded)
        }
        Tick() {
            const e = {
                timeScale: this._runtime.GetTimeScale(),
                gameTime: this._runtime.GetGameTime(),
                instPans: this.GetInstancePans(),
                tickCount: this._runtime.GetTickCountNoSave()
            };
            if (this._listenerInst) {
                const t = this._listenerInst.GetWorldInfo();
                this._listenerX = t.GetX(), this._listenerY = t.GetY(), e.listenerPos = [this._listenerX, this._listenerY, this._listenerZ]
            }
            this.PostToDOM("tick", e)
        }
        rotatePtAround(e, t, n, s, o) {
            if (n === 0) return [e, t];
            const i = Math.sin(n),
                a = Math.cos(n);
            e -= s, t -= o;
            const r = e * i,
                c = t * i,
                l = e * a,
                d = t * a;
            return e = l - c, t = d + r, e += s, t += o, [e, t]
        }
        GetInstancePans() {
            return this._lastAIState.filter(e => e.uid !== -1).map(e => this._runtime.GetInstanceByUID(e.uid)).filter(e => e).map(e => {
                const t = e.GetWorldInfo(),
                    n = t.GetLayer().GetAngle(),
                    [s, o] = this.rotatePtAround(t.GetX(), t.GetY(), -n, this._listenerX, this._listenerY);
                return {
                    uid: e.GetUID(),
                    x: s,
                    y: o,
                    angle: t.GetAngle() - n
                }
            })
        }
        GetAnalyserData(t, n) {
            for (const s of this._lastAnalysersData)
                if (s.index === n && e.equalsNoCase(s.tag, t)) return s;
            return null
        }
        _IncrementEffectCount(e) {
            this._effectCount.set(e, (this._effectCount.get(e) || 0) + 1)
        }
        _ShouldSave(e) {
            return !e.hasOwnProperty("placeholder") && this._saveLoadMode !== 3 && !(e.isMusic && this._saveLoadMode === 1) && (!!e.isMusic || this._saveLoadMode !== 2)
        }
        SaveToJson() {
            return {
                isSilent: this._isSilent,
                masterVolume: this._masterVolume,
                listenerZ: this._listenerZ,
                listenerUid: this._listenerInst ? this._listenerInst.GetUID() : -1,
                remoteUrls: [...this._remoteUrls.entries()],
                playing: this._lastAIState.filter(e => this._ShouldSave(e)),
                effects: this._lastFxState,
                analysers: this._lastAnalysersData
            }
        }
        LoadFromJson(e) {
            if (this._isSilent = e.isSilent, this._masterVolume = e.masterVolume, this._listenerZ = e.listenerZ, this._listenerInst = null, this._loadListenerUid = e.listenerUid, this._remoteUrls.clear(), e.remoteUrls)
                for (const [t, n] of e.remoteUrls) this._remoteUrls.set(t, n);
            this._lastAIState = e.playing, this._lastFxState = e.effects, this._lastAnalysersData = e.analysers
        }
        _OnAfterLoad() {
            if (this._loadListenerUid !== -1 && (this._listenerInst = this._runtime.GetInstanceByUID(this._loadListenerUid), this._loadListenerUid = -1, this._listenerInst)) {
                const e = this._listenerInst.GetWorldInfo();
                this._listenerX = e.GetX(), this._listenerY = e.GetY()
            }
            for (const e of this._lastAIState) {
                const t = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e.bufferOriginalUrl);
                t ? (e.bufferUrl = t.url, e.bufferType = t.type) : e.bufferUrl = null
            }
            for (const e of Object.values(this._lastFxState))
                for (const t of e)
                    if (t.hasOwnProperty("bufferOriginalUrl")) {
                        const e = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t.bufferOriginalUrl);
                        e && (t.bufferUrl = e.url, t.bufferType = e.type)
                    } this.PostToDOM("load-state", {
                saveLoadMode: this._saveLoadMode,
                timeScale: this._runtime.GetTimeScale(),
                gameTime: this._runtime.GetGameTime(),
                listenerPos: [this._listenerX, this._listenerY, this._listenerZ],
                isSilent: this._isSilent,
                masterVolume: this._masterVolume,
                playing: this._lastAIState.filter(e => e.bufferUrl !== null),
                effects: this._lastFxState
            })
        }
        GetDebuggerProperties() {
            const t = [];
            for (const [e, n] of Object.entries(this._lastFxState)) t.push({
                name: "$" + e,
                value: n.map(e => e.type).join(", ")
            });
            const e = "plugins.audio.debugger";
            return [{
                title: e + ".tag-effects",
                properties: t
            }, {
                title: e + ".currently-playing",
                properties: [{
                    name: e + ".currently-playing-count",
                    value: this._lastAIState.length
                }, ...this._lastAIState.map((e, t) => ({
                    name: "$#" + t,
                    value: `${e.bufferOriginalUrl} ("${e.tag}") ${Math.round(e.playbackTime*10)/10} / ${Math.round(e.duration*10)/10}`
                }))]
            }]
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Audio.Cnds = {
        OnEnded(t) {
            return e.equalsNoCase(this._triggerTag, t)
        },
        OnFadeEnded(t) {
            return e.equalsNoCase(this._triggerTag, t)
        },
        PreloadsComplete() {
            return this._preloadCount === this._preloadTotal
        },
        AdvancedAudioSupported() {
            return !0
        },
        IsSilent() {
            return this._isSilent
        },
        IsAnyPlaying() {
            for (const e of this._lastAIState)
                if (e.isPlaying) return !0;
            return !1
        },
        IsTagPlaying(e) {
            return this._IsTagPlaying(e)
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = ["lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "peaking", "notch", "allpass"];
    e.Plugins.Audio.Acts = {
        async Play(e, t, n, s) {
            if (this._isSilent) return;
            const i = e[1],
                o = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e[0]);
            if (!o) return;
            const r = this._nextPlayTime;
            this._nextPlayTime = 0;
            const a = this._MaybeMarkAsPlaying(s.toLowerCase(), i, t !== 0, this.DbToLinear(n));
            try {
                await this.PostToDOMAsync("play", {
                    originalUrl: e[0],
                    url: o.url,
                    type: o.type,
                    isMusic: i,
                    tag: s.toLowerCase(),
                    isLooping: t !== 0,
                    vol: this.DbToLinear(n),
                    pos: 0,
                    off: r,
                    trueClock: !!self.C3_GetAudioContextCurrentTime
                })
            } finally {
                a && (a.placeholder = this._runtime.GetTickCountNoSave())
            }
        },
        async PlayAtPosition(t, n, s, o, i, a, r, c, l, d) {
            if (this._isSilent) return;
            const h = t[1],
                u = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t[0]);
            if (!u) return;
            const f = this._nextPlayTime;
            this._nextPlayTime = 0;
            const m = this._MaybeMarkAsPlaying(d.toLowerCase(), h, n !== 0, this.DbToLinear(s));
            try {
                await this.PostToDOMAsync("play", {
                    originalUrl: t[0],
                    url: u.url,
                    type: u.type,
                    isMusic: h,
                    tag: d.toLowerCase(),
                    isLooping: n !== 0,
                    vol: this.DbToLinear(s),
                    pos: 0,
                    off: f,
                    trueClock: !!self.C3_GetAudioContextCurrentTime,
                    panning: {
                        x: o,
                        y: i,
                        angle: e.toRadians(a),
                        innerAngle: e.toRadians(r),
                        outerAngle: e.toRadians(c),
                        outerGain: this.DbToLinear(l)
                    }
                })
            } finally {
                m && (m.placeholder = this._runtime.GetTickCountNoSave())
            }
        },
        async PlayAtObject(t, n, s, o, i, a, r, c) {
            if (this._isSilent) return;
            if (!o) return;
            const l = o.GetFirstPicked();
            if (!l || !l.GetWorldInfo()) return;
            const d = l.GetWorldInfo(),
                h = d.GetLayer().GetAngle(),
                [p, g] = this.rotatePtAround(d.GetX(), d.GetY(), -h, this._listenerX, this._listenerY),
                m = t[1],
                u = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t[0]);
            if (!u) return;
            const v = this._nextPlayTime;
            this._nextPlayTime = 0;
            const f = this._MaybeMarkAsPlaying(c.toLowerCase(), m, n !== 0, this.DbToLinear(s));
            try {
                await this.PostToDOMAsync("play", {
                    originalUrl: t[0],
                    url: u.url,
                    type: u.type,
                    isMusic: m,
                    tag: c.toLowerCase(),
                    isLooping: n !== 0,
                    vol: this.DbToLinear(s),
                    pos: 0,
                    off: v,
                    trueClock: !!self.C3_GetAudioContextCurrentTime,
                    panning: {
                        x: p,
                        y: g,
                        angle: d.GetAngle() - h,
                        innerAngle: e.toRadians(i),
                        outerAngle: e.toRadians(a),
                        outerGain: this.DbToLinear(r),
                        uid: l.GetUID()
                    }
                })
            } finally {
                f && (f.placeholder = this._runtime.GetTickCountNoSave())
            }
        },
        async PlayByName(e, t, n, s, o) {
            if (this._isSilent) return;
            const a = e === 1,
                i = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t) || this._remoteUrls.get(t.toLowerCase());
            if (!i) return;
            const c = this._nextPlayTime;
            this._nextPlayTime = 0;
            const r = this._MaybeMarkAsPlaying(o.toLowerCase(), a, n !== 0, this.DbToLinear(s));
            try {
                await this.PostToDOMAsync("play", {
                    originalUrl: t,
                    url: i.url,
                    type: i.type,
                    isMusic: a,
                    tag: o.toLowerCase(),
                    isLooping: n !== 0,
                    vol: this.DbToLinear(s),
                    pos: 0,
                    off: c,
                    trueClock: !!self.C3_GetAudioContextCurrentTime
                })
            } finally {
                r && (r.placeholder = this._runtime.GetTickCountNoSave())
            }
        },
        async PlayAtPositionByName(t, n, s, o, i, a, r, c, l, d, u) {
            if (this._isSilent) return;
            const m = t === 1,
                h = this._runtime.GetAssetManager().GetProjectAudioFileUrl(n) || this._remoteUrls.get(n.toLowerCase());
            if (!h) return;
            const p = this._nextPlayTime;
            this._nextPlayTime = 0;
            const f = this._MaybeMarkAsPlaying(u.toLowerCase(), m, s !== 0, this.DbToLinear(o));
            try {
                await this.PostToDOMAsync("play", {
                    originalUrl: n,
                    url: h.url,
                    type: h.type,
                    isMusic: m,
                    tag: u.toLowerCase(),
                    isLooping: s !== 0,
                    vol: this.DbToLinear(o),
                    pos: 0,
                    off: p,
                    trueClock: !!self.C3_GetAudioContextCurrentTime,
                    panning: {
                        x: i,
                        y: a,
                        angle: e.toRadians(r),
                        innerAngle: e.toRadians(c),
                        outerAngle: e.toRadians(l),
                        outerGain: this.DbToLinear(d)
                    }
                })
            } finally {
                f && (f.placeholder = this._runtime.GetTickCountNoSave())
            }
        },
        async PlayAtObjectByName(t, n, s, o, i, a, r, c, l) {
            if (this._isSilent) return;
            if (this._isSilent) return;
            if (!i) return;
            const d = i.GetFirstPicked();
            if (!d || !d.GetWorldInfo()) return;
            const u = d.GetWorldInfo(),
                m = u.GetLayer().GetAngle(),
                [g, v] = this.rotatePtAround(u.GetX(), u.GetY(), -m, this._listenerX, this._listenerY),
                f = t === 1,
                h = this._runtime.GetAssetManager().GetProjectAudioFileUrl(n) || this._remoteUrls.get(n.toLowerCase());
            if (!h) return;
            const b = this._nextPlayTime;
            this._nextPlayTime = 0;
            const p = this._MaybeMarkAsPlaying(l.toLowerCase(), f, s !== 0, this.DbToLinear(o));
            try {
                await this.PostToDOMAsync("play", {
                    originalUrl: n,
                    url: h.url,
                    type: h.type,
                    isMusic: f,
                    tag: l.toLowerCase(),
                    isLooping: s !== 0,
                    vol: this.DbToLinear(o),
                    pos: 0,
                    off: b,
                    trueClock: !!self.C3_GetAudioContextCurrentTime,
                    panning: {
                        x: g,
                        y: v,
                        angle: u.GetAngle() - m,
                        innerAngle: e.toRadians(a),
                        outerAngle: e.toRadians(r),
                        outerGain: this.DbToLinear(c),
                        uid: d.GetUID()
                    }
                })
            } finally {
                p && (p.placeholder = this._runtime.GetTickCountNoSave())
            }
        },
        SetLooping(e, t) {
            this.PostToDOM("set-looping", {
                tag: e.toLowerCase(),
                isLooping: t === 0
            })
        },
        SetMuted(e, t) {
            this.PostToDOM("set-muted", {
                tag: e.toLowerCase(),
                isMuted: t === 0
            })
        },
        SetVolume(e, t) {
            this.PostToDOM("set-volume", {
                tag: e.toLowerCase(),
                vol: this.DbToLinear(t)
            })
        },
        FadeVolume(e, t, n, s) {
            this.PostToDOM("fade-volume", {
                tag: e.toLowerCase(),
                vol: this.DbToLinear(t),
                duration: n,
                stopOnEnd: s === 0
            })
        },
        async Preload(e) {
            const n = e[1],
                t = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e[0]);
            if (!t) return;
            this._preloadTotal++, await this.PostToDOMAsync("preload", {
                originalUrl: e[0],
                url: t.url,
                type: t.type,
                isMusic: n
            }), this._preloadCount++
        },
        async PreloadByName(e, t) {
            const s = e === 1,
                n = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t) || this._remoteUrls.get(t.toLowerCase());
            if (!n) return;
            this._preloadTotal++, await this.PostToDOMAsync("preload", {
                originalUrl: t,
                url: n.url,
                type: n.type,
                isMusic: s
            }), this._preloadCount++
        },
        SetPlaybackRate(e, t) {
            this.PostToDOM("set-playback-rate", {
                tag: e.toLowerCase(),
                rate: Math.max(t, 0)
            })
        },
        Stop(e) {
            this.PostToDOM("stop", {
                tag: e.toLowerCase()
            })
        },
        StopAll() {
            this.PostToDOM("stop-all")
        },
        SetPaused(e, t) {
            this.PostToDOM("set-paused", {
                tag: e.toLowerCase(),
                paused: t === 0
            })
        },
        Seek(e, t) {
            this.PostToDOM("seek", {
                tag: e.toLowerCase(),
                pos: t
            })
        },
        SetSilent(e) {
            if (e === 2 && (e = this._isSilent ? 1 : 0), e = e === 0, this._isSilent === e) return;
            this._isSilent = e, this.PostToDOM("set-silent", {
                isSilent: e
            })
        },
        SetMasterVolume(e) {
            const t = this.DbToLinear(e);
            if (this._masterVolume === t) return;
            this._masterVolume = t, this.PostToDOM("set-master-volume", {
                vol: t
            })
        },
        AddFilterEffect(n, s, o, i, a, r, c) {
            n = n.toLowerCase();
            const l = t[s];
            this._IncrementEffectCount(n), this.PostToDOM("add-effect", {
                type: "filter",
                tag: n,
                params: [l, o, i, a, r, e.clamp(c / 100, 0, 1)]
            })
        },
        AddDelayEffect(t, n, s, o) {
            t = t.toLowerCase(), this._IncrementEffectCount(t), this.PostToDOM("add-effect", {
                type: "delay",
                tag: t,
                params: [n, this.DbToLinear(s), e.clamp(o / 100, 0, 1)]
            })
        },
        AddFlangerEffect(t, n, s, o, i, a) {
            t = t.toLowerCase(), this._IncrementEffectCount(t), this.PostToDOM("add-effect", {
                type: "flanger",
                tag: t,
                params: [n / 1e3, s / 1e3, o, i / 100, e.clamp(a / 100, 0, 1)]
            })
        },
        AddPhaserEffect(t, n, s, o, i, a, r) {
            t = t.toLowerCase(), this._IncrementEffectCount(t), this.PostToDOM("add-effect", {
                type: "phaser",
                tag: t,
                params: [n, s, o, i, a, e.clamp(r / 100, 0, 1)]
            })
        },
        AddConvolutionEffect(t, n, s, o) {
            t = t.toLowerCase();
            const i = this._runtime.GetAssetManager().GetProjectAudioFileUrl(n[0]);
            if (!i) return;
            this._IncrementEffectCount(t), this.PostToDOM("add-effect", {
                type: "convolution",
                tag: t,
                bufferOriginalUrl: n[0],
                bufferUrl: i.url,
                bufferType: i.type,
                params: [s === 0, e.clamp(o / 100, 0, 1)]
            })
        },
        AddGainEffect(e, t) {
            e = e.toLowerCase(), this._IncrementEffectCount(e), this.PostToDOM("add-effect", {
                type: "gain",
                tag: e,
                params: [this.DbToLinear(t)]
            })
        },
        AddMuteEffect(e) {
            e = e.toLowerCase(), this._IncrementEffectCount(e), this.PostToDOM("add-effect", {
                type: "gain",
                tag: e,
                params: [0]
            })
        },
        AddTremoloEffect(t, n, s) {
            t = t.toLowerCase(), this._IncrementEffectCount(t), this.PostToDOM("add-effect", {
                type: "tremolo",
                tag: t,
                params: [n, e.clamp(s / 100, 0, 1)]
            })
        },
        AddRingModEffect(t, n, s) {
            t = t.toLowerCase(), this._IncrementEffectCount(t), this.PostToDOM("add-effect", {
                type: "ringmod",
                tag: t,
                params: [n, e.clamp(s / 100, 0, 1)]
            })
        },
        AddDistortionEffect(t, n, s, o, i, a) {
            t = t.toLowerCase(), this._IncrementEffectCount(t), this.PostToDOM("add-effect", {
                type: "distortion",
                tag: t,
                params: [this.DbToLinearNoCap(n), this.DbToLinearNoCap(s), o, this.DbToLinearNoCap(i), e.clamp(a / 100, 0, 1)]
            })
        },
        AddCompressorEffect(e, t, n, s, o, i) {
            e = e.toLowerCase(), this._IncrementEffectCount(e), this.PostToDOM("add-effect", {
                type: "compressor",
                tag: e,
                params: [t, n, s, o / 1e3, i / 1e3]
            })
        },
        AddAnalyserEffect(e, t, n) {
            e = e.toLowerCase(), this._IncrementEffectCount(e), this.PostToDOM("add-effect", {
                type: "analyser",
                tag: e,
                params: [t, n]
            })
        },
        RemoveEffects(e) {
            e = e.toLowerCase(), this._effectCount.set(e, 0), this.PostToDOM("remove-effects", {
                tag: e
            }), this._lastFxState = {}
        },
        SetEffectParameter(e, t, n, s, o, i) {
            this.PostToDOM("set-effect-param", {
                tag: e.toLowerCase(),
                index: Math.floor(t),
                param: n,
                value: s,
                ramp: o,
                time: i
            })
        },
        SetListenerObject(e) {
            if (!e) return;
            const t = e.GetFirstPicked();
            if (!t || !t.GetWorldInfo()) return;
            this._listenerInst = t
        },
        SetListenerZ(e) {
            this._listenerZ = e
        },
        ScheduleNextPlay(e) {
            this._nextPlayTime = Math.max(e, 0)
        },
        UnloadAudio(e) {
            const n = e[1],
                t = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e[0]);
            if (!t) return;
            this.PostToDOM("unload", {
                url: t.url,
                type: t.type,
                isMusic: n
            })
        },
        UnloadAudioByName(e, t) {
            const s = e === 1,
                n = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t) || this._remoteUrls.get(t.toLowerCase());
            if (!n) return;
            this.PostToDOM("unload", {
                url: n.url,
                type: n.type,
                isMusic: s
            })
        },
        UnloadAll() {
            this.PostToDOM("unload-all")
        },
        AddRemoteURL(e, t, n) {
            this._remoteUrls.set(n.toLowerCase(), {
                url: e,
                type: t
            })
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Audio.Exps = {
        Duration(e) {
            const t = this._GetFirstAudioStateByTag(e);
            return t ? t.duration : 0
        },
        PlaybackTime(e) {
            const t = this._GetFirstAudioStateByTag(e);
            return t ? t.playbackTime : 0
        },
        PlaybackRate(e) {
            const t = this._GetFirstAudioStateByTag(e);
            return t ? t.playbackRate : 0
        },
        Volume(e) {
            const t = this._GetFirstAudioStateByTag(e);
            return t ? this.LinearToDb(t.volume) : 0
        },
        MasterVolume() {
            return this.LinearToDb(this._masterVolume)
        },
        EffectCount(e) {
            return this._effectCount.get(e.toLowerCase()) || 0
        },
        AnalyserFreqBinCount(e, t) {
            const n = this.GetAnalyserData(e, Math.floor(t));
            return n ? n.binCount : 0
        },
        AnalyserFreqBinAt(e, t, n) {
            const s = this.GetAnalyserData(e, Math.floor(t));
            return s ? (n = Math.floor(n), n < 0 || n >= s.binCount ? 0 : s.freqBins[n]) : 0
        },
        AnalyserPeakLevel(e, t) {
            const n = this.GetAnalyserData(e, Math.floor(t));
            return n ? n.peak : 0
        },
        AnalyserRMSLevel(e, t) {
            const n = this.GetAnalyserData(e, Math.floor(t));
            return n ? n.rms : 0
        },
        SampleRate() {
            return this._sampleRate
        },
        CurrentTime() {
            return self.C3_GetAudioContextCurrentTime ? self.C3_GetAudioContextCurrentTime() : performance.now() / 1e3
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.NinePatch = class NinePatchPlugin extends e.SDKPluginBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.NinePatch.Type = class NinePatchType extends e.SDKTypeBase {
        constructor(e) {
            super(e), this._textureSet = null, this._drawable = null
        }
        Release() {
            this.ReleaseTextures(), super.Release()
        }
        OnCreate() {
            this.GetImageInfo().LoadAsset(this._runtime)
        }
        async LoadTextures() {
            const t = this.GetImageInfo();
            this._drawable = await t.ExtractImageToCanvas()
        }
        CreatePatch(e, t, n, s) {
            if (this._textureSet || !this._drawable) return;
            this._textureSet = new self.NinePatchTextureSet(this), this._textureSet.CreateTextures(this._drawable, e, t, n, s)
        }
        ReleaseTextures() {
            this._textureSet && (this._textureSet.Release(), this._textureSet = null)
        }
        GetTextureSet() {
            return this._textureSet
        }
    }
}
"use strict";
{
    const t = self.C3,
        s = 0,
        o = 1,
        i = 2,
        a = 3,
        r = 4,
        c = 5,
        l = 6,
        u = 7,
        d = 8,
        e = t.New(t.Rect),
        n = t.New(t.Quad);
    t.Plugins.NinePatch.Instance = class NinePatchInstance extends t.SDKWorldInstanceBase {
        constructor(e, t) {
            super(e), this._leftMargin = 16, this._rightMargin = 16, this._topMargin = 16, this._bottomMargin = 16, this._edges = 1, this._fill = 1, this._isSeamless = !0, t && (this._leftMargin = t[s], this._rightMargin = t[o], this._topMargin = t[i], this._bottomMargin = t[a], this._edges = t[r], this._fill = t[c], this._isSeamless = !!t[d], this.GetWorldInfo().SetVisible(!!t[l])), this._sdkType.CreatePatch(this._leftMargin, this._rightMargin, this._topMargin, this._bottomMargin)
        }
        Release() {
            super.Release()
        }
        Draw(e) {
            let a = this._sdkType.GetTextureSet();
            if (!a && (this._sdkType.CreatePatch(this._leftMargin, this._rightMargin, this._topMargin, this._bottomMargin), a = this._sdkType.GetTextureSet(), !a)) return;
            const m = this.GetWorldInfo(),
                t = this._leftMargin,
                o = this._rightMargin,
                n = this._topMargin,
                i = this._bottomMargin,
                b = a.GetImageWidth(),
                v = a.GetImageHeight(),
                l = b - o,
                d = v - i,
                p = m.GetBoundingQuad(),
                c = p.getTlx(),
                r = p.getTly(),
                u = m.GetWidth(),
                h = m.GetHeight(),
                s = this._isSeamless ? 1 : 0,
                g = this._edges,
                f = this._fill;
            if (t > 0 && n > 0 && this._DrawPatch(e, a.GetTexture(), 0, 0, t + s, n + s, c, r, t + s, n + s), o > 0 && n > 0 && this._DrawPatch(e, a.GetTexture(), l - s, 0, o + s, n + s, c + u - o - s, r, o + s, n + s), o > 0 && i > 0 && this._DrawPatch(e, a.GetTexture(), l - s, d - s, o + s, i + s, c + u - o - s, r + h - i - s, o + s, i + s), t > 0 && i > 0 && this._DrawPatch(e, a.GetTexture(), 0, d - s, t + s, i + s, c, r + h - i - s, t + s, i + s), g === 0) {
                const m = f === 2 ? 0 : s;
                t > 0 && d > n && this._TilePatch(e, a.GetLeftTexture(), c, r + n, t + m, h - n - i, 0, 0), o > 0 && d > n && this._TilePatch(e, a.GetRightTexture(), c + u - o - m, r + n, o + m, h - n - i, m, 0), n > 0 && l > t && this._TilePatch(e, a.GetTopTexture(), c + t, r, u - t - o, n + m, 0, 0), i > 0 && l > t && this._TilePatch(e, a.GetBottomTexture(), c + t, r + h - i - m, u - t - o, i + m, 0, m)
            } else g === 1 && (t > 0 && d > n && this._DrawPatch(e, a.GetTexture(), 0, n, t, d - n, c, r + n, t, h - n - i), o > 0 && d > n && this._DrawPatch(e, a.GetTexture(), l, n, o, d - n, c + u - o, r + n, o, h - n - i), n > 0 && l > t && this._DrawPatch(e, a.GetTexture(), t, 0, l - t, n, c + t, r, u - t - o, n), i > 0 && l > t && this._DrawPatch(e, a.GetTexture(), t, d, l - t, i, c + t, r + h - i, u - t - o, i));
            d > n && l > t && (f === 0 ? this._TilePatch(e, a.GetFillTexture(), c + t, r + n, u - t - o, h - n - i, 0, 0) : f === 1 && this._DrawPatch(e, a.GetTexture(), t, n, l - t, d - n, c + t, r + n, u - t - o, h - n - i))
        }
        _DrawPatch(t, s, o, i, a, r, c, l, d, u) {
            const h = s.GetWidth(),
                m = s.GetHeight();
            t.SetTexture(s);
            const f = this.GetWorldInfo(),
                p = f.GetBoundingQuad(),
                g = p.getTlx(),
                v = p.getTly();
            e.set(c, l, c + d, l + u), e.offset(-g, -v), n.setFromRotatedRect(e, f.GetAngle()), n.offset(g, v), e.set(o / h, i / m, (o + a) / h, (i + r) / m), t.Quad3(n, e)
        }
        _TilePatch(t, s, o, i, a, r, c, l) {
            const d = s.GetWidth(),
                u = s.GetHeight();
            t.SetTexture(s);
            const h = this.GetWorldInfo(),
                m = h.GetBoundingQuad(),
                f = m.getTlx(),
                p = m.getTly();
            e.set(o, i, o + a, i + r), e.offset(-f, -p), n.setFromRotatedRect(e, h.GetAngle()), n.offset(f, p), e.set(-c / d, -l / u, (a - c) / d, (r - l) / u), t.Quad3(n, e)
        }
        GetCurrentImageInfo() {
            this._objectClass.GetImageInfo()
        }
        GetPropertyValueByIndex() {}
        SetPropertyValueByIndex() {}
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.NinePatch.Cnds = {}
}
"use strict";
{
    const e = self.C3;
    e.Plugins.NinePatch.Acts = {
        SetEffect(e) {
            this.GetWorldInfo().SetBlendMode(e), this._runtime.UpdateRender()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.NinePatch.Exps = {}
}
"use strict";
{
    const e = self.C3;

    function CloneDrawable(t) {
        const n = e.CreateCanvas(t.width, t.height),
            s = n.getContext("2d");
        return s.drawImage(t, 0, 0), n
    }
    self.NinePatchTextureSet = class NinePatchTextureSet {
        constructor(e) {
            this._sdkType = e, this._runtime = this._sdkType.GetRuntime(), this._texture = null, this._fillTexture = null, this._leftTexture = null, this._rightTexture = null, this._topTexture = null, this._bottomTexture = null, this._imageWidth = 0, this._imageHeight = 0, this._renderer = this._runtime.GetWebGLRenderer(), this._isLoading = !1, this._wasReleased = !1
        }
        Release() {
            this._renderer.IsContextLost() || (this._renderer.DeleteTexture(this._texture), this._renderer.DeleteTexture(this._fillTexture), this._renderer.DeleteTexture(this._leftTexture), this._renderer.DeleteTexture(this._rightTexture), this._renderer.DeleteTexture(this._topTexture), this._renderer.DeleteTexture(this._bottomTexture)), this._texture = null, this._fillTexture = null, this._leftTexture = null, this._rightTexture = null, this._topTexture = null, this._bottomTexture = null, this._sdkType = null, this._renderer = null, this._wasReleased = !0
        }
        WasReleased() {
            return this._wasReleased
        }
        CreateTextures(e, t, n, s, o) {
            this._SliceImage(e, t, n, s, o)
        }
        HasCreatedTextures() {
            return !!this._texture
        }
        _SliceImage(e, t, n, s, o) {
            if (this._wasReleased) return;
            const c = e.width,
                l = e.height;
            this._imageWidth = c, this._imageHeight = l;
            const i = c - n,
                a = l - o,
                r = this._runtime.GetSampling();
            this._texture = this._renderer.CreateStaticTexture(CloneDrawable(e), {
                sampling: r
            }), i > t && a > s && (this._fillTexture = this._renderer.CreateStaticTexture(this._SliceSubImage(CloneDrawable(e), t, s, i, a), {
                wrapX: "repeat",
                wrapY: "repeat",
                sampling: r
            })), t > 0 && a > s && (this._leftTexture = this._renderer.CreateStaticTexture(this._SliceSubImage(CloneDrawable(e), 0, s, t, a), {
                wrapY: "repeat",
                sampling: r
            })), n > 0 && a > s && (this._rightTexture = this._renderer.CreateStaticTexture(this._SliceSubImage(CloneDrawable(e), i, s, c, a), {
                wrapY: "repeat",
                sampling: r
            })), s > 0 && i > t && (this._topTexture = this._renderer.CreateStaticTexture(this._SliceSubImage(CloneDrawable(e), t, 0, i, s), {
                wrapX: "repeat",
                sampling: r
            })), o > 0 && i > t && (this._bottomTexture = this._renderer.CreateStaticTexture(this._SliceSubImage(CloneDrawable(e), t, a, i, l), {
                wrapX: "repeat",
                sampling: r
            }))
        }
        _SliceSubImage(t, n, s, o, i) {
            const a = o - n,
                r = i - s,
                c = e.CreateCanvas(a, r),
                l = c.getContext("2d");
            return l.drawImage(t, n, s, a, r, 0, 0, a, r), c
        }
        GetImageWidth() {
            return this._imageWidth
        }
        GetImageHeight() {
            return this._imageHeight
        }
        GetTexture() {
            return this._texture
        }
        GetFillTexture() {
            return this._fillTexture
        }
        GetLeftTexture() {
            return this._leftTexture
        }
        GetRightTexture() {
            return this._rightTexture
        }
        GetTopTexture() {
            return this._topTexture
        }
        GetBottomTexture() {
            return this._bottomTexture
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.gamepad = class GamepadPlugin extends e.SDKPluginBase {
        constructor(e) {
            super(e), this._isSupported = !1, this._runtime.AddLoadPromise(this._runtime.PostComponentMessageToDOMAsync("gamepad", "is-supported").then(e => this._isSupported = !!e))
        }
        Release() {
            super.Release()
        }
        IsSupported() {
            return this._isSupported
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.gamepad.Type = class GamepadType extends e.SDKTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
}
"use strict";
{
    const e = self.C3,
        n = "gamepad";
    class s {
        constructor(e, n) {
            this._index = e, this._id = n, this._state = new t, this._oldState = new t
        }
        GetID() {
            return this._id
        }
        Update(e, t) {
            const n = this._oldState;
            this._oldState = this._state, this._state = n, this._state.Update(e, t)
        }
        GetButtonCount() {
            return this._state.GetButtonCount()
        }
        GetAxisCount() {
            return this._state.GetAxisCount()
        }
        HasButtonBecomePressed(e) {
            return this._state.GetButtonAt(e) >= .5 && this._oldState.GetButtonAt(e) < .5
        }
        HasButtonBecomeReleased(e) {
            return this._state.GetButtonAt(e) < .5 && this._oldState.GetButtonAt(e) >= .5
        }
        GetButtonAt(e) {
            return this._state.GetButtonAt(e)
        }
        IsButtonDown(e) {
            return this._state.GetButtonAt(e) >= .5
        }
        GetAxisAt(e) {
            return this._state.GetAxisAt(e)
        }
    }
    class t {
        constructor() {
            this._buttons = [], this._axes = []
        }
        Update(t, n) {
            const o = this._buttons;
            let s = 0;
            for (let n = t.length; s < n; ++s) {
                const e = t[s];
                s === o.length ? o.push(e.value) : o[s] = e.value
            }
            s < o.length && e.truncateArray(o, s), e.shallowAssignArray(this._axes, n)
        }
        GetButtonCount() {
            return this._buttons.length
        }
        GetAxisCount() {
            return this._axes.length
        }
        GetButtonAt(e) {
            return e = Math.floor(e), e < 0 || e >= this._buttons.length ? 0 : this._buttons[e]
        }
        GetAxisAt(e) {
            return e = Math.floor(e), e < 0 || e >= this._axes.length ? 0 : this._axes[e]
        }
    }
    e.Plugins.gamepad.Instance = class GamepadInstance extends e.SDKInstanceBase {
        constructor(e, t) {
            super(e, n), this._deadZone = 25, this._lastButton = 0, this._lastIndex = -1, this._gamepads = new Map, t && (this._deadZone = t[0]), this.AddDOMMessageHandler("gamepad-connected", e => this._OnGamepadConnected(e)), this.AddDOMMessageHandler("gamepad-disconnected", e => this._OnGamepadDisconnected(e)), this.AddDOMMessageHandler("input-update", e => this._OnInputUpdate(e)), this.PostToDOM("ready")
        }
        Release() {
            super.Release()
        }
        _OnGamepadConnected(t) {
            const n = t.index;
            this._lastIndex = n;
            const o = t.id;
            if (this._gamepads.has(n)) return;
            this._gamepads.set(n, new s(n, o)), this.Trigger(e.Plugins.gamepad.Cnds.OnGamepadConnected), this._lastIndex = -1
        }
        _OnGamepadDisconnected(t) {
            const n = t.index;
            this._lastIndex = n, this.Trigger(e.Plugins.gamepad.Cnds.OnGamepadDisconnected), this._gamepads.delete(n), this._lastIndex = -1
        }
        _OnInputUpdate(e) {
            for (const t of e) this._OnGamepadInputUpdate(t)
        }
        _OnGamepadInputUpdate(e) {
            const n = e.index;
            this._gamepads.has(n) || this._OnGamepadConnected(e);
            const t = this._gamepads.get(n);
            t.Update(e.buttons, e.axes);
            for (let e = 0, n = t.GetButtonCount(); e < n; ++e) t.HasButtonBecomePressed(e) && (this._lastButton = e)
        }
        _GetGamepadByIndex(e) {
            return this._gamepads.get(Math.floor(e)) || null
        }
        GetDebuggerProperties() {
            const e = "plugins.gamepad";
            return [{
                title: e + ".name",
                properties: [{
                    name: e + ".debugger.last-button",
                    value: this._lastButton
                }]
            }]
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.gamepad.Cnds = {
        SupportsGamepad() {
            return this.GetPlugin().IsSupported()
        },
        OnGamepadConnected() {
            return !0
        },
        OnGamepadDisconnected() {
            return !0
        },
        IsButtonDown(e, t) {
            const n = this._GetGamepadByIndex(e);
            if (!n) return !1;
            const s = n.IsButtonDown(t);
            return s && (this._lastButton = t), s
        },
        OnButtonDown(e, t) {
            const n = this._GetGamepadByIndex(e);
            if (!n) return !1;
            const s = n.HasButtonBecomePressed(t);
            return s && (this._lastButton = t), s
        },
        OnButtonUp(e, t) {
            const n = this._GetGamepadByIndex(e);
            if (!n) return !1;
            const s = n.HasButtonBecomeReleased(t);
            return s && (this._lastButton = t), s
        },
        HasGamepads() {
            return this._gamepads.size > 0
        },
        CompareAxis(t, n, s, o) {
            n = Math.floor(n);
            const i = this._GetGamepadByIndex(t);
            if (!i) return !1;
            let a = i.GetAxisAt(n),
                r = 0;
            return n % 2 === 0 ? r = i.GetAxisAt(n + 1) : r = i.GetAxisAt(n - 1), a *= 100, r *= 100, Math.hypot(a, r) <= this._deadZone && (a = 0), e.compare(a, s, o)
        },
        OnAnyButtonDown(e) {
            const t = this._GetGamepadByIndex(e);
            if (!t) return !1;
            for (let e = 0, n = t.GetButtonCount(); e < n; ++e)
                if (t.HasButtonBecomePressed(e)) return this._lastButton = e, !0;
            return !1
        },
        OnAnyButtonUp(e) {
            const t = this._GetGamepadByIndex(e);
            if (!t) return !1;
            for (let e = 0, n = t.GetButtonCount(); e < n; ++e)
                if (t.HasButtonBecomeReleased(e)) return this._lastButton = e, !0;
            return !1
        },
        IsButtonIndexDown(e, t) {
            t = Math.floor(t);
            const n = this._GetGamepadByIndex(e);
            if (!n) return !1;
            const s = n.IsButtonDown(t);
            return s && (this._lastButton = t), s
        },
        OnButtonIndexDown(e, t) {
            t = Math.floor(t);
            const n = this._GetGamepadByIndex(e);
            if (!n) return !1;
            const s = n.HasButtonBecomePressed(t);
            return s && (this._lastButton = t), s
        },
        OnButtonIndexUp(e, t) {
            t = Math.floor(t);
            const n = this._GetGamepadByIndex(e);
            if (!n) return !1;
            const s = n.HasButtonBecomeReleased(t);
            return s && (this._lastButton = t), s
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.gamepad.Acts = {
        Vibrate(t, n, s, o) {
            this.PostToDOM("vibrate", {
                index: t,
                duration: n,
                weakMag: e.clamp(s / 100, 0, 1),
                strongMag: e.clamp(o / 100, 0, 1)
            })
        },
        ResetVibrate(e) {
            this.PostToDOM("reset-vibrate", {
                index: e
            })
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.gamepad.Exps = {
        GamepadCount() {
            return this._gamepads.size
        },
        GamepadID(e) {
            const t = this._GetGamepadByIndex(e);
            return t ? t.GetID() : ""
        },
        GamepadIndex() {
            return this._lastIndex
        },
        GamepadAxes(e) {
            const t = this._GetGamepadByIndex(e);
            if (!t) return "";
            let n = "";
            for (let e = 0, s = t.GetAxisCount(); e < s; ++e) n += `Axis ${e}: ${Math.round(t.GetAxisAt(e)*100)}
`;
            return n
        },
        GamepadButtons(e) {
            const t = this._GetGamepadByIndex(e);
            if (!t) return "";
            let n = "";
            for (let e = 0, s = t.GetButtonCount(); e < s; ++e) n += `Button ${e}: ${Math.round(t.GetButtonAt(e)*100)}
`;
            return n
        },
        RawButton(e, t) {
            const n = this._GetGamepadByIndex(e);
            return n ? n.GetButtonAt(Math.floor(t)) : 0
        },
        RawAxis(e, t) {
            const n = this._GetGamepadByIndex(e);
            return n ? n.GetAxisAt(Math.floor(t)) : 0
        },
        RawButtonCount(e) {
            const t = this._GetGamepadByIndex(e);
            return t ? t.GetButtonCount() : 0
        },
        RawAxisCount(e) {
            const t = this._GetGamepadByIndex(e);
            return t ? t.GetAxisCount() : 0
        },
        Button(e, t) {
            const n = this._GetGamepadByIndex(e);
            return n ? n.GetButtonAt(Math.floor(t)) * 100 : 0
        },
        Axis(e, t) {
            t = Math.floor(t);
            const n = this._GetGamepadByIndex(e);
            if (!n) return 0;
            let s = n.GetAxisAt(t),
                o = 0;
            return t % 2 === 0 ? o = n.GetAxisAt(t + 1) : o = n.GetAxisAt(t - 1), s *= 100, o *= 100, Math.hypot(s, o) <= this._deadZone && (s = 0), s
        },
        LastButton() {
            return this._lastButton
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = "text-input";
    e.Plugins.TextBox = class TextInputPlugin extends e.SDKDOMPluginBase {
        constructor(e) {
            super(e, t), this.AddElementMessageHandler("click", (e, t) => e._OnClick(t)), this.AddElementMessageHandler("dblclick", (e, t) => e._OnDoubleClick(t)), this.AddElementMessageHandler("change", (e, t) => e._OnChange(t))
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.TextBox.Type = class TextInputType extends e.SDKTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
}
"use strict";
{
    const t = self.C3,
        l = 0,
        i = 1,
        s = 2,
        d = 3,
        o = 4,
        n = 5,
        a = 6,
        u = 7,
        r = 8,
        c = 9,
        h = "text-input",
        m = ["text", "password", "email", "number", "tel", "url", "textarea", "search"];
    t.Plugins.TextBox.Instance = class TextInputInstance extends t.SDKDOMInstanceBase {
        constructor(e, t) {
            super(e, h), this._text = "", this._placeholder = "", this._title = "", this._isEnabled = !0, this._isReadOnly = !1, this._spellCheck = !1, this._type = "text", this._autoFontSize = !0, this._maxLength = -1, this._id = "", t && (this._text = t[l], this._placeholder = t[i], this._title = t[s], this.GetWorldInfo().SetVisible(t[d]), this._isEnabled = t[o], this._isReadOnly = t[n], this._spellCheck = t[a], this._type = m[t[u]], this._autoFontSize = t[r], this._id = t[c]), this.CreateElement({
                type: this._type,
                id: this._id
            })
        }
        Release() {
            super.Release()
        }
        GetElementState() {
            return {
                text: this._text,
                placeholder: this._placeholder,
                title: this._title,
                isEnabled: this._isEnabled,
                isReadOnly: this._isReadOnly,
                spellCheck: this._spellCheck,
                maxLength: this._maxLength
            }
        }
        async _OnClick() {
            this.GetScriptInterface().dispatchEvent(t.New(t.Event, "click", !0)), await this.TriggerAsync(t.Plugins.TextBox.Cnds.OnClicked)
        }
        async _OnDoubleClick() {
            this.GetScriptInterface().dispatchEvent(t.New(t.Event, "dblclick", !0)), await this.TriggerAsync(t.Plugins.TextBox.Cnds.OnDoubleClicked)
        }
        async _OnChange(e) {
            this._text = e.text, this.GetScriptInterface().dispatchEvent(t.New(t.Event, "change", !0)), await this.TriggerAsync(t.Plugins.TextBox.Cnds.OnTextChanged)
        }
        _SetText(e) {
            if (this._text === e) return;
            this._text = e, this.UpdateElementState()
        }
        _GetText() {
            return this._text
        }
        _SetPlaceholder(e) {
            if (this._placeholder === e) return;
            this._placeholder = e, this.UpdateElementState()
        }
        _GetPlaceholder() {
            return this._placeholder
        }
        _SetTooltip(e) {
            if (this._title === e) return;
            this._title = e, this.UpdateElementState()
        }
        _GetTooltip() {
            return this._title
        }
        _SetEnabled(e) {
            if (e = !!e, this._isEnabled === e) return;
            this._isEnabled = e, this.UpdateElementState()
        }
        _IsEnabled() {
            return this._isEnabled
        }
        _SetReadOnly(e) {
            if (e = !!e, this._isReadOnly === e) return;
            this._isReadOnly = e, this.UpdateElementState()
        }
        _IsReadOnly() {
            return this._isReadOnly
        }
        _SetMaxLength(e) {
            if (e = Math.max(+e, -1), this._maxLength === e) return;
            this._maxLength = e, this.UpdateElementState()
        }
        _GetMaxLength() {
            return this._maxLength
        }
        _ScrollToBottom() {
            this.PostToDOMElement("scroll-to-bottom")
        }
        Draw() {}
        SaveToJson() {
            return {
                t: this._text,
                p: this._placeholder,
                ti: this._title,
                e: this._isEnabled,
                r: this._isReadOnly,
                sp: this._spellCheck,
                ml: this._maxLength,
                type: this._type,
                id: this._id
            }
        }
        LoadFromJson(e) {
            this._text = e.t, this._placeholder = e.p, this._title = e.ti, this._isEnabled = e.e, this._isReadOnly = e.r, this._spellCheck = e.sp, this._maxLength = e.hasOwnProperty("ml") ? e.ml : -1, this._type = e.type, this._id = e.id, this.UpdateElementState()
        }
        GetPropertyValueByIndex(e) {
            switch (e) {
                case l:
                    return this._text;
                case i:
                    return this._placeholder;
                case s:
                    return this._title;
                case o:
                    return this._isEnabled;
                case n:
                    return this._isReadOnly;
                case a:
                    return this._spellCheck;
                case r:
                    return this._autoFontSize;
                case c:
                    return this._id
            }
        }
        SetPropertyValueByIndex(e, t) {
            switch (e) {
                case l:
                    if (this._text === t) return;
                    this._text = t, this.UpdateElementState();
                    break;
                case i:
                    if (this._placeholder === t) return;
                    this._placeholder = t, this.UpdateElementState();
                    break;
                case s:
                    if (this._title === t) return;
                    this._title = t, this.UpdateElementState();
                    break;
                case o:
                    if (this._isEnabled === !!t) return;
                    this._isEnabled = !!t, this.UpdateElementState();
                    break;
                case n:
                    if (this._isReadOnly === !!t) return;
                    this._isReadOnly = !!t, this.UpdateElementState();
                    break;
                case a:
                    if (this._spellCheck === !!t) return;
                    this._spellCheck = !!t, this.UpdateElementState();
                    break;
                case r:
                    this._autoFontSize = !!t;
                    break;
                case c:
                    if (this._id === t) return;
                    this._id = t, this.UpdateElementState();
                    break
            }
        }
        GetDebuggerProperties() {
            const n = t.Plugins.TextBox.Acts,
                e = "plugins.textbox";
            return [{
                title: e + ".name",
                properties: [{
                    name: e + ".properties.text.name",
                    value: this._text,
                    onedit: e => this.CallAction(n.SetText, e)
                }, {
                    name: e + ".properties.enabled.name",
                    value: this._isEnabled,
                    onedit: e => this.CallAction(n.SetEnabled, e)
                }, {
                    name: e + ".properties.read-only.name",
                    value: this._isReadOnly,
                    onedit: e => this.CallAction(n.SetReadOnly, e)
                }]
            }]
        }
        GetScriptInterfaceClass() {
            return self.ITextInputInstance
        }
    };
    const e = new WeakMap;
    self.ITextInputInstance = class ITextInputInstance extends self.IDOMInstance {
        constructor() {
            super(), e.set(this, self.IInstance._GetInitInst().GetSdkInstance())
        }
        set text(t) {
            e.get(this)._SetText(t)
        }
        get text() {
            return e.get(this)._GetText()
        }
        set placeholder(t) {
            e.get(this)._SetPlaceholder(t)
        }
        get placeholder() {
            return e.get(this)._GetPlaceholder()
        }
        set tooltip(t) {
            e.get(this)._SetTooltip(t)
        }
        get tooltip() {
            return e.get(this)._GetTooltip()
        }
        set isEnabled(t) {
            e.get(this)._SetEnabled(t)
        }
        get isEnabled() {
            return e.get(this)._IsEnabled()
        }
        set isReadOnly(t) {
            e.get(this)._SetReadOnly(t)
        }
        get isReadOnly() {
            return e.get(this)._IsReadOnly()
        }
        set maxLength(t) {
            e.get(this)._SetMaxLength(t)
        }
        get maxLength() {
            return e.get(this)._GetMaxLength()
        }
        scrollToBottom() {
            e.get(this)._ScrollToBottom()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.TextBox.Cnds = {
        CompareText(t, n) {
            return n === 0 ? e.equalsNoCase(this._text, t) : this._text === t
        },
        OnTextChanged() {
            return !0
        },
        OnClicked() {
            return !0
        },
        OnDoubleClicked() {
            return !0
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.TextBox.Acts = {
        SetText(e) {
            this._SetText(e.toString())
        },
        AppendText(e) {
            if (e === "") return;
            this._SetText(this._GetText() + e)
        },
        SetPlaceholder(e) {
            this._SetPlaceholder(e)
        },
        SetTooltip(e) {
            this._SetTooltip(e)
        },
        SetReadOnly(e) {
            this._SetReadOnly(e === 0)
        },
        ScrollToBottom() {
            this._ScrollToBottom()
        },
        SetMaxLength(e) {
            this._SetMaxLength(e)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.TextBox.Exps = {
        Text() {
            return this._GetText()
        },
        MaxLength() {
            return this._GetMaxLength()
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = "sliderbar";
    e.Plugins.sliderbar = class SliderBarPlugin extends e.SDKDOMPluginBase {
        constructor(e) {
            super(e, t), this.AddElementMessageHandler("click", (e, t) => e._OnClick(t)), this.AddElementMessageHandler("change", (e, t) => e._OnChange(t)), this.AddElementMessageHandler("input", (e, t) => e._OnInput(t))
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.sliderbar.Type = class SliderBarType extends e.SDKTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
}
"use strict";
{
    const t = self.C3,
        n = 0,
        s = 1,
        o = 2,
        i = 3,
        a = 4,
        l = 5,
        r = 6,
        c = 7,
        d = "sliderbar";
    t.Plugins.sliderbar.Instance = class SliderBarInstance extends t.SDKDOMInstanceBase {
        constructor(e, t) {
            super(e, d), this._value = 0, this._min = 0, this._max = 100, this._step = 1, this._title = "", this._isEnabled = !0, this._id = "", t && (this._value = t[n], this._min = t[s], this._max = t[o], this._step = t[i], this._title = t[a], this.GetWorldInfo().SetVisible(t[l]), this._isEnabled = t[r], this._id = t[c]), this.CreateElement({
                id: this._id
            })
        }
        Release() {
            super.Release()
        }
        GetElementState() {
            return {
                value: this._value,
                min: this._min,
                max: this._max,
                step: this._step,
                title: this._title,
                isEnabled: this._isEnabled
            }
        }
        async _OnClick() {
            this.GetScriptInterface().dispatchEvent(t.New(t.Event, "click", !0)), await this.TriggerAsync(t.Plugins.sliderbar.Cnds.OnClicked)
        }
        async _OnChange(e) {
            this._value = e.value, this.GetScriptInterface().dispatchEvent(t.New(t.Event, "change", !0)), await this.TriggerAsync(t.Plugins.sliderbar.Cnds.OnChanged)
        }
        _OnInput(e) {
            this._value = e.value
        }
        Draw() {}
        _SetValue(e) {
            if (this._value === e) return;
            this._value = e, this.UpdateElementState()
        }
        _GetValue() {
            return this._value
        }
        _SetMaximum(e) {
            if (this._max === e) return;
            this._max = e, this.UpdateElementState()
        }
        _GetMaximum() {
            return this._max
        }
        _SetMinimum(e) {
            if (this._min === e) return;
            this._min = e, this.UpdateElementState()
        }
        _GetMinimum() {
            return this._min
        }
        _SetTooltip(e) {
            if (this._title === e) return;
            this._title = e, this.UpdateElementState()
        }
        _GetTooltip() {
            return this._title
        }
        _SetStep(e) {
            if (this._step === e) return;
            this._step = e, this.UpdateElementState()
        }
        _GetStep() {
            return this._step
        }
        _SetEnabled(e) {
            if (e = !!e, this._isEnabled === e) return;
            this._isEnabled = e, this.UpdateElementState()
        }
        _IsEnabled() {
            return this._isEnabled
        }
        SaveToJson() {
            return {
                v: this._value,
                min: this._min,
                max: this._max,
                s: this._step,
                t: this._title,
                e: this._isEnabled,
                id: this._id
            }
        }
        LoadFromJson(e) {
            this._value = e.v, this._min = e.min, this._max = e.max, this._step = e.s, this._title = e.t, this._isEnabled = e.e, this._id = e.id, this.UpdateElementState()
        }
        GetPropertyValueByIndex(e) {
            switch (e) {
                case n:
                    return this._GetValue();
                case s:
                    return this._GetMinimum();
                case o:
                    return this._GetMaximum();
                case i:
                    return this._GetStep();
                case a:
                    return this._GetTooltip();
                case r:
                    return this._IsEnbled();
                case c:
                    return this._id
            }
        }
        SetPropertyValueByIndex(e, t) {
            switch (e) {
                case n:
                    this._SetValue(t);
                    break;
                case s:
                    this._SetMinimum(t);
                    break;
                case o:
                    this._SetMaximum(t);
                    break;
                case i:
                    this._SetStep(t);
                    break;
                case a:
                    this._SetTooltip(t);
                    break;
                case r:
                    this._SetEnabled(t);
                    break;
                case c:
                    if (this._id === t) return;
                    this._id = t, this.UpdateElementState();
                    break
            }
        }
        GetDebuggerProperties() {
            const n = t.Plugins.sliderbar.Acts,
                e = "plugins.sliderbar";
            return [{
                title: e + ".name",
                properties: [{
                    name: e + ".properties.value.name",
                    value: this._GetValue(),
                    onedit: e => this._SetValue(e)
                }, {
                    name: e + ".properties.minimum.name",
                    value: this._GetMinimum(),
                    onedit: e => this._SetMinimum(e)
                }, {
                    name: e + ".properties.maximum.name",
                    value: this._GetMaximum(),
                    onedit: e => this._SetMaximum(e)
                }, {
                    name: e + ".properties.step.name",
                    value: this._GetStep(),
                    onedit: e => this._SetStep(e)
                }]
            }]
        }
        GetScriptInterfaceClass() {
            return self.ISliderBarInstance
        }
    };
    const e = new WeakMap;
    self.ISliderBarInstance = class ITextInputInstance extends self.IDOMInstance {
        constructor() {
            super(), e.set(this, self.IInstance._GetInitInst().GetSdkInstance())
        }
        set value(t) {
            e.get(this)._SetValue(t)
        }
        get value() {
            return e.get(this)._GetValue()
        }
        set maximum(t) {
            e.get(this)._SetMaximum(t)
        }
        get maximum() {
            return e.get(this)._GetMaximum()
        }
        set minimum(t) {
            e.get(this)._SetMinimum(t)
        }
        get minimum() {
            return e.get(this)._GetMinimum()
        }
        set step(t) {
            e.get(this)._SetStep(t)
        }
        get step() {
            return e.get(this)._GetStep()
        }
        set tooltip(t) {
            e.get(this)._SetTooltip(t)
        }
        get tooltip() {
            return e.get(this)._GetTooltip()
        }
        set isEnabled(t) {
            e.get(this)._SetEnabled(t)
        }
        get isEnabled() {
            return e.get(this)._IsEnabled()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.sliderbar.Cnds = {
        OnClicked() {
            return !0
        },
        OnChanged() {
            return !0
        },
        CompareValue(t, n) {
            return e.compare(this._GetValue(), t, n)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.sliderbar.Acts = {
        SetTooltip(e) {
            this._SetTooltip(e)
        },
        SetValue(e) {
            this._SetValue(e)
        },
        SetMaximum(e) {
            this._SetMaximum(e)
        },
        SetMinimum(e) {
            this._SetMinimum(e)
        },
        SetStep(e) {
            this._SetStep(e)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.sliderbar.Exps = {
        Value() {
            return this._GetValue()
        },
        Maximum() {
            return this._GetMaximum()
        },
        Minimum() {
            return this._GetMinimum()
        },
        Step() {
            return this._GetStep()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Browser = class BrowserPlugin extends e.SDKPluginBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Browser.Type = class BrowserType extends e.SDKTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
}
"use strict";
{
    const e = self.C3,
        t = "browser";
    e.Plugins.Browser.Instance = class BrowserInstance extends e.SDKInstanceBase {
        constructor(n) {
            super(n, t), this._initLocationStr = "", this._isOnline = !1, this._referrer = "", this._docTitle = "", this._isCookieEnabled = !1, this._screenWidth = 0, this._screenHeight = 0, this._windowOuterWidth = 0, this._windowOuterHeight = 0, this._isScirraArcade = !1, this.AddDOMMessageHandlers([
                ["online-state", e => this._OnOnlineStateChanged(e)],
                ["backbutton", () => this._OnBackButton()],
                ["sw-message", e => this._OnSWMessage(e)],
                ["hashchange", e => this._OnHashChange(e)]
            ]);
            const o = this.GetRuntime().Dispatcher();
            this._disposables = new e.CompositeDisposable(e.Disposable.From(o, "afterfirstlayoutstart", () => this._OnAfterFirstLayoutStart()), e.Disposable.From(o, "window-resize", () => this._OnWindowResize()), e.Disposable.From(o, "suspend", () => this._OnSuspend()), e.Disposable.From(o, "resume", () => this._OnResume())), this._runtime.AddLoadPromise(this.PostToDOMAsync("get-initial-state", {
                exportType: this._runtime.GetExportType()
            }).then(e => {
                this._initLocationStr = e.location, this._isOnline = e.isOnline, this._referrer = e.referrer, this._docTitle = e.title, this._isCookieEnabled = e.isCookieEnabled, this._screenWidth = e.screenWidth, this._screenHeight = e.screenHeight, this._windowOuterWidth = e.windowOuterWidth, this._windowOuterHeight = e.windowOuterHeight, this._isScirraArcade = e.isScirraArcade
            }))
        }
        Release() {
            super.Release()
        }
        _OnAfterFirstLayoutStart() {
            this.PostToDOM("ready-for-sw-messages")
        }
        async _OnOnlineStateChanged(t) {
            const n = !!t.isOnline;
            if (this._isOnline === n) return;
            this._isOnline = n, this._isOnline ? await this.TriggerAsync(e.Plugins.Browser.Cnds.OnOnline) : await this.TriggerAsync(e.Plugins.Browser.Cnds.OnOffline)
        }
        async _OnWindowResize() {
            await this.TriggerAsync(e.Plugins.Browser.Cnds.OnResize)
        }
        _OnSuspend() {
            this.Trigger(e.Plugins.Browser.Cnds.OnPageHidden)
        }
        _OnResume() {
            this.Trigger(e.Plugins.Browser.Cnds.OnPageVisible)
        }
        async _OnBackButton() {
            await this.TriggerAsync(e.Plugins.Browser.Cnds.OnBackButton)
        }
        _OnSWMessage(t) {
            const n = t.type;
            n === "downloading-update" ? this.Trigger(e.Plugins.Browser.Cnds.OnUpdateFound) : n === "update-ready" || n === "update-pending" ? this.Trigger(e.Plugins.Browser.Cnds.OnUpdateReady) : n === "offline-ready" && this.Trigger(e.Plugins.Browser.Cnds.OnOfflineReady)
        }
        _OnHashChange(t) {
            this._initLocationStr = t.location, this.Trigger(e.Plugins.Browser.Cnds.OnHashChange)
        }
        GetDebuggerProperties() {
            const e = "plugins.browser.debugger";
            return [{
                title: "plugins.browser.name",
                properties: [{
                    name: e + ".user-agent",
                    value: navigator.userAgent
                }, {
                    name: e + ".is-online",
                    value: this._isOnline
                }, {
                    name: e + ".is-fullscreen",
                    value: this._runtime.GetCanvasManager().IsDocumentFullscreen()
                }]
            }]
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Browser.Cnds = {
        IsOnline() {
            return this._isOnline
        },
        OnOnline() {
            return !0
        },
        OnOffline() {
            return !0
        },
        OnResize() {
            return !0
        },
        CookiesEnabled() {
            return this._isCookieEnabled
        },
        IsFullscreen() {
            return this._runtime.GetCanvasManager().IsDocumentFullscreen()
        },
        OnBackButton() {
            return !0
        },
        IsPortraitLandscape(e) {
            const t = this._runtime.GetCanvasManager().GetLastWidth(),
                n = this._runtime.GetCanvasManager().GetLastHeight(),
                s = t <= n ? 0 : 1;
            return s === e
        },
        OnUpdateFound() {
            return !0
        },
        OnUpdateReady() {
            return !0
        },
        OnOfflineReady() {
            return !0
        },
        OnHashChange() {
            return !0
        },
        PageVisible() {
            return !this._runtime.IsSuspended()
        },
        OnPageHidden() {
            return !0
        },
        OnPageVisible() {
            return !0
        },
        HasJava() {
            return !1
        },
        IsDownloadingUpdate() {
            return !1
        },
        OnMenuButton() {
            return !1
        },
        OnSearchButton() {
            return !1
        },
        IsMetered() {
            return !1
        },
        IsCharging() {
            return !0
        },
        SupportsFullscreen() {
            return !0
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = ["portrait", "landscape", "portrait-primary", "portrait-secondary", "landscape-primary", "landscape-secondary"];
    e.Plugins.Browser.Acts = {
        Alert(e) {
            this.PostToDOM("alert", {
                message: e.toString()
            })
        },
        Close() {
            if (this._isScirraArcade) return;
            this._runtime.IsDebug() ? self.C3Debugger.CloseWindow() : this.PostToDOM("close")
        },
        Focus() {
            this.PostToDOM("set-focus", {
                isFocus: !0
            })
        },
        Blur() {
            this.PostToDOM("set-focus", {
                isFocus: !1
            })
        },
        GoBack() {
            if (this._isScirraArcade) return;
            this.PostToDOM("navigate", {
                type: "back"
            })
        },
        GoForward() {
            if (this._isScirraArcade) return;
            this.PostToDOM("navigate", {
                type: "forward"
            })
        },
        GoHome() {
            if (this._isScirraArcade) return;
            this.PostToDOM("navigate", {
                type: "home"
            })
        },
        Reload() {
            if (this._isScirraArcade) return;
            this._runtime.IsDebug() ? this._runtime.PostToDebugger({
                type: "reload"
            }) : this.PostToDOM("navigate", {
                type: "reload"
            })
        },
        GoToURL(e, t) {
            this._PostToDOMMaybeSync("navigate", {
                type: "url",
                url: e,
                target: t,
                exportType: this._runtime.GetExportType()
            })
        },
        GoToURLWindow(e, t) {
            this._PostToDOMMaybeSync("navigate", {
                type: "new-window",
                url: e,
                tag: t,
                exportType: this._runtime.GetExportType()
            })
        },
        RequestFullScreen(t, n) {
            t >= 2 && (t += 1), t === 6 && (t = 2), t === 1 && (t = 0);
            const s = e.CanvasManager._FullscreenModeNumberToString(t);
            this._runtime.GetCanvasManager().SetDocumentFullscreenMode(s), this._PostToDOMMaybeSync("request-fullscreen", {
                navUI: n
            })
        },
        CancelFullScreen() {
            this._PostToDOMMaybeSync("exit-fullscreen")
        },
        Vibrate(e) {
            const t = e.split(",");
            for (let e = 0, n = t.length; e < n; ++e) t[e] = parseInt(t[e], 10);
            this._PostToDOMMaybeSync("vibrate", {
                pattern: t
            })
        },
        async InvokeDownload(e, t) {
            if (!t) return;
            const n = await this._runtime.GetAssetManager().GetProjectFileUrl(e);
            this._runtime.InvokeDownload(n, t)
        },
        InvokeDownloadString(e, t, n) {
            if (!n) return;
            const s = `data:${t},${encodeURIComponent(e)}`;
            this._runtime.InvokeDownload(s, n)
        },
        ConsoleLog(e, t) {
            t = t.toString(), e === 0 ? console.log(t) : e === 1 ? console.warn(t) : e === 2 && console.error(t)
        },
        ConsoleGroup(e) {
            console.group(e)
        },
        ConsoleGroupEnd() {
            console.groupEnd()
        },
        ExecJs(e) {
            try {
                eval(e)
            } catch (e) {
                console.error("Error executing JavaScript: ", e)
            }
        },
        LockOrientation(e) {
            if (e = Math.floor(e), e < 0 || e >= t.length) return;
            const n = t[e];
            this._PostToDOMMaybeSync("lock-orientation", {
                orientation: n
            })
        },
        UnlockOrientation() {
            this._PostToDOMMaybeSync("unlock-orientation")
        },
        LoadStyleSheet(e) {
            this._runtime.GetAssetManager().LoadStyleSheet(e)
        },
        SetHash(e) {
            this.PostToDOM("set-hash", {
                hash: e
            })
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Browser.Exps = {
        URL() {
            return this._runtime.IsInWorker() ? this._initLocationStr : location.toString()
        },
        Protocol() {
            return this._runtime.IsInWorker() ? new URL(this._initLocationStr).protocol : location.protocol
        },
        Domain() {
            return this._runtime.IsInWorker() ? new URL(this._initLocationStr).hostname : location.hostname
        },
        Port() {
            return this._runtime.IsInWorker() ? new URL(this._initLocationStr).port : location.port
        },
        PathName() {
            return this._runtime.IsInWorker() ? new URL(this._initLocationStr).pathname : location.pathname
        },
        Hash() {
            return this._runtime.IsInWorker() ? new URL(this._initLocationStr).hash : location.hash
        },
        QueryString() {
            return this._runtime.IsInWorker() ? new URL(this._initLocationStr).search : location.search
        },
        QueryParam(e) {
            const n = this._runtime.IsInWorker() ? new URL(this._initLocationStr).search : location.search,
                t = RegExp("[?&]" + e + "=([^&]*)").exec(n);
            return t ? decodeURIComponent(t[1].replace(/\+/g, " ")) : ""
        },
        Referrer() {
            return this._referrer
        },
        Title() {
            return this._docTitle
        },
        Language() {
            return navigator.language
        },
        Platform() {
            return navigator.platform
        },
        UserAgent() {
            return navigator.userAgent
        },
        ExecJS(e) {
            let t = 0;
            try {
                t = eval(e)
            } catch (e) {
                console.error("Error executing JavaScript: ", e)
            }
            return typeof t == "number" || typeof t == "string" ? t : typeof t == "boolean" ? t ? 1 : 0 : 0
        },
        Name() {
            return navigator.appName
        },
        Version() {
            return navigator.appVersion
        },
        Product() {
            return navigator.product
        },
        Vendor() {
            return navigator.vendor
        },
        BatteryLevel() {
            return 1
        },
        BatteryTimeLeft() {
            return 1 / 0
        },
        Bandwidth() {
            const e = navigator.connection;
            return e ? e.downlink || e.downlinkMax || e.bandwidth || 1 / 0 : 1 / 0
        },
        ConnectionType() {
            const e = navigator.connection;
            return e ? e.type || "unknown" : "unknown"
        },
        DevicePixelRatio() {
            return self.devicePixelRatio
        },
        ScreenWidth() {
            return this._screenWidth
        },
        ScreenHeight() {
            return this._screenHeight
        },
        WindowInnerWidth() {
            return this._runtime.GetCanvasManager().GetLastWidth()
        },
        WindowInnerHeight() {
            return this._runtime.GetCanvasManager().GetLastHeight()
        },
        WindowOuterWidth() {
            return this._windowOuterWidth
        },
        WindowOuterHeight() {
            return this._windowOuterWidth
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = "progress-bar";
    e.Plugins.progressbar = class ProgressBarPlugin extends e.SDKDOMPluginBase {
        constructor(e) {
            super(e, t), this.AddElementMessageHandler("click", (e, t) => e._OnClick(t))
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.progressbar.Type = class ProgressBarType extends e.SDKTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
}
"use strict";
{
    const e = self.C3,
        t = 0,
        n = 1,
        s = 2,
        i = 3,
        o = 4,
        a = "progress-bar";
    e.Plugins.progressbar.Instance = class ProgressBarInstance extends e.SDKDOMInstanceBase {
        constructor(e, r) {
            super(e, a), this._value = 0, this._max = 100, this._title = "", this._id = "", r && (this._value = r[t], this._max = r[n], this._title = r[s], this.GetWorldInfo().SetVisible(r[i]), this._id = r[o]), this.CreateElement({
                id: this._id
            })
        }
        Release() {
            super.Release()
        }
        GetElementState() {
            return {
                value: this._value,
                max: this._max,
                title: this._title
            }
        }
        async _OnClick() {
            await this.TriggerAsync(e.Plugins.progressbar.Cnds.OnClicked)
        }
        Draw() {}
        SaveToJson() {
            return {
                v: this._value,
                m: this._max,
                t: this._title,
                id: this._id
            }
        }
        LoadFromJson(e) {
            this._value = e.v, this._max = e.m, this._title = e.t, this._id = e.id, this.UpdateElementState()
        }
        GetPropertyValueByIndex(e) {
            switch (e) {
                case t:
                    return this._value;
                case n:
                    return this._max;
                case s:
                    return this._title;
                case o:
                    return this._id
            }
        }
        SetPropertyValueByIndex(e, i) {
            switch (e) {
                case t:
                    if (this._value === i) return;
                    this._value = i, this.UpdateElementState();
                    break;
                case n:
                    if (this._max === i) return;
                    this._max = i, this.UpdateElementState();
                    break;
                case s:
                    if (this._title === i) return;
                    this._title = i, this.UpdateElementState();
                    break;
                case o:
                    if (this._id === i) return;
                    this._id = i, this.UpdateElementState();
                    break
            }
        }
        GetDebuggerProperties() {
            const n = e.Plugins.progressbar.Acts,
                t = "plugins.progressbar";
            return [{
                title: t + ".name",
                properties: [{
                    name: t + ".properties.value.name",
                    value: this._value,
                    onedit: e => this.CallAction(n.SetProgress, e)
                }, {
                    name: t + ".properties.maximum.name",
                    value: this._max,
                    onedit: e => this.CallAction(n.SetMaximum, e)
                }]
            }]
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.progressbar.Cnds = {
        OnClicked() {
            return !0
        },
        CompareProgress(t, n) {
            return e.compare(this._value, t, n)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.progressbar.Acts = {
        SetTooltip(e) {
            if (this._title === e) return;
            this._title = e, this.UpdateElementState()
        },
        SetProgress(e) {
            if (this._value === e) return;
            this._value = e, this.UpdateElementState()
        },
        SetMaximum(e) {
            if (this._max === e) return;
            this._max = e, this.UpdateElementState()
        },
        SetIndeterminate() {
            this._max = 0, this._value = 0, this.UpdateElementState()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.progressbar.Exps = {
        Progress() {
            return this._value
        },
        Maximum() {
            return this._max
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Touch = class TouchPlugin extends e.SDKPluginBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Touch.Type = class TouchType extends e.SDKTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        GetScriptInterfaceClass() {
            return self.ITouchObjectType
        }
    };
    let t = null;

    function GetTouchSdkInstance() {
        return t.GetSingleGlobalInstance().GetSdkInstance()
    }
    self.ITouchObjectType = class ITouchObjectType extends self.IObjectClass {
        constructor(e) {
            super(e), t = e, e.GetRuntime()._GetCommonScriptInterfaces().touch = this
        }
        requestPermission(e) {
            const t = GetTouchSdkInstance();
            if (e === "orientation") return t._RequestPermission(0);
            if (e === "motion") return t._RequestPermission(1);
            throw new Error("invalid type")
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = "touch";
    e.Plugins.Touch.Instance = class TouchInstance extends e.SDKInstanceBase {
        constructor(n, s) {
            super(n, t), this._touches = new Map, this._useMouseInput = !1, this._isMouseDown = !1, this._orientCompassHeading = 0, this._orientAlpha = 0, this._orientBeta = 0, this._orientGamma = 0, this._accX = 0, this._accY = 0, this._accZ = 0, this._accWithGX = 0, this._accWithGY = 0, this._accWithGZ = 0, this._triggerIndex = 0, this._triggerId = 0, this._triggerPermission = 0, this._curTouchX = 0, this._curTouchY = 0, this._getTouchIndex = 0, this._permissionPromises = [], s && (this._useMouseInput = s[0]), this.AddDOMMessageHandler("permission-result", e => this._OnPermissionResult(e));
            const o = this.GetRuntime().Dispatcher();
            this._disposables = new e.CompositeDisposable(e.Disposable.From(o, "pointerdown", e => this._OnPointerDown(e.data)), e.Disposable.From(o, "pointermove", e => this._OnPointerMove(e.data)), e.Disposable.From(o, "pointerup", e => this._OnPointerUp(e.data, !1)), e.Disposable.From(o, "pointercancel", e => this._OnPointerUp(e.data, !0)), e.Disposable.From(o, "deviceorientation", e => this._OnDeviceOrientation(e.data)), e.Disposable.From(o, "deviceorientationabsolute", e => this._OnDeviceOrientationAbsolute(e.data)), e.Disposable.From(o, "devicemotion", e => this._OnDeviceMotion(e.data)), e.Disposable.From(o, "tick2", e => this._OnTick2()))
        }
        Release() {
            this._touches.clear(), super.Release()
        }
        _OnPointerDown(t) {
            if (t.pointerType === "mouse")
                if (this._useMouseInput) this._isMouseDown = !0;
                else return;
            const n = t.pointerId;
            if (this._touches.has(n)) return;
            const s = t.pageX - this._runtime.GetCanvasClientX(),
                o = t.pageY - this._runtime.GetCanvasClientY(),
                r = t.timeStamp,
                i = this._touches.size;
            this._triggerIndex = i, this._triggerId = n;
            const a = e.New(e.Plugins.Touch.TouchInfo);
            a.Init(r, s, o, n, i), this._touches.set(n, a), this.Trigger(e.Plugins.Touch.Cnds.OnNthTouchStart), this.Trigger(e.Plugins.Touch.Cnds.OnTouchStart), this._curTouchX = s, this._curTouchY = o, this.Trigger(e.Plugins.Touch.Cnds.OnTouchObject)
        }
        _OnPointerMove(e) {
            if (e.pointerType === "mouse" && !this._isMouseDown) return;
            const t = this._touches.get(e.pointerId);
            if (!t) return;
            const n = e.timeStamp;
            if (n - t.GetTime() < 2) return;
            const s = e.pageX - this._runtime.GetCanvasClientX(),
                o = e.pageY - this._runtime.GetCanvasClientY();
            t.Update(n, s, o, e.width, e.height, e.pressure)
        }
        _OnPointerUp(t, n) {
            if (t.pointerType === "mouse")
                if (this._isMouseDown) this._isMouseDown = !1;
                else return;
            const i = t.timeStamp,
                o = t.pointerId,
                s = this._touches.get(o);
            if (!s) return;
            if (this._triggerIndex = s.GetStartIndex(), this._triggerId = s.GetId(), this.Trigger(e.Plugins.Touch.Cnds.OnNthTouchEnd), this.Trigger(e.Plugins.Touch.Cnds.OnTouchEnd), !n) {
                const t = s.ShouldTriggerTap(i);
                t === "single-tap" ? (this.Trigger(e.Plugins.Touch.Cnds.OnTapGesture), this._curTouchX = s.GetX(), this._curTouchY = s.GetY(), this.Trigger(e.Plugins.Touch.Cnds.OnTapGestureObject)) : t === "double-tap" && (this.Trigger(e.Plugins.Touch.Cnds.OnDoubleTapGesture), this._curTouchX = s.GetX(), this._curTouchY = s.GetY(), this.Trigger(e.Plugins.Touch.Cnds.OnDoubleTapGestureObject))
            }
            s.Release(), this._touches.delete(o)
        }
        _RequestPermission(e) {
            return this._PostToDOMMaybeSync("request-permission", {
                type: e
            }), new Promise((t, n) => {
                this._permissionPromises.push({
                    type: e,
                    resolve: t,
                    reject: n
                })
            })
        }
        _OnPermissionResult(t) {
            const s = t.result,
                n = t.type;
            this._triggerPermission = n;
            const o = this._permissionPromises.filter(e => e.type === n);
            for (const e of o) e.resolve(s ? "granted" : "denied");
            this._permissionPromises = this._permissionPromises.filter(e => e.type !== n), s ? (this.Trigger(e.Plugins.Touch.Cnds.OnPermissionGranted), n === 0 ? this._runtime.RequestDeviceOrientationEvent() : this._runtime.RequestDeviceMotionEvent()) : this.Trigger(e.Plugins.Touch.Cnds.OnPermissionDenied)
        }
        _OnDeviceOrientation(e) {
            typeof e.webkitCompassHeading == "number" ? this._orientCompassHeading = e.webkitCompassHeading : e.absolute && (this._orientCompassHeading = e.alpha), this._orientAlpha = e.alpha, this._orientBeta = e.beta, this._orientGamma = e.gamma
        }
        _OnDeviceOrientationAbsolute(e) {
            this._orientCompassHeading = e.alpha
        }
        _OnDeviceMotion(e) {
            const t = e.acceleration;
            t && (this._accX = t.x, this._accY = t.y, this._accZ = t.z);
            const n = e.accelerationIncludingGravity;
            n && (this._accWithGX = n.x, this._accWithGY = n.y, this._accWithGZ = n.z)
        }
        _OnTick2() {
            const t = performance.now();
            let n = 0;
            for (const s of this._touches.values()) s.GetTime() <= t - 50 && s._SetLastTime(t), s.ShouldTriggerHold(t) && (this._triggerIndex = s.GetStartIndex(), this._triggerId = s.GetId(), this._getTouchIndex = n, this.Trigger(e.Plugins.Touch.Cnds.OnHoldGesture), this._curTouchX = s.GetX(), this._curTouchY = s.GetY(), this.Trigger(e.Plugins.Touch.Cnds.OnHoldGestureObject), this._getTouchIndex = 0), ++n
        }
        _GetTouchByIndex(e) {
            e = Math.floor(e);
            for (const t of this._touches.values()) {
                if (e === 0) return t;
                --e
            }
            return null
        }
        _IsClientPosOnCanvas(e, t) {
            return e >= 0 && t >= 0 && e < this._runtime.GetCanvasCssWidth() && t < this._runtime.GetCanvasCssHeight()
        }
        GetDebuggerProperties() {
            const e = "plugins.touch.debugger";
            return [{
                title: e + ".touches",
                properties: [...this._touches.values()].map(e => ({
                    name: "$" + e.GetId(),
                    value: e.GetX() + ", " + e.GetY()
                }))
            }]
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = [];
    e.Plugins.Touch.Cnds = {
        OnTouchStart() {
            return !0
        },
        OnTouchEnd() {
            return !0
        },
        IsInTouch() {
            return this._touches.size > 0
        },
        OnTouchObject(e) {
            return !!e && !!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(e, this._curTouchX, this._curTouchY, !1)
        },
        IsTouchingObject(n) {
            if (!n) return !1;
            const s = n.GetCurrentSol(),
                o = s.GetInstances();
            for (const n of o) {
                const e = n.GetWorldInfo(),
                    s = e.GetLayer();
                for (const o of this._touches.values()) {
                    if (!this._IsClientPosOnCanvas(o.GetX(), o.GetY())) continue;
                    const [i, a] = s.CanvasCssToLayer(o.GetX(), o.GetY(), e.GetTotalZElevation());
                    if (e.ContainsPoint(i, a)) {
                        t.push(n);
                        break
                    }
                }
            }
            return !!t.length && (s.SetArrayPicked(t), n.ApplySolToContainer(), e.clearArray(t), !0)
        },
        CompareTouchSpeed(t, n, s) {
            const o = this._GetTouchByIndex(t);
            return !!o && e.compare(o.GetSpeed(), n, s)
        },
        OrientationSupported() {
            return !0
        },
        MotionSupported() {
            return !0
        },
        CompareOrientation(t, n, s) {
            this._runtime.RequestDeviceOrientationEvent();
            let o = 0;
            return t === 0 ? o = this._orientAlpha : t === 1 ? o = this._orientBeta : o = this._orientGamma, e.compare(o, n, s)
        },
        CompareAcceleration(t, n, s) {
            this._runtime.RequestDeviceMotionEvent();
            let o = 0;
            return t === 0 ? o = this._accWithGX : t === 1 ? o = this._accWithGY : t === 2 ? o = this._accWithGZ : t === 3 ? o = this._accX : t === 4 ? o = this._accY : o = this._accZ, e.compare(o, n, s)
        },
        OnNthTouchStart(e) {
            return e = Math.floor(e), e === this._triggerIndex
        },
        OnNthTouchEnd(e) {
            return e = Math.floor(e), e === this._triggerIndex
        },
        HasNthTouch(e) {
            return e = Math.floor(e), this._touches.size >= e + 1
        },
        OnHoldGesture() {
            return !0
        },
        OnTapGesture() {
            return !0
        },
        OnDoubleTapGesture() {
            return !0
        },
        OnHoldGestureObject(e) {
            return !!e && !!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(e, this._curTouchX, this._curTouchY, !1)
        },
        OnTapGestureObject(e) {
            return !!e && !!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(e, this._curTouchX, this._curTouchY, !1)
        },
        OnDoubleTapGestureObject(e) {
            return !!e && !!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(e, this._curTouchX, this._curTouchY, !1)
        },
        OnPermissionGranted(e) {
            return this._triggerPermission === e
        },
        OnPermissionDenied(e) {
            return this._triggerPermission === e
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Touch.Acts = {
        RequestPermission(e) {
            this._RequestPermission(e)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Touch.Exps = {
        TouchCount() {
            return this._touches.size
        },
        X(e) {
            const t = this._GetTouchByIndex(this._getTouchIndex);
            return t ? t.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, !0) : 0
        },
        Y(e) {
            const t = this._GetTouchByIndex(this._getTouchIndex);
            return t ? t.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, !1) : 0
        },
        XAt(e, t) {
            const n = this._GetTouchByIndex(e);
            return n ? n.GetPositionForLayer(this._runtime.GetCurrentLayout(), t, !0) : 0
        },
        YAt(e, t) {
            const n = this._GetTouchByIndex(e);
            return n ? n.GetPositionForLayer(this._runtime.GetCurrentLayout(), t, !1) : 0
        },
        XForID(e, t) {
            const n = this._touches.get(e);
            return n ? n.GetPositionForLayer(this._runtime.GetCurrentLayout(), t, !0) : 0
        },
        YForID(e, t) {
            const n = this._touches.get(e);
            return n ? n.GetPositionForLayer(this._runtime.GetCurrentLayout(), t, !1) : 0
        },
        AbsoluteX() {
            const e = this._GetTouchByIndex(0);
            return e ? e.GetX() : 0
        },
        AbsoluteY() {
            const e = this._GetTouchByIndex(0);
            return e ? e.GetY() : 0
        },
        AbsoluteXAt(e) {
            const t = this._GetTouchByIndex(e);
            return t ? t.GetX() : 0
        },
        AbsoluteYAt(e) {
            const t = this._GetTouchByIndex(e);
            return t ? t.GetY() : 0
        },
        AbsoluteXForID(e) {
            const t = this._touches.get(e);
            return t ? t.GetX() : 0
        },
        AbsoluteYForID(e) {
            const t = this._touches.get(e);
            return t ? t.GetY() : 0
        },
        SpeedAt(e) {
            const t = this._GetTouchByIndex(e);
            return t ? t.GetSpeed() : 0
        },
        SpeedForID(e) {
            const t = this._touches.get(e);
            return t ? t.GetSpeed() : 0
        },
        AngleAt(t) {
            const n = this._GetTouchByIndex(t);
            return n ? e.toDegrees(n.GetAngle()) : 0
        },
        AngleForID(t) {
            const n = this._touches.get(t);
            return n ? e.toDegrees(n.GetAngle()) : 0
        },
        CompassHeading() {
            return this._runtime.RequestDeviceOrientationEvent(), this._orientCompassHeading
        },
        Alpha() {
            return this._runtime.RequestDeviceOrientationEvent(), this._orientAlpha
        },
        Beta() {
            return this._runtime.RequestDeviceOrientationEvent(), this._orientBeta
        },
        Gamma() {
            return this._runtime.RequestDeviceOrientationEvent(), this._orientGamma
        },
        AccelerationXWithG() {
            return this._runtime.RequestDeviceMotionEvent(), this._accWithGX
        },
        AccelerationYWithG() {
            return this._runtime.RequestDeviceMotionEvent(), this._accWithGY
        },
        AccelerationZWithG() {
            return this._runtime.RequestDeviceMotionEvent(), this._accWithGZ
        },
        AccelerationX() {
            return this._runtime.RequestDeviceMotionEvent(), this._accX
        },
        AccelerationY() {
            return this._runtime.RequestDeviceMotionEvent(), this._accY
        },
        AccelerationZ() {
            return this._runtime.RequestDeviceMotionEvent(), this._accZ
        },
        TouchIndex() {
            return this._triggerIndex
        },
        TouchID() {
            return this._triggerId
        },
        WidthForID(e) {
            const t = this._touches.get(e);
            return t ? t.GetWidth() : 0
        },
        HeightForID(e) {
            const t = this._touches.get(e);
            return t ? t.GetHeight() : 0
        },
        PressureForID(e) {
            const t = this._touches.get(e);
            return t ? t.GetPressure() : 0
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = 15,
        a = 500,
        i = 333,
        r = 25;
    let n = -1e3,
        s = -1e3,
        o = -1e4;
    e.Plugins.Touch.TouchInfo = class TouchInfo extends e.DefendedBase {
        constructor() {
            super(), this._pointerId = 0, this._startIndex = 0, this._startTime = 0, this._time = 0, this._lastTime = 0, this._startX = 0, this._startY = 0, this._x = 0, this._y = 0, this._lastX = 0, this._lastY = 0, this._width = 0, this._height = 0, this._pressure = 0, this._hasTriggeredHold = !1, this._isTooFarForHold = !1
        }
        Release() {}
        Init(e, t, n, s, o) {
            this._pointerId = s, this._startIndex = o, this._time = e, this._lastTime = e, this._startTime = e, this._startX = t, this._startY = n, this._x = t, this._y = n, this._lastX = t, this._lastY = n
        }
        Update(n, s, o, i, a, r) {
            this._lastTime = this._time, this._time = n, this._lastX = this._x, this._lastY = this._y, this._x = s, this._y = o, this._width = i, this._height = a, this._pressure = r, !this._isTooFarForHold && e.distanceTo(this._startX, this._startY, this._x, this._y) >= t && (this._isTooFarForHold = !0)
        }
        GetId() {
            return this._pointerId
        }
        GetStartIndex() {
            return this._startIndex
        }
        GetTime() {
            return this._time
        }
        _SetLastTime(e) {
            this._lastTime = e
        }
        GetX() {
            return this._x
        }
        GetY() {
            return this._y
        }
        GetSpeed() {
            const n = e.distanceTo(this._x, this._y, this._lastX, this._lastY),
                t = (this._time - this._lastTime) / 1e3;
            return t > 0 ? n / t : 0
        }
        GetAngle() {
            return e.angleTo(this._lastX, this._lastY, this._x, this._y)
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        GetPressure() {
            return this._pressure
        }
        ShouldTriggerHold(n) {
            return !this._hasTriggeredHold && n - this._startTime >= a && !this._isTooFarForHold && e.distanceTo(this._startX, this._startY, this._x, this._y) < t && (this._hasTriggeredHold = !0, !0)
        }
        ShouldTriggerTap(a) {
            return this._hasTriggeredHold ? "" : a - this._startTime <= i && !this._isTooFarForHold && e.distanceTo(this._startX, this._startY, this._x, this._y) < t ? a - o <= i * 2 && e.distanceTo(n, s, this._x, this._y) < r ? (n = -1e3, s = -1e3, o = -1e4, "double-tap") : (n = this._x, s = this._y, o = a, "single-tap") : ""
        }
        GetPositionForLayer(e, t, n) {
            if (typeof t == "undefined") {
                const t = e.GetLayerByIndex(0);
                return t.CanvasCssToLayer_DefaultTransform(this._x, this._y)[n ? 0 : 1]
            }
            const s = e.GetLayer(t);
            return s ? s.CanvasCssToLayer(this._x, this._y)[n ? 0 : 1] : 0
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.PlatformInfo = class PlatformInfoPlugin extends e.SDKPluginBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.PlatformInfo.Type = class PlatformInfoType extends e.SDKTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
}
"use strict";
{
    const e = self.C3,
        t = "platform-info";
    e.Plugins.PlatformInfo.Instance = class PlatformInfoInstance extends e.SDKInstanceBase {
        constructor(e) {
            super(e, t), this._screenWidth = 0, this._screenHeight = 0, this._windowOuterWidth = 0, this._windowOuterHeight = 0, this._safeAreaInset = [0, 0, 0, 0], this._supportsWakeLock = !1, this._isWakeLockActive = !1, this.AddDOMMessageHandlers([
                ["window-resize", e => this._OnWindowResize(e)],
                ["wake-lock-acquired", e => this._OnWakeLockAcquired(e)],
                ["wake-lock-error", e => this._OnWakeLockError(e)],
                ["wake-lock-released", e => this._OnWakeLockReleased(e)]
            ]), navigator.connection && navigator.connection.addEventListener("change", () => this._OnNetworkChange()), this._runtime.AddLoadPromise(this.PostToDOMAsync("get-initial-state").then(e => {
                this._screenWidth = e.screenWidth, this._screenHeight = e.screenHeight, this._windowOuterWidth = e.windowOuterWidth, this._windowOuterHeight = e.windowOuterHeight, this._safeAreaInset = e.safeAreaInset, this._supportsWakeLock = e.supportsWakeLock
            }))
        }
        Release() {
            super.Release()
        }
        _OnWindowResize(e) {
            this._windowOuterWidth = e.windowOuterWidth, this._windowOuterHeight = e.windowOuterHeight, this._safeAreaInset = e.safeAreaInset
        }
        async _OnNetworkChange() {
            await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnNetworkChange)
        }
        async _OnWakeLockAcquired() {
            this._isWakeLockActive = !0, await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnWakeLockAcquired)
        }
        async _OnWakeLockError() {
            this._isWakeLockActive = !1, await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnWakeLockError)
        }
        async _OnWakeLockReleased() {
            this._isWakeLockActive = !1, await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnWakeLockReleased)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.PlatformInfo.Cnds = {
        IsOnMobile() {
            return e.Platform.IsMobile
        },
        IsOnWindows() {
            return e.Platform.OS === "Windows"
        },
        IsOnMacOS() {
            return e.Platform.OS === "Mac OS X"
        },
        IsOnLinux() {
            return e.Platform.OS === "Linux"
        },
        IsOnChromeOS() {
            return e.Platform.OS === "Chrome OS"
        },
        IsOnAndroid() {
            return e.Platform.OS === "Android"
        },
        IsOniOS() {
            return e.Platform.OS === "iOS"
        },
        IsWebExport() {
            const e = this._runtime.GetExportType();
            return e === "html5" || e === "scirra-arcade" || e === "preview" || e === "instant-games"
        },
        IsCordovaExport() {
            return this._runtime.IsCordova()
        },
        IsNWjsExport() {
            return this._runtime.GetExportType() === "nwjs"
        },
        IsWindowsUWPExport() {
            return this._runtime.GetExportType() === "windows-uwp"
        },
        OnNetworkChange() {
            return !0
        },
        OnWakeLockAcquired() {
            return !0
        },
        OnWakeLockError() {
            return !0
        },
        OnWakeLockReleased() {
            return !0
        },
        IsWakeLockActive() {
            return this._isWakeLockActive
        },
        IsWakeLockSupported() {
            return this._supportsWakeLock
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.PlatformInfo.Acts = {
        RequestWakeLock() {
            if (!this._supportsWakeLock) return;
            this._PostToDOMMaybeSync("request-wake-lock")
        },
        ReleaseWakeLock() {
            if (!this._supportsWakeLock) return;
            this._isWakeLockActive = !1, this.PostToDOM("release-wake-lock")
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.PlatformInfo.Exps = {
        Renderer() {
            const e = this._runtime.GetWebGLRenderer();
            let t = "webgl" + e.GetWebGLVersionNumber();
            return e.HasMajorPerformanceCaveat() && (t += "-software"), t
        },
        RendererDetail() {
            return this._runtime.GetWebGLRenderer().GetUnmaskedRenderer()
        },
        DevicePixelRatio() {
            return self.devicePixelRatio
        },
        ScreenWidth() {
            return this._screenWidth
        },
        ScreenHeight() {
            return this._screenHeight
        },
        WindowInnerWidth() {
            return this._runtime.GetCanvasManager().GetLastWidth()
        },
        WindowInnerHeight() {
            return this._runtime.GetCanvasManager().GetLastHeight()
        },
        WindowOuterWidth() {
            return this._windowOuterWidth
        },
        WindowOuterHeight() {
            return this._windowOuterHeight
        },
        CanvasCssWidth() {
            return this._runtime.GetCanvasManager().GetCssWidth()
        },
        CanvasCssHeight() {
            return this._runtime.GetCanvasManager().GetCssHeight()
        },
        CanvasDeviceWidth() {
            return this._runtime.GetCanvasManager().GetDeviceWidth()
        },
        CanvasDeviceHeight() {
            return this._runtime.GetCanvasManager().GetDeviceHeight()
        },
        Downlink() {
            return navigator.connection ? navigator.connection.downlink || 0 : 0
        },
        DownlinkMax() {
            return navigator.connection ? navigator.connection.downlinkMax || 0 : 0
        },
        ConnectionType() {
            return navigator.connection ? navigator.connection.type || "unknown" : "unknown"
        },
        ConnectionEffectiveType() {
            return navigator.connection ? navigator.connection.effectiveType || "unknown" : "unknown"
        },
        ConnectionRTT() {
            return navigator.connection ? navigator.connection.rtt || 0 : 0
        },
        HardwareConcurrency() {
            return navigator.hardwareConcurrency || 0
        },
        DeviceMemory() {
            return navigator.deviceMemory || 0
        },
        SafeAreaInsetTop() {
            return this._safeAreaInset[0]
        },
        SafeAreaInsetRight() {
            return this._safeAreaInset[1]
        },
        SafeAreaInsetBottom() {
            return this._safeAreaInset[2]
        },
        SafeAreaInsetLeft() {
            return this._safeAreaInset[3]
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.shadowlight = class ShadowLightPlugin extends e.SDKPluginBase {
        constructor(e) {
            super(e), this._penumbraAsset = this._runtime.LoadImage({
                url: "https://cdn.jsdelivr.net/gh/mamayaya1/game@f3a882424a8f28d07bdf456b251d889725c4c1e4/projects/among-us/penumbra.png"
            }), this._penumbraDrawable = null, this._runtime.AddLoadPromise(this._penumbraAsset.LoadToDrawable().then(e => this._penumbraDrawable = e))
        }
        Release() {
            super.Release()
        }
        GetPenumbraDrawable() {
            return this._penumbraDrawable
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.shadowlight.Type = class ShadowLightType extends e.SDKTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        LoadTextures() {}
        ReleaseTextures() {}
    }
}
"use strict";
{
    const e = self.C3,
        c = 0,
        r = 1,
        s = 2,
        i = 3,
        a = 4,
        l = 0,
        d = 1,
        u = 2,
        n = [0, 0, 0],
        h = ["all", "same-tag", "different-tag"],
        o = e.New(e.Color),
        t = e.New(e.CollisionPoly),
        m = [],
        f = e.New(e.Rect);
    e.Plugins.shadowlight.Instance = class ShadowLightInstance extends e.SDKWorldInstanceBase {
        constructor(t, n) {
            super(t);
            const o = this.GetWorldInfo();
            if (this._lightX = o.GetX(), this._lightY = o.GetY(), this._lightZ = 0, this._maxExtrude = 1e3, this._lightRadius = 0, this._color = e.New(e.Color), this._castFrom = 0, this._tag = "", this._lastKnownX = o.GetX(), this._lastKnownY = o.GetY(), this._penumbraTexture = null, n) {
                this._lightZ = n[c], this._lightRadius = this._lightZ === 0 ? n[r] : 0;
                const e = n[s];
                this._color.setRgb(e[0], e[1], e[2]), this._castFrom = n[i], this._tag = n[a]
            }
            this._shadowRenderer = e.New(self.ShadowRenderer), this.HandleWebGLContextLoss(), this._StartTicking2()
        }
        Release() {
            this._ReleasePenumbraTexture(), this._shadowRenderer && (this._shadowRenderer.Release(), this._shadowRenderer = null), this._color = null, super.Release()
        }
        SaveToJson() {
            return {
                lh: this._lightZ,
                lr: this._lightRadius,
                sc: this._color.toJSON(),
                cf: this._castFrom,
                t: this._tag
            }
        }
        LoadFromJson(e) {
            this._lightZ = e.lh, this._lightRadius = e.lr, this._color.setFromJSON(e.sc), this._castFrom = e.cf, this._tag = e.t
        }
        _ReleasePenumbraTexture() {
            if (!this._penumbraTexture) return;
            this._runtime.GetWebGLRenderer().DeleteTexture(this._penumbraTexture), this._penumbraTexture = null
        }
        OnWebGLContextLost() {
            this._penumbraTexture = null
        }
        OnWebGLContextRestored() {}
        _CastsFrom(t) {
            switch (this._castFrom) {
                case l:
                    return !0;
                case d:
                    return e.equalsNoCase(this._tag, t);
                case u:
                    return !e.equalsNoCase(this._tag, t)
            }
        }
        Tick2() {
            const t = this.GetWorldInfo();
            (this._lastKnownX !== t.GetX() || this._lastKnownY !== t.GetY()) && (this._lightX = t.GetX(), this._lightY = t.GetY());
            const n = f;
            t.GetLayer().GetViewportForZ(t.GetTotalZElevation(), n);
            const s = n.midX(),
                o = n.midY(),
                i = n.width() + this._maxExtrude,
                a = n.height() + this._maxExtrude;
            (s !== t.GetX() || o !== t.GetY() || i !== t.GetWidth() || a !== t.GetHeight()) && (t.SetXY(s, o), t.SetSize(i, a), t.SetBboxChanged()), this._lastKnownX = t.GetX(), this._lastKnownY = t.GetY(), this._maxExtrude = e.distanceTo(n.getLeft(), n.getTop(), n.getRight(), n.getBottom()) * 15
        }
        _GetShadowCasterCandidates() {
            const t = this._runtime.GetPluginManager().GetBehaviorByConstructorFunction(e.Behaviors.shadowcaster);
            if (!t) return [];
            const n = this.GetWorldInfo(),
                o = n.GetLayer(),
                i = n.GetBoundingBox(),
                a = t.GetObjectClasses(),
                s = [],
                r = this._runtime.GetCollisionEngine();
            return r.GetObjectClassesCollisionCandidates(o, a, i, s), [...new Set(s)]
        }
        _UpdateShadowRendererParameters() {
            this._shadowRenderer.SetLightX(this._lightX), this._shadowRenderer.SetLightY(this._lightY), this._shadowRenderer.SetLightZ(this._lightZ), this._shadowRenderer.SetLightRadius(this._lightRadius), this._shadowRenderer.SetCastFrom(h[this._castFrom]), this._shadowRenderer.SetTag(this._tag), this._shadowRenderer.SetMaxExtrude(this._maxExtrude)
        }
        _MaybeCreatePenumbraTexture(t) {
            if (this._penumbraTexture) return;
            const s = this.GetPlugin().GetPenumbraDrawable(),
                o = s.width,
                i = s.height,
                r = e.CreateCanvas(o, i),
                a = r.getContext("2d");
            a.drawImage(s, 0, 0, o, i);
            const c = a.getImageData(0, 0, o, i),
                n = c.data,
                l = Math.floor(this._color.getR() * 255),
                d = Math.floor(this._color.getG() * 255),
                u = Math.floor(this._color.getB() * 255);
            for (let e = 0, t = n.length; e < t; e += 4) n[e] = l, n[e + 1] = d, n[e + 2] = u;
            a.putImageData(c, 0, 0), this._penumbraTexture = t.CreateStaticTexture(r, {
                sampling: this._runtime.GetSampling()
            })
        }
        Draw(e) {
            this._UpdateShadowRendererParameters(), this._MaybeCreatePenumbraTexture(e), this._shadowRenderer.SetPenumbraTexture(this._penumbraTexture);
            const t = this.GetWorldInfo();
            o.copyRgb(this._color), o.setA(t.GetOpacity()), o.premultiply(), e.SetColor(o), e.SetColorFillMode();
            for (const t of this._GetShadowCasterCandidates()) this._DrawInstanceShadow(e, t)
        }
        _DrawInstanceShadow(e, n) {
            const s = n.GetSavedDataMap();
            if (!s.get("shadowcasterEnabled") || !this._CastsFrom(s.get("shadowcasterTag"))) return;
            const o = s.get("shadowcasterHeight");
            if (n.HasTilemap()) this._DrawTilemapShadow(e, n, o);
            else {
                const s = n.GetWorldInfo(),
                    i = s.GetTransformedCollisionPoly();
                t.copy(i), t.offset(s.GetX(), s.GetY()), this._shadowRenderer.RenderShadow(e, t, o)
            }
        }
        _DrawTilemapShadow(n, s, o) {
            const i = m,
                l = this.GetWorldInfo().GetBoundingBox();
            s.GetSdkInstance().GetCollisionRectCandidates(l, i);
            const a = s.GetWorldInfo(),
                r = a.GetX(),
                c = a.GetY();
            for (let e = 0, d = i.length; e < d; ++e) {
                const a = i[e],
                    s = a.GetRect(),
                    l = a.GetPoly();
                l ? (t.copy(l), t.offset(r + s.getLeft(), c + s.getTop())) : t.setFromRect(s, -r, -c), this._shadowRenderer.RenderShadow(n, t, o)
            }
            e.clearArray(i)
        }
        GetPropertyValueByIndex(e) {
            switch (e) {
                case c:
                    return this._lightZ;
                case r:
                    return this._lightRadius;
                case s:
                    return n[0] = this._color.getR(), n[1] = this._color.getG(), n[2] = this._color.getB(), n.slice(0);
                case i:
                    return this._castFrom;
                case a:
                    return this._tag
            }
        }
        SetPropertyValueByIndex(e, t) {
            switch (e) {
                case c:
                    this._lightZ = t;
                    break;
                case r:
                    this._lightRadius = t;
                    break;
                case s:
                    this._color.setRgb(t[0], t[1], t[2]);
                    break;
                case i:
                    this._castFrom = t;
                    break;
                case a:
                    this._tag = t;
                    break
            }
        }
        SetPropertyColorOffsetValueByIndex(e, t, n, o) {
            if (t === 0 && n === 0 && o === 0) return;
            switch (e) {
                case s:
                    this._color.addRgb(t, n, o);
                    break
            }
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.shadowlight.Cnds = {}
}
"use strict";
{
    const t = self.C3,
        e = t.New(t.Color);
    t.Plugins.shadowlight.Acts = {
        SetLightHeight(e) {
            if (this._lightZ === e) return;
            this._lightZ = e, this._runtime.UpdateRender()
        },
        SetLightColor(t) {
            if (e.setFromRgbValue(t), e.clamp(), this._color.equalsIgnoringAlpha(e)) return;
            this._color.copyRgb(e), this._ReleasePenumbraTexture(), this._runtime.UpdateRender()
        },
        SetTag(e) {
            if (this._tag === e) return;
            this._tag = e, this._runtime.UpdateRender()
        },
        SetCastFrom(e) {
            if (this._castFrom === e) return;
            this._castFrom = e, this._runtime.UpdateRender()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.shadowlight.Exps = {
        LightX() {
            return this._lightX
        },
        LightY() {
            return this._lightY
        },
        Tag() {
            return this._tag
        }
    }
}
"use strict";
{
    const e = self.C3;

    function IsBackFace(t, n, s, o, i, a) {
        let r = e.angleTo(s, o, i, a) - Math.PI / 2,
            c = e.angleTo(s, o, t, n);
        return e.angleDiff(c, r) >= Math.PI / 2
    }
    let t = 0,
        n = 0;

    function SegmentIntersectionAt(e, s, o, i, a, r, c, l) {
        let u = o - e,
            h = i - s,
            f = c - a,
            p = l - r,
            d = -f * h + u * p;
        if (d === 0) return !1;
        let g = (-h * (e - a) + u * (s - r)) / d;
        if (d = -f * h + u * p, d === 0) return !1;
        let m = (f * (s - r) - p * (e - a)) / d;
        return g >= 0 && g <= 1 && m >= 0 && m <= 1 && (t = e + m * u, n = s + m * h, !0)
    }
    let s = new e.Quad,
        o = new e.Quad;
    const i = new Set(["all", "same-tag", "different-tag"]);
    self.ShadowRenderer = class ShadowRenderer {
        constructor() {
            this._lightX = 0, this._lightY = 0, this._lightZ = 0, this._lightRadius = 0, this._castFrom = "all", this._tag = "", this._maxExtrude = 1e3, this._backFaces1 = [], this._backFaces2 = [], this._umbraPts = [], this._cwEdge1 = -1, this._cwEdge2 = -1, this._acwEdge1 = -1, this._acwEdge2 = -1, this._acwUmbraRootX = 0, this._acwUmbraRootY = 0, this._cwUmbraRootX = 0, this._cwUmbraRootY = 0, this._acwUmbraProjX = 0, this._acwUmbraProjY = 0, this._cwUmbraProjX = 0, this._cwUmbraProjY = 0, this._polyMidX = 0, this._polyMidY = 0, this._penumbraTexture = null
        }
        Release() {
            this.Reset(), this._backFaces1 = null, this._backFaces2 = null, this._umbraPts = null, this._penumbraTexture = null
        }
        Reset() {
            e.clearArray(this._backFaces1), e.clearArray(this._backFaces2), e.clearArray(this._umbraPts), this._cwEdge1 = -1, this._cwEdge2 = -1, this._acwEdge1 = -1, this._acwEdge2 = -1, this._acwUmbraRootX = 0, this._acwUmbraRootY = 0, this._cwUmbraRootX = 0, this._cwUmbraRootY = 0, this._acwUmbraProjX = 0, this._acwUmbraProjY = 0, this._cwUmbraProjX = 0, this._cwUmbraProjY = 0, this._polyMidX = 0, this._polyMidY = 0
        }
        SetLightX(e) {
            this._lightX = e
        }
        GetLightX() {
            return this._lightX
        }
        SetLightY(e) {
            this._lightY = e
        }
        GetLightY() {
            return this._lightY
        }
        SetLightZ(e) {
            this._lightZ = e
        }
        GetLightZ() {
            return this._lightZ
        }
        SetLightRadius(e) {
            e < 0 && (e = 0), this._lightRadius = e
        }
        GetLightRadius() {
            return this._lightRadius
        }
        SetCastFrom(e) {
            if (!i.has(e)) throw new Error("invalid cast-from");
            this._castFrom = e
        }
        GetCastFrom() {
            return this._castFrom
        }
        SetTag(e) {
            this._tag = e
        }
        GetTag() {
            return this._tag
        }
        SetMaxExtrude(e) {
            this._maxExtrude = e
        }
        GetMaxExtrude() {
            return this._maxExtrude
        }
        SetPenumbraTexture(e) {
            this._penumbraTexture = e
        }
        RenderShadow(e, t, n) {
            this.Reset(), this.CalculateShadow(t, n), e.SetColorFillMode(), this._umbraPts.length >= 6 && e.ConvexPoly(this._umbraPts), this._lightRadius > 0 && this._penumbraTexture && (this._cwEdge1 > -1 && this._cwEdge2 > -1 && (e.SetTextureFillMode(), e.SetTexture(this._penumbraTexture), this.FillPenumbra(e, t, !0)), this._acwEdge1 > -1 && this._acwEdge2 > -1 && (e.SetTextureFillMode(), e.SetTexture(this._penumbraTexture), this.FillPenumbra(e, t, !1)))
        }
        CalculateShadow(e, t) {
            this._polyMidX = e.GetMidX(), this._polyMidY = e.GetMidY(), this._lightRadius > 0 ? this._CalculateShadowWithRadius(e, t) : this._CalculateShadowWithoutRadius(e, t)
        }
        _CalculateShadowWithRadius(t, n) {
            if (this._CalcBackFaces(t, -this._lightRadius), this._FindEdges(), e.shallowAssignArray(this._backFaces2, this._backFaces1), this._cwEdge2 = this._cwEdge1, this._acwEdge2 = this._acwEdge1, e.clearArray(this._backFaces1), this._cwEdge1 = -1, this._acwEdge1 = -1, this._CalcBackFaces(t, this._lightRadius), this._FindEdges(), this._cwEdge1 === -1 || this._acwEdge1 === -1 || this._cwEdge2 === -1 || this._acwEdge2 === -1) return;
            this._CalcUmbraWithRadius(t, n)
        }
        _CalculateShadowWithoutRadius(e, t) {
            this._CalcBackFaces(e, 0), this._FindEdges();
            let n = e.GetPointsArray();
            for (let e = 0, s = n.length; e < s; e += 2) {
                let o = n[e],
                    i = n[e + 1];
                this._CalcShadowSegment(e / 2, this._lightX, this._lightY, o, i, t)
            }
        }
        _CalcBackFaces(t, n) {
            let o = this._lightX,
                i = this._lightY,
                r = o,
                c = i,
                a = 0;
            n !== 0 && (a = e.angleTo(o, i, this._polyMidX, this._polyMidY) - Math.PI / 2);
            let s = t.GetPointsArray();
            for (let e = 0, l = s.length; e < l; e += 2) {
                let t = e + 2;
                t === l && (t = 0);
                let d = s[e],
                    u = s[e + 1],
                    h = s[t],
                    m = s[t + 1];
                n !== 0 && (r = o + Math.cos(a) * n, c = i + Math.sin(a) * n), this._backFaces1.push(IsBackFace(r, c, d, u, h, m))
            }
        }
        _GetBackFaceAt(e) {
            return e %= this._backFaces1.length, e < 0 && (e += this._backFaces1.length), this._backFaces1[e]
        }
        _FindEdges() {
            for (let e = 0, s = this._backFaces1.length; e < s; ++e) {
                let t = this._backFaces1[e],
                    n = this._GetBackFaceAt(e - 1);
                n && !t && (this._cwEdge1 = e), !n && t && (this._acwEdge1 = e)
            }
        }
        _CalcShadowSegment(t, n, s, o, i, a) {
            let l = this._backFaces1[t],
                d = this._GetBackFaceAt(t - 1),
                u = t === this._cwEdge1,
                h = t === this._acwEdge1,
                r = 0,
                c = 0;
            if (l || d) {
                let t = e.angleTo(n, s, o, i),
                    l = e.distanceTo(n, s, o, i),
                    d = this._CalculateExtrusion(n, s, o, i, a);
                r = n + Math.cos(t) * (l + d), c = s + Math.sin(t) * (l + d)
            } else r = o, c = i;
            h && (this._umbraPts.push(o), this._umbraPts.push(i)), this._umbraPts.push(r), this._umbraPts.push(c), u && (this._umbraPts.push(o), this._umbraPts.push(i))
        }
        _CalculateExtrusion(t, n, s, o, i) {
            if (i >= this._lightZ) return this._maxExtrude;
            if (i <= 0) return 0;
            let a = e.distanceTo(t, n, s, o),
                r = i * (a / (this._lightZ - i));
            return e.clamp(r, 0, this._maxExtrude)
        }
        _CalcUmbraWithRadius(s) {
            let i = this._cwEdge2,
                y = 0,
                j = 0,
                E = s.GetPointCount(),
                u = s.GetPointsArray();
            for (;; ++i) {
                i === E && (i = 0);
                let e = i * 2;
                if (y = u[e], j = u[e + 1], this._umbraPts.push(y), this._umbraPts.push(j), i === this._acwEdge1) break
            }
            let h = this._lightRadius,
                m = y,
                f = j,
                r = e.angleTo(this._lightX, this._lightY, this._polyMidX, this._polyMidY),
                g = this._lightX + Math.cos(r - Math.PI / 2) * h,
                p = this._lightY + Math.sin(r - Math.PI / 2) * h,
                c = e.angleTo(g, p, m, f),
                a = e.distanceTo(g, p, m, f),
                v = g + Math.cos(c) * (a + this._maxExtrude),
                b = p + Math.sin(c) * (a + this._maxExtrude),
                C = this._cwEdge2 * 2,
                d = u[C],
                l = u[C + 1];
            r = e.angleTo(this._lightX, this._lightY, this._polyMidX, this._polyMidY);
            let _ = this._lightX + Math.cos(r + Math.PI / 2) * h,
                w = this._lightY + Math.sin(r + Math.PI / 2) * h;
            c = e.angleTo(_, w, d, l), a = e.distanceTo(_, w, d, l);
            let O = _ + Math.cos(c) * (a + this._maxExtrude),
                x = w + Math.sin(c) * (a + this._maxExtrude);
            this._acwUmbraRootX = m, this._acwUmbraRootY = f, this._cwUmbraRootX = d, this._cwUmbraRootY = l, SegmentIntersectionAt(m, f, v, b, d, l, O, x) ? (this._umbraPts.push(t), this._umbraPts.push(n), this._acwUmbraProjX = t, this._acwUmbraProjY = n, this._cwUmbraProjX = t, this._cwUmbraProjY = n) : (this._umbraPts.push(v), this._umbraPts.push(b), this._umbraPts.push(O), this._umbraPts.push(x), this._acwUmbraProjX = v, this._acwUmbraProjY = b, this._cwUmbraProjX = O, this._cwUmbraProjY = x)
        }
        FillPenumbra(t, n, i) {
            let g = this._lightX,
                b = this._lightY,
                v = n.GetPointsArray(),
                a = 0,
                r = 0,
                m = 0,
                p = 0;
            i ? (a = this._cwUmbraRootX, r = this._cwUmbraRootY, m = this._cwUmbraProjX, p = this._cwUmbraProjY) : (a = this._acwUmbraRootX, r = this._acwUmbraRootY, m = this._acwUmbraProjX, p = this._acwUmbraProjY);
            let O = this._lightRadius,
                c = e.angleTo(g, b, this._polyMidX, this._polyMidY),
                f = Math.PI / 2;
            i && (f = -f), g += Math.cos(c + f) * O, b += Math.sin(c + f) * O;
            let u = !1,
                d = 0,
                l = 0;
            i ? (u = this._cwEdge1 !== this._cwEdge2, u && (d = v[this._cwEdge1 * 2], l = v[this._cwEdge1 * 2 + 1])) : (u = this._acwEdge1 !== this._acwEdge2, u && (d = v[this._acwEdge2 * 2], l = v[this._acwEdge2 * 2 + 1])), u ? c = e.angleTo(d, l, a, r) : c = e.angleTo(g, b, a, r);
            let j = a + Math.cos(c) * this._maxExtrude,
                y = r + Math.sin(c) * this._maxExtrude,
                _ = 0,
                w = 0,
                h = 0,
                x = 0,
                C = 1;
            if (u) {
                let t = e.angleTo(g, b, d, l);
                _ = d + Math.cos(t) * this._maxExtrude, w = l + Math.sin(t) * this._maxExtrude;
                let u = c,
                    f = e.angleTo(a, r, m, p);
                h = e.angleDiff(u, t) / e.angleDiff(f, t);
                let n = e.distanceTo(d, l, a, r),
                    s = n / (n + this._maxExtrude),
                    o = e.angleTo(0, 1, h, 0),
                    i = e.distanceTo(0, 1, h, 0);
                x += Math.cos(o) * s * i, C += Math.sin(o) * s * i
            }
            s.set(a, r, m, p, j, y, j, y), o.set(x, C, 1, 0, h, 0, h, 0), t.Quad4(s, o), u && (s.set(d, l, j, y, _, w, _, w), o.set(0, 1, h, 0, 0, 0, 0, 0), t.Quad4(s, o))
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = "button";
    e.Plugins.Button = class ButtonPlugin extends e.SDKDOMPluginBase {
        constructor(e) {
            super(e, t), this.AddElementMessageHandler("click", (e, t) => e._OnClick(t))
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Button.Type = class ButtonType extends e.SDKTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
}
"use strict";
{
    const t = self.C3,
        c = 0,
        n = 1,
        s = 2,
        l = 3,
        o = 4,
        i = 5,
        a = 6,
        r = 7,
        d = "button";
    t.Plugins.Button.Instance = class ButtonInstance extends t.SDKDOMInstanceBase {
        constructor(e, t) {
            super(e, d), this._text = "OK", this._isCheckbox = !1, this._isChecked = !1, this._title = "", this._id = "", this._isEnabled = !0, this._autoFontSize = !0, t && (this._isCheckbox = t[c] === 1, this._text = t[n], this._title = t[s], this.GetWorldInfo().SetVisible(t[l]), this._isEnabled = t[o], this._autoFontSize = t[i], this._isChecked = t[a], this._id = t[r]), this.CreateElement({
                id: this._id
            })
        }
        Release() {
            super.Release()
        }
        GetElementState() {
            return {
                text: this._text,
                isCheckbox: this._isCheckbox,
                isChecked: this._isChecked,
                title: this._title,
                isVisible: this.GetWorldInfo().IsVisible(),
                isEnabled: this._isEnabled
            }
        }
        async _OnClick(e) {
            this._isChecked = e.isChecked, this.GetScriptInterface().dispatchEvent(t.New(t.Event, "click", !0)), await this.TriggerAsync(t.Plugins.Button.Cnds.OnClicked)
        }
        _SetText(e) {
            if (this._text === e) return;
            this._text = e, this.UpdateElementState()
        }
        _GetText() {
            return this._text
        }
        _SetTooltip(e) {
            if (this._title === e) return;
            this._title = e, this.UpdateElementState()
        }
        _GetTooltip() {
            return this._title
        }
        _SetEnabled(e) {
            if (e = !!e, this._isEnabled === e) return;
            this._isEnabled = e, this.UpdateElementState()
        }
        _IsEnabled() {
            return this._isEnabled
        }
        _SetChecked(e) {
            if (!this._isCheckbox) return;
            if (e = !!e, this._isChecked === e) return;
            this._isChecked = e, this.UpdateElementState()
        }
        _IsChecked() {
            return this._isChecked
        }
        Draw() {}
        SaveToJson() {
            return {
                text: this._text,
                checked: this._isChecked,
                title: this._title,
                enabled: this._isEnabled
            }
        }
        LoadFromJson(e) {
            this._text = e.text, this._isChecked = e.checked, this._title = e.title, this._isEnabled = e.enabled, this.UpdateElementState()
        }
        GetPropertyValueByIndex(e) {
            switch (e) {
                case n:
                    return this._text;
                case s:
                    return this._title;
                case o:
                    return this._isEnabled;
                case i:
                    return this._autoFontSize;
                case a:
                    return this._isChecked;
                case r:
                    return this._id
            }
        }
        SetPropertyValueByIndex(e, t) {
            switch (e) {
                case n:
                    if (this._text === t) return;
                    this._text = t, this.UpdateElementState();
                    break;
                case s:
                    if (this._title === t) return;
                    this._title = t, this.UpdateElementState();
                    break;
                case o:
                    if (this._isEnabled === !!t) return;
                    this._isEnabled = !!t, this.UpdateElementState();
                    break;
                case i:
                    this._autoFontSize = !!t;
                    break;
                case a:
                    if (this._isChecked === !!t) return;
                    this._isChecked = !!t, this.UpdateElementState();
                    break;
                case r:
                    if (this._id === !!t) return;
                    this._id = t, this.UpdateElementState();
                    break
            }
        }
        GetDebuggerProperties() {
            const n = t.Plugins.Button.Acts,
                e = "plugins.button";
            return [{
                title: e + ".name",
                properties: [{
                    name: e + ".properties.text.name",
                    value: this._text,
                    onedit: e => this.CallAction(n.SetText, e)
                }, {
                    name: e + ".properties.enabled.name",
                    value: this._isEnabled,
                    onedit: e => this.CallAction(n.SetEnabled, e)
                }, {
                    name: e + ".properties.checked.name",
                    value: this._isChecked,
                    onedit: e => this.CallAction(n.SetChecked, e)
                }]
            }]
        }
        GetScriptInterfaceClass() {
            return self.IButtonInstance
        }
    };
    const e = new WeakMap;
    self.IButtonInstance = class IButtonInstance extends self.IDOMInstance {
        constructor() {
            super(), e.set(this, self.IInstance._GetInitInst().GetSdkInstance())
        }
        set text(t) {
            e.get(this)._SetText(t)
        }
        get text() {
            return e.get(this)._GetText()
        }
        set tooltip(t) {
            e.get(this)._SetTooltip(t)
        }
        get tooltip() {
            return e.get(this)._GetTooltip()
        }
        set isEnabled(t) {
            e.get(this)._SetEnabled(t)
        }
        get isEnabled() {
            return e.get(this)._IsEnabled()
        }
        set isChecked(t) {
            e.get(this)._SetChecked(t)
        }
        get isChecked() {
            return e.get(this)._IsChecked()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Button.Cnds = {
        OnClicked() {
            return !0
        },
        IsChecked() {
            return this._isChecked
        },
        CompareText(t, n) {
            return n ? this._text === t : e.equalsNoCase(this._text, t)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Button.Acts = {
        SetText(e) {
            this._SetText(e)
        },
        SetTooltip(e) {
            this._SetTooltip(e)
        },
        SetChecked(e) {
            this._SetChecked(e !== 0)
        },
        ToggleChecked() {
            if (!this._isCheckbox) return;
            this._isChecked = !this._isChecked, this.UpdateElementState()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Plugins.Button.Exps = {
        Text() {
            return this._text
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = Math.pow(2, 26) - 1;
    class n {
        constructor() {
            this._hcells = 0, this._vcells = 0, this._cells = null
        }
        SetData(e, t, n) {
            this._hcells = e, this._vcells = t, this._cells = n
        }
        UpdateRegion(e, t, n, s, o) {
            const i = this._cells;
            if (!i) return;
            for (let s = 0; s < n; ++s) i[e + s].set(o[s], t)
        }
        At(e, n) {
            return e < 0 || n < 0 || e >= this._hcells || n >= this._vcells ? t : this._cells[e][n]
        }
    }
    e.Behaviors.Pathfinding = class PathfindingBehavior extends e.SDKBehaviorBase {
        constructor(e) {
            super(e), this._mapState = new Map, this._runtime.AddLoadPromise(this._runtime.AddJobWorkerScripts(["https://cdn.jsdelivr.net/gh/mamayaya1/game@f3a882424a8f28d07bdf456b251d889725c4c1e4/projects/among-us/redblackset.js", "https://cdn.jsdelivr.net/gh/mamayaya1/game@f3a882424a8f28d07bdf456b251d889725c4c1e4/projects/among-us/pathfind.js"])), this._runtime.Dispatcher().addEventListener("beforelayoutchange", () => this._OnBeforeLayoutChange())
        }
        Release() {
            super.Release()
        }
        GetMapKey(e, t) {
            return e + "," + t
        }
        GetPathfinderState(e) {
            let t = this._mapState.get(e);
            return t || (t = {
                isReady: !1,
                mapData: new n,
                regenerate: !1,
                regenerateRegions: [],
                regeneratePromise: null,
                regenerateResolve: null
            }, this._mapState.set(e, t)), t
        }
        UpdateCellData(e, t, n, s, o) {
            this._runtime.BroadcastJob("PFCellData", {
                mapKey: e,
                hcells: t,
                vcells: n,
                cellData: s,
                diagonals: o
            });
            const i = this.GetPathfinderState(e);
            i.isReady = !0, i.mapData.SetData(t, n, s), i.regenerate = !1
        }
        UpdateRegion(e, t, n, s, o, i) {
            this._runtime.BroadcastJob("PFUpdateRegion", {
                mapKey: e,
                cx1: t,
                cy1: n,
                lenx: s,
                leny: o,
                cellData: i
            }), this.GetPathfinderState(e).mapData.UpdateRegion(t, n, s, o, i)
        }
        FindPath(e, t, n, s, o) {
            return this._runtime.AddJob("PFFindPath", {
                mapKey: e,
                cellX: t,
                cellY: n,
                destCellX: s,
                destCellY: o
            })
        }
        SetDiagonalsEnabled(e, t) {
            this._runtime.BroadcastJob("PFSetDiagonals", {
                mapKey: e,
                diagonals: t
            })
        }
        _OnBeforeLayoutChange() {
            for (const e of this._mapState.values()) e.isReady = !1, e.mapData.SetData(0, 0, null), e.regenerate = !0;
            this._runtime.BroadcastJob("PFResetAllCellData")
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.Pathfinding.Type = class PathfindingType extends e.SDKBehaviorTypeBase {
        constructor(e) {
            super(e), this._obstacleTypes = [], this._costTypes = []
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        GetObstacleTypes() {
            return this._obstacleTypes
        }
        GetCostTypes() {
            return this._costTypes
        }
    }
}
"use strict";
{
    const e = self.C3,
        m = 0,
        h = 1,
        u = 2,
        a = 3,
        i = 4,
        o = 5,
        r = 6,
        c = 7,
        l = 8,
        d = 9,
        f = 0,
        s = Math.pow(2, 26) - 1,
        n = new e.Rect,
        t = [];
    e.Behaviors.Pathfinding.Instance = class PathfindingInstance extends e.SDKBehaviorInstanceBase {
        constructor(t, n) {
            super(t);
            const s = this.GetWorldInfo();
            this._cellSize = 30, this._cellBorder = -1, this._obstacles = 0, this._maxSpeed = 200, this._acc = 1e3, this._dec = 2e3, this._av = e.toRadians(135), this._isRotateEnabled = !0, this._isDiagonalsEnabled = !0, this._isEnabled = !0, this._isMoving = !1, this._movingFromStopped = !1, this._firstTickMovingWhileMoving = !1, this._hasPath = !1, this._moveNode = 0, this._a = s.GetAngle(), this._lastKnownAngle = s.GetAngle(), this._s = 0, this._rabbitX = 0, this._rabbitY = 0, this._rabbitA = 0, this._myHcells = 0, this._myVcells = 0, this._myPath = [], this._delayFindPath = !1, this._delayFindPathResolves = [], this._delayPathX = 0, this._delayPathY = 0, this._isDestroyed = !1, this._isCalculating = !1, this._calcPathX = 0, this._calcPathY = 0, this._isFirstRun = !0, n && (this._cellSize = n[m], this._cellBorder = n[h], this._obstacles = n[u], this._maxSpeed = n[a], this._acc = n[i], this._dec = n[o], this._av = e.toRadians(n[r]), this._isRotateEnabled = !!n[c], this._isDiagonalsEnabled = !!n[l], this._isEnabled = !!n[d]);
            const f = s.GetLayout();
            this._myHcells = Math.ceil(f.GetWidth() / this._cellSize), this._myVcells = Math.ceil(f.GetHeight() / this._cellSize);
            const p = this._runtime.Dispatcher();
            this._disposables = new e.CompositeDisposable(e.Disposable.From(p, "afterload", e => this._OnAfterLoad())), this._cellSize < 3 && (this._cellSize = 3), this._isEnabled && (this._StartTicking(), this._StartTicking2()), this.GetBehavior().SetDiagonalsEnabled(this.GetMapKey(), this._isDiagonalsEnabled)
        }
        Release() {
            this._isDestroyed = !0, super.Release()
        }
        GetMapKey() {
            return this.GetBehavior().GetMapKey(this._cellSize, this._cellBorder)
        }
        GetMyState() {
            return this.GetBehavior().GetPathfinderState(this.GetMapKey())
        }
        SaveToJson() {
            const e = {
                cs: this._cellSize,
                cb: this._cellBorder,
                ms: this._maxSpeed,
                acc: this._acc,
                dec: this._dec,
                av: this._av,
                re: this._isRotateEnabled,
                de: this._isDiagonalsEnabled,
                o: this._obstacles,
                im: this._isMoving,
                mfs: this._movingFromStopped,
                ftmwm: this._firstTickMovingWhileMoving,
                hp: this._hasPath,
                mn: this._moveNode,
                a: this._a,
                lka: this._lastKnownAngle,
                s: this._s,
                rx: this._rabbitX,
                ry: this._rabbitY,
                ra: this._rabbitA,
                hc: this._myHcells,
                vc: this._myVcells,
                p: this._myPath,
                e: this._isEnabled,
                fr: this._isFirstRun,
                obs: this.GetSdkType().GetObstacleTypes().map(e => e.GetSID()),
                costs: this.GetSdkType().GetCostTypes().map(e => ({
                    sid: e.objectClass.GetSID(),
                    cost: e.cost
                }))
            };
            return this._isCalculating ? (e.dfp = !0, e.dfx = this._calcPathX, e.dfy = this._calcPathY) : (e.dfp = this._delayFindPath, e.dfx = this._delayPathX, e.dfy = this._delayPathY), e
        }
        LoadFromJson(t) {
            this._cellSize = t.cs, this._cellBorder = t.cb, this._maxSpeed = t.ms, this._acc = t.acc, this._dec = t.dec, this._av = t.av, this._isRotateEnabled = t.re, this._isDiagonalsEnabled = t.de, this._obstacles = t.o, this._isMoving = t.im, this._movingFromStopped = t.mfs, this._firstTickMovingWhileMoving = t.ftmwm, this._hasPath = t.hp, this._moveNode = t.mn, this._a = t.a, this._lastKnownAngle = t.lka, this._s = t.s, this._rabbitX = t.rx, this._rabbitY = t.ry, this._rabbitA = t.ra, this._myHcells = t.hc, this._myVcells = t.vc, this._myPath = t.p, this._SetEnabled(t.e), this._isFirstRun = t.fr, this._delayFindPath = t.dfp, e.clearArray(this._delayFindPathResolves), this._delayPathX = t.dfx, this._delayPathY = t.dfy;
            const s = this.GetSdkType().GetObstacleTypes();
            e.clearArray(s);
            for (const n of t.obs) {
                const e = this._runtime.GetObjectClassBySID(n);
                e && s.push(e)
            }
            const n = this.GetSdkType().GetCostTypes();
            e.clearArray(n);
            for (const e of n) {
                const t = this._runtime.GetObjectClassBySID(e.sid);
                t && n.push({
                    objectClass: t,
                    cost: e.cost
                })
            }
            this._cellSize < 3 && (this._cellSize = 3), this.GetBehavior().SetDiagonalsEnabled(this.GetMapKey(), this._isDiagonalsEnabled)
        }
        _OnAfterLoad() {
            this.GetMyState().regenerate = !0
        }
        Tick() {
            if (!this._isEnabled || !this._isMoving) return;
            const s = this._runtime.GetDt(this._inst),
                t = this._inst.GetWorldInfo();
            this._isRotateEnabled && t.GetAngle() !== this._lastKnownAngle && (this._a = t.GetAngle());
            const n = this._myPath,
                r = Math.min(this._maxSpeed * .4, Math.abs(t.GetWidth()) * 2),
                c = Math.max(this._s * 1.5, 30);
            let o = 0,
                i = 0;
            if (this._moveNode < n.length) {
                o = n[this._moveNode].x, i = n[this._moveNode].y;
                const t = e.distanceTo(this._rabbitX, this._rabbitY, o, i);
                t < 3 * c * s && (this._moveNode++, this._rabbitX = o, this._rabbitY = i, this._moveNode < n.length && (o = n[this._moveNode].x, i = n[this._moveNode].y))
            } else o = n[n.length - 1].x, i = n[n.length - 1].y;
            this._rabbitA = e.angleTo(this._rabbitX, this._rabbitY, o, i);
            const l = e.distanceTo(t.GetX(), t.GetY(), this._rabbitX, this._rabbitY);
            if (l < r && this._moveNode < n.length) {
                let e = 0;
                this._firstTickMovingWhileMoving ? (e = r, this._firstTickMovingWhileMoving = !1) : e = c * s, this._rabbitX += Math.cos(this._rabbitA) * e, this._rabbitY += Math.sin(this._rabbitA) * e
            }
            const d = e.angleTo(t.GetX(), t.GetY(), this._rabbitX, this._rabbitY),
                a = e.angleDiff(this._a, d),
                u = e.distanceTo(t.GetX(), t.GetY(), n[n.length - 1].x, n[n.length - 1].y),
                h = this._maxSpeed * this._maxSpeed / (2 * this._dec);
            if (l > 1) {
                this._a = e.angleRotate(this._a, d, this._av * s);
                let n = 0;
                if (e.toDegrees(a) <= .5) n = this._maxSpeed;
                else if (e.toDegrees(a) >= 120 || this._movingFromStopped && this._moveNode === 0) this._movingFromStopped = !0;
                else {
                    const s = a / this._av,
                        o = e.distanceTo(t.GetX(), t.GetY(), this._rabbitX, this._rabbitY),
                        i = o / (2 * Math.sin(a)),
                        r = i * a;
                    n = e.clamp(r / s, 0, this._maxSpeed)
                }
                u < h && (n = Math.min(n, u / h * this._maxSpeed + this._maxSpeed / 40)), this._s += this._acc * s, this._s > n && (this._s = n)
            }
            if (t.OffsetXY(Math.cos(this._a) * this._s * s, Math.sin(this._a) * this._s * s), this._isRotateEnabled && (t.SetAngle(this._a), this._lastKnownAngle = t.GetAngle()), t.SetBboxChanged(), this._moveNode === n.length && e.distanceTo(t.GetX(), t.GetY(), o, i) < Math.max(3 * this._s * s, 10)) return this._isMoving = !1, this._hasPath = !1, this._moveNode = 0, this._s = 0, this.DebugTrigger(e.Behaviors.Pathfinding.Cnds.OnArrived)
        }
        Tick2() {
            if (!this._isEnabled) return;
            this._MaybeGenerateMap(), this._DoDelayFindPath()
        }
        _RegeneratePromise() {
            const e = this.GetMyState();
            return e.regeneratePromise || (e.regeneratePromise = new Promise(t => e.regenerateResolve = t)), e.regeneratePromise
        }
        _MaybeGenerateMap() {
            const t = this.GetMyState();
            if (t.isReady && !t.regenerate && !t.regenerateRegions.length) return;
            !t.isReady || t.regenerate ? this._GenerateFullMap() : t.regenerateRegions.length && this._RegenerateRegions(t.regenerateRegions), e.clearArray(t.regenerateRegions), t.regenerateResolve && t.regenerateResolve(), t.regeneratePromise = null, t.regenerateResolve = null
        }
        _GenerateFullMap() {
            const t = this.GetWorldInfo().GetLayout();
            this._myHcells = Math.ceil(t.GetWidth() / this._cellSize), this._myVcells = Math.ceil(t.GetHeight() / this._cellSize);
            const n = e.MakeFilledArray(this._myHcells, () => new Uint32Array(this._myVcells)),
                s = this._myVcells;
            for (let e = 0, t = this._myHcells; e < t; ++e)
                for (let t = 0; t < s; ++t) n[e][t] = this._QueryCellCollision(e, t);
            this.GetBehavior().UpdateCellData(this.GetMapKey(), this._myHcells, this._myVcells, n, this._isDiagonalsEnabled)
        }
        _AddRegenerateRegion(e, t, n, s) {
            const o = this._cellBorder,
                i = this._cellSize,
                d = this._myHcells,
                u = this._myVcells,
                h = Math.min(e, n) - o,
                m = Math.min(t, s) - o,
                f = Math.max(e, n) + o,
                p = Math.max(t, s) + o,
                a = Math.max(Math.floor(h / i), 0),
                r = Math.max(Math.floor(m / i), 0),
                c = Math.min(Math.ceil(f / i), d),
                l = Math.min(Math.ceil(p / i), u);
            return !(a >= c || r >= l) && (this.GetMyState().regenerateRegions.push([a, r, c, l]), !0)
        }
        _RegenerateRegions(e) {
            for (const [t, n, s, o] of e) this._RegenerateRegion(t, n, s, o)
        }
        _RegenerateRegion(t, n, s, o) {
            const i = s - t,
                a = o - n,
                r = e.MakeFilledArray(i, () => new Uint32Array(a));
            for (let e = 0; e < i; ++e)
                for (let s = 0; s < a; ++s) r[e][s] = this._QueryCellCollision(t + e, n + s);
            this.GetBehavior().UpdateRegion(this.GetMapKey(), t, n, i, a, r)
        }
        _QueryCellCollision(o, i) {
            const u = this.GetWorldInfo(),
                l = u.GetLayer(),
                r = this._cellSize,
                c = this._cellBorder,
                a = this._runtime.GetCollisionEngine();
            if (n.set(o * r - c, i * r - c, (o + 1) * r + c, (i + 1) * r + c), this._obstacles === 0) {
                if (a.TestRectOverlapSolid(n)) return s
            } else {
                a.GetObjectClassesCollisionCandidates(l, this._sdkType.GetObstacleTypes(), n, t);
                for (let o = 0, i = t.length; o < i; ++o)
                    if (a.TestRectOverlap(n, t[o])) return e.clearArray(t), s;
                e.clearArray(t)
            }
            let d = 0;
            const h = this._sdkType.GetCostTypes();
            for (const {
                    objectClass: s,
                    cost: o
                }
                of h) {
                a.GetCollisionCandidates(l, s, n, t);
                for (let e = 0, s = t.length; e < s; ++e) a.TestRectOverlap(n, t[e]) && (d += o);
                e.clearArray(t)
            }
            return Math.min(d, s)
        }
        async _DoDelayFindPath() {
            if (this._delayFindPath && !this._isDestroyed) {
                this._delayFindPath = !1;
                const t = this._delayFindPathResolves;
                this._delayFindPathResolves = [];
                const e = this.GetWorldInfo();
                await this._DoFindPath(e.GetX(), e.GetY(), this._delayPathX, this._delayPathY);
                for (const e of t) e()
            }
        }
        _FindNearestNonObstacleCell(e, t, n) {
            let o = 1 / 0,
                i = 0,
                a = 0;
            for (let r = 0, c = this._myHcells; r < c; ++r)
                for (let c = 0, l = this._myVcells; c < l; ++c)
                    if (e.At(r, c) !== s) {
                        const e = t - r,
                            s = n - c,
                            l = e * e + s * s;
                        l < o && (o = l, i = r, a = c)
                    } return [i, a]
        }
        async _DoFindPath(t, n, o, i) {
            const l = this.GetMyState();
            if (!l.isReady) return !1;
            const d = l.mapData;
            this._isCalculating = !0, this._calcPathX = o, this._calcPathY = i;
            const a = this._cellSize,
                h = Math.floor(t / a),
                m = Math.floor(n / a);
            let r = Math.floor(o / a),
                c = Math.floor(i / a);
            d.At(r, c) === s && ([r, c] = this._FindNearestNonObstacleCell(d, r, c));
            const u = await this.GetBehavior().FindPath(this.GetMapKey(), h, m, r, c);
            if (this._isDestroyed) return;
            if (this._isCalculating = !1, this._moveNode = 0, u === null) e.clearArray(this._myPath), this._hasPath = !1, this._isMoving = !1, await this.TriggerAsync(e.Behaviors.Pathfinding.Cnds.OnFailedToFindPath);
            else {
                const t = this._cellSize;
                this._myPath = u.map(e => ({
                    x: (e.x + .5) * t,
                    y: (e.y + .5) * t
                })), this._hasPath = this._myPath.length > 0, await this.TriggerAsync(e.Behaviors.Pathfinding.Cnds.OnPathFound)
            }
            this._DoDelayFindPath()
        }
        _GetPath() {
            return this._myPath
        }
        GetPropertyValueByIndex(t) {
            switch (t) {
                case m:
                    return this._cellSize;
                case h:
                    return this._cellBorder;
                case u:
                    return this._obstacles;
                case a:
                    return this._maxSpeed;
                case i:
                    return this._acc;
                case o:
                    return this._dec;
                case r:
                    return e.toDegrees(this._av);
                case c:
                    return this._isRotateEnabled;
                case l:
                    return this._isDiagonalsEnabled;
                case d:
                    return this._isEnabled
            }
        }
        SetPropertyValueByIndex(t, n) {
            switch (t) {
                case m:
                    this._cellSize = n, this._cellSize < 3 && (this._cellSize = 3);
                    break;
                case h:
                    this._cellBorder = n;
                    break;
                case u:
                    this._obstacles = n;
                    break;
                case a:
                    this._maxSpeed = n;
                    break;
                case i:
                    this._acc = n;
                    break;
                case o:
                    this._dec = n;
                    break;
                case r:
                    this._av = e.toRadians(n);
                    break;
                case c:
                    this._isRotateEnabled = !!n;
                    break;
                case l:
                    this._isDiagonalsEnabled = !!n, this.GetBehavior().SetDiagonalsEnabled(this.GetMapKey(), this._isDiagonalsEnabled);
                    break;
                case d:
                    this._SetEnabled(n);
                    break
            }
        }
        _SetEnabled(e) {
            this._isEnabled = !!e, this._isEnabled ? (this._StartTicking(), this._StartTicking2()) : (this._StopTicking(), this._StopTicking2())
        }
        GetDebuggerProperties() {
            const t = "behaviors.pathfinding";
            return [{
                title: "$" + this.GetBehaviorType().GetName(),
                properties: [{
                    name: t + ".debugger.has-path",
                    value: this._hasPath
                }, {
                    name: t + ".debugger.is-calculating-path",
                    value: this._isCalculating
                }, {
                    name: t + ".debugger.is-moving",
                    value: this._isMoving
                }, {
                    name: t + ".debugger.speed",
                    value: this._isMoving ? this._s : 0,
                    onedit: e => this._s = e
                }, {
                    name: t + ".debugger.angle-of-motion",
                    value: e.toDegrees(this._a),
                    onedit: t => this._a = e.toRadians(t)
                }, {
                    name: t + ".properties.max-speed.name",
                    value: this._maxSpeed,
                    onedit: e => this._maxSpeed = e
                }, {
                    name: t + ".properties.acceleration.name",
                    value: this._acc,
                    onedit: e => this._acc = e
                }, {
                    name: t + ".properties.deceleration.name",
                    value: this._dec,
                    onedit: e => this._dec = e
                }, {
                    name: t + ".properties.rotate-speed.name",
                    value: e.toDegrees(this._av),
                    onedit: t => this._av = e.toRadians(t)
                }, {
                    name: t + ".properties.enabled.name",
                    value: this._isEnabled,
                    onedit: e => this._SetEnabled(e)
                }]
            }]
        }
    }
}
"use strict";
{
    const e = self.C3,
        t = Math.pow(2, 26) - 1;
    e.Behaviors.Pathfinding.Cnds = {
        OnPathFound() {
            return !0
        },
        OnFailedToFindPath() {
            return !0
        },
        IsCellObstacle(e, n) {
            return this.GetMyState().mapData.At(e, n) === t
        },
        IsCalculatingPath() {
            return this._isCalculating
        },
        IsMoving() {
            return this._isMoving
        },
        OnArrived() {
            return !0
        },
        CompareSpeed(t, n) {
            return e.compare(this._isMoving ? this._s : 0, t, n)
        },
        DiagonalsEnabled() {
            return this._isDiagonalsEnabled
        },
        IsEnabled() {
            return this._isEnabled
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.Pathfinding.Acts = {
        async FindPath(e, t) {
            if (!this._isEnabled) return;
            const n = this.GetMyState();
            if (this._isCalculating || !n.isReady) await new Promise(n => {
                this._delayFindPath = !0, this._delayFindPathResolves.push(n), this._delayPathX = e, this._delayPathY = t
            });
            else {
                const n = this.GetWorldInfo();
                await this._DoFindPath(n.GetX(), n.GetY(), e, t)
            }
        },
        StartMoving() {
            if (!this._hasPath) return;
            this._isMoving && (this._firstTickMovingWhileMoving = !0), this._movingFromStopped = !this._isMoving, this._isMoving = !0;
            const e = this.GetWorldInfo();
            this._rabbitX = e.GetX(), this._rabbitY = e.GetY(), this._rabbitA = e.GetAngle()
        },
        Stop() {
            this._isMoving = !1
        },
        SetEnabled(e) {
            this._SetEnabled(e !== 0)
        },
        async RegenerateMap() {
            this.GetMyState().regenerate = !0, await this._RegeneratePromise()
        },
        AddObstacle(e) {
            const t = this.GetSdkType().GetObstacleTypes();
            if (t.includes(e)) return;
            for (const n of t)
                if (n.IsFamily() && n.FamilyHasMember(e)) return;
            t.push(e)
        },
        ClearObstacles() {
            e.clearArray(this._sdkType.GetObstacleTypes())
        },
        AddCost(e, t) {
            const n = this.GetSdkType().GetCostTypes();
            for (const s of n) {
                const t = s.objectClass;
                if (t === e) return;
                if (t.IsFamily() && t.FamilyHasMember(e)) return
            }
            n.push({
                objectClass: e,
                cost: t
            })
        },
        ClearCost() {
            e.clearArray(this._sdkType.GetCostTypes())
        },
        SetMaxSpeed(e) {
            this._maxSpeed = e
        },
        SetSpeed(t) {
            this._s = e.clamp(t, 0, this._maxSpeed)
        },
        SetAcc(e) {
            this._acc = e
        },
        SetDec(e) {
            this._dec = e
        },
        SetRotateSpeed(t) {
            this._av = e.toRadians(t)
        },
        SetDiagonalsEnabled(e) {
            this._isDiagonalsEnabled = e !== 0, this.GetBehavior().SetDiagonalsEnabled(this.GetMapKey(), this._isDiagonalsEnabled)
        },
        async RegenerateRegion(e, t, n, s) {
            this._AddRegenerateRegion(e, t, n, s) && await this._RegeneratePromise()
        },
        async RegenerateObjectRegion(e) {
            if (!e) return;
            const n = e.GetCurrentSol().GetInstances();
            let t = !1;
            for (const o of n) {
                const s = o.GetWorldInfo();
                if (!s) continue;
                const e = s.GetBoundingBox(),
                    i = this._AddRegenerateRegion(e.getLeft(), e.getTop(), e.getRight(), e.getBottom());
                t = t || i
            }
            t && await this._RegeneratePromise()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.Pathfinding.Exps = {
        NodeCount() {
            return this._myPath.length
        },
        NodeXAt(e) {
            return e = Math.floor(e), e < 0 || e >= this._myPath.length ? 0 : this._myPath[e].x
        },
        NodeYAt(e) {
            return e = Math.floor(e), e < 0 || e >= this._myPath.length ? 0 : this._myPath[e].y
        },
        CellSize() {
            return this._cellSize
        },
        RabbitX() {
            return this._rabbitX
        },
        RabbitY() {
            return this._rabbitY
        },
        MaxSpeed() {
            return this._maxSpeed
        },
        Acceleration() {
            return this._acc
        },
        Deceleration() {
            return this._dec
        },
        RotateSpeed() {
            return e.toDegrees(this._av)
        },
        MovingAngle() {
            return e.toDegrees(this._a)
        },
        CurrentNode() {
            return this._moveNode
        },
        Speed() {
            return this._isMoving ? this._s : 0
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.EightDir = class EightDirBehavior extends e.SDKBehaviorBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.EightDir.Type = class EightDirType extends e.SDKBehaviorTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
}
"use strict";
{
    const t = self.C3,
        l = self.IBehaviorInstance,
        n = 0,
        s = 1,
        o = 2,
        i = 3,
        a = 4,
        r = 5,
        c = 6;
    t.Behaviors.EightDir.Instance = class EightDirInstance extends t.SDKBehaviorInstanceBase {
        constructor(e, t) {
            super(e), this._upKey = !1, this._downKey = !1, this._leftKey = !1, this._rightKey = !1, this._ignoreInput = !1, this._simUp = !1, this._simDown = !1, this._simLeft = !1, this._simRight = !1, this._dx = 0, this._dy = 0, this._maxSpeed = 200, this._acc = 600, this._dec = 500, this._directions = 3, this._angleMode = 3, this._defaultControls = !0, this._isEnabled = !0, t && (this._maxSpeed = t[n], this._acc = t[s], this._dec = t[o], this._directions = t[i], this._angleMode = t[a], this._defaultControls = !!t[r], this._isEnabled = !!t[c]), this._isEnabled && this._StartTicking(), this._defaultControls && this._BindEvents()
        }
        _BindEvents() {
            if (this._disposables) return;
            const e = this._runtime.Dispatcher();
            this._disposables = new t.CompositeDisposable(t.Disposable.From(e, "keydown", e => this._OnKeyDown(e.data)), t.Disposable.From(e, "keyup", e => this._OnKeyUp(e.data)), t.Disposable.From(e, "window-blur", () => this._OnWindowBlur()))
        }
        _UnBindEvents() {
            if (!this._disposables) return;
            this._disposables.Release(), this._disposables = null
        }
        Release() {
            super.Release()
        }
        SaveToJson() {
            return {
                dx: this._dx,
                dy: this._dy,
                e: this._isEnabled,
                ms: this._maxSpeed,
                acc: this._acc,
                dec: this._dec,
                d: this._directions,
                am: this._angleMode,
                dc: this._defaultControls,
                ii: this._ignoreInput
            }
        }
        LoadFromJson(e) {
            this._dx = e.dx, this._dy = e.dy, this._SetEnabled(e.e), this._maxSpeed = e.ms, this._acc = e.acc, this._dec = e.dec, this._directions = e.d, this._angleMode = e.am, this._defaultControls = e.dc, this._ignoreInput = e.ii, this._upKey = !1, this._downKey = !1, this._leftKey = !1, this._rightKey = !1, this._simUp = !1, this._simDown = !1, this._simLeft = !1, this._simRight = !1, this._defaultControls ? this._BindEvents() : this._UnBindEvents()
        }
        _OnKeyDown(e) {
            switch (e.key) {
                case "ArrowLeft":
                    this._leftKey = !0;
                    break;
                case "ArrowUp":
                    this._upKey = !0;
                    break;
                case "ArrowRight":
                    this._rightKey = !0;
                    break;
                case "ArrowDown":
                    this._downKey = !0;
                    break
            }
        }
        _OnKeyUp(e) {
            switch (e.key) {
                case "ArrowLeft":
                    this._leftKey = !1;
                    break;
                case "ArrowUp":
                    this._upKey = !1;
                    break;
                case "ArrowRight":
                    this._rightKey = !1;
                    break;
                case "ArrowDown":
                    this._downKey = !1;
                    break
            }
        }
        _OnWindowBlur() {
            this._upKey = !1, this._downKey = !1, this._leftKey = !1, this._rightKey = !1
        }
        Tick() {
            const e = this._runtime.GetDt(this._inst),
                n = this._runtime.GetCollisionEngine();
            let o = this._leftKey || this._simLeft,
                i = this._rightKey || this._simRight,
                a = this._upKey || this._simUp,
                r = this._downKey || this._simDown;
            if (this._simLeft = !1, this._simRight = !1, this._simUp = !1, this._simDown = !1, !this._isEnabled) return;
            let s = n.TestOverlapSolid(this._inst);
            if (s && (n.RegisterCollision(this._inst, s), !n.PushOutSolidNearest(this._inst))) return;
            this._ignoreInput && (o = i = a = r = !1), this._directions === 0 ? o = i = !1 : this._directions === 1 && (a = r = !1), this._directions === 2 && (a || r) && (o = i = !1), o === i && (this._dx < 0 ? this._dx = Math.min(this._dx + this._dec * e, 0) : this._dx > 0 && (this._dx = Math.max(this._dx - this._dec * e, 0))), a === r && (this._dy < 0 ? this._dy = Math.min(this._dy + this._dec * e, 0) : this._dy > 0 && (this._dy = Math.max(this._dy - this._dec * e, 0)));
            let c = 0,
                l = 0;
            if (o && !i && (this._dx > 0 ? c = -(this._acc + this._dec) : c = -this._acc), i && !o && (this._dx < 0 ? c = this._acc + this._dec : c = this._acc), a && !r && (this._dy > 0 ? l = -(this._acc + this._dec) : l = -this._acc), r && !a && (this._dy < 0 ? l = this._acc + this._dec : l = this._acc), this._dx += c * e, this._dy += l * e, this._dx !== 0 || this._dy !== 0) {
                const v = Math.sqrt(this._dx * this._dx + this._dy * this._dy),
                    g = Math.atan2(this._dy, this._dx),
                    p = this._maxSpeed * Math.cos(g),
                    r = this._maxSpeed * Math.sin(g);
                v > this._maxSpeed && (this._dx = p, this._dy = r);
                const d = Math.abs(p) * e,
                    u = Math.abs(r) * e,
                    o = this._inst.GetWorldInfo(),
                    b = o.GetX(),
                    j = o.GetY(),
                    h = o.GetAngle(),
                    m = t.clamp(this._dx * e + .5 * c * e * e, -d, d);
                o.OffsetX(m), o.SetBboxChanged(), s = n.TestOverlapSolid(this._inst), s && (n.PushOutSolid(this._inst, this._dx < 0 ? 1 : -1, 0, Math.max(Math.abs(Math.floor(m)), 1)) || (o.SetX(b), o.SetBboxChanged()), this._dx = 0, n.RegisterCollision(this._inst, s));
                const f = t.clamp(this._dy * e + .5 * l * e * e, -u, u);
                o.OffsetY(f), o.SetBboxChanged(), s = n.TestOverlapSolid(this._inst), s && (n.PushOutSolid(this._inst, 0, this._dy < 0 ? 1 : -1, Math.max(Math.abs(Math.floor(f)), 1)) || (o.SetY(j), o.SetBboxChanged()), this._dy = 0, n.RegisterCollision(this._inst, s));
                const a = t.round6dp(this._dx),
                    i = t.round6dp(this._dy);
                (a !== 0 || i !== 0) && this._inst.GetPlugin().IsRotatable() && (this._angleMode === 1 ? o.SetAngle(t.toRadians(Math.round(t.toDegrees(Math.atan2(i, a)) / 90) * 90)) : this._angleMode === 2 ? o.SetAngle(t.toRadians(Math.round(t.toDegrees(Math.atan2(i, a)) / 45) * 45)) : this._angleMode === 3 && o.SetAngle(Math.atan2(i, a))), o.SetBboxChanged(), o.GetAngle() != h && (s = n.TestOverlapSolid(this._inst), s && (o.SetAngle(h), o.SetBboxChanged(), n.RegisterCollision(this._inst, s)))
            }
        }
        GetPropertyValueByIndex(e) {
            switch (e) {
                case n:
                    return this._GetMaxSpeed();
                case s:
                    return this._GetAcceleration();
                case o:
                    return this._GetDeceleration();
                case i:
                    return this._directions;
                case a:
                    return this._angleMode;
                case r:
                    return this._IsDefaultControls();
                case c:
                    return this._IsEnabled()
            }
        }
        SetPropertyValueByIndex(e, t) {
            switch (e) {
                case n:
                    this._SetMaxSpeed(t);
                    break;
                case s:
                    this._SetAcceleration(t);
                    break;
                case o:
                    this._SetDeceleration(t);
                    break;
                case i:
                    this._directions = t;
                    break;
                case a:
                    this._angleMode = t;
                    break;
                case r:
                    this._SetDefaultControls(!!t);
                    break;
                case c:
                    this._SetEnabled(!!t);
                    break
            }
        }
        _Stop() {
            this._dx = 0, this._dy = 0
        }
        _Reverse() {
            this._dx *= -1, this._dy *= -1
        }
        _MaybeClampSpeed() {
            const e = Math.hypot(this._dx, this._dy);
            e > this._maxSpeed && this._SetSpeed(e)
        }
        _SetSpeed(e) {
            e = t.clamp(e, 0, this._maxSpeed);
            const n = Math.atan2(this._dy, this._dx);
            this._dx = e * Math.cos(n), this._dy = e * Math.sin(n)
        }
        _GetSpeed() {
            return Math.hypot(this._dx, this._dy)
        }
        _SetMaxSpeed(e) {
            this._maxSpeed = Math.max(e, 0)
        }
        _GetMaxSpeed() {
            return this._maxSpeed
        }
        _SetAcceleration(e) {
            this._acc = Math.max(e, 0)
        }
        _GetAcceleration() {
            return this._acc
        }
        _SetDeceleration(e) {
            this._dec = Math.max(e, 0)
        }
        _GetDeceleration() {
            return this._dec
        }
        _GetMovingAngle() {
            return Math.atan2(this._dy, this._dx)
        }
        _SetVectorX(e) {
            this._dx = e, this._MaybeClampSpeed()
        }
        _GetVectorX() {
            return this._dx
        }
        _SetVectorY(e) {
            this._dy = e, this._MaybeClampSpeed()
        }
        _GetVectorY() {
            return this._dy
        }
        _SimulateControl(e) {
            if (!this._isEnabled) return;
            switch (e) {
                case 0:
                    this._simLeft = !0;
                    break;
                case 1:
                    this._simRight = !0;
                    break;
                case 2:
                    this._simUp = !0;
                    break;
                case 3:
                    this._simDown = !0;
                    break
            }
        }
        _SetDefaultControls(e) {
            if (e = !!e, this._defaultControls === e) return;
            this._defaultControls = e, this._defaultControls ? this._BindEvents() : (this._UnBindEvents(), this._OnWindowBlur())
        }
        _IsDefaultControls() {
            return this._defaultControls
        }
        _SetIgnoreInput(e) {
            this._ignoreInput = !!e
        }
        _IsIgnoreInput() {
            return this._ignoreInput
        }
        _SetEnabled(e) {
            this._isEnabled = !!e, this._isEnabled ? this._StartTicking() : (this._simLeft = !1, this._simRight = !1, this._simUp = !1, this._simDown = !1, this._StopTicking())
        }
        _IsEnabled() {
            return this._isEnabled
        }
        GetDebuggerProperties() {
            const e = "behaviors.eightdir";
            return [{
                title: "$" + this.GetBehaviorType().GetName(),
                properties: [{
                    name: e + ".debugger.vector-x",
                    value: this._GetVectorX(),
                    onedit: e => this._SetVectorX(e)
                }, {
                    name: e + ".debugger.vector-y",
                    value: this._GetVectorY(),
                    onedit: e => this._SetVectorY(e)
                }, {
                    name: e + ".debugger.speed",
                    value: this._GetSpeed(),
                    onedit: e => this._SetSpeed(e)
                }, {
                    name: e + ".debugger.angle-of-motion",
                    value: t.toDegrees(this._GetMovingAngle())
                }, {
                    name: e + ".properties.max-speed.name",
                    value: this._GetMaxSpeed(),
                    onedit: e => this._SetMaxSpeed(e)
                }, {
                    name: e + ".properties.acceleration.name",
                    value: this._GetAcceleration(),
                    onedit: e => this._SetAcceleration(e)
                }, {
                    name: e + ".properties.deceleration.name",
                    value: this._GetDeceleration(),
                    onedit: e => this._SetDeceleration(e)
                }, {
                    name: e + ".properties.enabled.name",
                    value: this._IsEnabled(),
                    onedit: e => this._SetEnabled(e)
                }]
            }]
        }
        GetScriptInterfaceClass() {
            return self.I8DirectionBehaviorInstance
        }
    };
    const e = new WeakMap,
        d = new Map([
            ["left", 0],
            ["right", 1],
            ["up", 2],
            ["down", 3]
        ]);
    self.I8DirectionBehaviorInstance = class I8DirectionBehaviorInstance extends l {
        constructor() {
            super(), e.set(this, l._GetInitInst().GetSdkInstance())
        }
        stop() {
            e.get(this)._Stop()
        }
        reverse() {
            e.get(this)._Reverse()
        }
        simulateControl(t) {
            const n = d.get(t);
            if (typeof n != "number") throw new Error("invalid control");
            e.get(this)._SimulateControl(n)
        }
        get speed() {
            return e.get(this)._GetSpeed()
        }
        set speed(t) {
            e.get(this)._SetSpeed(t)
        }
        get maxSpeed() {
            return e.get(this)._GetMaxSpeed()
        }
        set maxSpeed(t) {
            e.get(this)._SetMaxSpeed(t)
        }
        get acceleration() {
            return e.get(this)._GetAcceleration()
        }
        set acceleration(t) {
            e.get(this)._SetAcceleration(t)
        }
        get deceleration() {
            return e.get(this)._GetDeceleration()
        }
        set deceleration(t) {
            e.get(this)._SetDeceleration(t)
        }
        get vectorX() {
            return e.get(this)._GetVectorX()
        }
        set vectorX(t) {
            e.get(this)._SetVectorX(t)
        }
        get vectorY() {
            return e.get(this)._GetVectorY()
        }
        set vectorY(t) {
            e.get(this)._SetVectorX(t)
        }
        get isDefaultControls() {
            return e.get(this)._IsDefaultControls()
        }
        set isDefaultControls(t) {
            e.get(this)._SetDefaultControls(!!t)
        }
        get isIgnoringInput() {
            return e.get(this)._IsIgnoreInput()
        }
        set isIgnoringInput(t) {
            e.get(this)._SetIgnoreInput(!!t)
        }
        get isEnabled() {
            return e.get(this)._IsEnabled()
        }
        set isEnabled(t) {
            e.get(this)._SetEnabled(!!t)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.EightDir.Cnds = {
        IsMoving() {
            return this._GetSpeed() > 1e-10
        },
        CompareSpeed(t, n) {
            return e.compare(this._GetSpeed(), t, n)
        },
        IsEnabled() {
            return this._IsEnabled()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.EightDir.Acts = {
        Stop() {
            this._Stop()
        },
        Reverse() {
            this._Reverse()
        },
        SetIgnoreInput(e) {
            this._SetIgnoreInput(e)
        },
        SetSpeed(e) {
            this._SetSpeed(e)
        },
        SetMaxSpeed(e) {
            this._SetMaxSpeed(e)
        },
        SetAcceleration(e) {
            this._SetAcceleration(e)
        },
        SetDeceleration(e) {
            this._SetDeceleration(e)
        },
        SimulateControl(e) {
            this._SimulateControl(e)
        },
        SetEnabled(e) {
            this._SetEnabled(e)
        },
        SetVectorX(e) {
            this._SetVectorX(e)
        },
        SetVectorY(e) {
            this._SetVectorY(e)
        },
        SetDefaultControls(e) {
            this._SetDefaultControls(!!e)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.EightDir.Exps = {
        Speed() {
            return this._GetSpeed()
        },
        MaxSpeed() {
            return this._GetMaxSpeed()
        },
        Acceleration() {
            return this._GetAcceleration()
        },
        Deceleration() {
            return this._GetDeceleration()
        },
        MovingAngle() {
            return e.toDegrees(this._GetMovingAngle())
        },
        VectorX() {
            return this._GetVectorX()
        },
        VectorY() {
            return this._GetVectorY()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.LOS = class LOSBehavior extends e.SDKBehaviorBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.LOS.Type = class LOSType extends e.SDKBehaviorTypeBase {
        constructor(e) {
            super(e), this._obstacleTypes = []
        }
        Release() {
            e.clearArray(this._obstacleTypes), super.Release()
        }
        OnCreate() {}
        GetObstacleTypes() {
            return this._obstacleTypes
        }
        FindLOSBehavior(e) {
            const t = this.GetBehaviorType();
            for (const n of e.GetBehaviorInstances())
                if (n.GetBehaviorType() === t) return n.GetSdkInstance();
            return null
        }
    }
}
"use strict";
{
    const e = self.C3,
        n = 0,
        s = 1,
        o = 2,
        i = 3,
        a = 0,
        t = [];
    e.Behaviors.LOS.Instance = class LOSInstance extends e.SDKBehaviorInstanceBase {
        constructor(t, a) {
            super(t), this._obstacleMode = 0, this._range = 1e4, this._cone = e.toRadians(360), this._useCollisionCells = !0, this._ray = new e.Ray, a && (this._obstacleMode = a[n], this._range = a[s], this._cone = e.toRadians(a[o]), this._useCollisionCells = a[i])
        }
        Release() {
            super.Release()
        }
        SaveToJson() {
            return {
                r: this._range,
                c: this._cone,
                om: this._obstacleMode,
                ucc: this._useCollisionCells,
                t: this.GetSdkType().GetObstacleTypes().map(e => e.GetSID())
            }
        }
        LoadFromJson(t) {
            this._range = t.r, this._cone = t.c, this._obstacleMode = t.om || 0, this._useCollisionCells = !!t.ucc;
            const n = this.GetSdkType().GetObstacleTypes();
            e.clearArray(n);
            for (const s of t.t) {
                const e = this._runtime.GetObjectClassBySID(s);
                e && n.push(e)
            }
        }
        HasLOSToInstance(e, t) {
            const n = e.GetUID(),
                [s, o] = e.GetImagePoint(t),
                i = this.HasLOSTo(s, o);
            return i || this._ray.hitUid === n
        }
        HasLOSTo(e, t) {
            const n = this.GetWorldInfo();
            let s = n.GetAngle();
            return n.GetWidth() < 0 && (s += Math.PI), this.HasLOSBetweenPositions(n.GetX(), n.GetY(), s, e, t)
        }
        HasLOSBetweenPositions(t, n, s, o, i) {
            const a = this._range;
            if (e.distanceSquared(t, n, o, i) > a * a) return !1;
            const r = e.angleTo(t, n, o, i);
            if (e.angleDiff(s, r) > this._cone / 2) return !1;
            const c = this.CastRay(t, n, o, i, this._useCollisionCells);
            return !c.DidCollide()
        }
        _GetCollisionCandidates(n, s) {
            if (s) {
                const e = this.GetWorldInfo().GetLayer(),
                    s = this._runtime.GetCollisionEngine();
                return this._obstacleMode === a ? s.GetSolidCollisionCandidates(e, n.rect, t) : s.GetObjectClassesCollisionCandidates(e, this._GetObstacleTypes(), n.rect, t), t
            }
            if (this._obstacleMode === a) {
                const e = this._runtime.GetSolidBehavior();
                return e ? e.GetInstances() : t
            } else {
                for (const n of this._GetObstacleTypes()) e.appendArray(t, n.GetInstances());
                return t
            }
        }
        _GetObstacleTypes() {
            return this.GetSdkType().GetObstacleTypes()
        }
        CastRay(n, s, o, i, r) {
            const c = this._ray.Set(n, s, o, i),
                l = this._GetCollisionCandidates(c, r),
                d = this._runtime.GetCollisionEngine(),
                h = this._obstacleMode === a,
                u = this._inst;
            for (let e = 0, n = l.length; e < n; ++e) {
                const t = l[e];
                if (t === u) continue;
                (!h || d.IsSolidCollisionAllowed(t, u)) && d.TestRayIntersectsInstance(t, c)
            }
            return c.Complete(), e.clearArray(t), c
        }
        GetPropertyValueByIndex(t) {
            switch (t) {
                case n:
                    return this._obstacleMode;
                case s:
                    return this._range;
                case o:
                    return e.toDegrees(this._cone);
                case i:
                    return this._useCollisionCells
            }
        }
        SetPropertyValueByIndex(t, a) {
            switch (t) {
                case n:
                    this._obstacleMode = a;
                    break;
                case s:
                    this._range = a;
                    break;
                case o:
                    this._cone = e.toRadians(a);
                    break;
                case i:
                    this._useCollisionCells = !!a;
                    break
            }
        }
        GetDebuggerProperties() {
            const t = "behaviors.los.properties";
            return [{
                title: "$" + this.GetBehaviorType().GetName(),
                properties: [{
                    name: t + ".range.name",
                    value: this._range,
                    onedit: e => this._range = e
                }, {
                    name: t + ".cone-of-view.name",
                    value: e.toDegrees(this._cone),
                    onedit: t => this._cone = e.toRadians(t)
                }]
            }]
        }
    }
}
"use strict";
{
    const n = self.C3,
        e = new Set,
        t = new Set;
    n.Behaviors.LOS.Cnds = {
        HasLOSToPosition(e, t) {
            return this.HasLOSTo(e, t)
        },
        RayIntersected() {
            return this._ray.DidCollide()
        },
        HasLOSBetweenPositions(e, t, s, o, i) {
            return this.HasLOSBetweenPositions(e, t, n.toRadians(s), o, i)
        },
        HasLOSToObject(s, o) {
            if (!s) return !1;
            const l = this._runtime.GetCurrentCondition(),
                d = l.GetEventBlock().IsOrBlock(),
                u = l.GetRuntime(),
                i = l.GetObjectClass().GetCurrentSol(),
                a = s.GetCurrentSol();
            let c = i.GetInstances(),
                r = a.GetInstances();
            i.IsSelectAll() ? n.clearArray(i._GetOwnElseInstances()) : d && (u.IsCurrentConditionFirst() && !i._GetOwnElseInstances().length && i._GetOwnInstances().length ? c = i._GetOwnInstances() : c = i._GetOwnElseInstances()), a.IsSelectAll() ? n.clearArray(a._GetOwnElseInstances()) : d && (u.IsCurrentConditionFirst() && !a._GetOwnElseInstances().length && a._GetOwnInstances().length ? r = a._GetOwnInstances() : r = a._GetOwnElseInstances());
            const h = l.IsInverted(),
                m = this.GetSdkType();
            for (const s of c) {
                let i = !1;
                const a = m.FindLOSBehavior(s);
                if (r.length === 0) h && (i = !0);
                else
                    for (const e of r) s !== e && n.xor(a.HasLOSToInstance(e, o), h) && (i = !0, t.add(e));
                i && e.add(s)
            }
            return d ? (c === i._GetOwnElseInstances() ? i.TransferElseInstancesToOwn(e) : (i.AddElseInstances(e, c), i.SetSetPicked(e)), r === a._GetOwnElseInstances() ? a.TransferElseInstancesToOwn(t) : (a.AddElseInstances(t, r), a.SetSetPicked(t))) : (i.SetSetPicked(e), a.SetSetPicked(t)), e.clear(), t.clear(), i.HasAnyInstances()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.LOS.Acts = {
        SetRange(e) {
            this._range = e
        },
        SetCone(t) {
            this._cone = e.toRadians(t)
        },
        CastRay(e, t, n, s, o) {
            this.CastRay(e, t, n, s, o)
        },
        AddObstacle(e) {
            const t = this.GetSdkType().GetObstacleTypes();
            if (t.includes(e)) return;
            for (const n of t)
                if (n.IsFamily() && n.FamilyHasMember(e)) return;
            t.push(e)
        },
        ClearObstacles() {
            e.clearArray(this.GetSdkType().GetObstacleTypes())
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.LOS.Exps = {
        Range() {
            return this._range
        },
        ConeOfView() {
            return e.toDegrees(this._cone)
        },
        HitX() {
            const e = this._ray;
            return e.DidCollide() ? e.hitX : 0
        },
        HitY() {
            const e = this._ray;
            return e.DidCollide() ? e.hitY : 0
        },
        HitDistance() {
            const e = this._ray;
            return e.DidCollide() ? e.distance : 0
        },
        HitUID() {
            const e = this._ray;
            return e.DidCollide() ? e.hitUid : -1
        },
        NormalX(e) {
            const t = this._ray;
            return t.DidCollide() ? t.hitX + e * t.normalX : 0
        },
        NormalY(e) {
            const t = this._ray;
            return t.DidCollide() ? t.hitY + e * t.normalY : 0
        },
        NormalAngle() {
            const t = this._ray;
            return t.DidCollide() ? e.toDegrees(t.hitNormal) : 0
        },
        ReflectionX(e) {
            const t = this._ray;
            return t.DidCollide() ? t.hitX + e * t.reflectionX : 0
        },
        ReflectionY(e) {
            const t = this._ray;
            return t.DidCollide() ? t.hitY + e * t.reflectionY : 0
        },
        ReflectionAngle() {
            const t = this._ray;
            return t.DidCollide() ? e.toDegrees(Math.atan2(t.reflectionY, t.reflectionX)) : 0
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.solid = class SolidBehavior extends e.SDKBehaviorBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.solid.Type = class SolidType extends e.SDKBehaviorTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
}
"use strict";
{
    const t = self.C3,
        e = 0,
        n = 1,
        s = new Set;
    t.Behaviors.solid.Instance = class SolidInstance extends t.SDKBehaviorInstanceBase {
        constructor(t, s) {
            super(t), this.SetEnabled(!0), s && (this.SetEnabled(s[e]), this.SetTags(s[n]))
        }
        Release() {
            super.Release()
        }
        SetEnabled(e) {
            this._inst._SetSolidEnabled(!!e)
        }
        IsEnabled() {
            return this._inst._IsSolidEnabled()
        }
        SetTags(e) {
            const n = this._inst.GetSavedDataMap();
            if (!e.trim()) {
                n.delete("solidTags");
                return
            }
            let t = n.get("solidTags");
            t || (t = new Set, n.set("solidTags", t)), t.clear();
            for (const n of e.split(" ")) n && t.add(n.toLowerCase())
        }
        GetTags() {
            return this._inst.GetSavedDataMap().get("solidTags") || s
        }
        SaveToJson() {
            return {
                e: this.IsEnabled()
            }
        }
        LoadFromJson(e) {
            this.SetEnabled(e.e)
        }
        GetPropertyValueByIndex(t) {
            switch (t) {
                case e:
                    return this.IsEnabled()
            }
        }
        SetPropertyValueByIndex(t, n) {
            switch (t) {
                case e:
                    this.SetEnabled(n);
                    break
            }
        }
        GetDebuggerProperties() {
            return [{
                title: "$" + this.GetBehaviorType().GetName(),
                properties: [{
                    name: "behaviors.solid.properties.enabled.name",
                    value: this.IsEnabled(),
                    onedit: e => this.SetEnabled(e)
                }]
            }]
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.solid.Cnds = {
        IsEnabled() {
            return this.IsEnabled()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.solid.Acts = {
        SetEnabled(e) {
            this.SetEnabled(e)
        },
        SetTags(e) {
            this.SetTags(e)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.solid.Exps = {}
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.scrollto = class ScrollToBehavior extends e.SDKBehaviorBase {
        constructor(e) {
            super(e), this._shakeMag = 0, this._shakeStart = 0, this._shakeEnd = 0, this._shakeMode = 0
        }
        Release() {
            super.Release()
        }
        SetShakeMagnitude(e) {
            this._shakeMag = e
        }
        GetShakeMagnitude() {
            return this._shakeMag
        }
        SetShakeStart(e) {
            this._shakeStart = e
        }
        GetShakeStart() {
            return this._shakeStart
        }
        SetShakeEnd(e) {
            this._shakeEnd = e
        }
        GetShakeEnd() {
            return this._shakeEnd
        }
        SetShakeMode(e) {
            this._shakeMode = e
        }
        GetShakeMode() {
            return this._shakeMode
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.scrollto.Type = class ScrollToType extends e.SDKBehaviorTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
}
"use strict";
{
    const e = self.C3,
        t = 0;
    e.Behaviors.scrollto.Instance = class ScrollToInstance extends e.SDKBehaviorInstanceBase {
        constructor(e, n) {
            super(e), this._isEnabled = !0, n && (this._isEnabled = n[t]), this._isEnabled && this._StartTicking2()
        }
        Release() {
            super.Release()
        }
        SaveToJson() {
            const e = this.GetBehavior();
            return {
                e: this._isEnabled,
                smg: e.GetShakeMagnitude(),
                ss: e.GetShakeStart(),
                se: e.GetShakeEnd(),
                smd: e.GetShakeMode()
            }
        }
        LoadFromJson(e) {
            const t = this.GetBehavior();
            t.SetShakeMagnitude(e.smg), t.SetShakeStart(e.ss), t.SetShakeEnd(e.se), t.SetShakeMode(e.smd), this._isEnabled = e.e, this._isEnabled ? this._StartTicking2() : this._StopTicking2()
        }
        IsEnabled() {
            return this._isEnabled
        }
        Tick2() {
            if (!this.IsEnabled()) return;
            const d = this._runtime.GetDt(this._inst),
                t = this.GetBehavior(),
                l = t.GetInstances();
            let o = 0,
                i = 0,
                n = 0;
            for (const t of l) {
                const s = t.GetBehaviorInstanceFromCtor(e.Behaviors.scrollto);
                if (!s || !s.GetSdkInstance().IsEnabled()) continue;
                const a = t.GetWorldInfo();
                o += a.GetX(), i += a.GetY(), ++n
            }
            const a = this._inst.GetWorldInfo().GetLayout(),
                s = this._runtime.GetGameTime();
            let r = 0,
                c = 0;
            if (s >= t.GetShakeStart() && s < t.GetShakeEnd()) {
                let e = t.GetShakeMagnitude() * Math.min(this._runtime.GetTimeScale(), 1);
                t.GetShakeMode() === 0 && (e *= 1 - (s - t.GetShakeStart()) / (t.GetShakeEnd() - t.GetShakeStart()));
                const n = this._runtime.Random() * Math.PI * 2,
                    o = this._runtime.Random() * e;
                r = Math.cos(n) * o, c = Math.sin(n) * o
            }
            a.SetScrollX(o / n + r), a.SetScrollY(i / n + c)
        }
        GetPropertyValueByIndex(e) {
            switch (e) {
                case t:
                    return this._isEnabled
            }
        }
        SetPropertyValueByIndex(e, n) {
            switch (e) {
                case t:
                    this._isEnabled = !!n, this._isEnabled ? this._StartTicking2() : this._StopTicking2();
                    break
            }
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.scrollto.Cnds = {
        IsEnabled() {
            return this._isEnabled
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.scrollto.Acts = {
        Shake(e, t, n) {
            const s = this.GetBehavior();
            s.SetShakeMagnitude(e), s.SetShakeStart(this._runtime.GetGameTime()), s.SetShakeEnd(this._runtime.GetGameTime() + t), s.SetShakeMode(n)
        },
        SetEnabled(e) {
            this._isEnabled = e !== 0, this._isEnabled ? this._StartTicking2() : this._StopTicking2()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.scrollto.Exps = {}
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.Sin = class SinBehavior extends e.SDKBehaviorBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.Sin.Type = class SinType extends e.SDKBehaviorTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
}
"use strict";
{
    const t = self.C3,
        r = 0,
        c = 1,
        n = 2,
        E = 3,
        d = 4,
        A = 5,
        i = 6,
        y = 7,
        a = 8,
        f = 0,
        u = 1,
        h = 2,
        m = 3,
        l = 4,
        o = 5,
        g = 6,
        k = 7,
        b = 8,
        j = 9,
        C = 0,
        _ = 1,
        w = 2,
        O = 3,
        x = 4,
        e = 2 * Math.PI,
        s = Math.PI / 2,
        v = 3 * Math.PI / 2,
        p = [0, 1, 8, 3, 4, 2, 5, 6, 9, 7];
    t.Behaviors.Sin.Instance = class SinInstance extends t.SDKBehaviorInstanceBase {
        constructor(s, l) {
            super(s), this._i = 0, this._movement = 0, this._wave = 0, this._period = 0, this._mag = 0, this._isEnabled = !0, this._basePeriod = 0, this._basePeriodOffset = 0, this._baseMag = 0, this._periodRandom = 0, this._periodOffsetRandom = 0, this._magnitudeRandom = 0, this._initialValue = 0, this._initialValue2 = 0, this._lastKnownValue = 0, this._lastKnownValue2 = 0, this._ratio = 0, l && (this._movement = p[l[r]], this._wave = l[c], this._periodRandom = this._runtime.Random() * l[E], this._basePeriod = l[n], this._period = l[n], this._period += this._periodRandom, this._basePeriodOffset = l[d], this._period !== 0 && (this._periodOffsetRandom = this._runtime.Random() * l[A], this._i = l[d] / this._period * e, this._i += this._periodOffsetRandom / this._period * e), this._magnitudeRandom = this._runtime.Random() * l[y], this._baseMag = l[i], this._mag = l[i], this._mag += this._magnitudeRandom, this._isEnabled = !!l[a]), this._movement === o && (this._mag = t.toRadians(this._mag)), this.Init(), this._isEnabled && this._StartTicking()
        }
        Release() {
            super.Release()
        }
        SaveToJson() {
            return {
                i: this._i,
                e: this._isEnabled,
                mv: this._movement,
                w: this._wave,
                p: this._period,
                mag: this._mag,
                iv: this._initialValue,
                iv2: this._initialValue2,
                r: this._ratio,
                lkv: this._lastKnownValue,
                lkv2: this._lastKnownValue2
            }
        }
        LoadFromJson(e) {
            this._i = e.i, this._SetEnabled(e.e), this._movement = e.mv, this._wave = e.w, this._period = e.p, this._mag = e.mag, this._initialValue = e.iv, this._initialValue2 = e.iv2, this._ratio = e.r, this._lastKnownValue = e.lkv, this._lastKnownValue2 = e.lkv2
        }
        Init() {
            const e = this._inst.GetWorldInfo();
            switch (this._movement) {
                case f:
                    this._initialValue = e.GetX();
                    break;
                case u:
                    this._initialValue = e.GetY();
                    break;
                case h:
                    this._initialValue = e.GetWidth(), this._ratio = e.GetHeight() / e.GetWidth();
                    break;
                case m:
                    this._initialValue = e.GetWidth();
                    break;
                case l:
                    this._initialValue = e.GetHeight();
                    break;
                case o:
                    this._initialValue = e.GetAngle();
                    break;
                case g:
                    this._initialValue = e.GetOpacity();
                    break;
                case k:
                    this._initialValue = 0;
                    break;
                case b:
                    this._initialValue = e.GetX(), this._initialValue2 = e.GetY();
                    break;
                case j:
                    this._initialValue = e.GetZElevation();
                    break;
                default:
            }
            this._lastKnownValue = this._initialValue, this._lastKnownValue2 = this._initialValue2
        }
        WaveFunc(t) {
            switch (t = t % e, this._wave) {
                case C:
                    return Math.sin(t);
                case _:
                    return t <= s ? t / s : t <= v ? 1 - 2 * (t - s) / Math.PI : (t - v) / s - 1;
                case w:
                    return 2 * t / e - 1;
                case O:
                    return -2 * t / e + 1;
                case x:
                    return t < Math.PI ? -1 : 1
            }
            return 0
        }
        Tick() {
            const t = this._runtime.GetDt(this._inst);
            if (!this._isEnabled || t === 0) return;
            this._period === 0 ? this._i = 0 : this._i = (this._i + t / this._period * e) % e, this._UpdateFromPhase()
        }
        _UpdateFromPhase() {
            const e = this._inst.GetWorldInfo();
            switch (this._movement) {
                case f:
                    e.GetX() !== this._lastKnownValue && (this._initialValue += e.GetX() - this._lastKnownValue), e.SetX(this._initialValue + this.WaveFunc(this._i) * this._mag), this._lastKnownValue = e.GetX();
                    break;
                case u:
                    e.GetY() !== this._lastKnownValue && (this._initialValue += e.GetY() - this._lastKnownValue), e.SetY(this._initialValue + this.WaveFunc(this._i) * this._mag), this._lastKnownValue = e.GetY();
                    break;
                case h:
                    e.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag), e.SetHeight(e.GetWidth() * this._ratio);
                    break;
                case m:
                    e.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag);
                    break;
                case l:
                    e.SetHeight(this._initialValue + this.WaveFunc(this._i) * this._mag);
                    break;
                case o:
                    e.GetAngle() !== this._lastKnownValue && (this._initialValue = t.clampAngle(this._initialValue + (e.GetAngle() - this._lastKnownValue))), e.SetAngle(this._initialValue + this.WaveFunc(this._i) * this._mag), this._lastKnownValue = e.GetAngle();
                    break;
                case g:
                    e.SetOpacity(this._initialValue + this.WaveFunc(this._i) * this._mag / 100);
                    break;
                case b:
                    e.GetX() !== this._lastKnownValue && (this._initialValue += e.GetX() - this._lastKnownValue), e.GetY() !== this._lastKnownValue2 && (this._initialValue2 += e.GetY() - this._lastKnownValue2), e.SetX(this._initialValue + Math.cos(e.GetAngle()) * this.WaveFunc(this._i) * this._mag), e.SetY(this._initialValue2 + Math.sin(e.GetAngle()) * this.WaveFunc(this._i) * this._mag), this._lastKnownValue = e.GetX(), this._lastKnownValue2 = e.GetY();
                    break;
                case j:
                    e.SetZElevation(this._initialValue + this.WaveFunc(this._i) * this._mag);
                    break
            }
            e.SetBboxChanged()
        }
        _OnSpriteFrameChanged() {}
        _SetEnabled(e) {
            this._isEnabled = !!e, this._isEnabled ? this._StartTicking() : this._StopTicking()
        }
        GetPropertyValueByIndex(e) {
            switch (e) {
                case r:
                    return this._movement;
                case c:
                    return this._wave;
                case n:
                    return this._basePeriod;
                case i:
                    return this._baseMag;
                case a:
                    return this._isEnabled
            }
        }
        SetPropertyValueByIndex(s, l) {
            switch (s) {
                case r:
                    this._movement = p[l], this.Init();
                    break;
                case c:
                    this._wave = l;
                    break;
                case n:
                    this._basePeriod = l, this._period = this._basePeriod + this._periodRandom, this._isEnabled || (this._period !== 0 ? (this._i = this._basePeriodOffset / this._period * e, this._i += this._periodOffsetRandom / this._period * e) : this._i = 0);
                    break;
                case i:
                    this._baseMag = l, this._mag = this._baseMag + this._magnitudeRandom, this._movement === o && (this._mag = t.toRadians(this._mag));
                    break;
                case a:
                    this._isEnabled = !!l;
                    break
            }
        }
        GetDebuggerProperties() {
            const e = "behaviors.sin";
            return [{
                title: "$" + this.GetBehaviorType().GetName(),
                properties: [{
                    name: e + ".properties.enabled.name",
                    value: this._isEnabled,
                    onedit: e => this._SetEnabled(e)
                }, {
                    name: e + ".properties.period.name",
                    value: this._period,
                    onedit: e => this._period = e
                }, {
                    name: e + ".properties.magnitude.name",
                    value: this._mag,
                    onedit: e => this._mag = e
                }, {
                    name: e + ".debugger.value",
                    value: this.WaveFunc(this._i) * this._mag
                }]
            }]
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.Sin.Cnds = {
        IsEnabled() {
            return this._isEnabled
        },
        CompareMovement(e) {
            return this._movement === e
        },
        ComparePeriod(t, n) {
            return e.compare(this._period, t, n)
        },
        CompareMagnitude(t, n) {
            return this._movement === 5 ? e.compare(this._mag, t, e.toRadians(n)) : e.compare(this._mag, t, n)
        },
        CompareWave(e) {
            return this._wave === e
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.Sin.Acts = {
        SetEnabled(e) {
            this._SetEnabled(e !== 0)
        },
        SetPeriod(e) {
            this._period = e
        },
        SetMagnitude(t) {
            this._mag = t, this._movement === 5 && (this._mag = e.toRadians(this._mag))
        },
        SetMovement(t) {
            this._movement === 5 && t !== 5 && (this._mag = e.toDegrees(this._mag)), this._movement = t, this.Init()
        },
        SetWave(e) {
            this._wave = e
        },
        SetPhase(e) {
            const t = Math.PI * 2;
            this._i = e * t % t, this._UpdateFromPhase()
        },
        UpdateInitialState() {
            this.Init()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.Sin.Exps = {
        CyclePosition() {
            return this._i / (2 * Math.PI)
        },
        Period() {
            return this._period
        },
        Magnitude() {
            return this._movement === 5 ? e.toDegrees(this._mag) : this._mag
        },
        Value() {
            return this.WaveFunc(this._i) * this._mag
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.Timer = class TimerBehavior extends e.SDKBehaviorBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.Timer.Type = class TimerType extends e.SDKBehaviorTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.Timer.SingleTimer = class SingleTimer {
        constructor(t, n, s, o) {
            this._current = e.New(e.KahanSum), this._current.Set(t || 0), this._total = e.New(e.KahanSum), this._total.Set(n || 0), this._duration = s || 0, this._isRegular = !!o, this._isPaused = !1
        }
        GetCurrentTime() {
            return this._current.Get()
        }
        GetTotalTime() {
            return this._total.Get()
        }
        GetDuration() {
            return this._duration
        }
        SetPaused(e) {
            this._isPaused = !!e
        }
        IsPaused() {
            return this._isPaused
        }
        Add(e) {
            this._current.Add(e), this._total.Add(e)
        }
        HasFinished() {
            return this._current.Get() >= this._duration
        }
        Update() {
            if (this.HasFinished())
                if (this._isRegular) this._current.Subtract(this._duration);
                else return !0;
            return !1
        }
        SaveToJson() {
            return {
                c: this._current.Get(),
                t: this._total.Get(),
                d: this._duration,
                r: this._isRegular,
                p: this._isPaused
            }
        }
        LoadFromJson(e) {
            this._current.Set(e.c), this._total.Set(e.t), this._duration = e.d, this._isRegular = !!e.r, this._isPaused = !!e.p
        }
    }, e.Behaviors.Timer.Instance = class TimerInstance extends e.SDKBehaviorInstanceBase {
        constructor(e) {
            super(e), this._timers = new Map
        }
        Release() {
            this._timers.clear(), super.Release()
        }
        _UpdateTickState() {
            this._timers.size > 0 ? (this._StartTicking(), this._StartTicking2()) : (this._StopTicking(), this._StopTicking2())
        }
        SaveToJson() {
            const e = {};
            for (const [t, n] of this._timers.entries()) e[t] = n.SaveToJson();
            return e
        }
        LoadFromJson(t) {
            this._timers.clear();
            for (const [s, o] of Object.entries(t)) {
                const n = new e.Behaviors.Timer.SingleTimer;
                n.LoadFromJson(o), this._timers.set(s, n)
            }
            this._UpdateTickState()
        }
        Tick() {
            const e = this._runtime.GetDt(this._inst);
            for (const t of this._timers.values()) t.IsPaused() || t.Add(e)
        }
        Tick2() {
            for (const [e, t] of this._timers.entries()) {
                const n = t.Update();
                n && this._timers.delete(e)
            }
        }
        GetDebuggerProperties() {
            return [{
                title: "behaviors.timer.debugger.timers",
                properties: [...this._timers.entries()].map(e => ({
                    name: "$" + e[0],
                    value: `${Math.round(e[1].GetCurrentTime()*10)/10} / ${Math.round(e[1].GetDuration()*10)/10}`
                }))
            }]
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.Timer.Cnds = {
        OnTimer(e) {
            const t = this._timers.get(e.toLowerCase());
            return !!t && t.HasFinished()
        },
        IsTimerRunning(e) {
            return this._timers.has(e.toLowerCase())
        },
        IsTimerPaused(e) {
            const t = this._timers.get(e.toLowerCase());
            return t && t.IsPaused()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.Timer.Acts = {
        StartTimer(t, n, s) {
            const o = new e.Behaviors.Timer.SingleTimer(0, 0, t, n === 1);
            this._timers.set(s.toLowerCase(), o), this._UpdateTickState()
        },
        StopTimer(e) {
            this._timers.delete(e.toLowerCase()), this._UpdateTickState()
        },
        PauseResumeTimer(e, t) {
            const n = this._timers.get(e.toLowerCase());
            n && n.SetPaused(t === 0)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.Timer.Exps = {
        CurrentTime(e) {
            const t = this._timers.get(e.toLowerCase());
            return t ? t.GetCurrentTime() : 0
        },
        TotalTime(e) {
            const t = this._timers.get(e.toLowerCase());
            return t ? t.GetTotalTime() : 0
        },
        Duration(e) {
            const t = this._timers.get(e.toLowerCase());
            return t ? t.GetDuration() : 0
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.shadowcaster = class ShadowCasterBehavior extends e.SDKBehaviorBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.shadowcaster.Type = class ShadowCasterType extends e.SDKBehaviorTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
}
"use strict";
{
    const s = self.C3,
        e = 0,
        t = 1,
        n = 2;
    s.Behaviors.shadowcaster.Instance = class ShadowCasterInstance extends s.SDKBehaviorInstanceBase {
        constructor(s, o) {
            super(s), o ? (this.SetHeight(o[e]), this.SetTag(o[t]), this.SetEnabled(!!o[n])) : (this.SetHeight(100), this.SetTag(""), this.SetEnabled(!0))
        }
        Release() {
            super.Release()
        }
        SetHeight(e) {
            this._inst.GetSavedDataMap().set("shadowcasterHeight", e)
        }
        GetHeight() {
            return this._inst.GetSavedDataMap().get("shadowcasterHeight")
        }
        SetTag(e) {
            this._inst.GetSavedDataMap().set("shadowcasterTag", e)
        }
        GetTag() {
            return this._inst.GetSavedDataMap().get("shadowcasterTag")
        }
        SetEnabled(e) {
            this._inst.GetSavedDataMap().set("shadowcasterEnabled", !!e)
        }
        IsEnabled() {
            return this._inst.GetSavedDataMap().get("shadowcasterEnabled")
        }
        SaveToJson() {
            return {
                h: this.GetHeight(),
                t: this.GetTag(),
                e: this.IsEnabled()
            }
        }
        LoadFromJson(e) {
            this.SetHeight(e.h), this.SetTag(e.t), this.SetEnabled(e.e)
        }
        GetPropertyValueByIndex(s) {
            switch (s) {
                case e:
                    return this.GetHeight();
                case t:
                    return this.GetTag();
                case n:
                    return this.IsEnabled()
            }
        }
        SetPropertyValueByIndex(s, o) {
            switch (s) {
                case e:
                    this.SetHeight(o);
                    break;
                case t:
                    this.SetTag(o);
                    break;
                case n:
                    this.SetEnabled(o);
                    break
            }
        }
        GetDebuggerProperties() {
            const e = "behaviors.shadowcaster",
                t = this._inst.GetSavedDataMap();
            return [{
                title: "$" + this.GetBehaviorType().GetName(),
                properties: [{
                    name: e + ".properties.enabled.name",
                    value: this.IsEnabled(),
                    onedit: e => this.SetEnabled(e)
                }, {
                    name: e + ".properties.height.name",
                    value: this.GetHeight(),
                    onedit: e => this.SetHeight(e)
                }, {
                    name: e + ".properties.tag.name",
                    value: this.GetTag(),
                    onedit: e => this.SetTag(e)
                }]
            }]
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.shadowcaster.Cnds = {
        IsEnabled() {
            return this.IsEnabled()
        },
        CompareHeight(t, n) {
            return e.compare(this.GetHeight(), t, n)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.shadowcaster.Acts = {
        SetEnabled(e) {
            this.SetEnabled(e)
        },
        SetHeight(e) {
            this.GetHeight() !== e && (this.SetHeight(e), this._runtime.UpdateRender())
        },
        SetTag(e) {
            this.GetTag() !== e && (this.SetTag(e), this._runtime.UpdateRender())
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.shadowcaster.Exps = {
        Height() {
            return this.GetHeight()
        },
        Tag() {
            return this.GetTag()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.MoveTo = class MoveToBehavior extends e.SDKBehaviorBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.MoveTo.Type = class MoveToType extends e.SDKBehaviorTypeBase {
        constructor(e) {
            super(e)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
}
"use strict";
{
    const e = self.C3,
        l = self.IBehaviorInstance,
        n = 0,
        s = 1,
        o = 2,
        i = 3,
        a = 4,
        r = 5,
        c = 6;
    e.Behaviors.MoveTo.Instance = class MoveToInstance extends e.SDKBehaviorInstanceBase {
        constructor(t, l) {
            super(t), this._maxSpeed = 200, this._acc = 600, this._dec = 600, this._rotateSpeed = 0, this._setAngle = !0, this._stopOnSolids = !1, this._isEnabled = !0, this._speed = 0, this._movingAngle = this.GetWorldInfo().GetAngle(), this._waypoints = [], l && (this._maxSpeed = l[n], this._acc = l[s], this._dec = l[o], this._rotateSpeed = e.toRadians(l[i]), this._setAngle = l[a], this._stopOnSolids = l[r], this._isEnabled = l[c])
        }
        Release() {
            super.Release()
        }
        SaveToJson() {
            return {
                ms: this._maxSpeed,
                acc: this._acc,
                dec: this._dec,
                rs: this._rotateSpeed,
                sa: this._setAngle,
                sos: this._stopOnSolids,
                s: this._speed,
                ma: this._movingAngle,
                wp: this._waypoints.map(e => ({
                    x: e.x,
                    y: e.y
                })),
                e: this._isEnabled
            }
        }
        LoadFromJson(e) {
            this._maxSpeed = e.ms, this._acc = e.acc, this._dec = e.dec, this._rotateSpeed = e.rs, this._setAngle = e.sa, this._stopOnSolids = e.sos, this._speed = e.s, this._movingAngle = e.ma, this._waypoints = e.wp.map(e => ({
                x: e.x,
                y: e.y
            })), this._SetEnabled(e.e), this._isEnabled && this._waypoints.length > 0 && this._StartTicking()
        }
        _AddWaypoint(t, n, s) {
            s && e.clearArray(this._waypoints), this._waypoints.push({
                x: t,
                y: n
            }), this._isEnabled && this._StartTicking()
        }
        _GetWaypointCount() {
            return this._waypoints.length
        }
        _GetWaypointXAt(e) {
            return e = Math.floor(e), e < 0 || e >= this._waypoints.length ? 0 : this._waypoints[e].x
        }
        _GetWaypointYAt(e) {
            return e = Math.floor(e), e < 0 || e >= this._waypoints.length ? 0 : this._waypoints[e].y
        }
        _IsMoving() {
            return this._waypoints.length > 0
        }
        _Stop() {
            e.clearArray(this._waypoints), this._speed = 0, this._StopTicking()
        }
        _GetTargetX() {
            return this._waypoints.length > 0 ? this._waypoints[0].x : 0
        }
        _GetTargetY() {
            return this._waypoints.length > 0 ? this._waypoints[0].y : 0
        }
        _SetSpeed(e) {
            if (!this._IsMoving()) return;
            this._speed = Math.min(e, this._maxSpeed)
        }
        _GetSpeed() {
            return this._speed
        }
        _SetMaxSpeed(e) {
            this._maxSpeed = Math.max(e, 0), this._SetSpeed(this._speed)
        }
        _GetMaxSpeed() {
            return this._maxSpeed
        }
        _IsRotationEnabled() {
            return this._rotateSpeed !== 0
        }
        Tick() {
            if (!this._isEnabled || !this._IsMoving()) return;
            const n = this._runtime.GetDt(this._inst),
                t = this._inst.GetWorldInfo(),
                l = t.GetX(),
                c = t.GetY(),
                f = t.GetAngle();
            let a = this._speed,
                i = this._maxSpeed;
            const h = this._acc,
                r = this._dec,
                o = this._GetTargetX(),
                s = this._GetTargetY(),
                m = e.angleTo(l, c, o, s);
            let d = !1;
            if (r > 0 && this._waypoints.length === 1) {
                const t = .5 * a * a / r * 1.0001;
                if (d = e.distanceSquared(l, c, o, s) <= t * t, d) {
                    const t = e.distanceTo(l, c, o, s);
                    a = Math.sqrt(2 * r * t), i = a, this._speed = a
                }
            }
            if (this._IsRotationEnabled()) {
                const n = e.angleDiff(this._movingAngle, m);
                if (n > Number.EPSILON) {
                    const a = n / this._rotateSpeed,
                        r = e.distanceTo(t.GetX(), t.GetY(), o, s),
                        c = r / (2 * Math.sin(n)),
                        l = c * n;
                    i = Math.min(i, e.clamp(l / a, 0, this._maxSpeed))
                }
            }
            let p = d ? -r : h;
            const u = Math.min(a * n + .5 * p * n * n, i * n);
            if (d) {
                if (r > 0 && (this._speed = Math.max(this._speed - r * n, 0), this._speed === 0)) {
                    this._OnArrived(t, o, s);
                    return
                }
            } else h === 0 ? this._speed = i : this._speed = Math.min(this._speed + h * n, i);
            if (e.distanceSquared(t.GetX(), t.GetY(), o, s) <= u * u) {
                this._OnArrived(t, o, s);
                return
            }
            this._IsRotationEnabled() ? this._movingAngle = e.angleRotate(this._movingAngle, m, this._rotateSpeed * n) : this._movingAngle = m, t.OffsetXY(Math.cos(this._movingAngle) * u, Math.sin(this._movingAngle) * u), this._setAngle && t.SetAngle(this._movingAngle), t.SetBboxChanged(), this._CheckSolidCollision(l, c, f)
        }
        _OnArrived(t, n, s) {
            t.SetXY(n, s), t.SetBboxChanged(), this._waypoints.shift(), this._waypoints.length === 0 && (this._speed = 0, this._StopTicking()), this.GetScriptInterface().dispatchEvent(e.New(e.Event, "arrived")), this.Trigger(e.Behaviors.MoveTo.Cnds.OnArrived)
        }
        _CheckSolidCollision(t, n, s) {
            const o = this._runtime.GetCollisionEngine();
            if (this._stopOnSolids && o.TestOverlapSolid(this._inst)) {
                this._Stop();
                const i = this._inst.GetWorldInfo(),
                    a = i.GetX(),
                    r = i.GetY(),
                    c = e.angleTo(a, r, t, n),
                    l = e.distanceTo(a, r, t, n);
                o.PushOutSolid(this._inst, Math.cos(c), Math.sin(c), Math.max(l, 1)) || (i.SetXY(t, n), i.SetAngle(s), i.SetBboxChanged()), this.GetScriptInterface().dispatchEvent(e.New(e.Event, "hitsolid")), this.Trigger(e.Behaviors.MoveTo.Cnds.OnHitSolid)
            }
        }
        _IsSetAngle() {
            return this._setAngle
        }
        _SetSetAngle(e) {
            this._setAngle = !!e
        }
        _SetAngleOfMotion(e) {
            if (this._movingAngle = e, this._isEnabled && this._setAngle && !this._IsMoving()) {
                const e = this.GetWorldInfo();
                e.SetAngle(this._movingAngle), e.SetBboxChanged()
            }
        }
        _GetAngleOfMotion() {
            return this._movingAngle
        }
        _SetAcceleration(e) {
            this._acc = Math.max(e, 0)
        }
        _GetAcceleration() {
            return this._acc
        }
        _SetDeceleration(e) {
            this._dec = Math.max(e, 0)
        }
        _GetDeceleration() {
            return this._dec
        }
        _SetRotateSpeed(e) {
            this._rotateSpeed = Math.max(e, 0)
        }
        _GetRotateSpeed() {
            return this._rotateSpeed
        }
        _SetStopOnSolids(e) {
            this._stopOnSolids = !!e
        }
        _IsStopOnSolids() {
            return this._stopOnSolids
        }
        _SetEnabled(e) {
            if (e = !!e, this._isEnabled === e) return;
            this._isEnabled = e, this._isEnabled && this._IsMoving() ? this._StartTicking() : this._StopTicking()
        }
        _IsEnabled() {
            return this._isEnabled
        }
        GetPropertyValueByIndex(t) {
            switch (t) {
                case n:
                    return this._GetMaxSpeed();
                case s:
                    return this._GetAcceleration();
                case o:
                    return this._GetDeceleration();
                case i:
                    return e.toDegrees(this._GetRotateSpeed());
                case a:
                    return this._IsSetAngle();
                case r:
                    return this._IsStopOnSolids();
                case c:
                    return this._IsEnabled()
            }
        }
        SetPropertyValueByIndex(t, l) {
            switch (t) {
                case n:
                    this._SetMaxSpeed(l);
                    break;
                case s:
                    this._SetAcceleration(l);
                    break;
                case o:
                    this._SetDeceleration(l);
                    break;
                case i:
                    this._SetRotateSpeed(e.toRadians(l));
                    break;
                case a:
                    this._SetSetAngle(l);
                    break;
                case r:
                    this._SetStopOnSolids(l);
                    break;
                case c:
                    this._SetEnabled(l);
                    break
            }
        }
        GetDebuggerProperties() {
            const t = "behaviors.moveto";
            return [{
                title: "$" + this.GetBehaviorType().GetName(),
                properties: [{
                    name: t + ".debugger.speed",
                    value: this._GetSpeed(),
                    onedit: e => this._SetSpeed(e)
                }, {
                    name: t + ".debugger.angle-of-motion",
                    value: e.toDegrees(this._GetAngleOfMotion()),
                    onedit: t => this._movingAngle = e.toRadians(t)
                }, {
                    name: t + ".debugger.target-x",
                    value: this._GetTargetX()
                }, {
                    name: t + ".debugger.target-y",
                    value: this._GetTargetY()
                }, {
                    name: t + ".debugger.waypoint-count",
                    value: this._GetWaypointCount()
                }, {
                    name: t + ".properties.max-speed.name",
                    value: this._GetMaxSpeed(),
                    onedit: e => this._SetMaxSpeed(e)
                }, {
                    name: t + ".properties.acceleration.name",
                    value: this._GetAcceleration(),
                    onedit: e => this._SetAcceleration(e)
                }, {
                    name: t + ".properties.deceleration.name",
                    value: this._GetDeceleration(),
                    onedit: e => this._SetDeceleration(e)
                }, {
                    name: t + ".properties.rotate-speed.name",
                    value: e.toDegrees(this._GetRotateSpeed()),
                    onedit: t => this._SetRotateSpeed(e.toRadians(t))
                }, {
                    name: t + ".properties.enabled.name",
                    value: this._IsEnabled(),
                    onedit: e => this._SetEnabled(e)
                }]
            }]
        }
        GetScriptInterfaceClass() {
            return self.IMoveToBehaviorInstance
        }
    };
    const t = new WeakMap;
    self.IMoveToBehaviorInstance = class IMoveToBehaviorInstance extends l {
        constructor() {
            super(), t.set(this, l._GetInitInst().GetSdkInstance())
        }
        moveToPosition(e, n, s = !0) {
            t.get(this)._AddWaypoint(e, n, !!s)
        }
        getTargetX() {
            return t.get(this)._GetTargetX()
        }
        getTargetY() {
            return t.get(this)._GetTargetY()
        }
        getTargetPosition() {
            const e = t.get(this);
            return [e._GetTargetX(), e._GetTargetY()]
        }
        getWaypointCount() {
            return t.get(this)._GetWaypointCount()
        }
        getWaypointX(e) {
            return t.get(this)._GetWaypointXAt(+e)
        }
        getWaypointY(e) {
            return t.get(this)._GetWaypointYAt(+e)
        }
        getWaypoint(e) {
            e = +e;
            const n = t.get(this);
            return [n._GetWaypointXAt(e), n._GetWaypointYAt(e)]
        }
        stop() {
            t.get(this)._Stop()
        }
        get isMoving() {
            return t.get(this)._IsMoving()
        }
        get speed() {
            return t.get(this)._GetSpeed()
        }
        set speed(e) {
            t.get(this)._SetSpeed(e)
        }
        get maxSpeed() {
            return t.get(this)._GetMaxSpeed()
        }
        set maxSpeed(e) {
            t.get(this)._SetMaxSpeed(e)
        }
        get acceleration() {
            return t.get(this)._GetAcceleration()
        }
        set acceleration(e) {
            t.get(this)._SetAcceleration(e)
        }
        get deceleration() {
            return t.get(this)._GetDeceleration()
        }
        set deceleration(e) {
            t.get(this)._SetDeceleration(e)
        }
        get angleOfMotion() {
            return t.get(this)._GetAngleOfMotion()
        }
        set angleOfMotion(e) {
            t.get(this)._SetAngleOfMotion(e)
        }
        get rotateSpeed() {
            return t.get(this)._GetRotateSpeed()
        }
        set rotateSpeed(e) {
            t.get(this)._SetRotateSpeed(e)
        }
        get isStopOnSolids() {
            return t.get(this)._IsStopOnSolids()
        }
        set isStopOnSolids(e) {
            t.get(this)._SetStopOnSolids(e)
        }
        get isEnabled() {
            return t.get(this)._IsEnabled()
        }
        set isEnabled(e) {
            t.get(this)._SetEnabled(e)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.MoveTo.Cnds = {
        IsMoving() {
            return this._IsMoving()
        },
        CompareSpeed(t, n) {
            return e.compare(this._GetSpeed(), t, n)
        },
        IsEnabled() {
            return this._IsEnabled()
        },
        OnArrived() {
            return !0
        },
        OnHitSolid() {
            return !0
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.MoveTo.Acts = {
        MoveToPosition(e, t, n) {
            this._AddWaypoint(e, t, n === 0)
        },
        MoveToObject(e, t, n) {
            if (!e) return;
            const s = e.GetPairedInstance(this._inst);
            if (!s || !s.GetWorldInfo()) return;
            const [o, i] = s.GetImagePoint(t);
            this._AddWaypoint(o, i, n === 0)
        },
        MoveAlongPathfindingPath(t) {
            const s = this._inst.GetBehaviorSdkInstanceFromCtor(e.Behaviors.Pathfinding);
            if (!s) return;
            const n = s._GetPath();
            if (n.length === 0) return;
            for (let e = 0, o = n.length; e < o; ++e) {
                const s = n[e];
                this._AddWaypoint(s.x, s.y, e === 0 && t === 0)
            }
        },
        MoveAlongTimeline(t, n, s) {
            let o = null;
            if (n ? o = t.GetTrackById(n) : o = e.first(t.GetTracks()), !o) return;
            const i = o.GetPropertyTrack("offsetX"),
                a = o.GetPropertyTrack("offsetY");
            if (!i || !a) return;
            const r = [...i.GetPropertyKeyframeValues()],
                c = [...a.GetPropertyKeyframeValues()];
            if (r.length === 0 || c.length === 0) return;
            let l = 0,
                d = 0;
            const u = this._inst.GetWorldInfo();
            i.GetResultMode() === "relative" && (l = u.GetX()), a.GetResultMode() === "relative" && (d = u.GetY());
            for (let e = 0, t = Math.min(r.length, c.length); e < t; ++e) {
                const n = r[e] + l,
                    o = c[e] + d;
                this._AddWaypoint(n, o, e === 0 && s === 0)
            }
        },
        MoveAlongTimelineByName(t, n, s) {
            const o = this._runtime.GetTimelineManager().GetTimelineByName(t);
            if (!o) return;
            e.Behaviors.MoveTo.Acts.MoveAlongTimeline.call(this, o, n, s)
        },
        Stop() {
            this._Stop()
        },
        SetMovingAngle(t) {
            this._SetAngleOfMotion(e.toRadians(t))
        },
        SetSpeed(e) {
            this._SetSpeed(e)
        },
        SetMaxSpeed(e) {
            this._SetMaxSpeed(e)
        },
        SetAcceleration(e) {
            this._SetAcceleration(e)
        },
        SetDeceleration(e) {
            this._SetDeceleration(e)
        },
        SetRotateSpeed(t) {
            this._SetRotateSpeed(e.toRadians(t))
        },
        SetStopOnSolids(e) {
            this._SetStopOnSolids(e)
        },
        SetEnabled(e) {
            this._SetEnabled(e)
        }
    }
}
"use strict";
{
    const e = self.C3;
    e.Behaviors.MoveTo.Exps = {
        Speed() {
            return this._GetSpeed()
        },
        MaxSpeed() {
            return this._GetMaxSpeed()
        },
        Acceleration() {
            return this._GetAcceleration()
        },
        Deceleration() {
            return this._GetDeceleration()
        },
        MovingAngle() {
            return e.toDegrees(this._GetAngleOfMotion())
        },
        RotateSpeed() {
            return e.toDegrees(this._GetRotateSpeed())
        },
        TargetX() {
            return this._GetTargetX()
        },
        TargetY() {
            return this._GetTargetY()
        },
        WaypointCount() {
            return this._GetWaypointCount()
        },
        WaypointXAt(e) {
            return this._GetWaypointXAt(e)
        },
        WaypointYAt(e) {
            return this._GetWaypointYAt(e)
        }
    }
} {
    const e = self.C3;
    self.C3_GetObjectRefTable = function() {
        return [e.Plugins.Sprite, e.Behaviors.Pathfinding, e.Behaviors.EightDir, e.Behaviors.LOS, e.Plugins.Text, e.Plugins.Keyboard, e.Behaviors.solid, e.Behaviors.scrollto, e.Behaviors.Sin, e.Plugins.Mouse, e.Plugins.TiledBg, e.Plugins.Audio, e.Plugins.NinePatch, e.Plugins.gamepad, e.Behaviors.Timer, e.Plugins.TextBox, e.Plugins.sliderbar, e.Plugins.Browser, e.Plugins.progressbar, e.Plugins.Touch, e.Plugins.PlatformInfo, e.Plugins.shadowlight, e.Behaviors.shadowcaster, e.Plugins.Button, e.Behaviors.MoveTo, e.Plugins.System.Cnds.IsGroupActive, e.Plugins.System.Cnds.CompareVar, e.Plugins.System.Cnds.TriggerOnce, e.Behaviors.Pathfinding.Acts.Stop, e.Behaviors.Pathfinding.Acts.FindPath, e.Plugins.Sprite.Exps.X, e.Plugins.Sprite.Exps.Y, e.Plugins.System.Acts.WaitForPreviousActions, e.Behaviors.Pathfinding.Acts.StartMoving, e.Plugins.System.Cnds.ForEach, e.Plugins.Sprite.Cnds.IsOverlapping, e.Plugins.System.Acts.Wait, e.Behaviors.Timer.Acts.StopTimer, e.Plugins.System.Acts.SetVar, e.Plugins.Sprite.Cnds.CompareInstanceVar, e.Plugins.Sprite.Acts.SetInstanceVar, e.Behaviors.LOS.Cnds.HasLOSToObject, e.Plugins.Sprite.Cnds.IsAnimPlaying, e.Behaviors.Pathfinding.Cnds.OnArrived, e.Plugins.Audio.Acts.Stop, e.Plugins.Sprite.Cnds.IsVisible, e.Plugins.Audio.Cnds.IsTagPlaying, e.Plugins.Sprite.Acts.SetVisible, e.Plugins.Audio.Acts.Play, e.Plugins.System.Acts.GoToLayout, e.Plugins.System.Cnds.Else, e.Plugins.Sprite.Acts.SetAnim, e.Plugins.Keyboard.Cnds.OnKey, e.Plugins.System.Cnds.For, e.Behaviors.Pathfinding.Exps.CellSize, e.Behaviors.Pathfinding.Cnds.IsCellObstacle, e.Plugins.System.Exps.loopindex, e.Plugins.System.Acts.CreateObject, e.Plugins.Sprite.Acts.SetSize, e.Plugins.System.Cnds.Every, e.Plugins.System.Exps.random, e.Behaviors.Pathfinding.Cnds.IsMoving, e.Plugins.System.Cnds.PickRandom, e.Plugins.System.Cnds.AngleWithin, e.Behaviors.Pathfinding.Exps.MovingAngle, e.Plugins.Sprite.Acts.SetMirrored, e.Behaviors.Pathfinding.Acts.SetEnabled, e.Plugins.Sprite.Cnds.PickDistance, e.Behaviors.LOS.Cnds.HasLOSToPosition, e.Plugins.Sprite.Acts.SetPosToObject, e.Plugins.Mouse.Cnds.OnObjectClicked, e.Plugins.Touch.Cnds.OnTapGestureObject, e.Plugins.Sprite.Acts.SetEffectParam, e.Plugins.System.Acts.SubVar, e.Plugins.System.Cnds.EveryTick, e.Plugins.Text.Acts.SetText, e.Plugins.Text.Acts.SetVisible, e.Plugins.System.Acts.AddVar, e.Plugins.progressbar.Exps.Maximum, e.Plugins.Sprite.Acts.Destroy, e.Plugins.System.Cnds.CompareTime, e.Plugins.Sprite.Exps.ObjectTypeName, e.Plugins.System.Cnds.OnLayoutStart, e.Plugins.Sprite.Cnds.IsOnScreen, e.Plugins.Sprite.Cnds.CompareFrame, e.Plugins.shadowlight.Acts.SetLightHeight, e.Plugins.shadowlight.Acts.Destroy, e.Plugins.System.Acts.SetLayerVisible, e.Plugins.progressbar.Acts.SetCSSStyle, e.Plugins.progressbar.Acts.SetProgress, e.Plugins.progressbar.Acts.SetMaximum, e.Plugins.Keyboard.Cnds.IsKeyDown, e.Behaviors.EightDir.Acts.SimulateControl, e.Behaviors.EightDir.Cnds.IsMoving, e.Plugins.Sprite.Acts.SetPos, e.Plugins.Sprite.Acts.SetX, e.Plugins.Sprite.Acts.SetY, e.Plugins.System.Acts.SortZOrderByInstVar, e.Behaviors.LOS.Acts.SetRange, e.Behaviors.Pathfinding.Acts.SetMaxSpeed, e.Behaviors.EightDir.Acts.SetMaxSpeed, e.Behaviors.Pathfinding.Acts.SetAcc, e.Behaviors.Pathfinding.Exps.MaxSpeed, e.Behaviors.EightDir.Acts.SetAcceleration, e.Behaviors.EightDir.Exps.MaxSpeed, e.Plugins.Text.Acts.SetPos, e.Plugins.Sprite.Acts.ZMoveToObject, e.Plugins.Sprite.Acts.SetAnimFrame, e.Plugins.shadowlight.Acts.SetPosToObject, e.Plugins.System.Cnds.Compare, e.Behaviors.MoveTo.Acts.MoveToObject, e.Plugins.progressbar.Cnds.CompareProgress, e.Plugins.progressbar.Exps.Progress, e.Plugins.System.Exps.dt, e.Plugins.Sprite.Acts.SetEffectEnabled, e.Plugins.Keyboard.Cnds.OnKeyReleased, e.Plugins.Sprite.Acts.AddInstanceVar, e.Plugins.PlatformInfo.Cnds.IsOnMobile, e.Behaviors.Timer.Acts.StartTimer, e.Behaviors.EightDir.Acts.SetEnabled, e.Behaviors.Timer.Exps.CurrentTime, e.Plugins.Touch.Exps.TouchCount, e.Plugins.System.Cnds.CompareBetween, e.Plugins.Touch.Exps.XAt, e.Plugins.Sprite.Exps.BBoxLeft, e.Plugins.Sprite.Exps.Width, e.Plugins.Sprite.Exps.BBoxRight, e.Plugins.Touch.Exps.YAt, e.Plugins.Sprite.Exps.BBoxTop, e.Plugins.Sprite.Exps.Height, e.Plugins.Sprite.Exps.BBoxBottom, e.Plugins.System.Exps.min, e.Plugins.System.Cnds.IsBetweenAngles, e.Plugins.Audio.Acts.StopAll, e.Plugins.System.Exps.choose, e.Plugins.Mouse.Cnds.IsOverObject, e.Plugins.Sprite.Acts.SetDefaultColor, e.Plugins.Browser.Acts.Close, e.Plugins.NinePatch.Acts.SetVisible, e.Plugins.Sprite.Cnds.IsOutsideLayout, e.Behaviors.Sin.Acts.SetPhase, e.Plugins.Browser.Acts.GoToURL, e.ScriptsInEvents.MainMenu_Event25, e.Plugins.Sprite.Acts.SetScale, e.Plugins.Sprite.Acts.MoveAtAngle, e.Plugins.Sprite.Acts.RotateCounterclockwise, e.Plugins.Sprite.Acts.SetAngle, e.Plugins.Sprite.Exps.Angle, e.Plugins.Text.Acts.TypewriterText, e.Plugins.Text.Cnds.OnTypewriterTextFinished, e.Plugins.Button.Acts.SetChecked, e.Plugins.Mouse.Acts.SetCursor, e.Plugins.NinePatch.Acts.SetDefaultColor, e.Plugins.TextBox.Acts.SetText, e.Plugins.sliderbar.Acts.SetValue, e.Plugins.TextBox.Exps.Text, e.Plugins.sliderbar.Exps.Value, e.Plugins.Button.Cnds.IsChecked, e.ScriptsInEvents.Settings_Event73, e.Plugins.System.Cnds.PickByComparison, e.Plugins.System.Exps.loadingprogress, e.Plugins.System.Cnds.OnLoadFinished]
    }, self.C3_JsPropNameTable = [{
        Area: 0
    }, {
        Area2: 0
    }, {
        Area3: 0
    }, {
        Area4: 0
    }, {
        Area5: 0
    }, {
        Area6: 0
    }, {
        Area7: 0
    }, {
        Area8: 0
    }, {
        Area9: 0
    }, {
        Area10: 0
    }, {
        Area11: 0
    }, {
        Area12: 0
    }, {
        Area13: 0
    }, {
        Area14: 0
    }, {
        Area15: 0
    }, {
        Area16: 0
    }, {
        Area17: 0
    }, {
        Area18: 0
    }, {
        Area19: 0
    }, {
        Area20: 0
    }, {
        Area21: 0
    }, {
        Area22: 0
    }, {
        Button: 0
    }, {
        Area23: 0
    }, {
        Area24: 0
    }, {
        Area25: 0
    }, {
        Area26: 0
    }, {
        Area27: 0
    }, {
        Area28: 0
    }, {
        Area29: 0
    }, {
        Arrow: 0
    }, {
        Arrow2: 0
    }, {
        Arrow3: 0
    }, {
        Arrow4: 0
    }, {
        Arrow5: 0
    }, {
        Arrow6: 0
    }, {
        Arrow7: 0
    }, {
        Arrow8: 0
    }, {
        Arrow9: 0
    }, {
        Arrow10: 0
    }, {
        Arrow11: 0
    }, {
        Arrow12: 0
    }, {
        Arrow13: 0
    }, {
        Arrow14: 0
    }, {
        Arrow15: 0
    }, {
        Arrow16: 0
    }, {
        Yz: 0
    }, {
        Deadd: 0
    }, {
        FYS: 0
    }, {
        Gone: 0
    }, {
        dead: 0
    }, {
        Pathfinding: 0
    }, {
        Crewmate1: 0
    }, {
        Crewmate3: 0
    }, {
        Crewmate4: 0
    }, {
        Crewmate8: 0
    }, {
        Crewmate5: 0
    }, {
        Crewmate6: 0
    }, {
        Crewmate2: 0
    }, {
        Crewmate7: 0
    }, {
        InVent: 0
    }, {
        "8Direction": 0
    }, {
        LineOfSight: 0
    }, {
        Player: 0
    }, {
        Crewmate9: 0
    }, {
        Crew1: 0
    }, {
        Crew2: 0
    }, {
        Crew3: 0
    }, {
        Crew4: 0
    }, {
        Crew5: 0
    }, {
        Crew6: 0
    }, {
        Crew7: 0
    }, {
        Crew8: 0
    }, {
        Crew9: 0
    }, {
        Crew10: 0
    }, {
        PlanetSprites: 0
    }, {
        Keyboard: 0
    }, {
        Solid: 0
    }, {
        Collision: 0
    }, {
        Cafeteria: 0
    }, {
        Cafeteria2: 0
    }, {
        room_weapon: 0
    }, {
        Light: 0
    }, {
        ScrollTo: 0
    }, {
        Sine: 0
    }, {
        Sine2: 0
    }, {
        Camera: 0
    }, {
        Kill: 0
    }, {
        Mouse: 0
    }, {
        CellMarker: 0
    }, {
        Text: 0
    }, {
        room_storage: 0
    }, {
        room_tunnel: 0
    }, {
        room_specimen: 0
    }, {
        launchPadWalls: 0
    }, {
        Lobby: 0
    }, {
        Text2: 0
    }, {
        TiledBackground: 0
    }, {
        BeforeVoting: 0
    }, {
        BeforeVoting2: 0
    }, {
        Text3: 0
    }, {
        Audio: 0
    }, {
        bannerLogo_AmongUs: 0
    }, {
        MainMenu: 0
    }, {
        MainMenu2: 0
    }, {
        Vent: 0
    }, {
        Buttons: 0
    }, {
        "9patch": 0
    }, {
        closeresourcesassets: 0
    }, {
        Text4: 0
    }, {
        AU_SmoothCriminal_S: 0
    }, {
        Sprite: 0
    }, {
        AU_SmoothCriminal_S2: 0
    }, {
        Mainmenubutton: 0
    }, {
        Gamepad: 0
    }, {
        sabotage: 0
    }, {
        Buttons2: 0
    }, {
        Timer: 0
    }, {
        Buttons3: 0
    }, {
        Meltdown: 0
    }, {
        Buttons4: 0
    }, {
        HQAssets: 0
    }, {
        Medbayscanner: 0
    }, {
        Coms: 0
    }, {
        HQAssets2: 0
    }, {
        AdminCommsElecEngineHallsShieldsStorage: 0
    }, {
        Text5: 0
    }, {
        Buttons5: 0
    }, {
        engineAlign_slider: 0
    }, {
        engineAlign_slider2: 0
    }, {
        TextInput: 0
    }, {
        Buttons6: 0
    }, {
        SliderBar: 0
    }, {
        Text6: 0
    }, {
        PlanetSprites2: 0
    }, {
        PlanetSprites3: 0
    }, {
        PlanetSprites4: 0
    }, {
        HQAssets3: 0
    }, {
        Buttons7: 0
    }, {
        Browser: 0
    }, {
        lights: 0
    }, {
        Buttons8: 0
    }, {
        Text7: 0
    }, {
        ProgressBar: 0
    }, {
        Buttons9: 0
    }, {
        Text8: 0
    }, {
        PlanetSprites5: 0
    }, {
        AdminCommsElecEngineHallsShieldsStorage2: 0
    }, {
        AdminCommsElecEngineHallsShieldsStorage3: 0
    }, {
        AdminCommsElecEngineHallsShieldsStorage4: 0
    }, {
        AdminCommsElecEngineHallsShieldsStorage5: 0
    }, {
        Touch: 0
    }, {
        a: 0
    }, {
        d: 0
    }, {
        TStick: 0
    }, {
        Selected: 0
    }, {
        offsetx: 0
    }, {
        offsety: 0
    }, {
        r: 0
    }, {
        TouchID: 0
    }, {
        left: 0
    }, {
        TStick2: 0
    }, {
        PlatformInfo: 0
    }, {
        SliderBar2: 0
    }, {
        Text9: 0
    }, {
        SliderBar3: 0
    }, {
        Text10: 0
    }, {
        Buttons10: 0
    }, {
        hats: 0
    }, {
        engineAlign_slider3: 0
    }, {
        engineAlign_slider4: 0
    }, {
        AdminCommsElecEngineHallsShieldsStorage6: 0
    }, {
        SliderBar4: 0
    }, {
        Text11: 0
    }, {
        Sprite2: 0
    }, {
        TiledBackground2: 0
    }, {
        TiledBackground3: 0
    }, {
        ShadowLight: 0
    }, {
        ShadowCaster: 0
    }, {
        Wallslight: 0
    }, {
        room_broadcast: 0
    }, {
        TiledBackground4: 0
    }, {
        PlanetSprites6: 0
    }, {
        room_science: 0
    }, {
        PlanetSprites7: 0
    }, {
        PlanetSprites8: 0
    }, {
        PlanetSprites9: 0
    }, {
        Button2: 0
    }, {
        Lobby2: 0
    }, {
        backbutton: 0
    }, {
        engineAlign_slider5: 0
    }, {
        engineAlign_slider6: 0
    }, {
        MoveTo: 0
    }, {
        Pets: 0
    }, {
        MainMenu3: 0
    }, {
        abcskeld: 0
    }, {
        Sprite3: 0
    }, {
        Sprite4: 0
    }, {
        Sprite5: 0
    }, {
        Sprite6: 0
    }, {
        Sprite7: 0
    }, {
        Button3: 0
    }, {
        Lobby3: 0
    }, {
        download: 0
    }, {
        download2: 0
    }, {
        Sine3: 0
    }, {
        MainScreenCrew: 0
    }, {
        Zorder: 0
    }, {
        Crewmates: 0
    }, {
        Areas: 0
    }, {
        Report: 0
    }, {
        Players: 0
    }, {
        Arrows: 0
    }, {
        Sabotagemap: 0
    }, {
        KillDistance: 0
    }, {
        KillCooldown: 0
    }, {
        PlayerCount: 0
    }, {
        Found: 0
    }, {
        Sabotage: 0
    }, {
        SabotageCooldown: 0
    }, {
        TUM: 0
    }, {
        progress: 0
    }, {
        sus: 0
    }, {
        EGR: 0
    }, {
        About: 0
    }, {
        DomainCheck: 0
    }, {
        link1: 0
    }, {
        link2: 0
    }, {
        link3: 0
    }, {
        link4: 0
    }, {
        link5: 0
    }, {
        Name1: 0
    }, {
        Name2: 0
    }, {
        Name3: 0
    }, {
        Name4: 0
    }, {
        Name5: 0
    }, {
        Name6: 0
    }, {
        Name7: 0
    }, {
        Name8: 0
    }, {
        Name9: 0
    }, {
        Voted: 0
    }, {
        Vote: 0
    }, {
        Color: 0
    }, {
        PlayerName: 0
    }, {
        MaxKillCooldown: 0
    }, {
        Speed: 0
    }, {
        hat: 0
    }, {
        TaskBar: 0
    }, {
        shadows: 0
    }, {
        pet: 0
    }, {
        MapNumber: 0
    }, {
        hdSkeld: 0
    }, {
        Shared: 0
    }]
}
"use strict";
{
    const e = self.C3;

    function unaryminus(e) {
        return typeof e == "number" ? -e : e
    }

    function bothNumbers(e, t) {
        return typeof e == "number" && typeof t == "number"
    }

    function add(e, t) {
        return bothNumbers(e, t) ? e + t : e
    }

    function subtract(e, t) {
        return bothNumbers(e, t) ? e - t : e
    }

    function multiply(e, t) {
        return bothNumbers(e, t) ? e * t : e
    }

    function divide(e, t) {
        return bothNumbers(e, t) ? e / t : e
    }

    function mod(e, t) {
        return bothNumbers(e, t) ? e % t : e
    }

    function pow(e, t) {
        return bothNumbers(e, t) ? Math.pow(e, t) : e
    }

    function and(e, t) {
        if (typeof e == "string" || typeof t == "string") {
            let n, s;
            return typeof e == "number" ? n = (Math.round(e * 1e10) / 1e10).toString() : n = e, typeof t == "number" ? s = (Math.round(t * 1e10) / 1e10).toString() : s = t, n + s
        }
        return e && t ? 1 : 0
    }

    function or(e, t) {
        return bothNumbers(e, t) ? e || t ? 1 : 0 : e
    }
    self.C3_ExpressionFuncs = [() => "Crewmate", () => "Meltdown", () => 1, e => {
        const t = e._GetNode(0);
        return () => t.ExpObject()
    }, () => .5, () => "ded", () => 25, () => 0, e => {
        const t = e._GetNode(0).GetVar();
        return () => t.GetValue() + 5
    }, () => "Lights", () => "Found you slipping", () => "Goinginvent", () => "Crewmate Report", () => "die", () => "r", () => -5, () => 3, () => "", () => "Meeting", () => "Crewmate Pathfinding", () => "x", e => {
        const t = e._GetNode(0);
        return () => 5926 / t.ExpBehavior()
    }, () => "y", e => {
        const t = e._GetNode(0);
        return () => 5e3 / t.ExpBehavior()
    }, e => {
        const t = e._GetNode(0).GetBoundMethod();
        return () => t("x")
    }, e => {
        const t = e._GetNode(0).GetBoundMethod();
        return () => t("y")
    }, () => "Player", e => {
        const t = e._GetNode(0).GetBoundMethod(),
            n = e._GetNode(1);
        return () => t("x") * n.ExpBehavior()
    }, e => {
        const t = e._GetNode(0).GetBoundMethod(),
            n = e._GetNode(1);
        return () => t("y") * n.ExpBehavior()
    }, e => {
        const t = e._GetNode(0);
        return () => t.ExpBehavior()
    }, () => "Crewmate 1", e => {
        const t = e._GetNode(0).GetBoundMethod();
        return () => Math.floor(t(1, 5))
    }, () => 60, () => 180, () => "walk", () => "idle", () => "Crewmate 2", () => "Crewmate 3", () => "Crewmate 4", () => "Crewmate 5", () => "Crewmate 6", () => "Crewmate 7", () => "Crewmate 8", () => "Crewmate 9", () => "Crewmates Killing", e => {
        const t = e._GetNode(0).GetVar();
        return () => t.GetValue()
    }, () => "OutLine", () => "Brightness", () => 100, () => 50, e => {
        const t = e._GetNode(0).GetBoundMethod();
        return () => Math.floor(t(5, 10))
    }, e => {
        const t = e._GetNode(0).GetBoundMethod();
        return () => Math.floor(t(10))
    }, () => 4, () => 2, () => -10, () => 6, () => "Collision", () => "a", () => "background", () => "lime", e => {
        const t = e._GetNode(0).GetVar();
        return () => t.GetValue() + 2.5
    }, e => {
        const t = e._GetNode(0);
        return () => t.ExpObject() - 40
    }, t => {
        const n = t._GetNode(0),
            s = t._GetNode(1);
        return () => e.lerp(n.ExpObject(), s.ExpObject(), .09)
    }, t => {
        const n = t._GetNode(0),
            s = t._GetNode(1);
        return () => e.lerp(n.ExpObject(), s.ExpObject() - 40, .09)
    }, e => {
        const t = e._GetNode(0).GetVar();
        return () => and("Time until Meltdown: ", t.GetValue())
    }, e => {
        const t = e._GetNode(0);
        return () => t.ExpBehavior() + 500
    }, e => {
        const t = e._GetNode(0);
        return () => t.ExpObject() - 120
    }, t => {
        const n = t._GetNode(0),
            s = t._GetNode(1),
            o = t._GetNode(2),
            i = t._GetNode(3);
        return () => e.distanceTo(n.ExpObject(), s.ExpObject(), o.ExpObject(), i.ExpObject())
    }, () => 75, () => 500, e => {
        const t = e._GetNode(0);
        return () => t.ExpObject() - 150
    }, e => {
        const t = e._GetNode(0),
            n = e._GetNode(1).GetBoundMethod();
        return () => t.ExpObject() + n() * 10
    }, () => "On", () => "Default", () => "Open", () => .2, () => 57, () => 30, () => "M", e => {
        const t = e._GetNode(0);
        return () => t.ExpBehavior("ded")
    }, () => 24.99, () => -7, () => "1", () => "2", () => "3", () => "4", () => "5", () => "6", () => "ReplaceSolidColor2", () => 195, () => "ReplaceSolidColor", () => 143, () => 8, () => 1781302, () => 856604, () => "ReplaceSolidColor4", () => 16760576, () => 6840845, () => 3235377, () => 1199906, () => 621276, () => 626638, () => 5, () => 1579547, () => 255, () => "Thumbstick", () => "t", e => {
        const t = e._GetNode(0).GetBoundMethod();
        return () => t() - 1
    }, e => {
        const t = e._GetNode(0).GetBoundMethod(),
            n = e._GetNode(1).GetBoundMethod();
        return () => t(n(), "HUD")
    }, e => {
        const t = e._GetNode(0),
            n = e._GetNode(1);
        return () => t.ExpObject() - n.ExpObject() * 2
    }, e => {
        const t = e._GetNode(0),
            n = e._GetNode(1);
        return () => t.ExpObject() + n.ExpObject() * 2
    }, t => {
        const n = t._GetNode(0),
            s = t._GetNode(1),
            o = t._GetNode(2).GetBoundMethod(),
            i = t._GetNode(3).GetBoundMethod(),
            a = t._GetNode(4).GetBoundMethod(),
            r = t._GetNode(5).GetBoundMethod();
        return () => e.toDegrees(e.angleTo(n.ExpObject(), s.ExpObject(), o(i(), "HUD"), a(r(), "HUD")))
    }, t => {
        const n = t._GetNode(0),
            s = t._GetNode(1),
            o = t._GetNode(2).GetBoundMethod(),
            i = t._GetNode(3).GetBoundMethod(),
            a = t._GetNode(4).GetBoundMethod(),
            r = t._GetNode(5).GetBoundMethod();
        return () => e.distanceTo(n.ExpObject(), s.ExpObject(), o(i(), "HUD"), a(r(), "HUD"))
    }, e => {
        const t = e._GetNode(0).GetBoundMethod(),
            n = e._GetNode(1),
            s = e._GetNode(2),
            o = e._GetNode(3);
        return () => t(n.ExpInstVar(), s.ExpObject() / 2 - o.ExpObject() / 3)
    }, t => {
        const n = t._GetNode(0),
            s = t._GetNode(1),
            o = t._GetNode(2);
        return () => n.ExpObject() + s.ExpInstVar() * Math.cos(e.toRadians(o.ExpInstVar()))
    }, t => {
        const n = t._GetNode(0),
            s = t._GetNode(1),
            o = t._GetNode(2);
        return () => n.ExpObject() + s.ExpInstVar() * Math.sin(e.toRadians(o.ExpInstVar()))
    }, () => "Simulate Controls", e => {
        const t = e._GetNode(0);
        return () => t.ExpInstVar()
    }, () => -60, () => 150, () => 120, () => 240, () => 210, () => 330, () => "ReplaceSolidColor3", () => "31", () => "0", () => 9, e => {
        const t = e._GetNode(0).GetBoundMethod();
        return () => t("1", "2", "3")
    }, e => {
        const t = e._GetNode(0).GetBoundMethod();
        return () => t("JORDAN", "AMERICA", "GOANTRONI", "MEXICO", "1", "1Malta", "20", "addnorthk", "canada", "canadawin", "Canadian", "DOGO", "kittycorn", "Love", "shopatshara", "superstar", "teamtrees", "TeamUSA", "WIN", "zephyr", "10001", "HydroFlask", "TheCamilo", "", "00", "00Elixr", "00GUNNER", "00USA4EVR", "PAKAMMAD", "USA", "", "KONG", "w", "", "OTTOMAN", "0", "3", "Dl", "l", "butcheckBo", "FRANCE", "yana", "GDDaninot", "HaHax2broJ", "IXFIREPWR", "IYIDirili", "PParynhar", "PQuestOn", "SM", "SMPRO", "TTARGET", "TTFatso", "GOGREEN", "Russia", "SDD", "MYTHICAL", "AZhhhh", "Trump2020", "ABAB", "Royo", "siam", "strontium", "TypicalYT", "COLOMBIA", "COLOMBIA", "", "", "Yee", "KONG", "", "keysmash", "algeria", "", "Cube", "", "", "", "emily", "France", "ELENAMX", "Emma", "OHFRANCIS", " Huxery ", "AMERICA", "", "", "", "for", "0TanqR0YT", "11000", "11", "100legal", "100PLS", "100BOY", "10005", "10001", "100000like", "123yurdead", "1234567890hm", "1W", "2shotsVodka", "2cuz", "2cuzsweden", "20BOMSPLS", "20cent", "22W", "2bias", "2mokeycat", "3582", "3D", "3r1k", "5worldcups", "5worldcups", "6893", "69420fu", "6RSKY9", "700fu", "7snoo", "8D69", "a", "ABitTired", "acat", "agoodname", "AMAAAADMAN", "aperson", "Asmallloan", "A", "aguy", "APerson", "AA", "aaa", "aaaaa", "aaaaaaa", "aakashtheboi", "Aakhyan", "aakkash", "aaon", "Aarav", "aarope", "aayashpro", "aayyy", "AB", "ababua", "abbebg", "bb", "Abby", "Abc", "Abc123", "abcde", "abcdefg", "abcneat123", "Abdul", "Abdulaziz", "abdullahhi", "abdulmajid", "abekat", "abi", "abir", "ABIR216", "Aboriginal", "AceOfSpades", "achoo", "achtung", "acts238bi", "addevil", "ADA", "Adam", "ADAWE", "ADDJZD1029", "Addie", "Addie", "ADR", "Adrian", "ADROS", "adsa", "ADSF", "Adventurer2", "", "aeiouyyyy", "AG31", "agentx9999", "Agi", "Agtzsafety", "ahbaba", "ahh", "ahhaha", "ahhh", "ahmad", "aid", "Aidan", "Aiden", "AIDENROBINS", "aids", "Aigarosik", "air", "AIRFORCEGIRL", "Ais", "aiskkdSK", "aj", "AJPLAYZ", "AJYomastr", "ak47", "AK47juice", "akaash", "akaysha", "Akbar", "Akira", "Al", "alabama", "AlanEdam", "AlanWalker", "alaniakacat", "ALB", "Alba", "alban", "albania", "Albania4ever", "albert", "AlbertEnstin", "Albertnoobb", "alegor", "AlejoToro", "alek", "alelilisisi", "AlenJins", "alenroshni", "AleQu", "Alex", "alexa190", "alexandra", "Alexey", "ALEXIS", "alexx", "Alexzandra", "algeria", "algerianboy", "algirianboy", "Ali", "aliraza", "AliSh", "ALI07", "AliA", "alice", "aliv", "ALIVE", "AllBlacks", "allahakbar", "allect", "allia", "Almidorya", "alphawolf", "Alred", "Alvato", "alx", "Alyssa", "AMsavage26", "amanda", "amantegado", "Amarica", "Ambushflex", "Amelcia", "amelie", "AMERICAYEET", "americabest", "AMERICABABY", "ametz", "amgfriends", "amitsharma", "Ammar", "Anarchy", "anasaqil", "Anasun", "Ancalagon", "ANCIENT01", "AndIoop", "andres", "Andrey", "andrey22807", "android", "Andromeda", "andrw22", "angel", "angelamunt", "angelo1510", "angeloabas", "angg31", "animals101", "Aninha", "anis", "anitaa", "anna", "annabortion", "ANNAFEDE", "Anonihouse", "Anonymous", "ANONYMOYS", "anyd", "", "AON", "apepa", "AppleInc", "applypie", "Arabsno1", "araceli", "aragatina", "Ararat", "Ardian", "argentina", "arhaan", "AriANNA", "ARIANNA77", "ariel", "Aritz", "Arizona", "armagedon", "ARMENIA", "rpdvezr", "artem", "arthur", "Artury", "ARYANRACE", "as20", "Asd", "asdf", "asdfgh", "Ash", "ashe", "ashley", "Ashmita", "AShoky", "AsianMan", "aspessoas", "aspod", "asta", "ATAHAN", "atankwadi", "atizaz", "AtletiMadrid", "AtomicNut", "attack70", "aubrie", "Audrey", "Auri3", "Aurora", "AUS", "Ausbest", "Ausie", "Aussie", "aussie1", "AUSSIE2", "AUSSIE64", "AussieAussi", "Aussiebeast", "AUSSIEROO", "AussieAussi", "aussie18", "austin ", "Austrailia", "Australia", "Australia1", "ava", "AvadaKedavra", "Avagyan", "Avalak13", "avalina", "Avans", "avd", "aver", "avi", "AvocadoToast", "Avrey", "awd", "awe", "Awesome", "awienchewie", "axelliamkl", "AXIS", "Ayaan", "ayaz", "AYBARS", "ayberk", "ayden", "Aytric", "Ayuma", "az", "azan", "AZERBAIJAN", "Azerbaycan", "AZRBAYCAN", "azz", "Azzyland", "B", "BGFCRTEN", "BSAUCE3gam", "b2by", "bab", "Babilawi", "Baby", "babylips", "babyJack7", "BACKINNAM", "badbunny", "badr", "Baguette", "Bahartet", "Bahrain", "bahraini3451", "Baju", "baka", "BALI", "baligeul", "bala", "balta", "Balzac", "bam", "bamam", "BAN", "banana", "Bananaboat", "bananaman", "bananapotato", "Bangladesh", "Bara", "Barni", "barrhet", "bart", "bartsimpson", "bartolo", "Baryonx", "Bschti", "basem", "Basher", "batty", "bautista", "bazing", "BB", "bbb", "bbobbobo", "BC190", "bd212", "BeakersLab", "Beanos", "bear", "Beast", "BeastMode", "Beau", "Becca", "BEEFCURRY", "beep", "Bees", "bejnjamin", "Belarus2", "belgium", "Belgiumteam", "Bella360", "bellathecat", "Bello", "BelynG", "ben", "bendover", "BN", "Benet", "benitocamela", "Benji", "berddewalvis", "Bernie2020", "Bernie2020", "best", "BESTBOSS", "BestPlayer", "bestio", "Bestie2", "bestisindia", "besty", "bfcjfv", "BFFs", "bh", "bhhygu", "bhoongar", "bia", "biche", "bicth", "bielARTICO", "Big", "bigboi", "bigbois", "bigchicken", "bigdad", "bigdaddy", "bige", "BIGMAC", "bignicca", "bigpapa", "BIGSHAQ", "bigsista", "bigslangers", "bigboy", "BigBoyNOOO", "bigbrain", "BIGBRAINS", "bigboy1158", "bigchungus", "BigChungus69", "BIGETRON", "BIGGERSON", "BIGGGGBOY", "biggiecheese", "bigpeen69", "BigRgo", "Bigs", "BigT", "bigtoe", "BiH", "BiiGMakk", "BijuMike", "bill", "billaraa1", "Billy", "billybai", "Billz", "Bin", "Binder", "bip", "biroBR", "bishop", "Bj", "bjorn", "BK", "Bl3ckJackYT", "BL7", "BlackFlash", "Blacky", "blake", "blantra", "Blaster", "BLClRE", "Bleh", "bleumeanie", "bling", "Blink", "BlipBlop", "BLITZ", "Blizzard156", "Blob", "BLOBBOY", "Blobble", "blobs", "blobsly", "Blocked", "BLOCKITY", "Blood4Life", "blossom", "blow", "blowme", "bluthebest", "blubblub", "blue7y", "blueberry", "blueberrypie", "blueboy", "bluebronco7", "bluhbluh", "blur", "Blur2", "blur3", "BM", "bmw", "BO", "boas", "bob", "bobesponja", "bobross", "bobthenoob", "bob100", "bob2", "boba", "bobbone", "bobert", "BOBomb", "bobplayz", "bobthebuilde", "bobyz", "Bochisback", "bode", "boe", "BOEF", "Bog", "bogleo", "BogDan", "Bognar", "Boho", "boi", "boiii", "boizzzzzzzzz", "bojkata", "bok", "boneless", "Bonitobr", "Bonny", "boo", "boof", "BOOFI", "booger08", "Boohkkake", "BOOOOOOOOOY", "BOOP", "boot", "bop", "bordbistro", "brkviking", "borna", "bosna", "BOSS", "bossTWBM", "BossDude20", "bot", "botboooooot", "BOT20", "BOT1", "bot1212", "bot12122", "botaaaaaa", "Bots", "bouji", "boy", "boylovesme", "BoysInGreen", "boyviking", "bozo", "braaaaaaaaap", "braaaaaap", "brady", "Brainiac14", "Brasil", "BRASILCARAI", "brasilmatt", "BRAXTON", "Brayan", "BRAZIL", "Brazilmito", "BRAZILMITO2", "Brazilmito", "BRAZILRULES", "BrazilSnake", "brenaopvp", "Brendoo1", "Brett", "Brian", "brickboss", "BRITIAN", "British", "BritSpeed", "bro", "Brocklysan", "brofourt", "Brookieuwu", "brooklynn", "brooxslugger", "BROSKITO", "BrownBear", "bru", "Bruh", "bruklin", "Brunofoda", "brushmyhat", "BRUTE", "bryleigh", "BTS", "btsarmy", "bubba", "bubby", "bucins", "Buddy", "Buguinha13", "Bulgaria", "bulldog68", "Buna", "BUNINGSSNAG", "BUNNINGSSNAG", "Bunnyfur", "Bunnyo", "burger", "Butkizz", "Bzi", "buwygib", "BuzT", "bye", "BZX", "C", "cvcbgnbfm", "c2", "Caam", "caarlaaa", "caca", "cacawater", "cade", "caden", "CAIO", "cake", "calabresa", "caleb", "calebb213", "callum", "cam", "canadabest", "canadasucks", "canadatrash", "Canadalife", "CanadaLeader", "CANADIANS", "Candinho", "CANNON", "Cantu", "Capitooooosh", "Cappapotomus", "CAPSLOCK", "captain", "CaPtAiNMaRs", "carenzo", "carl", "CARLLLLLLLLL", "Carlos", "CarolusRex", "carrot", "carrots1", "CARRSRSTDYYT", "CARSONCAVE", "cart", "Carter", "Cash", "cat", "catboyisaac", "catcher", "catforcanada", "Cathal", "CaThErIne", "CatMaker", "cats", "CATS4LIFE", "caule", "CAussier", "cc", "ccgamer", "ccccc", "CerealKiller", "CF", "chags", "chai", "CHAIR", "champ", "Champion", "chanyeol", "chao", "Ch o", "ChaoCB", "CHAOSCC101", "chap", "char", "chariec", "charliegren", "charlotte", "chase", "ChaseH", "Chaselliot9", "Chavezv", "ChavezVive", "chckenvndlo", "Checkmate", "cheenema", "cheekibreek", "Cheerwine", "cheesballxx", "cheeseboi", "cheeseburger", "cheezydibz", "chengchang", "Chesse", "Chewie", "chgicken", "chicken", "chicorey", "Chile", "chill", "chillB", "Chilllllllll", "CHiNA", "CHINARULES", "CHINGONA", "chinoooo", "chistmas", "Chloe", "Chomp", "Chopper", "chris", "chrisbrunt", "christian", "christine", "Christmas", "chuckllboy", "chuglet", "chungoscrun", "chynn", "Cirrus", "cisarmilos", "cj", "claire", "Clara", "clash", "Clatter", "Claudia", "Clenched", "Clint", "CMoney", "cnhwrg", "coal", "cobby", "cobos", "CocaCola", "coco", "codelazar", "Codewolf", "codelazaryet", "colombia", "Colombiahpt", "comeonuk", "cometudo", "comisuamae", "COMMIEKILLA", "commonwealth", "Communism", "Computer01", "Conic", "conor", "conquistame", "controlwhax", "CookieGamer", "CookieGuy", "cool", "coolboy", "coolguy39", "Coolman", "cooleo", "coop", "Cooper", "CORBIN", "Corey", "Corvus", "CosmicBagel", "Costarica", "Cougarclaw", "CoulombCube", "Cowgoesmoo", "COYR213", "CR7", "crack", "crackhead", "Craftian", "crainer", "crainer1422", "crazynonga", "CRAZYARNO", "CrazyKidooo9", "CreeperAwMan", "Crimeaisours", "cristianocr7", "Croatia", "Croatia4Life", "Crocomire", "crownkiller", "Croydzzz", "cskns", "ctrlw", "ctrlwteam", "ctrlw", "ctrlwHACK", "ctrlw", "ctrlwforspee", "CtrlWToHack", "cube", "cubix", "CUCA", "cujo", "cullengreat", "cupcake", "Curry", "cutehunter", "Cute247", "cw", "CYBERHUNTER", "cykablayt", "CykaBlyat", "cyprusdemon", "Cyrus2", "CzechEmpire", "Czechia", "d", "daway", "dab", "dabmaster", "DaCeeb", "dad", "dadaddy", "daddy", "daddyo", "DaFisHBoy83", "Dafloppa", "daichei22", "DakDudez", "dakota", "DALESNAIL", "DaleWhite", "Dallasusa", "DaltonWGG13", "dalyarak", "DAMONKEYPREZ", "dan", "danceisfun", "Dancequeen", "danger", "DangerMouse", "dani21", "daniel", "DanielUSA", "Daniella", "Danislav", "dankdoge", "Danmark", "dannybot", "DanTDM", "dantegol1432", "danymany", "DANZ", "dapizzaman", "Darius", "Dark", "DarkNebula", "darkleader", "Darkyz", "darrison33", "Darsh", "DarthSauron", "dasda", "DASH", "DatiMomtente", "dave", "David", "DAWG8", "dawnelle", "dawsdhbabad", "day", "DAZ", "DBTCAMERON", "DBTdiesel", "DBTJames", "dd", "ddd", "ddog", "De", "denaam", "dead", "Deadpool", "deanmarney", "DeathItself", "DEATHOFKILL", "DeathPlays09", "debaixoviado", "dedi", "deevegemie", "DEEMAR", "Deepak", "DEEZNUTZ", "Degurchaff", "DeimonEXE", "Dejmian", "DemREREs", "dEm0g0RgAn", "Dema", "Demid", "demogorgon", "demongurlie", "denisa", "Denmark", "dennis", "DerEchte", "derf", "DerGerman", "deriveomr", "DerNEGER", "desmataso", "destroyer", "destrukt", "DEUTSCHLAND", "DEUTSHCLAND", "Deutshland", "devansh", "dfew", "DGYA8805YI", "dharel", "DHPstudios", "Diamondlucas", "diana", "DiarArifi", "diara", "die", "DietoDeath", "DienoOB", "die25", "Dieforme", "DiegoChacon", "Dieku2909", "Dieku2909MX", "Diex177", "dieyou", "DiggyHole", "digitalkids", "Diktator", "diman", "Dimka", "Dimond", "dinmamma", "dingdong", "Dingleberry", "dingo", "DINGOEZo", "diosama", "dio12345", "Dis2008", "disney", "dkofjkvdfvfn", "do", "DOCTRLW", "doge", "Doh", "Dom", "Domiiiii", "Dominate", "DOMINIKXY", "DonaldDuck", "DonaldTrump", "DonaldTRUMP", "donthurtme", "Dontkillme", "dontkill", "dontkillme", "DoNtAtMEbRo", "dontkillnoob", "doof", "DOOFIS", "doom", "Dooney", "Dowdi", "drpaper", "DracoHeart", "dragnealife", "drago", "Dragon30", "Drama", "dreizer", "DREWSKI", "dripak47", "Drisikray", "DrizzyAiden", "Drogon", "DropBear", "DrUgs", "DRUNKFIG", "DRUNKOBAMA", "ds", "dsallsa", "dsawwaa", "dsf", "DTMdan", "dtrgfxfghuyg", "Dubai", "ducanh", "duck", "duckduckya", "duck20", "ducky", "dude", "dudulindo", "dumpstered", "dutch", "dxrkshxdxw", "dyl", "dylanperr4", "dynamois", "dysha", "Dziadzia", "e", "EMASTERMORT", "eromero", "Eamon", "EastNed", "easy1top", "Eat", "eAtiT", "eatme0", "eatme", "ebuking", "ed", "eden1", "Eder", "edgar", "EDKH", "eeee", "eeeeeeeeeeee", "Eeonegee", "eevee", "egg", "EGGGGGGGG", "EgoitzHernandez", "Egypt", "eh", "ehan", "elguero", "ElSalvador", "ElThirox", "ELVIEJO360", "elaine", "ELAM0", "ELENA174RUS", "eli", "Elias", "eliassucks", "elijah", "Eliminater", "EliTinyRex", "ella", "ElmastroOO", "elmira", "EloyFerreiro", "lqasm", "ElRoberto93", "elsacha35", "elvis", "ELVISOMG", "ElWachin", "Ema", "Emad", "Emanuel", "emerald", "emil", "emily", "emily18", "eminem", "emir", "Emirkohall", "EmirPr14", "emmet", "empireofis", "EMPIREMEMES", "emresikecek", "Engille", "ENGLAND", "EnsarV7123", "Enzito", "Enzoplays", "epicnoob", "epicpro", "EquipoMxico", "eragon", "eresmariqua", "eric", "erichbete", "Erick", "ERICLOL", "Erik", "Erli", "ERNAR", "Ernesto", "erwef", "Eshla", "ESPAA", "Espaita", "especteral", "estonia", "eth50", "ethan", "EthnicBrit", "etyg6f4567v7", "eua", "eufwe", "Eugenecom", "EveGet", "Everleigh224", "Everydaybro", "Evgenii", "evil", "EvilJohn", "EWAFAKA", "EXGuardian", "expectations", "EYELIGMA", "eyes", "eznumber1", "f", "fShaman", "fun", "FrUsSia", "fk", "Fckoff", "Fckoff", "f111", "faa", "facundo", "fady", "FAHEEM", "faith", "faku", "Falak", "FANAF", "fantastic5", "far5", "farhan", "FARD", "farleyfun", "fatpig", "fatpig", "fatafatland", "fatanah", "FATHERLAND", "fatty", "faye", "FaZejarvis", "fazelucas", "FazeUzamaki", "FaZeAtlantic", "FBI", "FCKU", "fddjbkhbjkdf", "fdgfh", "fdkjm", "fearless70", "Feetus", "fermito2008", "Fernanda", "Fernanfloo", "FERRIX", "FEW", "ff", "fff", "ffff", "fgeetv", "FGEETVFAN", "fgeev", "fgfd", "FGTEEV", "fgteevAarav", "FGTEEVDAD", "FGTEEVDUDDY", "fgteevfan", "FgteevLexi", "FGTEEVDUDDY", "fgtv", "fgtvfan", "fgtvduddy", "fgtvv", "fgtvvyfan", "fgva", "fhhcvhvdvhhg", "fiawsome", "Fierce", "FIFI", "Fightme", "FightMeNOW", "fighter", "filipt", "filipino", "fire", "FIREBOY", "firered", "FISHSTICK", "fishy", "FiVx", "fizzgig", "fj", "fJWASDKNFIO", "Flame", "flamingo", "Flash", "Fletch", "FLEXTAPELF", "flipous", "Flitzdefelar", "float", "floof", "Flora", "florida", "Florijn", "FLYBOY", "Flyingsolo", "flynn", "folk", "FOOT", "FORAUSSIES", "Forstraya", "Foreigner", "Forge", "Forrestgump", "FORTNIT2", "FORTNITECOOL", "Fotis", "fourtwenty", "Fox", "foxysoap", "foxysoap", "fr", "frahermes", "Francewillwi", "Franco", "Franco777", "francoooo", "FrancsFranco", "FrankPepe", "Frankenstein", "freank", "Frece", "FRED", "freddy", "FREEFIRE", "freek", "Freence", "Frenchboy456", "FrenchPlayer", "fresh", "Freya", "friemelkont", "friend", "Frodo", "froggyboy483", "Frooty", "FrostKing", "FrostFire", "frozen2", "FRT", "Fryskjongkje", "fsd", "fsu", "ftgvfamboy", "fu", "fucjswedan", "Full", "Furt1", "futdebt", "futebol", "FutureHacker", "FUZIONS38", "fvv", "fwog", "Fyre", "", "g", "Gaaaaaldi", "Gabe", "Gabeitch", "gabeitches", "gabeitch", "GABEE", "gabesdad", "gabi", "gabienivaldo", "GABIFOOTBALL", "gabigol", "GABO", "gabriel", "gabriele", "gagaga", "Gage", "GalaxyPaper", "GalaxyBlitz", "GalaxyKnown", "galexyyyyyyy", "Gallardin", "Gamer101", "gamerbent", "GamerJax11", "Gamers", "gamingkhan", "gandork", "Ganesti", "gang", "GanjaWay420", "Gapci", "Garlictwins", "garrett", "gatopanama", "gauthampro", "gay", "GayNiger", "GB2A", "gdhenrique", "gdaymate", "GEAR4LUFFY", "GEHDT", "Gemany", "gemma", "Gem", "gendikari", "GeneralTOM", "George", "Georgia", "Georgian", "GErma", "GERMAN", "GermanGuy", "GermanReich", "Germany", "Germany1944", "GermanyIan", "germs", "GerryAdams", "gesuzzo", "getclapped", "getgud", "getrekt", "Getoff", "getmethanos", "GetNaeNaed", "GetRektM8", "gfdxhgzs", "gfgdfsgdgd", "gfgfg", "GG", "ggg", "gggg", "Gggggggggggg", "ggman", "ggs", "ghost", "gialy", "gibs1234", "giladoriz", "Giocatore", "Gipssksmm", "giselle", "GlaGlaGlaGla", "Glitch222", "GLORIOUS", "Glue", "Glugglug", "gm", "gmb", "GMFMATTEO", "GMSCORPION", "go", "goAUSTRALIA", "GoCanada101", "GoNepal", "goNZ", "goat", "GoAustralia", "goblin", "GOCANADAGO", "gogeta", "gogo", "gogogadget", "gojira", "GOKU", "Goldpaper", "goloma", "gonnacrushU", "good", "goodgirl", "goodoldUSA", "Goodbye", "google", "GOOIE", "GOOTED", "gordominais", "gorqui", "GotaGER", "GPDenmark", "Grace", "Grades", "GradovskY", "Gramma", "Gran", "Greaselight", "GreatGermany", "greece", "GreekGeek", "Green", "Greg", "Gregory", "gretarex", "Grey", "greycouch", "Grian", "Gringo", "gruccigang", "Guardsman", "guatemala", "GuavaJuice", "Gucci", "gui10", "Guilherme", "Guizinho", "gurnishan", "GUS", "GustavVasa", "Gustav2Adolf", "gustavo", "guy", "gyggygygygyg", "h", "hg", "hacker", "Habilis", "hacker", "HagenGANG", "HagenGANGSTA", "haha", "HAHAHAHAHHA", "hahahha", "hai", "hailnorway", "hakan23cm", "HAKER", "hallahwalla", "ham", "hampizza", "hamoodeh", "hamza", "Hanii", "hank", "HappyBoy", "happyplace34", "Har", "hardesnarl", "haranga", "hardik", "Harrison", "harry", "HARTKVTKUPV", "hatz", "HAWAII", "hayhay", "Hazbinhotel", "HECTOR", "hedgi", "heehoo", "hehe", "heheeh", "heipdeg", "heinrik", "hejhej", "hejjj", "Hekler", "Helen", "HELO", "help", "HELPFORNUKE", "helpme", "henk", "henry", "Henry2209", "henrydanger", "Henryking", "Her0", "Hermione", "herobrine", "Hexa", "hey", "heyyousmel", "heyhey", "HEYIMCASEY", "Heylo", "heyyyyyyy", "heyyyyyyyyyy", "HGC", "hgfd", "hhh", "hhhh", "hhjjhjhjjhjh", "HHKB", "hi", "hibobandje", "hiboy", "hidude", "hiimstan", "hiluis", "hipeoples", "HiWalkers", "hi123", "hidie", "hiperson", "hiwyatt", "hi", "hid", "hidde", "HiddenLeaf", "Hideintree", "HIGHFIGH", "hihi", "hihihihi", "hihihihihihi", "hiiiiii", "hiiiiiiiiiii", "hikeplays", "HillyBilly", "hindustan", "hipe", "hirochima", "Hitman", "HiTTVbtw", "hi", "hjb", "hjgkljsdfos", "hjjj", "hjk", "hkiufit", "hkv", "hmm", "hojoe", "Hobbit", "hockeylover4", "hoddieryne", "hoe", "HOGWARTS", "Hoi", "hola", "Holdenchan", "hOleio", "Holly", "HolyRomans", "HOLYJARVIS", "HomerS", "HONDURAS", "HongKong", "HONZA", "HOTDEATH", "hotdog", "hour", "houston", "houthirebel", "Howyoudoin", "howdy", "Hristijan", "hrllo", "HSWR", "htflame", "Huddy", "HUEstation", "Hufflepuff", "HUGO", "HUGOIPTV", "hugoprohaker", "Hungary", "hunter", "huts", "huzefa", "hvfhjjmgjvf", "hwy", "hxhxjjk", "Hyacinth", "hyh", "Hyper", "hytw123", "iamanoob", "IamCharles", "IAMDA", "iamdrad", "IAMGROOT", "IamNoob", "iclappedu", "igot100nvm", "ikillyou", "iloveCHINA", "iloveyou", "Inoharmu", "inokill", "ipro", "iwannadie", "IwantPeace", "iwilleatu", "iwin", "iwinsike", "Imgreece", "IamDA", "IAMDA", "IAMMENACE", "iwillbeat", "i97", "ialwayswin", "Ian", "ibad", "icecream", "icebear42", "icecreamking", "iced2", "ICEman", "ICEPAJINGKO", "Ida", "idiot", "idk", "IDK18", "IDOS", "idris", "Ifyou", "ifirst4evr", "ifkillmeugay", "igotthesnap", "iHASYOU", "ihatemylife", "Ihjhy", "iiiii", "iiiiiiiiii", "iiiiiiiiiiii", "IKEANEMPIRE", "ikjuhygtfrde", "IKKO", "ilie", "illrollya", "ilovecorn", "ILoveMyMommy", "Iluvcats", "Imamer", "imatoast", "Imatree", "imdepressed", "imgaymama", "iminschool", "IMTHEBEST", "Imyourboss", "IMIRISSH", "im100india", "IMAPAPER", "IMASQUARE", "ImThanos", "im100percent", "imawinner", "imachristan", "Imaunicorn", "imbryk", "imCANADIAN", "imcoming4you", "IMGRINDIN4UK", "ImJustDrunk", "immwinbruv", "immigration", "IMPEACH", "Impeachment", "ImpeachTrump", "Imperium", "imtc", "imusti42", "india", "Indiarules", "india560020", "Indiabest", "indiaisbest", "indian", "INDIANBOSS", "Indiangame", "indianking", "IndianPro", "indonesia", "infinity", "ingooooooooo", "ingrid", "Inklink", "INKYZ", "inuyasha", "Invensible", "io", "io2", "iornmanmk75", "ios0", "IOU", "IRA", "irakot", "irairaniran", "IRAN", "IRAQ", "ireberrrr", "ireland", "irene", "IRIS", "IrishBrit", "IRONMAN", "IronSabbath", "ironmanmk14", "ironmanmk608", "irshlad", "isthebest", "isaaac", "isaac", "IsaacandSa", "IsaacHLACS", "isaak", "ISACTYB", "isam", "isamil", "Isamilpro", "ISINHA", "Islambad", "ismailovic15", "ISMELLPENNYS", "Israel", "isreal", "issasheep", "IT", "itvictory25", "ITAKILLER", "ITALIA", "ITALIAN", "italy", "ItalyBoch1", "ITALYYYYOwO", "itsmeee", "itsyeboi", "ItsBrunoYT", "ItsOver", "ubbjhzuui", "iungiyoibbbb", "Ivan", "IvanBars", "ivangol", "IWINYOULOSER", "ixpo", "izahia", "Izzy", "IJacob", "J", "JERK", "jt", "j0enu", "jace", "Jaci", "jackbenimble", "jacob", "Jacquie", "JAD", "jafetv593", "jaidyn", "Jak", "Jakdude", "Jake", "JakeCool", "JAKEWALL", "jakemerecr", "jakituning", "jakkiesmith", "jakobandmax", "jamaicajr", "JAMAICA4LIFE", "james", "jamesw", "jameswardp5", "jan", "janbannan", "JasmineSandl", "jason", "javi", "jaxon", "Jaybae82", "jayden", "JAYJAYBOYY", "jaylen", "Jaylelocker", "JayMinecraft", "JAyyy", "jaz", "JBEE", "jbl", "JD", "Jdvinter", "je", "Jemama", "jebisesrbija", "jed123456789", "jeef", "jeff", "Jeffery", "jeffy", "jelly", "jellyfan", "Jelly20", "Jellybeans", "jellyiscool", "JEMMADAUNI", "jenne", "JENSNORRMAN", "Jeonghyeok", "Jeremiah", "JeremyStoke", "Jerry", "jessica", "JsusCrust", "JesusSaves", "Jetsky", "Jewh8er", "Jews", "jezwik", "jfng", "jhetalal", "jhlkhlkh", "jhunvhuvvc", "Jicken", "Jigglewiggle", "JimJamJong", "Jimbo", "Jimenakiller", "jimmy", "jimmyswag", "jimmybob", "JingleBells", "JJ", "JJs", "jk", "jkhh", "Jkk", "jksdjksdqa", "JL", "jlovo", "jmlvk", "jo", "jomama", "joddiejo", "joe", "joedaddy", "JOEMAMA", "JOEmoma", "Joe", "JoeMoma", "joemooomyy", "jOEmAMmA", "joey", "Jogador", "johan", "johao", "john", "JohnEllis", "JohnSA", "johnson", "JOJO", "Jojoeeta", "JoKaRy", "Joker", "jomo", "jon", "jonsnow", "jonathan", "joni", "JOOJ", "jordan1", "jordankiller", "jordigay", "jordyn", "jos", "JosBanana", "jose", "joseA", "JOSELOL", "JoseMourinho", "JosephiKrak", "josh", "JoshTSM", "joshyboy", "JoshyLegends", "josyel", "Jotarokuzo", "Joueur", "JR", "jswag", "jtt", "ju", "juan", "JuanM", "juanson", "JuChEGaNg", "judgerachel", "Juegagerman", "Juhis", "juice", "JUJU", "julian", "juliana", "Julie", "julien", "julius", "July41776", "Jumbo", "JuneIparis", "junebee09", "Jupiter", "Justice", "jvsqod", "jx", "J", "k", "k1rby", "k1slyy", "k1w1p0w3r", "kaaaaarl", "Kaaba", "kaas", "kafu", "kage", "Kaiismine", "Kaitlynn", "KaizariRum", "KaKa", "KAKADOCV", "kakka", "kaleb1204", "kalllhurr", "Kappetroelia", "Karen", "karenisab", "Karl", "KarlX", "katgamer12", "katgamer77", "katrina", "katsudon", "kattrussian", "Katya", "katlll", "Kawhi", "kayaismylove", "kayden", "Kazakhstan", "kbmnbuidhibd", "kc", "kcv", "kd", "KEBAB", "kefal", "Keizo", "KekBur", "KEKW", "kenkaneki", "Kendall", "kendog", "kenya", "Kerby", "Kerfuffle", "KERMIT", "Kevin", "kez", "kgf", "khaled", "Khattab", "Kiddo", "kidfury2123", "kien", "kier", "Kilian20", "kill", "killme", "killacat", "Killer", "killer", "killerzombie", "killmonger", "KillTrump", "Killz", "kimjonuun", "KimJongUn", "kimberly", "Kimitzuu", "KimJungUn", "kinca", "king", "King100", "king11", "KINGBOB", "kingboy", "KINGBRIER", "kingJr", "KINGKILL", "Kingofall", "KINGOFME", "KingPengu", "kingrian", "kingio", "kingiusti", "KINGBEAST", "kingcobra", "KingGeorge", "kingkinohi", "kingman", "kingnoah", "kip", "kira", "KIRB", "kirito", "KittaM", "kitty", "kiwi", "Kiya", "kk", "KKTC", "KLAUS", "klc", "Klose", "Klovborg", "Knickers", "knockknock", "knockyghost", "knowlen", "koasar", "Kobybilly", "Kohai", "kolek", "kolibri", "Konstantin", "Konstantinos", "koolcid", "KOOLAIDMAN", "Korea", "kosi6ixx", "kostis4", "Krachen", "KRAL", "krall", "Kramek", "kret", "krvtky", "KSI", "KT", "KUBUS", "KURVA", "kuy", "Kuzgret99", "kvamp", "kx", "ky", "kylancruz", "kyle", "kys", "L", "Lis4Layla", "L0rdFox", "L8Nick", "lamalasuer", "lafaucheuse", "lachie", "lachydachy", "ladd", "Lady", "ladybag", "Lagz", "lala", "lalalalalala", "lalalalla", "lalaland", "lambolovers", "lamis", "lan", "lance", "landon", "landonh", "lano", "Laraffel", "LarsGille", "LATVIJA", "Laura", "laurengallo", "LaUruguaya", "lava", "laveylavey", "Lavika", "Layla", "lazarbeam", "LAZARLAZAR", "lazerbeam", "lazeryeet", "LazerGlow", "lazerkid", "lbj", "le", "LePagg", "leTUEUR", "leah", "leandro", "lebanon", "lebensraum", "LEBHjr", "lebronjames", "lee", "LeeLa", "lega", "Legend", "Legomancalle", "lel", "LELO", "lemmeget100", "lemonisha", "lenka", "lentil", "leo", "leonekip", "leopapi69", "lesturmwaffe", "LETITGO", "letme100", "letme50pls", "letme100pls", "letmeget100", "letspiay", "LetsPlay", "letsswim", "Letsdothis", "levani", "Levant", "level1", "levistinkt", "levman", "Lew", "Lewiatann", "LewisPlayz", "lex", "LexluFV", "leys096", "Liam", "LiamYouTube", "LiaoPing", "liban", "licea", "lichtenstein", "liconligers", "lIeSucKs", "lier", "Lietuva", "lightning", "ligma", "likeaboss", "lilboat", "Lilnazbol", "LILpaper", "lilbigbrai", "lilnaxx", "LILTJ", "Lilac", "LILBOB", "lilbon", "lilian", "lilly", "Lilo", "Lilou", "Lilpootpoot", "lilproon", "lilpump449", "lilu", "lily", "LilyS", "lilymachmakr", "limbo", "lina", "Lionman", "Lisa", "LISE", "litdabfam", "Lithuania", "littlej", "littletimmy", "LittleBilly", "LittleBike", "Liya", "Liz", "lk", "lkd", "LL", "LLLLOOOOLLLL", "Lloyd", "lmao", "lnj349", "Loading", "loaggy", "Locky", "loding", "logan", "logan205", "LOGIN", "lol", "Lolhi", "lolsdf", "LOLUYT", "lol2", "LOL3D", "Lolmini", "lolo", "LOLy", "long", "lord", "LordPawwGame", "Lordplayer", "Lorenzo", "loroivan", "Lort", "Losmejores", "loser", "LosinTex", "Lost", "LostCause", "lotsofcash", "Louis", "lovedaniela", "Love1234", "lovebug", "", "lubagopzon", "LUCA", "LUCA83", "Lucaasak747", "Lucas", "LUCIthelol", "Lucy", "Lucy3", "luiz", "Luk", "Lukas", "Luke", "lukestorm", "Lukerdepuuk", "lukezquad", "lul", "LulaLivre", "Lullin", "lulu", "lunapup", "lunchtime", "LUZ", "LynetteNoni", "M", "MQaseem", "MM", "MVerstappen", "MANDA", "M10D", "maas", "Macedonia", "macedonija", "MACYMYDOG", "maddog", "MAD", "madara", "madddddd", "maddy", "MadHamster", "Maegaard", "maelspi", "maguire", "maitrephenix", "maja", "MajikPaper", "mak", "MakarAndM", "makealgergrt", "MakerFaffa", "MAKI681", "malala", "MALAYMAN", "Malaysia", "MALEAH", "malekBully", "malik", "malikye", "Malta", "mamaam", "Mammarussia", "mammamia", "Man0fY33ts", "mandascript", "MANDO", "manga", "mAnixX", "mannekam", "ManofMelon", "Manon", "Map", "mar", "MARA", "maravilhoso", "MARCELO", "marchelo", "Marcolla", "Marcos", "marcproo", "Margaret", "mariaisabe", "mariana", "marianabr", "Marie", "MARIEM", "marina", "Marinette", "MArio", "mariotiffo7", "Markelpro", "Markify", "markus", "marquitos", "marshmello", "MarthaLupton", "martin", "MartinBrody", "Martinli", "marzens", "MascaraMaro", "mason", "mason6", "Mast3r4life", "master", "MasterT", "MasterGamers", "MasterJak", "MatEagle", "mateeney", "MATEFRANCO", "MATEJQQ", "mateo", "Mateusz", "mathiscool", "matheus", "MATHIAS", "Mathilde", "Mathon54", "matin", "Matteo", "Matthew", "MATTIE", "Mauri", "maury2", "MAX", "maxmandel", "maya", "mayi", "mazlum", "Mazur", "MC475", "mcrhyan", "mcfatty", "MD", "Me", "me1", "MEYOU", "melucky", "meme", "menamejeff", "Meow", "mede100pfv", "Mea", "Meah", "meeismarco", "MEEEEE", "meep", "MEGAP", "Megan", "meh", "mehmet", "melis", "melke", "melon", "MemeDawg123", "memememememe", "memes", "meowkitty", "Meowrianopi", "Mephito", "mepis", "Merca", "Merchanj", "MercifulLord", "merhaba", "meri", "merica", "merlin32", "Messi", "mestre", "met", "Metamorphicl", "METHFORKIDS", "mew", "Mexicanos", "Mxico", "Mey", "mhkgy", "MI", "miparaguay", "mia", "MiaD", "MIALG", "miau", "Micah", "Michael", "Michel849", "michiel", "Mickis", "micko", "Midnight", "Mids", "miedema", "mig", "mightygay", "Miguel", "MihaxGaming", "mihir", "Mikaela", "Mike", "mikeock", "mikey", "mikhail", "MIKI", "Milk", "Milliano", "millie", "millinum", "milosh", "mimai", "mine", "Minimorgz", "minibytor14Y", "minnietong", "miriam", "missbiggest", "mit", "mitchel", "MITTNAMN", "mitvit", "Miya", "Mizgin", "MJ", "MJOLNIR", "ml", "mmehdi", "MMERFOREVER", "mmmmmmmmeeee", "mo", "MOKHAN", "ModelHorse", "moenhide", "moh321", "mohamed", "MohammadOmar", "mokibaba", "Moldovant", "molina", "Mom", "momma", "mommy", "mommymommy", "momo", "momomcjol", "MONEY", "moneyman", "monkey", "Monkey13", "monkeycat", "Monster1", "moo", "moon", "moon21", "moosmilk", "morgan", "morganbrosct", "morocco", "MoMoldovan", "moskow", "Mother", "Motherbird", "motherland", "MOTHERRUSSIA", "motomoto", "MountainMama", "moutaindrew", "moutasem", "movelike", "mqi34wejpiwf", "mralmutari", "mrbeast", "mrcrab", "mrkrabs", "mrman", "MrMeat", "MrTurtleMan", "MrMcBean", "Mrblueberry", "MrMinion", "MrEboy27", "Mrbeast6000", "mrfreshasian", "MrTyr16", "Mrvel", "Mrwoo", "MSNB", "MszV2", "muchogracias", "Mugh", "muhammad", "Muharrem", "Muhib", "muji", "Mulle", "Murica", "murilo", "muslim", "muslimchild", "muslimsrule", "muslk", "mustafa", "mv", "Mwahahahaha", "MyDoom", "Myfrienz", "mynats", "MYSECRET", "mynameisj", "Mya", "MyDemons", "mym", "MyNameNoddy", "MyNameIsJeff", "N", "NORGE", "n54t834", "na", "NABIL", "nacl", "nadaave", "naden", "naimaD", "naji", "najib", "nala", "namastha", "name", "NameNoddyl", "namit", "nani", "nanny", "Napoleon", "Nara", "NARUTO", "Nash", "nate", "Natedogg", "NATII599PL", "native", "Nats", "naughtyomega", "naut", "nave", "naya", "nayr", "Nazar0360", "NBA265", "ndsbkhcs", "Neachraoin", "nebman", "nederland", "needreaper", "Negro", "NEIKO", "nein", "nenengbdi", "NenengZ", "neo", "neolixy", "neolixyFra", "NeoTilted", "Nepal", "NerdyPorg99", "netanel", "Netherlands", "Neupi", "nevo", "newhair", "newkid", "Newzealand", "NextVictim", "neymar", "NeymarJr", "NEZUKOOOO", "Nf", "Nguyen", "ni", "nice", "nicepro", "nici", "NICK", "nickgur", "NickJ", "NICKMANATE", "Nickalberto", "nickosama", "Nico", "nicolas", "NicolasPro", "nicole", "nicu", "NIGERIASBAD", "night", "nightcay", "nijo", "nikatsomaia", "NIKART", "nikefanjr", "NIKO", "NiNipine", "Ninja", "Ninjakid", "ninjaurso", "NipNip", "Nisaa", "Nishad", "NITROGALIXY", "Nix", "Nizam", "nkls", "NLgamer", "nn", "Nnbg", "nnn", "NNNsurvivor", "no", "nopewdiepie", "nou", "Noname", "nou", "noa", "NOAH", "nocapowo", "noco", "NOE", "nohemi", "NOLA", "Nolan", "nome", "nomi", "noncepedo", "Nono", "noob", "noobbbb", "noobie", "Noobies2006", "noobskill", "nooob", "nooooooobers", "noooooooo", "NoorPlayys", "nope", "Norge4theWIN", "North", "norway", "NORWAYFORW", "nosvsvos", "nostopme", "NotBill", "notdumbey", "Notyourtoy", "Nothing", "NotMyTail", "Nova", "NOVAKERIE", "NOWUNITED", "NowOrNever", "NP1", "NR077", "nu3galu3", "NUGGETS", "Numnom", "numsei02", "nunes", "nutnoodles", "NUTYALIADO", "nwo1840", "nyancat", "nyancat", "nyck", "nyoncatbye", "Nz", "NZBOIZ", "NzRules", "NZx3", "o", "OMuhammad", "ObiWan", "OBJECTION", "OG", "ogaurav", "OGnarutobeat", "OGnoobie", "OHCANADA", "OHYEAHHH", "ohio", "ohockey22", "oi", "oigdfggyhty", "oij", "ok", "OKBoomer", "ok", "OLCAY", "olddad", "OldSkooler03", "Oldtimer", "olivia", "ollallol", "ollie", "olliePRO", "ollyisbest", "ololo", "omar", "omarking", "OMG4lif", "OneF8", "onepaperman", "oniichan", "OO", "OOF", "oofmaster", "ookko", "oooooooo", "oops", "op", "OPTHEONE", "optwisty", "opiumGR", "opiumIZI", "opos", "optimusprime", "orange", "orchid", "Origarme", "ORIGIN", "s", "Osc45", "oscdosc", "Oskar", "oso", "sterreich", "otario", "OTSOSU", "Otto", "oui", "ouououououou", "OurChael", "ouss", "outmeal", "owe", "owenpro", "OWLCITY", "Owlhoot", "OwOgermany", "owwnoo", "OxoWhitney", "Oyuncu", "OZ", "OzBloke", "Ozmainia", "P1953", "PATrickO", "PS6", "P11", "p13", "p3n1s", "pablo", "paco", "Padfoot", "pahan", "Paislee77", "PAISLEY", "paitton", "Pak", "pakzindabad", "pakdabest", "palistine", "panama", "PanchoVilla", "pancrazienn", "panda", "panda16", "Pandix", "panther", "Panzer", "Panzerwagen", "papabear", "papaio", "PAPALGUAS", "Papasmurf", "PapelFolha", "paper", "Paper20", "papermoney", "paperio2", "Paperio", "PaperBoi", "Paperiochamp", "papermaster", "Papers", "papper", "papperskalle", "papy", "PARASITABR", "Parker", "Parkerjr89Yt", "partizan", "party", "parynhar", "pastry", "pat", "patataxD", "patilla", "patria", "patrickstar", "patriotuluca", "paul", "paulina", "paulius", "pauly", "PAX", "PB", "PCRagin", "PCM", "PCRM", "PDOGELEGEND", "peacemakers", "Pecularis", "Pedik", "PedoMan69", "pedro", "pedroloveusa", "peduncle", "peeandpoo", "peeen", "Peen", "peki", "PENCILM8", "pendejo", "Penela", "PennState", "pennis", "Penny", "pennywise", "pennywise", "Pennyise", "pennywisejr", "penywise", "people", "pepalacerda", "Pepe", "pepo", "Peppapig", "Percybeth", "perdy", "pereira", "perhaps", "PERIDOT", "Perko", "perrro69", "Persian23", "Person", "person20", "peru", "peruuu", "PeterParkour", "PewDiePie", "peytonfanni", "phantom", "Pharoah", "Phatan", "Phe", "pheobe", "PHIAAAAA", "Phil", "philippenes", "Philippines", "Phloxx", "phoenix", "phong", "PI077", "Pia", "pianter", "pichu", "pickle27", "pidor", "PIE", "Pierce", "Pierogi", "pietje", "Piggy", "piiiiiiiiiii", "pikachu", "Pikachu786", "pikaso", "pILar", "Pilipinas", "pilippinas", "Pineapples", "PINGAS", "PingPongPie", "pipka", "Pixalated", "Pixel", "pizza", "pizzaman", "PIZZAROLLS", "pizza123", "pizzaking", "pizzz", "PjIese", "pk", "plackins", "Plankaster", "PLANTAIN", "Player", "PlayerOne", "player3812", "player587joe", "Pleasedon", "pleasedont", "plolal", "plonk", "ploopy", "plsletme100", "Plywood", "PLZDONTKILL", "Plzdontkillm", "plzdontkilme", "plzplz111", "pnoob", "po", "POJHIOP", "poker", "Poland", "Polandbyycz", "POLANDPLAYE", "PolarBear", "POLICECHASE", "Polloh", "POLO", "POLSKA", "POLSKAGUROM", "pooh", "poohfromztek", "Poon888", "poooooo", "poooooooooop", "poooooooop", "poooop", "pooooppppppp", "pop", "popcorn", "popo", "porcodue", "Porgy", "porphygennet", "portabacaxi", "portugal", "Posada", "Poseidon", "poswjhygscfj", "PoTLbEaR", "potato", "PotatoLover", "POWER", "pp", "PPWater", "pppp", "pppppp", "Pranked", "Pratham", "Prentes", "PresidentXi", "pressctrlw", "prestoboy", "preston", "prettydark", "primetime", "princes", "Pringles", "PrinzEugen", "pro", "PROStatus", "progamer", "proinusa", "pro360", "Prooo", "PROS", "prosciuttix", "ProudAussie", "proudtobePK", "ProZ", "pseudo", "PSM2005", "PSU", "PUYSTILLB", "PUBGMOBILE", "PUMBA", "pumpkin", "PumpkinKing", "puppylover", "pups", "Pure", "purplegrape", "Purpureon", "PurringMotor", "PUTIN", "putinukraine", "puzzlezio", "Pweedy33", "Pwnd", "pz9", "q", "QARABAG", "Qeen", "QINGDYNASTY", "QixStar", "Qubec", "QueebOfHeart", "QUEEEEENN", "Queen", "Queenjuicy", "QueenS", "Queenjuicy", "Quicoarpro", "quim", "QUINCY", "QuinnDH", "qwerty", "qwertyio", "qwertyqwerty", "rrazzel", "ruok", "RMoldova", "ra", "R", "Raccr", "RaceTraitor", "rachelkgreen", "RadiantOryx", "R", "raed", "rageElixer", "rahmo", "Raiden", "RAIF", "rainbow", "Rainman", "raja", "rami", "RandomUser", "raphael", "RAPHAEL075", "rara", "RATATATA", "RATATAYEET0", "Raven23", "ray", "raycon", "Rayman", "Rayy", "raziq", "RAZORBLADE", "RdyPlayer1", "rdyer", "Realjelly", "realibby", "realization", "reallycool", "RealYourName", "ReapYT", "RedAxe", "redfox", "redrobbin", "Redcenter", "redpanda", "ree", "reee", "reeee", "REEEEEEEEEE", "reeeeeeeeeee", "rekt", "REMYCRAKERS", "Renato", "rereeeeeee", "REUTRIOX", "reuven", "revengetime", "RexLousdal", "Reyna", "Rhayven", "RHEC", "RHENIUS", "Rhubarb", "rhyan", "rhys", "ricardo777XD", "RiceFarmer", "richhomie", "Rick", "rickenbacker", "ridge", "riggidy", "Riket", "RILEYRILEY", "Ringer", "RipDuko", "RIPPER", "rj", "RM52", "rob", "robby", "roblox", "rock", "Rocket", "rockstar", "rdgrd", "rodrigao", "Roey", "rohit", "rojos", "romania", "Romeo", "Romes", "romrom", "romrorm", "RonaldOMG", "Ronaldo", "RONALDO7", "RONNIE", "roosalieee", "rose", "RoSh", "rot", "Rouchdi22", "rourou", "roverbre", "RoxaneBTW", "Roxanne", "roza", "rozaanim", "RPTROJANS", "RR2", "rRazvan", "rrr", "rrrrrrrrrrrr", "rrwwertf", "RSA", "rtkgjgvkjgbj", "RubiksMan", "RUBY", "RukiKazuki", "rup", "Ruperto", "rusame", "RusherTR", "Ruske", "Russia", "RussiaPutin", "RUSSIANDIMA", "RussianSFSR", "Russo", "RUUUUUDDDDYY", "ryan", "Ryanthepro", "Rylie", "s", "SARGE", "SMA", "s8n", "SAWichmann", "sabkat", "saba", "saba6", "sabanayb", "saber", "Sacred", "sad", "sadcubeboi", "Sadiq2010", "safg", "Sage", "sai", "said", "SaikoBears", "saitama", "salgadoBR", "sam", "samBates", "Samantha", "sammysonic", "SamoJako", "san", "SANJIN", "sanone", "sans", "Santa", "sap", "sapwings", "Sara", "sas", "SASCounqerer", "sasha", "Sasuke", "sasuske", "SaudiArabia", "Saugat", "savage", "savageFoxy", "Savagegemini", "savion", "Schnaubi", "SCHON", "schumhey", "scissors", "Scones", "Scottzen", "scp49", "SCRSBRATHENS", "Scrubby", "sda", "sdr", "sdsdsd", "seaku", "SearchBts", "sebiswaifu", "SebasSZN", "SEBASTIAN", "sebasydani", "Sec", "sedres", "sedric", "SEF", "sefs", "senorpot", "senorpotty", "Senpai", "Seppl", "Serbia", "Sergei", "serginho", "SERGIO", "Serv", "Servexal", "Sesed", "SEV7N", "SGE", "SGEKids", "SGthe2nd", "shadow", "shadowkille", "ShadowAlx", "shae", "shaheeribe", "SHAI", "shako", "Shannon", "shannonusa", "ShanShan", "Shanyya", "sharshya", "sharkpuppet", "sharonsmaf", "ShayanHadi", "SHAZIL", "shekelstein", "sherry", "shoj", "SHopa", "shortie", "shorty", "Shqiperia", "shrek2", "Shreyash", "Shrungus", "shutup", "SiIvaGunner", "SiLeNtViRgEn", "SillyMrQ", "sime", "Singapore", "sirawesome", "SirGeorge", "Sissy", "Sixball", "SJBoyz", "sjonvander", "Sk3tchYT", "SKNEERVOR", "skeletongame", "skeppyBALD", "skillz", "skinnyafrica", "skrtskrt", "SKS16", "SKSKSKSK", "SKSKSKSKS", "SKSKSKSKSKS", "Skull", "Skullcrusher", "skypeace", "Skyla", "Skylanders", "Slade", "slak", "slavdo", "slemmsf", "slimemoster", "slimer1011", "slipknot", "Slitherio", "Slithshowbob", "Slogoman", "slotz", "smaker", "SmallAsian", "smallhead", "smash", "smellmutoe", "Smellynegro", "SnakeGamer", "sneaKINGHU", "Snickers007", "snipsnip", "Sniper", "SnipezTylor", "SNOR", "snowflake", "sobangamer", "SocialismSUX", "SofiaJ", "sokk", "SoldMyKids", "someee", "someone", "sometimesno", "somila", "somo", "sonia", "sonic", "sonicmax", "Sonicspeed", "snnike", "soolkig", "SOPHIEKEEFE", "Sorry", "Sorryeh", "SorryEh", "sorryheather", "souseupai", "SouthAfrica", "SOUTHKOREA", "SouthKorean", "Souwla", "Soviet", "SovietRussia", "SovietUnion", "sp", "SPAIN", "Spainisbes", "Spainwinner", "SpamInaCan", "spangles", "sparemeplz", "SPARKLES", "spbk", "SPEEDISKEY", "SpeedP01", "Speler", "spiderman", "spiderroyd", "Spieler", "SpongeBob", "Spottedleaf", "sprinkles", "SQ", "squidbob", "squidward", "SrEzecolas", "Srbija", "SreeHari", "SrTheMeryem", "SS", "ssC", "sskkiinn", "SST", "ssundee", "StPierre", "Stalin", "STALKER", "STANDREU14", "StandWithHK", "star", "Starcastic", "Starrysky", "steen", "stefan88", "StegtFlsk", "Stephanie", "StephDami", "steve", "SteveIrwin", "SteveSmith", "SteveIrwin", "stfu", "StickyPaper", "STILAGa", "StinkyMex", "stnomas", "StokolaN", "StracheBeidl", "strawberry", "strong", "stu", "Stubbur04", "stud", "Stuxnet", "suatunarda", "sub2fgteev", "Sub2SSunde", "SUB2SUNDEE", "Sub2sundee", "SubToMe", "SUB2BADGAMER", "sub2blitz", "sub2estib", "Sub2MVRowner", "sub2Patherz", "sub2pewds", "Sub2pudiepie", "sub2RHally", "Sub2Ssundee", "subham", "subpewdiepie", "subpurpleify", "SubSpyrosTDB", "SubTobytalks", "subtofralica", "SUBTOPHANTOM", "subtossundee", "subtosundee", "succ", "suckdd", "suckd", "sullo", "SULTAN", "sunan", "suomi", "sup", "SUPWITHYOU", "supermine", "superaaronAH", "SUPERGI7000", "SUPERHERO", "supeRman", "SuperNova", "superpichu", "superstar4n", "SuperThanos", "superuser", "SUPREME", "SUUUUU", "suwayda", "sv", "SveaRike", "Sven", "Svenpro", "sw", "swampman", "sway", "swe", "sweatbilol", "Sweden", "SwedenBrk", "swedish", "Sweet", "sweetnsister", "swetyswedn", "Switzerland", "xh", "syd", "Sydney", "sylar", "SyrianRefuge", "t", "ta", "T0mmy1010100", "tamre", "Tacoman", "tacos", "Tai108", "tAimMDILG", "TaiwanNO1", "tajus", "takethat", "TaketheL", "Talvisota", "tamansuria", "Tania", "tankboy", "tankyou", "Tankart364", "TANKSCOMIN", "Tatann09", "tauaneee", "taxtywinky", "tay", "Taye", "Taysian08", "Tazlen", "Tazzer", "TBNRFRAGS", "tea", "TeamDenmark", "Teamkanada", "teamup", "teamwithme", "Team", "TEAMUSA", "teamcanada", "teammalaysia", "teamUSA", "TeamWMe", "Tedde", "Teddy", "TEDT", "TehnoKing", "tele", "teletubbie", "telletubi", "Temas2323", "teo", "termico", "tessa", "Tessbajanger", "tester", "TetPez", "tex", "tfs", "Tfue", "THAHAHAHAH", "thales", "Thanoidugly", "Thanos", "ThanosSnap", "Thanos1", "Thanos2", "thatguy", "thawra", "thcboi", "TheGuy", "thebeata", "Thebest", "THEBESTONE", "thebestwd", "THEBOSS", "thebrusier", "TheBuddy", "thecholo", "thecoolkid", "TheDisowner", "TheDoctor", "TheEraser", "thefake23", "thefastest", "TheGame", "thegoat", "TheHype", "thekid", "thekiller", "TheKING", "Thelegend", "TheMaster", "THEMVP", "THENoob", "theNXT", "Theone", "THEPENGUIN", "thepro", "ThePug", "thesnowpand", "TheSUCC", "thebestguy", "the0nlyJae", "TheCatsFans", "TheChukyYT", "thedanklord", "TheDGamer09", "Thefiend", "thegoat56", "TheKillerBR", "TheNameless", "theodeng", "Thepenguin50", "TheProcess21", "thethegiri", "TheZakking", "thhhhhh", "THICCBOI", "thiccymiky", "THISISUSA", "thizisUSA", "THOMAS", "ThomasTANK", "thor", "thotpatrol", "thunderthe1", "ti", "tictocer", "KSI", "tifonl", "TifoGang", "TIGRE", "TikTok", "tim", "Timhortons", "Timo", "Timorsrage", "Timothee", "TiNaO", "tiss", "TJENA", "tnbq", "tonemai", "Todoroki", "Todorov", "ToeCollector", "toeeater", "TOESSS", "Tolkeus", "tom", "tomn", "TOMCOM", "tomas", "Tommy", "tomtom", "TonT0", "tony", "Tony24", "tooooooooooo", "TopRamen", "TOPio2", "torbje", "tortle", "ToryMusic", "totalpharoh", "toto", "totolasticot", "Totolito", "TotusNata", "Toyree", "Tpdddd", "Tr", "TR3", "trao", "trash", "Trenton", "tributo", "trinaty", "trisha", "tristan", "troywilldoit", "Truce", "trudbucket", "TrueComrade", "truenopai", "TrueNorth", "Dream", "xxsniperkidxx", "gamer", "aaaaaaaaaaaaaa", "nosus", "TRUMPsupport", "*moan*", "truse", "tryme", "tryme", "tryghujk", "Trympan", "TsarIvan", "tsjraj", "tsmjeremiah", "tsneia", "Tt", "TTTTT", "TTVKingKay", "TTVOWENLIT", "TtvJaygucci", "tumadarcho", "tumama", "Tuesday", "TUKIK2009", "tumadre69", "tunghandsom", "tuosorello", "TURK", "TURKEY", "Trkiye", "TRKYE", "trkk", "Turky", "turnip", "Turpin", "tushar", "tutu", "tutubiel", "tuvieja", "TUY", "twinkywinky", "twojastara", "txera", "TxRkkkk", "ty", "Tytheguy", "u", "UBOT", "UeatIeat", "umommy", "USYAY", "usuckiwin", "UAE", "UK", "urrs", "USA1", "USM", "USSR", "UU", "ugay", "ulost", "uaeisbest", "Ubahn", "ubermensh", "Uchicago", "Uday", "udit", "uhPanda", "uhttikjbcxs", "ui", "uiiiii", "UK4DAWIN", "ukforlife", "UKisBEST", "Ukraine", "Ukrainebest", "ullfloat2", "ultarvision", "ultragoko", "ULTRANK", "umair", "Umairica", "umm", "unapeca", "unclephil", "unicorn", "unicorngirl", "unicorncrazy", "unicornnnnnn", "Unitedking", "unitedKingd", "Unitedstate", "UnitedStates", "unknown", "UNKNOWNX", "UNKNOWNX", "unspeakable", "unspeakableb", "unspeakablz", "Unspeakale", "uofaku5cvc", "updara", "upanddown", "URbad", "urdad", "URDEATH", "urmom", "urmum", "urdaddy", "URMUM", "urmumgay", "urielsucks", "urmomgaylul", "urmumgay", "urself", "USAlteWay", "USKiller", "USMILITARY", "uspatriot", "UStrumpfan", "USBorder", "USA", "USAEU", "USABEST", "USADEBOSS", "USAdominate", "Usaforlife", "usaforwin", "USAIsMyCity", "USAkillyou", "USAKING", "USAMina", "USAONTOP", "USARULES", "USAUSA", "USAUSAUSA", "USAUnited", "URMOM", "Jake", "USANO1", "USA  ", "USAAAAAA", "USAFORTHEWIN", "USAisBetter", "USAtrumpfan", "USAUSAUSAUSA", "usbruthers", "usg", "USofA", "UstajSrbine", "Usuck", "uuuusssaaa", "uwu", "uy", "Uzair", "V", "V00D00", "V0rix93", "vadfer", "vale", "Valou", "Vanderboy", "Vanessa", "vango", "Vanilla", "vankata", "VAR", "Vargen", "Vava", "vb", "VCcrew12", "vedant", "venezolano", "Verby", "Vesta", "viavidi", "victor", "VietNam", "viezejos", "vikishow", "Vikiingen", "Viking", "Vikinghorde", "viktorblook", "Vincent", "VINCENTE", "vinh", "vinidibra", "vinizx", "VIRTRUS", "vishvak", "VisitTrkiye", "viva", "VivaChavez", "Vivaespaa", "vivaMEXICO", "VivaVox", "VIVEALGERIA", "viveisrael", "vkng", "vlad", "vladputin", "VLADA", "Vladimir", "vlado", "vlle", "VoidZpace", "voldimortina", "Voldymorte", "voodooking", "VoughnDaBoss", "Vovchik007", "VOX", "vs", "VSCO", "VSCOGirl", "VSCOgirl", "vuci", "vufidviudhvo", "vvb", "vvbvbvbv", "W0rldRun", "WasaaaaDUD", "wabble", "WackyBacky", "wallace", "wantpunani", "Wanturoil", "war", "Warming", "warrengood", "wartshoter", "wasmama", "wasd", "wasezfe", "WatarMelen", "water", "WaterBlaster", "watermalon", "Wavyy", "wawa", "WAYNE14", "WE", "weareGroot", "Wewillwin", "webby", "weeeee", "weener", "wesad", "WesGamer", "Weston", "Whaaaaat", "What", "WHATTHEF", "WHATSAPPDIY", "whiplash636", "WhitherA", "WhoCares", "whodat", "Who", "whotfisnuty", "WHY", "WhySoMean", "why", "Wiiiiiiiiiii", "WiiPiiFit", "WiiPiiOnU", "Wiktor", "WilSmiff", "will", "william", "willjoal", "wilmer", "WilyS", "winkenya", "winner", "winston", "Witruwiusz", "wog", "Wogan", "Wojo", "WolfLover", "wolfpack", "Wolfierose", "wolverine700", "woot", "world", "WorldKing", "Worstplayer", "wow", "WOW", "wowzerz", "WriterGirl", "wrwf", "wsad", "wtf", "wueeee", "WWPAPER", "wwwww", "WWWWWWWWWWWW", "wyatt", "wyattplays", "wywy", "x", "xxa", "X3DGamerYTX", "x3m", "Xagustin5111", "Xavier", "xazza", "xc", "XD", "Xelan", "Xhibit26ph", "Xllth", "XMAN", "xmas", "Xmasiscomin", "Xoax", "XS", "xTman417xUSA", "Xtrullor", "xwolf", "xx", "XxJibTemixX", "Xxnz4lifexX", "XXOKWOWXX", "xXVoidPlayzX", "xyVikash", "y", "YUDUMB", "Y1N6Y4N6", "Y1N9Y4N9", "YABOI", "YADEDSON", "yayeet", "YaKingBoy", "YAAHACK", "yaaaaaa", "yaboi4639", "YahMan", "yahooooo", "YallAint", "yallbots", "Yamamoto", "yamum", "yanislepr00", "yas", "Yasqueen", "yasmin", "Yasmine", "Yay", "yea", "yeah", "Years", "yee", "yeehaw", "YEEEEEEEEEET", "yeeeeeeeeet", "yeeeeet", "yeeeet", "yeeet", "yeeetme", "yeet", "yeetboi", "yeetmaster", "yeetsauce", "yeetsir", "yeet42069", "yeetgg", "YeetMonters", "yeetakis", "YEETMAN", "YEETYBOI", "yeeyee", "Yellowz", "yelo", "yes", "yessirrUS", "yfl", "YGoUSA", "yi", "Yikes", "YmrtaKafa", "yiyiyy", "YNWmelly", "yo", "yocheck", "Yomama", "Yobama", "Yoboyjb13", "YoGayIfKill", "yogi", "Yolo", "yolopro", "YOMAHDUDES", "Yonadush", "yonatanaviz", "yonatanYT", "yoriaplayer", "yosra", "You", "YouAreDead", "youlose157", "younoobbb", "yousuck", "youtrash", "youraBOT", "YOURALTALK", "yourawesome", "yourdad", "yourdoom", "yourmama", "YourMom", "yourmommy", "yourmomy", "Yourmum", "Yourname", "yourpitaji", "yourtheman", "yourmom", "YourName", "yourdaddy", "YourDead", "YOUSEF", "YoutubeViBe", "youtude", "yoyo", "yoyoyo", "yoyoyomama", "yrt", "YT", "ythytfgvvhhh", "YukheisMine", "yuki", "Yukiii", "yukjh", "yungpinch", "yuriysid", "yuyu999", "YYeet", "Yyooooythvhg", "Yyyyyyyyyyyy", "z", "ZA", "zach", "zaden", "zahary", "zainab", "zair", "zaki", "zammer1", "zanderfire", "zappierflash", "Zarla", "ZavenWolf", "zavion335", "ZAZA", "zeluis", "zeke", "zekrom", "Zemond", "zen", "zendel", "zenitsu", "zeus", "ZeusNaCausa", "zeuuubbbiii", "zghjbnhb", "ziad", "ziggle", "Ziggy", "zimbabwe", "Zispy", "Zoe", "zombsgaming", "zoom", "zoomertoons", "Zorux", "zuly", "zVolcomBr", "zwicki", "zxc", "zz", "zzz", "ZZZZZ", "", "", "", "", "Greece", "", "", "", "", "", "", "", "", "", "", " ", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Girl", "", "", "", "", "", "", "", "", "", "", "", "", "", "6", " ", "", "", "", "20", "", "", "", "", "", "", "", "", "", "", "", "Dairachan", "", "", "", "", "BO", "OppPSksKs", "", "", "", "", "Reizuru", "", "")
    }, () => 1179392, () => 16777215, () => -15, () => "https://3kh0.github.io/", () => 1.25, () => .1, () => 1.5, e => {
        const t = e._GetNode(0).GetBoundMethod();
        return () => Math.floor(t(1, 11))
    }, () => 10, e => {
        const t = e._GetNode(0);
        return () => t.ExpObject() - 25
    }, () => 270, () => "out", e => {
        const t = e._GetNode(0).GetVar();
        return () => t.GetValue() + " was ejected because bro was a sussy baka"
    }, () => "None of deez were ejected", () => 7, () => -717706215031807, () => -30738534399, () => 11, () => -47872561120255, () => -717750023016447, () => "Outline", () => "OilPainting", e => {
        const t = e._GetNode(0).GetBoundMethod();
        return () => and(Math.round(t()), "%")
    }]
}